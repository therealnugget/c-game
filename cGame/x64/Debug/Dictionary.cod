; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35211.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	uintMap
PUBLIC	cConst
PUBLIC	aConst
PUBLIC	??_C@_0BD@CBEDEJPH@unknown?5image?5type@	; `string'
PUBLIC	??_C@_08NOGIMCHF@outofmem@			; `string'
PUBLIC	??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@ ; `string'
PUBLIC	??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0M@JPDHFAGK@can?8t?5fopen@		; `string'
PUBLIC	??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_0M@MHDBFHD@unsupported@			; `string'
PUBLIC	??_C@_0O@DEFOLMLB@bad?5size?5list@		; `string'
PUBLIC	??_C@_0BB@FOKGPEKG@bad?5code?5lengths@		; `string'
PUBLIC	??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ ; `string'
PUBLIC	??_C@_0BB@IIMLINA@bad?5huffman?5code@		; `string'
PUBLIC	??_C@_09IFDKCGFO@bad?5delta@			; `string'
PUBLIC	??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@	; `string'
PUBLIC	??_C@_0BA@KLNDOKJD@expected?5marker@		; `string'
PUBLIC	??_C@_0M@LPHNODCG@bad?5DRI?5len@		; `string'
PUBLIC	??_C@_0N@BOFJCHAP@bad?5DQT?5type@		; `string'
PUBLIC	??_C@_0O@CNHKKDIM@bad?5DQT?5table@		; `string'
PUBLIC	??_C@_0P@JLGKOCGN@bad?5DHT?5header@		; `string'
PUBLIC	??_C@_0M@CICAFFCH@bad?5COM?5len@		; `string'
PUBLIC	??_C@_0M@EENLKPDI@bad?5APP?5len@		; `string'
PUBLIC	??_C@_0P@NNGPHMMK@unknown?5marker@		; `string'
PUBLIC	??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@	; `string'
PUBLIC	??_C@_0M@GNEHAHOH@bad?5SOS?5len@		; `string'
PUBLIC	??_C@_0M@NOCCBFAC@bad?5DC?5huff@		; `string'
PUBLIC	??_C@_0M@JGMCBLGG@bad?5AC?5huff@		; `string'
PUBLIC	??_C@_07EEJOMGGP@bad?5SOS@			; `string'
PUBLIC	??_C@_0M@DOFMJEMP@bad?5SOF?5len@		; `string'
PUBLIC	??_C@_0L@BCINMEBJ@only?58?9bit@			; `string'
PUBLIC	??_C@_0BB@LNEGOMA@no?5header?5height@		; `string'
PUBLIC	??_C@_07BIDACDEF@0?5width@			; `string'
PUBLIC	??_C@_09OJDLMMBJ@too?5large@			; `string'
PUBLIC	??_C@_0BE@DAPHADHL@bad?5component?5count@	; `string'
PUBLIC	??_C@_05BLPKENEJ@bad?5H@			; `string'
PUBLIC	??_C@_05MPLLHCJG@bad?5V@			; `string'
PUBLIC	??_C@_06LJIHDFHI@bad?5TQ@			; `string'
PUBLIC	??_C@_06CLMBLEP@no?5SOI@			; `string'
PUBLIC	??_C@_06IFCEAHIA@no?5SOF@			; `string'
PUBLIC	??_C@_0M@EPMOIECP@bad?5DNL?5len@		; `string'
PUBLIC	??_C@_0P@PNCLKCLJ@bad?5DNL?5height@		; `string'
PUBLIC	??_C@_0N@KBPNPPBJ@bad?5req_comp@		; `string'
PUBLIC	??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ ; `string'
PUBLIC	??_C@_09EOHLEIKL@bad?5sizes@			; `string'
PUBLIC	??_C@_0BA@MDNKOBMC@bad?5codelengths@		; `string'
PUBLIC	??_C@_0BE@IBFIPFO@output?5buffer?5limit@	; `string'
PUBLIC	??_C@_08DIAPIMGJ@bad?5dist@			; `string'
PUBLIC	??_C@_0N@IECDHMDI@zlib?5corrupt@		; `string'
PUBLIC	??_C@_0BB@PIPBCKIA@read?5past?5buffer@		; `string'
PUBLIC	??_C@_0BA@OBKOPAFL@bad?5zlib?5header@		; `string'
PUBLIC	??_C@_0P@DOGMHEBI@no?5preset?5dict@		; `string'
PUBLIC	??_C@_0BA@MCNBDLPD@bad?5compression@		; `string'
PUBLIC	??_C@_0M@DMDNBACF@bad?5png?5sig@		; `string'
PUBLIC	??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ ; `string'
PUBLIC	??_C@_0BC@BHMPBBMG@not?5enough?5pixels@		; `string'
PUBLIC	??_C@_0P@FBBCPGMN@invalid?5filter@		; `string'
PUBLIC	??_C@_0O@MKGNGALN@invalid?5width@		; `string'
PUBLIC	??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_@ ; `string'
PUBLIC	??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ ; `string'
PUBLIC	??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ ; `string'
PUBLIC	??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_0O@KBHBNJOK@multiple?5IHDR@		; `string'
PUBLIC	??_C@_0N@POJLKMKK@bad?5IHDR?5len@		; `string'
PUBLIC	??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@	; `string'
PUBLIC	??_C@_09MBBNGCKB@bad?5ctype@			; `string'
PUBLIC	??_C@_0BA@MDMBDDFG@bad?5comp?5method@		; `string'
PUBLIC	??_C@_0BC@GHLIKKMD@bad?5filter?5method@		; `string'
PUBLIC	??_C@_0BF@JCGDPBAA@bad?5interlace?5method@	; `string'
PUBLIC	??_C@_0O@FNFBHCOO@0?9pixel?5image@		; `string'
PUBLIC	??_C@_0P@JEAFOMAF@first?5not?5IHDR@		; `string'
PUBLIC	??_C@_0N@JCPAJAKB@invalid?5PLTE@		; `string'
PUBLIC	??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@		; `string'
PUBLIC	??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@		; `string'
PUBLIC	??_C@_0N@KDLCCKCH@bad?5tRNS?5len@		; `string'
PUBLIC	??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@		; `string'
PUBLIC	??_C@_07CKIELOEH@no?5PLTE@			; `string'
PUBLIC	??_C@_0BA@PLHGLONG@IDAT?5size?5limit@		; `string'
PUBLIC	??_C@_09MNNCNKEO@outofdata@			; `string'
PUBLIC	??_C@_07MLPECBNA@no?5IDAT@			; `string'
PUBLIC	??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@	; `string'
PUBLIC	??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@ ; `string'
PUBLIC	??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ ; `string'
PUBLIC	??_C@_07IANEBNLB@not?5BMP@			; `string'
PUBLIC	??_C@_07IEJCHBDI@bad?5BMP@			; `string'
PUBLIC	??_C@_0M@KHBIBJBG@unknown?5BMP@			; `string'
PUBLIC	??_C@_07IMHMNOIB@BMP?5RLE@			; `string'
PUBLIC	??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@		; `string'
PUBLIC	??_C@_0L@PJHPAMCH@bad?5header@			; `string'
PUBLIC	??_C@_0L@JDPIFELH@bad?5offset@			; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_07JNJHIMGH@bad?5bpp@			; `string'
PUBLIC	??_C@_09DAEBACAB@bad?5masks@			; `string'
PUBLIC	??_C@_0L@DMAPJJO@bad?5format@			; `string'
PUBLIC	??_C@_0M@ILLOCNCO@bad?5palette@			; `string'
PUBLIC	??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ ; `string'
PUBLIC	??_C@_07ECNCNLIK@not?5PSD@			; `string'
PUBLIC	??_C@_0O@CHBCDKKC@wrong?5version@		; `string'
PUBLIC	??_C@_0BE@PJBNGDBE@wrong?5channel?5count@	; `string'
PUBLIC	??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@	; `string'
PUBLIC	??_C@_0BD@IOGGBMNK@wrong?5color?5format@	; `string'
PUBLIC	??_C@_07DPPMCAKL@corrupt@			; `string'
PUBLIC	??_C@_04KBFEPHFH@S?$IA?v4@			; `string'
PUBLIC	??_C@_04ELNJHLFH@PICT@				; `string'
PUBLIC	??_C@_08GGMBIFE@bad?5file@			; `string'
PUBLIC	??_C@_07KMJLPAII@not?5GIF@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0O@MGDACKOJ@no?5clear?5code@		; `string'
PUBLIC	??_C@_0P@GJNJCPDJ@too?5many?5codes@		; `string'
PUBLIC	??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@	; `string'
PUBLIC	??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@	; `string'
PUBLIC	??_C@_0BE@NAMJKDNF@missing?5color?5table@	; `string'
PUBLIC	??_C@_0N@DJABBOOH@unknown?5code@		; `string'
PUBLIC	??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@		; `string'
PUBLIC	??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@		; `string'
PUBLIC	??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@		; `string'
PUBLIC	??_C@_06NDOKKIDJ@?$CD?$DPRGBE@			; `string'
PUBLIC	??_C@_07NCIOKENI@not?5HDR@			; `string'
PUBLIC	??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@	; `string'
PUBLIC	??_C@_0BD@NKJFFLKL@unsupported?5format@		; `string'
PUBLIC	??_C@_03HKAKGGJN@?9Y?5@				; `string'
PUBLIC	??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@	; `string'
PUBLIC	??_C@_03FOKDFDHG@?$CLX?5@			; `string'
PUBLIC	??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ ; `string'
PUBLIC	??_C@_07IDKIDMGJ@bad?5PNM@			; `string'
PUBLIC	??_C@_0BH@OBINMOBC@integer?5parse?5overflow@	; `string'
PUBLIC	??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@	; `string'
PUBLIC	frameMap
PUBLIC	locMap
EXTRN	__imp__wassert:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_fopen_s:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp___glewGetUniformLocation:QWORD
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_ftell:PROC
uintMap	DQ	01H DUP (?)
frameMap DQ	064H DUP (?)
COMM	enemyDamage:QWORD
locMap	DQ	064H DUP (?)
COMM	monkHBNodes:QWORD
COMM	enemyHBs:QWORD
COMM	monkTakenDmg:QWORD
_DATA	ENDS
;	COMDAT ??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
CONST	SEGMENT
??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@ DB 'max value > 65535', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
CONST	SEGMENT
??_C@_0BH@OBINMOBC@integer?5parse?5overflow@ DB 'integer parse overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDKIDMGJ@bad?5PNM@
CONST	SEGMENT
??_C@_07IDKIDMGJ@bad?5PNM@ DB 'bad PNM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
CONST	SEGMENT
??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@ DB 'invalid decode'
	DB	'd scanline length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOKDFDHG@?$CLX?5@
CONST	SEGMENT
??_C@_03FOKDFDHG@?$CLX?5@ DB '+X ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
CONST	SEGMENT
??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@ DB 'unsupported data layout'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKAKGGJN@?9Y?5@
CONST	SEGMENT
??_C@_03HKAKGGJN@?9Y?5@ DB '-Y ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKJFFLKL@unsupported?5format@
CONST	SEGMENT
??_C@_0BD@NKJFFLKL@unsupported?5format@ DB 'unsupported format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
CONST	SEGMENT
??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@ DB 'FORMAT=32-bit_rle_rgbe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCIOKENI@not?5HDR@
CONST	SEGMENT
??_C@_07NCIOKENI@not?5HDR@ DB 'not HDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
CONST	SEGMENT
??_C@_06NDOKKIDJ@?$CD?$DPRGBE@ DB '#?RGBE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
CONST	SEGMENT
??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@ DB '#?RADIANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
CONST	SEGMENT
??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@ DB '#?RGBE', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
CONST	SEGMENT
??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@ DB '#?RADIANCE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJABBOOH@unknown?5code@
CONST	SEGMENT
??_C@_0N@DJABBOOH@unknown?5code@ DB 'unknown code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAMJKDNF@missing?5color?5table@
CONST	SEGMENT
??_C@_0BE@NAMJKDNF@missing?5color?5table@ DB 'missing color table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
CONST	SEGMENT
??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@ DB 'bad Image Descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
CONST	SEGMENT
??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@ DB 'illegal code in raster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJNJCPDJ@too?5many?5codes@
CONST	SEGMENT
??_C@_0P@GJNJCPDJ@too?5many?5codes@ DB 'too many codes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGDACKOJ@no?5clear?5code@
CONST	SEGMENT
??_C@_0O@MGDACKOJ@no?5clear?5code@ DB 'no clear code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJLPAII@not?5GIF@
CONST	SEGMENT
??_C@_07KMJLPAII@not?5GIF@ DB 'not GIF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGMBIFE@bad?5file@
CONST	SEGMENT
??_C@_08GGMBIFE@bad?5file@ DB 'bad file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELNJHLFH@PICT@
CONST	SEGMENT
??_C@_04ELNJHLFH@PICT@ DB 'PICT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEPHFH@S?$IA?v4@
CONST	SEGMENT
??_C@_04KBFEPHFH@S?$IA?v4@ DB 'S', 080H, 0f6H, '4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPPMCAKL@corrupt@
CONST	SEGMENT
??_C@_07DPPMCAKL@corrupt@ DB 'corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOGGBMNK@wrong?5color?5format@
CONST	SEGMENT
??_C@_0BD@IOGGBMNK@wrong?5color?5format@ DB 'wrong color format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
CONST	SEGMENT
??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@ DB 'unsupported bit depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
CONST	SEGMENT
??_C@_0BE@PJBNGDBE@wrong?5channel?5count@ DB 'wrong channel count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHBCDKKC@wrong?5version@
CONST	SEGMENT
??_C@_0O@CHBCDKKC@wrong?5version@ DB 'wrong version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECNCNLIK@not?5PSD@
CONST	SEGMENT
??_C@_07ECNCNLIK@not?5PSD@ DB 'not PSD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
CONST	SEGMENT
??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@ DB 't'
	DB	00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T'
	DB	00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILLOCNCO@bad?5palette@
CONST	SEGMENT
??_C@_0M@ILLOCNCO@bad?5palette@ DB 'bad palette', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMAPJJO@bad?5format@
CONST	SEGMENT
??_C@_0L@DMAPJJO@bad?5format@ DB 'bad format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAEBACAB@bad?5masks@
CONST	SEGMENT
??_C@_09DAEBACAB@bad?5masks@ DB 'bad masks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNJHIMGH@bad?5bpp@
CONST	SEGMENT
??_C@_07JNJHIMGH@bad?5bpp@ DB 'bad bpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDPIFELH@bad?5offset@
CONST	SEGMENT
??_C@_0L@JDPIFELH@bad?5offset@ DB 'bad offset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJHPAMCH@bad?5header@
CONST	SEGMENT
??_C@_0L@PJHPAMCH@bad?5header@ DB 'bad header', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@
CONST	SEGMENT
??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@ DB 'BMP JPEG/PNG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMHMNOIB@BMP?5RLE@
CONST	SEGMENT
??_C@_07IMHMNOIB@BMP?5RLE@ DB 'BMP RLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHBIBJBG@unknown?5BMP@
CONST	SEGMENT
??_C@_0M@KHBIBJBG@unknown?5BMP@ DB 'unknown BMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEJCHBDI@bad?5BMP@
CONST	SEGMENT
??_C@_07IEJCHBDI@bad?5BMP@ DB 'bad BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANEBNLB@not?5BMP@
CONST	SEGMENT
??_C@_07IANEBNLB@not?5BMP@ DB 'not BMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
CONST	SEGMENT
??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '8', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@
CONST	SEGMENT
??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@ DB 'v', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, '2', 00H, '5', 00H, '6', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
CONST	SEGMENT
??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@ DB 'bad bits_per_channel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLPECBNA@no?5IDAT@
CONST	SEGMENT
??_C@_07MLPECBNA@no?5IDAT@ DB 'no IDAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNNCNKEO@outofdata@
CONST	SEGMENT
??_C@_09MNNCNKEO@outofdata@ DB 'outofdata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLHGLONG@IDAT?5size?5limit@
CONST	SEGMENT
??_C@_0BA@PLHGLONG@IDAT?5size?5limit@ DB 'IDAT size limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKIELOEH@no?5PLTE@
CONST	SEGMENT
??_C@_07CKIELOEH@no?5PLTE@ DB 'no PLTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
CONST	SEGMENT
??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@ DB 'tRNS with alpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
CONST	SEGMENT
??_C@_0N@KDLCCKCH@bad?5tRNS?5len@ DB 'bad tRNS len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
CONST	SEGMENT
??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@ DB 'tRNS before PLTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
CONST	SEGMENT
??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@ DB 'tRNS after IDAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCPAJAKB@invalid?5PLTE@
CONST	SEGMENT
??_C@_0N@JCPAJAKB@invalid?5PLTE@ DB 'invalid PLTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEAFOMAF@first?5not?5IHDR@
CONST	SEGMENT
??_C@_0P@JEAFOMAF@first?5not?5IHDR@ DB 'first not IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNFBHCOO@0?9pixel?5image@
CONST	SEGMENT
??_C@_0O@FNFBHCOO@0?9pixel?5image@ DB '0-pixel image', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
CONST	SEGMENT
??_C@_0BF@JCGDPBAA@bad?5interlace?5method@ DB 'bad interlace method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHLIKKMD@bad?5filter?5method@
CONST	SEGMENT
??_C@_0BC@GHLIKKMD@bad?5filter?5method@ DB 'bad filter method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDMBDDFG@bad?5comp?5method@
CONST	SEGMENT
??_C@_0BA@MDMBDDFG@bad?5comp?5method@ DB 'bad comp method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBBNGCKB@bad?5ctype@
CONST	SEGMENT
??_C@_09MBBNGCKB@bad?5ctype@ DB 'bad ctype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
CONST	SEGMENT
??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@ DB '1/2/4/8/16-bit only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POJLKMKK@bad?5IHDR?5len@
CONST	SEGMENT
??_C@_0N@POJLKMKK@bad?5IHDR?5len@ DB 'bad IHDR len', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBHBNJOK@multiple?5IHDR@
CONST	SEGMENT
??_C@_0O@KBHBNJOK@multiple?5IHDR@ DB 'multiple IHDR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@ DB 's'
	DB	00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
CONST	SEGMENT
??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
CONST	SEGMENT
??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_@
CONST	SEGMENT
??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_@ DB 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H, '1', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, '_', 00H, 'n', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKGNGALN@invalid?5width@
CONST	SEGMENT
??_C@_0O@MKGNGALN@invalid?5width@ DB 'invalid width', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBBCPGMN@invalid?5filter@
CONST	SEGMENT
??_C@_0P@FBBCPGMN@invalid?5filter@ DB 'invalid filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
CONST	SEGMENT
??_C@_0BC@BHMPBBMG@not?5enough?5pixels@ DB 'not enough pixels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
CONST	SEGMENT
??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm'
	DB	00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMDNBACF@bad?5png?5sig@
CONST	SEGMENT
??_C@_0M@DMDNBACF@bad?5png?5sig@ DB 'bad png sig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCNBDLPD@bad?5compression@
CONST	SEGMENT
??_C@_0BA@MCNBDLPD@bad?5compression@ DB 'bad compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOGMHEBI@no?5preset?5dict@
CONST	SEGMENT
??_C@_0P@DOGMHEBI@no?5preset?5dict@ DB 'no preset dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
CONST	SEGMENT
??_C@_0BA@OBKOPAFL@bad?5zlib?5header@ DB 'bad zlib header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIPBCKIA@read?5past?5buffer@
CONST	SEGMENT
??_C@_0BB@PIPBCKIA@read?5past?5buffer@ DB 'read past buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECDHMDI@zlib?5corrupt@
CONST	SEGMENT
??_C@_0N@IECDHMDI@zlib?5corrupt@ DB 'zlib corrupt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIAPIMGJ@bad?5dist@
CONST	SEGMENT
??_C@_08DIAPIMGJ@bad?5dist@ DB 'bad dist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBFIPFO@output?5buffer?5limit@
CONST	SEGMENT
??_C@_0BE@IBFIPFO@output?5buffer?5limit@ DB 'output buffer limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNKOBMC@bad?5codelengths@
CONST	SEGMENT
??_C@_0BA@MDNKOBMC@bad?5codelengths@ DB 'bad codelengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHLEIKL@bad?5sizes@
CONST	SEGMENT
??_C@_09EOHLEIKL@bad?5sizes@ DB 'bad sizes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
CONST	SEGMENT
??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, '6', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBPNPPBJ@bad?5req_comp@
CONST	SEGMENT
??_C@_0N@KBPNPPBJ@bad?5req_comp@ DB 'bad req_comp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
CONST	SEGMENT
??_C@_0P@PNCLKCLJ@bad?5DNL?5height@ DB 'bad DNL height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMOIECP@bad?5DNL?5len@
CONST	SEGMENT
??_C@_0M@EPMOIECP@bad?5DNL?5len@ DB 'bad DNL len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFCEAHIA@no?5SOF@
CONST	SEGMENT
??_C@_06IFCEAHIA@no?5SOF@ DB 'no SOF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLMBLEP@no?5SOI@
CONST	SEGMENT
??_C@_06CLMBLEP@no?5SOI@ DB 'no SOI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJIHDFHI@bad?5TQ@
CONST	SEGMENT
??_C@_06LJIHDFHI@bad?5TQ@ DB 'bad TQ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPLLHCJG@bad?5V@
CONST	SEGMENT
??_C@_05MPLLHCJG@bad?5V@ DB 'bad V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLPKENEJ@bad?5H@
CONST	SEGMENT
??_C@_05BLPKENEJ@bad?5H@ DB 'bad H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAPHADHL@bad?5component?5count@
CONST	SEGMENT
??_C@_0BE@DAPHADHL@bad?5component?5count@ DB 'bad component count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJDLMMBJ@too?5large@
CONST	SEGMENT
??_C@_09OJDLMMBJ@too?5large@ DB 'too large', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BIDACDEF@0?5width@
CONST	SEGMENT
??_C@_07BIDACDEF@0?5width@ DB '0 width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNEGOMA@no?5header?5height@
CONST	SEGMENT
??_C@_0BB@LNEGOMA@no?5header?5height@ DB 'no header height', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCINMEBJ@only?58?9bit@
CONST	SEGMENT
??_C@_0L@BCINMEBJ@only?58?9bit@ DB 'only 8-bit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOFMJEMP@bad?5SOF?5len@
CONST	SEGMENT
??_C@_0M@DOFMJEMP@bad?5SOF?5len@ DB 'bad SOF len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEJOMGGP@bad?5SOS@
CONST	SEGMENT
??_C@_07EEJOMGGP@bad?5SOS@ DB 'bad SOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGMCBLGG@bad?5AC?5huff@
CONST	SEGMENT
??_C@_0M@JGMCBLGG@bad?5AC?5huff@ DB 'bad AC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOCCBFAC@bad?5DC?5huff@
CONST	SEGMENT
??_C@_0M@NOCCBFAC@bad?5DC?5huff@ DB 'bad DC huff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNEHAHOH@bad?5SOS?5len@
CONST	SEGMENT
??_C@_0M@GNEHAHOH@bad?5SOS?5len@ DB 'bad SOS len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
CONST	SEGMENT
??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@ DB 'bad SOS component coun'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNGPHMMK@unknown?5marker@
CONST	SEGMENT
??_C@_0P@NNGPHMMK@unknown?5marker@ DB 'unknown marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENLKPDI@bad?5APP?5len@
CONST	SEGMENT
??_C@_0M@EENLKPDI@bad?5APP?5len@ DB 'bad APP len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CICAFFCH@bad?5COM?5len@
CONST	SEGMENT
??_C@_0M@CICAFFCH@bad?5COM?5len@ DB 'bad COM len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLGKOCGN@bad?5DHT?5header@
CONST	SEGMENT
??_C@_0P@JLGKOCGN@bad?5DHT?5header@ DB 'bad DHT header', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNHKKDIM@bad?5DQT?5table@
CONST	SEGMENT
??_C@_0O@CNHKKDIM@bad?5DQT?5table@ DB 'bad DQT table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFJCHAP@bad?5DQT?5type@
CONST	SEGMENT
??_C@_0N@BOFJCHAP@bad?5DQT?5type@ DB 'bad DQT type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPHNODCG@bad?5DRI?5len@
CONST	SEGMENT
??_C@_0M@LPHNODCG@bad?5DRI?5len@ DB 'bad DRI len', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLNDOKJD@expected?5marker@
CONST	SEGMENT
??_C@_0BA@KLNDOKJD@expected?5marker@ DB 'expected marker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
CONST	SEGMENT
??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@ DB 'can''t merge dc and ac'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFDKCGFO@bad?5delta@
CONST	SEGMENT
??_C@_09IFDKCGFO@bad?5delta@ DB 'bad delta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIMLINA@bad?5huffman?5code@
CONST	SEGMENT
??_C@_0BB@IIMLINA@bad?5huffman?5code@ DB 'bad huffman code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
CONST	SEGMENT
??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@ DB '('
	DB	00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H
	DB	'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ']'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'h', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '['
	DB	00H, 'c', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
CONST	SEGMENT
??_C@_0BB@FOKGPEKG@bad?5code?5lengths@ DB 'bad code lengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEFOLMLB@bad?5size?5list@
CONST	SEGMENT
??_C@_0O@DEFOLMLB@bad?5size?5list@ DB 'bad size list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHDBFHD@unsupported@
CONST	SEGMENT
??_C@_0M@MHDBFHD@unsupported@ DB 'unsupported', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@ DB 'r'
	DB	00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPDHFAGK@can?8t?5fopen@
CONST	SEGMENT
??_C@_0M@JPDHFAGK@can?8t?5fopen@ DB 'can''t fopen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
CONST	SEGMENT
??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@ DB 'r'
	DB	00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '8', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'r', 00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, '6'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
CONST	SEGMENT
??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'g', 00H, 'o'
	DB	00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H
	DB	'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, '\', 00H, 'c', 00H, 'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, 'l', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'c', 00H, 'G', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, 's', 00H, '\', 00H, 's'
	DB	00H, 't', 00H, 'b', 00H, '-', 00H, 'm', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, '\', 00H, 's', 00H, 't', 00H, 'b'
	DB	00H, '_', 00H, 'i', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOGIMCHF@outofmem@
CONST	SEGMENT
??_C@_08NOGIMCHF@outofmem@ DB 'outofmem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEDEJPH@unknown?5image?5type@
CONST	SEGMENT
??_C@_0BD@CBEDEJPH@unknown?5image?5type@ DB 'unknown image type', 00H ; `string'
__8C83BECC_concurrencysal@h DB 01H
__608E3340_sal@h DB 01H
__FB67E29A_vadefs@h DB 01H
__1D1B619C_vcruntime@h DB 01H
__735960E1_corecrt@h DB 01H
__60B45B40_corecrt_stdio_config@h DB 01H
__CFA3741E_corecrt_wstdio@h DB 01H
__B3FE3303_stdio@h DB 01H
__211DB995_corecrt_malloc@h DB 01H
__955456CD_stddef@h DB 01H
__99AED4FB_corecrt_search@h DB 01H
__8B813BF6_corecrt_wstdlib@h DB 01H
__3D1CA2C3_limits@h DB 01H
__E8FB0A68_stdlib@h DB 01H
__B7B53233_stdarg@h DB 01H
__13DE2371_errno@h DB 01H
__8C6AE390_vcruntime_string@h DB 01H
__8ACB2152_corecrt_memcpy_s@h DB 01H
__EA6C9D17_corecrt_memory@h DB 01H
__0DF2AF52_corecrt_wstring@h DB 01H
__6E889ECC_string@h DB 01H
__1D9A7FA2_corecrt_math@h DB 01H
__2E93F1C0_math@h DB 01H
__9FB25DBE_assert@h DB 01H
__5C8CA4D3_mmintrin@h DB 01H
__7CD62D9E_malloc@h DB 01H
__9DCE0DC8_xmmintrin@h DB 01H
__F8AC8404_emmintrin@h DB 01H
__47E843D2_intrin0@inl@h DB 01H
__130964FF_setjmp@h DB 01H
__270DEC8D_pmmintrin@h DB 01H
__97D49F0F_tmmintrin@h DB 01H
__BEEF8A8C_smmintrin@h DB 01H
__DB8D0340_nmmintrin@h DB 01H
__0E36F90E_wmmintrin@h DB 01H
__C5A2B409_zmmintrin@h DB 01H
__F2B616C3_immintrin@h DB 01H
__4875F786_ammintrin@h DB 01H
__353FD888_intrin@h DB 01H
__EA75B8E6_stb_image@h DB 01H
__4C2AD0C7_winpackagefamily@h DB 01H
__9DED9ED1_winapifamily@h DB 01H
__12FEDF4E_sdkddkver@h DB 01H
__9BAEE128_excpt@h DB 01H
__6B04FCB3_specstrings_undef@h DB 01H
__F4027AF7_specstrings_strict@h DB 01H
__B90340D4_sdv_driverspecs@h DB 01H
__BFFF5AD3_driverspecs@h DB 01H
__32847078_specstrings@h DB 01H
__108B2620_corecrt_wctype@h DB 01H
__6CD6613D_ctype@h DB 01H
__30902A1F_kernelspecs@h DB 01H
__376FD5CA_basetsd@h DB 01H
__9BEDF4DE_guiddef@h DB 01H
__51BFD2FE_pshpack4@h DB 01H
__31652CEA_poppack@h DB 01H
__5532AE4C_pshpack2@h DB 01H
__58A52B9A_pshpack8@h DB 01H
__57741015_pshpack1@h DB 01H
__CDE68C90_apiset@h DB 01H
__0BF06E8D_ktmtypes@h DB 01H
__40C200C0_winnt@h DB 01H
__9336F789_minwindef@h DB 01H
__55136115_windef@h DB 01H
__32205BF0_apisetcconv@h DB 01H
__B48FDEA0_minwinbase@h DB 01H
__3551B028_apiquery2@h DB 01H
__65BE04AA_processenv@h DB 01H
__4767CA46_fileapi@h DB 01H
__282E6C4B_fileapifromapp@h DB 01H
__393AF12C_debugapi@h DB 01H
__EBC502B8_utilapiset@h DB 01H
__1EAD8C69_handleapi@h DB 01H
__D8EF9B29_errhandlingapi@h DB 01H
__97FC1204_fibersapi@h DB 01H
__27448220_namedpipeapi@h DB 01H
__6EA33B2A_profileapi@h DB 01H
__EAC6F673_heapapi@h DB 01H
__D64EEA5A_ioapiset@h DB 01H
__144BD4B6_synchapi@h DB 01H
__03B1C640_interlockedapi@h DB 01H
__DC64CB38_processthreadsapi@h DB 01H
__D719B518_sysinfoapi@h DB 01H
__410385B1_memoryapi@h DB 01H
__C1AD45EF_enclaveapi@h DB 01H
__F4C3AA32_threadpoollegacyapiset@h DB 01H
__AC5A7A9F_threadpoolapiset@h DB 01H
__F5254B21_jobapi@h DB 01H
__BCEA6EE8_jobapi2@h DB 01H
__D18ACE72_wow64apiset@h DB 01H
__669B0D4A_libloaderapi@h DB 01H
__645F7034_securitybaseapi@h DB 01H
__67E58557_namespaceapi@h DB 01H
__599D9D3A_systemtopologyapi@h DB 01H
__2337E373_processtopologyapi@h DB 01H
__02BFF239_securityappcontainer@h DB 01H
__9C196272_realtimeapiset@h DB 01H
__5AB313A4_winerror@h DB 01H
__B7E7187B_timezoneapi@h DB 01H
__6DE9EB6F_winbase@h DB 01H
__56B2AFF2_wingdi@h DB 01H
__BA1161A9_tvout@h DB 01H
__0501A018_winuser@h DB 01H
__EF12FA99_datetimeapi@h DB 01H
__8FA7C3CA_winnls@h DB 01H
__390F0C47_stringapiset@h DB 01H
__28605B0A_wincontypes@h DB 01H
__BFBDE86D_consoleapi@h DB 01H
__C3CAFBF0_consoleapi2@h DB 01H
__C20891C7_consoleapi3@h DB 01H
__717C98B6_wincon@h DB 01H
__2884C177_verrsrc@h DB 01H
__A3FD3A34_winver@h DB 01H
__6F8AD9F1_reason@h DB 01H
__4C90FD6F_winreg@h DB 01H
__68AFEBAD_wnnc@h DB 01H
__5A7AB086_winnetwk@h DB 01H
__859C3CD3_cderr@h DB 01H
__81B12F1A_dde@h DB 01H
__DD3AF97A_ddeml@h DB 01H
__E6B47715_dlgs@h DB 01H
__944BD57D_lzexpand@h DB 01H
__E4B2DFC7_mmsyscom@h DB 01H
__5287D88F_mciapi@h DB 01H
__DBDC1384_mmiscapi@h DB 01H
__1A78C0D7_mmiscapi2@h DB 01H
__0D05975C_playsoundapi@h DB 01H
__757A63A9_mmeapi@h DB 01H
__6326AB05_timeapi@h DB 01H
__77D483B2_joystickapi@h DB 01H
__59CF7431_mmsystem@h DB 01H
__CEAC417E_nb30@h DB 01H
__3BA1A118_rpcdcep@h DB 01H
__74064437_rpcdce@h DB 01H
__90546602_rpcnsi@h DB 01H
__83114A2C_rpcnterr@h DB 01H
__CA67519E_rpcasync@h DB 01H
__D8CEBCD8_rpc@h DB 01H
__9F43AC2D_shellapi@h DB 01H
__6C8D3703_winperf@h DB 01H
__AB40A29E_inaddr@h DB 01H
__40D4FEA5_winsock@h DB 01H
__51394074_bcrypt@h DB 01H
__F177C154_ncrypt@h DB 01H
__1445529E_dpapi@h DB 01H
__5743FB20_wincrypt@h DB 01H
__97CA12BF_winefs@h DB 01H
__6DF63719_rpcnsip@h DB 01H
__031EFCA1_rpcsal@h DB 01H
__BA08D1DA_rpcndr@h DB 01H
__3A941F83_wtypesbase@h DB 01H
__C244FEE1_wtypes@h DB 01H
__FB7C5F97_winioctl@h DB 01H
__4B65E4AC_winsmcrd@h DB 01H
__1EA80168_winscard@h DB 01H
__516FC0F9_prsht@h DB 01H
__88BA11C6_winspool@h DB 01H
__18DB4C56_unknwnbase@h DB 01H
__1AE6FA1A_objidlbase@h DB 01H
__7F98E437_cguid@h DB 01H
__6B2DFB49_combaseapi@h DB 01H
__CB0E8B37_unknwn@h DB 01H
__D981EF0A_objidl@h DB 01H
__37089EB8_oaidl@h DB 01H
__CA2DDD8B_propidlbase@h DB 01H
__39ED323E_coml2api@h DB 01H
__78E82682_oleidl@h DB 01H
__97883CFE_servprov@h DB 01H
__CE01DDB9_msxml@h DB 01H
__A4784895_urlmon@h DB 01H
__325F1C97_propidl@h DB 01H
__D3D43343_objbase@h DB 01H
__B3A2AF1B_oleauto@h DB 01H
__5722A8AA_ole2@h DB 01H
__590A450A_commdlg@h DB 01H
__2FE8A10C_stralign@h DB 01H
__34558472_winsvc@h DB 01H
__058845F1_mcx@h DB 01H
__7F16006B_ime_cmodes@h DB 01H
__0A3AF599_imm@h DB 01H
__11B87C25_Windows@h DB 01H
__0B1C67B3_gl@h DB 01H
__D7C03EE9_glu@h DB 01H
__13490EC2_glew@h DB 01H
__F2638511_stdbool@h DB 01H
__836A8CFC_stdint@h DB 01H
__129F966A_glfw3@h DB 01H
__0A8909AB_vectors@h DB 01H
__E0493894_main@h DB 01H
__5CFF7615_Debug@h DB 01H
__565DCB0D_animations@h DB 01H
__D929D131_Physics@h DB 01H
__294C502B_Mesh@h DB 01H
__D1DC2946_EntityManager@h DB 01H
__EBE4262C_Dictionary@h DB 01H
__1F46D782_scene 1@h DB 01H
__46B7CB64_math@h DB 01H
__7C36FFA4_Dictionary@c DB 01H
cConst	DQ	0000000000003039H
aConst	DQ	00000000015a4e35H
?rgb@?5??stbi__process_frame_header@@9@9 DB 052H	; `stbi__process_frame_header'::`6'::rgb
	DB	047H
	DB	042H
	ORG $+5
stbi__jbias DD	00H
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
stbi__zdefault_length DB 08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
stbi__jpeg_dezigzag DB 00H
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
stbi__zlength_base DD 03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
stbi__zdist_base DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
stbi__bmask DD	00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	ORG $+4
stbi__zlength_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
?tag@?O@??stbi__process_marker@@9@9 DB 04aH		; `stbi__process_marker'::`14'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
	ORG $+7
?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9 DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+5
stbi__depth_scale_table DB 00H
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+7
stbi__zdefault_distance DB 05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?tag@?BA@??stbi__process_marker@@9@9 DB 041H		; `stbi__process_marker'::`16'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
	ORG $+2
maxNugRand DQ	0000000100000000H
stbi__zdist_extra DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
?png_sig@?1??stbi__check_png_header@@9@9 DB 089H	; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
PUBLIC	NugHash
PUBLIC	GetFrame
PUBLIC	TryGetFrame
PUBLIC	AddFrameData
PUBLIC	AddLocVal2
PUBLIC	GetLocVal2
PUBLIC	AddUintVal2
PUBLIC	GetUintVal2
PUBLIC	UAbs
PUBLIC	NugRand
PUBLIC	stbi_is_16_bit_from_callbacks
PUBLIC	stbi_is_16_bit_from_memory
PUBLIC	stbi_info_from_callbacks
PUBLIC	stbi_info_from_memory
PUBLIC	stbi_is_16_bit_from_file
PUBLIC	stbi_is_16_bit
PUBLIC	stbi_info_from_file
PUBLIC	stbi_info
PUBLIC	stbi_convert_iphone_png_to_rgb_thread
PUBLIC	stbi_set_unpremultiply_on_load_thread
PUBLIC	stbi_convert_iphone_png_to_rgb
PUBLIC	stbi_set_unpremultiply_on_load
PUBLIC	stbi_zlib_decode_noheader_buffer
PUBLIC	stbi_zlib_decode_noheader_malloc
PUBLIC	stbi_zlib_decode_buffer
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_zlib_decode_malloc
PUBLIC	stbi_zlib_decode_malloc_guesssize
PUBLIC	stbi_hdr_to_ldr_scale
PUBLIC	stbi_hdr_to_ldr_gamma
PUBLIC	stbi_ldr_to_hdr_scale
PUBLIC	stbi_ldr_to_hdr_gamma
PUBLIC	stbi_is_hdr_from_callbacks
PUBLIC	stbi_is_hdr_from_file
PUBLIC	stbi_is_hdr
PUBLIC	stbi_is_hdr_from_memory
PUBLIC	stbi_loadf_from_file
PUBLIC	stbi_loadf
PUBLIC	stbi_loadf_from_callbacks
PUBLIC	stbi_loadf_from_memory
PUBLIC	stbi_load_gif_from_memory
PUBLIC	stbi_load_from_callbacks
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_16_from_callbacks
PUBLIC	stbi_load_16_from_memory
PUBLIC	stbi_load_16
PUBLIC	stbi_load_from_file_16
PUBLIC	stbi_load_from_file
PUBLIC	stbi_load
PUBLIC	stbi_set_flip_vertically_on_load_thread
PUBLIC	stbi_set_flip_vertically_on_load
PUBLIC	stbi_image_free
PUBLIC	TryGetFrame2
PUBLIC	stbi_failure_reason
stbi__vertically_flip_on_load_local DD 01H DUP (?)
stbi__de_iphone_flag_global DD 01H DUP (?)
stbi__vertically_flip_on_load_global DD 01H DUP (?)
	ALIGN	8

stbi__g_failure_reason DQ 01H DUP (?)
stbi__unpremultiply_on_load_global DD 01H DUP (?)
stbi__unpremultiply_on_load_set DD 01H DUP (?)
stbi__de_iphone_flag_local DD 01H DUP (?)
stbi__de_iphone_flag_set DD 01H DUP (?)
stbi__unpremultiply_on_load_local DD 01H DUP (?)
stbi__vertically_flip_on_load_set DD 01H DUP (?)
_TLS	ENDS
pdata	SEGMENT
$pdata$NugHash DD imagerel $LN7
	DD	imagerel $LN7+167
	DD	imagerel $unwind$NugHash
$pdata$GetFrame DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$GetFrame
$pdata$TryGetFrame DD imagerel $LN4
	DD	imagerel $LN4+149
	DD	imagerel $unwind$TryGetFrame
$pdata$AddFrameData DD imagerel $LN4
	DD	imagerel $LN4+277
	DD	imagerel $unwind$AddFrameData
$pdata$AddLocVal2 DD imagerel $LN4
	DD	imagerel $LN4+240
	DD	imagerel $unwind$AddLocVal2
$pdata$GetLocVal2 DD imagerel $LN6
	DD	imagerel $LN6+134
	DD	imagerel $unwind$GetLocVal2
$pdata$AddUintVal2 DD imagerel $LN10
	DD	imagerel $LN10+336
	DD	imagerel $unwind$AddUintVal2
$pdata$GetUintVal2 DD imagerel $LN12
	DD	imagerel $LN12+248
	DD	imagerel $unwind$GetUintVal2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UAbs DD	imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$UAbs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$NugRand DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$NugRand
pdata	ENDS
pdata	SEGMENT
$pdata$stbi_is_16_bit_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+155
	DD	imagerel $unwind$stbi_is_16_bit_from_callbacks
$pdata$stbi_is_16_bit_from_memory DD imagerel $LN3
	DD	imagerel $LN3+154
	DD	imagerel $unwind$stbi_is_16_bit_from_memory
$pdata$stbi_info_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+189
	DD	imagerel $unwind$stbi_info_from_callbacks
$pdata$stbi_info_from_memory DD imagerel $LN3
	DD	imagerel $LN3+188
	DD	imagerel $unwind$stbi_info_from_memory
$pdata$stbi_is_16_bit_from_file DD imagerel $LN3
	DD	imagerel $LN3+193
	DD	imagerel $unwind$stbi_is_16_bit_from_file
$pdata$stbi_is_16_bit DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$stbi_is_16_bit
$pdata$stbi_info_from_file DD imagerel $LN3
	DD	imagerel $LN3+232
	DD	imagerel $unwind$stbi_info_from_file
$pdata$stbi_info DD imagerel $LN4
	DD	imagerel $LN4+131
	DD	imagerel $unwind$stbi_info
$pdata$stbi__is_16_main DD imagerel stbi__is_16_main
	DD	imagerel stbi__is_16_main+93
	DD	imagerel $unwind$stbi__is_16_main
$pdata$stbi__info_main DD imagerel stbi__info_main
	DD	imagerel stbi__info_main+394
	DD	imagerel $unwind$stbi__info_main
$pdata$stbi__pnm_is16 DD imagerel stbi__pnm_is16
	DD	imagerel stbi__pnm_is16+60
	DD	imagerel $unwind$stbi__pnm_is16
$pdata$stbi__pnm_info DD imagerel stbi__pnm_info
	DD	imagerel stbi__pnm_info+1160
	DD	imagerel $unwind$stbi__pnm_info
$pdata$stbi__pnm_getinteger DD imagerel stbi__pnm_getinteger
	DD	imagerel stbi__pnm_getinteger+445
	DD	imagerel $unwind$stbi__pnm_getinteger
$pdata$stbi__pnm_isdigit DD imagerel stbi__pnm_isdigit
	DD	imagerel stbi__pnm_isdigit+69
	DD	imagerel $unwind$stbi__pnm_isdigit
$pdata$stbi__pnm_skip_whitespace DD imagerel stbi__pnm_skip_whitespace
	DD	imagerel stbi__pnm_skip_whitespace+858
	DD	imagerel $unwind$stbi__pnm_skip_whitespace
$pdata$stbi__pnm_isspace DD imagerel stbi__pnm_isspace
	DD	imagerel stbi__pnm_isspace+109
	DD	imagerel $unwind$stbi__pnm_isspace
$pdata$stbi__pnm_load DD imagerel stbi__pnm_load
	DD	imagerel stbi__pnm_load+908
	DD	imagerel $unwind$stbi__pnm_load
$pdata$stbi__pnm_test DD imagerel stbi__pnm_test
	DD	imagerel stbi__pnm_test+427
	DD	imagerel $unwind$stbi__pnm_test
$pdata$stbi__pic_info DD imagerel stbi__pic_info
	DD	imagerel stbi__pic_info+1882
	DD	imagerel $unwind$stbi__pic_info
$pdata$stbi__psd_is16 DD imagerel stbi__psd_is16
	DD	imagerel stbi__psd_is16+208
	DD	imagerel $unwind$stbi__psd_is16
$pdata$stbi__psd_info DD imagerel stbi__psd_info
	DD	imagerel stbi__psd_info+430
	DD	imagerel $unwind$stbi__psd_info
$pdata$stbi__bmp_info DD imagerel stbi__bmp_info
	DD	imagerel stbi__bmp_info+333
	DD	imagerel $unwind$stbi__bmp_info
$pdata$stbi__hdr_info DD imagerel stbi__hdr_info
	DD	imagerel stbi__hdr_info+691
	DD	imagerel $unwind$stbi__hdr_info
$pdata$stbi__hdr_load DD imagerel stbi__hdr_load
	DD	imagerel stbi__hdr_load+4616
	DD	imagerel $unwind$stbi__hdr_load
$pdata$stbi__hdr_convert DD imagerel stbi__hdr_convert
	DD	imagerel stbi__hdr_convert+623
	DD	imagerel $unwind$stbi__hdr_convert
$pdata$stbi__hdr_gettoken DD imagerel stbi__hdr_gettoken
	DD	imagerel stbi__hdr_gettoken+921
	DD	imagerel $unwind$stbi__hdr_gettoken
$pdata$stbi__hdr_test DD imagerel stbi__hdr_test
	DD	imagerel stbi__hdr_test+102
	DD	imagerel $unwind$stbi__hdr_test
$pdata$stbi__hdr_test_core DD imagerel stbi__hdr_test_core
	DD	imagerel stbi__hdr_test_core+292
	DD	imagerel $unwind$stbi__hdr_test_core
$pdata$stbi__gif_info DD imagerel stbi__gif_info
	DD	imagerel stbi__gif_info+68
	DD	imagerel $unwind$stbi__gif_info
$pdata$stbi__gif_load DD imagerel stbi__gif_load
	DD	imagerel stbi__gif_load+379
	DD	imagerel $unwind$stbi__gif_load
$pdata$stbi__load_gif_main DD imagerel stbi__load_gif_main
	DD	imagerel stbi__load_gif_main+1182
	DD	imagerel $unwind$stbi__load_gif_main
$pdata$stbi__load_gif_main_outofmem DD imagerel stbi__load_gif_main_outofmem
	DD	imagerel stbi__load_gif_main_outofmem+178
	DD	imagerel $unwind$stbi__load_gif_main_outofmem
$pdata$stbi__gif_load_next DD imagerel stbi__gif_load_next
	DD	imagerel stbi__gif_load_next+3988
	DD	imagerel $unwind$stbi__gif_load_next
$pdata$stbi__process_gif_raster DD imagerel stbi__process_gif_raster
	DD	imagerel stbi__process_gif_raster+1930
	DD	imagerel $unwind$stbi__process_gif_raster
$pdata$stbi__out_gif_code DD imagerel stbi__out_gif_code
	DD	imagerel stbi__out_gif_code+677
	DD	imagerel $unwind$stbi__out_gif_code
$pdata$stbi__gif_info_raw DD imagerel stbi__gif_info_raw
	DD	imagerel stbi__gif_info_raw+196
	DD	imagerel $unwind$stbi__gif_info_raw
$pdata$stbi__gif_header DD imagerel stbi__gif_header
	DD	imagerel stbi__gif_header+1993
	DD	imagerel $unwind$stbi__gif_header
$pdata$stbi__gif_parse_colortable DD imagerel stbi__gif_parse_colortable
	DD	imagerel stbi__gif_parse_colortable+733
	DD	imagerel $unwind$stbi__gif_parse_colortable
$pdata$stbi__gif_test DD imagerel stbi__gif_test
	DD	imagerel stbi__gif_test+56
	DD	imagerel $unwind$stbi__gif_test
$pdata$stbi__gif_test_raw DD imagerel stbi__gif_test_raw
	DD	imagerel stbi__gif_test_raw+1150
	DD	imagerel $unwind$stbi__gif_test_raw
$pdata$stbi__pic_test DD imagerel stbi__pic_test
	DD	imagerel stbi__pic_test+56
	DD	imagerel $unwind$stbi__pic_test
$pdata$stbi__pic_load DD imagerel stbi__pic_load
	DD	imagerel stbi__pic_load+1139
	DD	imagerel $unwind$stbi__pic_load
$pdata$stbi__pic_load_core DD imagerel stbi__pic_load_core
	DD	imagerel stbi__pic_load_core+3597
	DD	imagerel $unwind$stbi__pic_load_core
$pdata$stbi__copyval DD imagerel stbi__copyval
	DD	imagerel stbi__copyval+128
	DD	imagerel $unwind$stbi__copyval
$pdata$stbi__readval DD imagerel stbi__readval
	DD	imagerel stbi__readval+470
	DD	imagerel $unwind$stbi__readval
$pdata$stbi__pic_test_core DD imagerel stbi__pic_test_core
	DD	imagerel stbi__pic_test_core+263
	DD	imagerel $unwind$stbi__pic_test_core
$pdata$stbi__pic_is4 DD imagerel stbi__pic_is4
	DD	imagerel stbi__pic_is4+271
	DD	imagerel $unwind$stbi__pic_is4
$pdata$stbi__psd_load DD imagerel stbi__psd_load
	DD	imagerel stbi__psd_load+3291
	DD	imagerel $unwind$stbi__psd_load
$pdata$stbi__psd_decode_rle DD imagerel stbi__psd_decode_rle
	DD	imagerel stbi__psd_decode_rle+836
	DD	imagerel $unwind$stbi__psd_decode_rle
$pdata$stbi__psd_test DD imagerel stbi__psd_test
	DD	imagerel stbi__psd_test+85
	DD	imagerel $unwind$stbi__psd_test
$pdata$stbi__tga_load DD imagerel stbi__tga_load
	DD	imagerel stbi__tga_load+4981
	DD	imagerel $unwind$stbi__tga_load
$pdata$stbi__tga_read_rgb16 DD imagerel stbi__tga_read_rgb16
	DD	imagerel stbi__tga_read_rgb16+211
	DD	imagerel $unwind$stbi__tga_read_rgb16
$pdata$stbi__tga_test DD imagerel stbi__tga_test
	DD	imagerel stbi__tga_test+1175
	DD	imagerel $unwind$stbi__tga_test
$pdata$stbi__tga_info DD imagerel stbi__tga_info
	DD	imagerel stbi__tga_info+1544
	DD	imagerel $unwind$stbi__tga_info
$pdata$stbi__tga_get_comp DD imagerel stbi__tga_get_comp
	DD	imagerel stbi__tga_get_comp+164
	DD	imagerel $unwind$stbi__tga_get_comp
$pdata$stbi__bmp_load DD imagerel stbi__bmp_load
	DD	imagerel stbi__bmp_load+7838
	DD	imagerel $unwind$stbi__bmp_load
$pdata$stbi__bmp_parse_header DD imagerel stbi__bmp_parse_header
	DD	imagerel stbi__bmp_parse_header+1998
	DD	imagerel $unwind$stbi__bmp_parse_header
$pdata$stbi__bmp_set_mask_defaults DD imagerel stbi__bmp_set_mask_defaults
	DD	imagerel stbi__bmp_set_mask_defaults+237
	DD	imagerel $unwind$stbi__bmp_set_mask_defaults
$pdata$stbi__shiftsigned DD imagerel stbi__shiftsigned
	DD	imagerel stbi__shiftsigned+222
	DD	imagerel $unwind$stbi__shiftsigned
$pdata$stbi__bitcount DD imagerel stbi__bitcount
	DD	imagerel stbi__bitcount+153
	DD	imagerel $unwind$stbi__bitcount
$pdata$stbi__high_bit DD imagerel stbi__high_bit
	DD	imagerel stbi__high_bit+195
	DD	imagerel $unwind$stbi__high_bit
$pdata$stbi__bmp_test DD imagerel stbi__bmp_test
	DD	imagerel stbi__bmp_test+56
	DD	imagerel $unwind$stbi__bmp_test
$pdata$stbi__bmp_test_raw DD imagerel stbi__bmp_test_raw
	DD	imagerel stbi__bmp_test_raw+516
	DD	imagerel $unwind$stbi__bmp_test_raw
$pdata$stbi__png_is16 DD imagerel stbi__png_is16
	DD	imagerel stbi__png_is16+167
	DD	imagerel $unwind$stbi__png_is16
$pdata$stbi__png_info DD imagerel stbi__png_info
	DD	imagerel stbi__png_info+164
	DD	imagerel $unwind$stbi__png_info
$pdata$stbi__png_info_raw DD imagerel stbi__png_info_raw
	DD	imagerel stbi__png_info_raw+164
	DD	imagerel $unwind$stbi__png_info_raw
$pdata$stbi__png_test DD imagerel stbi__png_test
	DD	imagerel stbi__png_test+56
	DD	imagerel $unwind$stbi__png_test
$pdata$stbi__png_load DD imagerel stbi__png_load
	DD	imagerel stbi__png_load+194
	DD	imagerel $unwind$stbi__png_load
$pdata$stbi__do_png DD imagerel stbi__do_png
	DD	imagerel stbi__do_png+632
	DD	imagerel $unwind$stbi__do_png
$pdata$stbi__parse_png_file DD imagerel stbi__parse_png_file
	DD	imagerel stbi__parse_png_file+5957
	DD	imagerel $unwind$stbi__parse_png_file
$pdata$stbi__de_iphone DD imagerel stbi__de_iphone
	DD	imagerel stbi__de_iphone+801
	DD	imagerel $unwind$stbi__de_iphone
$pdata$stbi_convert_iphone_png_to_rgb_thread DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$stbi_convert_iphone_png_to_rgb_thread
$pdata$stbi_set_unpremultiply_on_load_thread DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$stbi_set_unpremultiply_on_load_thread
$pdata$stbi_convert_iphone_png_to_rgb DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$stbi_convert_iphone_png_to_rgb
$pdata$stbi_set_unpremultiply_on_load DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$stbi_set_unpremultiply_on_load
$pdata$stbi__expand_png_palette DD imagerel stbi__expand_png_palette
	DD	imagerel stbi__expand_png_palette+577
	DD	imagerel $unwind$stbi__expand_png_palette
$pdata$stbi__compute_transparency16 DD imagerel stbi__compute_transparency16
	DD	imagerel stbi__compute_transparency16+468
	DD	imagerel $unwind$stbi__compute_transparency16
$pdata$stbi__compute_transparency DD imagerel stbi__compute_transparency
	DD	imagerel stbi__compute_transparency+465
	DD	imagerel $unwind$stbi__compute_transparency
$pdata$stbi__create_png_image DD imagerel stbi__create_png_image
	DD	imagerel stbi__create_png_image+1376
	DD	imagerel $unwind$stbi__create_png_image
$pdata$stbi__create_png_image_raw DD imagerel stbi__create_png_image_raw
	DD	imagerel stbi__create_png_image_raw+6384
	DD	imagerel $unwind$stbi__create_png_image_raw
$pdata$stbi__paeth DD imagerel stbi__paeth
	DD	imagerel stbi__paeth+177
	DD	imagerel $unwind$stbi__paeth
$pdata$stbi__check_png_header DD imagerel stbi__check_png_header
	DD	imagerel stbi__check_png_header+278
	DD	imagerel $unwind$stbi__check_png_header
$pdata$stbi__get_chunk_header DD imagerel stbi__get_chunk_header
	DD	imagerel stbi__get_chunk_header+104
	DD	imagerel $unwind$stbi__get_chunk_header
$pdata$stbi_zlib_decode_noheader_buffer DD imagerel $LN5
	DD	imagerel $LN5+240
	DD	imagerel $unwind$stbi_zlib_decode_noheader_buffer
$pdata$stbi_zlib_decode_noheader_malloc DD imagerel $LN7
	DD	imagerel $LN7+306
	DD	imagerel $unwind$stbi_zlib_decode_noheader_malloc
$pdata$stbi_zlib_decode_buffer DD imagerel $LN5
	DD	imagerel $LN5+240
	DD	imagerel $unwind$stbi_zlib_decode_buffer
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN7
	DD	imagerel $LN7+322
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
$pdata$stbi_zlib_decode_malloc DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$stbi_zlib_decode_malloc
$pdata$stbi_zlib_decode_malloc_guesssize DD imagerel $LN7
	DD	imagerel $LN7+319
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize
$pdata$stbi__do_zlib DD imagerel stbi__do_zlib
	DD	imagerel stbi__do_zlib+122
	DD	imagerel $unwind$stbi__do_zlib
$pdata$stbi__parse_zlib DD imagerel stbi__parse_zlib
	DD	imagerel stbi__parse_zlib+473
	DD	imagerel $unwind$stbi__parse_zlib
$pdata$stbi__parse_zlib_header DD imagerel stbi__parse_zlib_header
	DD	imagerel stbi__parse_zlib_header+433
	DD	imagerel $unwind$stbi__parse_zlib_header
$pdata$stbi__parse_uncompressed_block DD imagerel stbi__parse_uncompressed_block
	DD	imagerel stbi__parse_uncompressed_block+882
	DD	imagerel $unwind$stbi__parse_uncompressed_block
$pdata$stbi__compute_huffman_codes DD imagerel stbi__compute_huffman_codes
	DD	imagerel stbi__compute_huffman_codes+2104
	DD	imagerel $unwind$stbi__compute_huffman_codes
$pdata$stbi__parse_huffman_block DD imagerel stbi__parse_huffman_block
	DD	imagerel stbi__parse_huffman_block+1707
	DD	imagerel $unwind$stbi__parse_huffman_block
$pdata$stbi__zexpand DD imagerel stbi__zexpand
	DD	imagerel stbi__zexpand+339
	DD	imagerel $unwind$stbi__zexpand
$pdata$stbi__zhuffman_decode DD imagerel stbi__zhuffman_decode
	DD	imagerel stbi__zhuffman_decode+247
	DD	imagerel $unwind$stbi__zhuffman_decode
$pdata$stbi__zhuffman_decode_slowpath DD imagerel stbi__zhuffman_decode_slowpath
	DD	imagerel stbi__zhuffman_decode_slowpath+496
	DD	imagerel $unwind$stbi__zhuffman_decode_slowpath
$pdata$stbi__zreceive DD imagerel stbi__zreceive
	DD	imagerel stbi__zreceive+158
	DD	imagerel $unwind$stbi__zreceive
$pdata$stbi__fill_bits DD imagerel stbi__fill_bits
	DD	imagerel stbi__fill_bits+265
	DD	imagerel $unwind$stbi__fill_bits
$pdata$stbi__zget8 DD imagerel stbi__zget8
	DD	imagerel stbi__zget8+130
	DD	imagerel $unwind$stbi__zget8
$pdata$stbi__zeof DD imagerel stbi__zeof
	DD	imagerel stbi__zeof+69
	DD	imagerel $unwind$stbi__zeof
$pdata$stbi__zbuild_huffman DD imagerel stbi__zbuild_huffman
	DD	imagerel stbi__zbuild_huffman+1298
	DD	imagerel $unwind$stbi__zbuild_huffman
$pdata$stbi__bit_reverse DD imagerel stbi__bit_reverse
	DD	imagerel stbi__bit_reverse+219
	DD	imagerel $unwind$stbi__bit_reverse
$pdata$stbi__bitreverse16 DD imagerel stbi__bitreverse16
	DD	imagerel stbi__bitreverse16+153
	DD	imagerel $unwind$stbi__bitreverse16
$pdata$stbi__jpeg_info DD imagerel stbi__jpeg_info
	DD	imagerel stbi__jpeg_info+151
	DD	imagerel $unwind$stbi__jpeg_info
$pdata$stbi__jpeg_info_raw DD imagerel stbi__jpeg_info_raw
	DD	imagerel stbi__jpeg_info_raw+186
	DD	imagerel $unwind$stbi__jpeg_info_raw
$pdata$stbi__jpeg_test DD imagerel stbi__jpeg_test
	DD	imagerel stbi__jpeg_test+146
	DD	imagerel $unwind$stbi__jpeg_test
$pdata$stbi__jpeg_load DD imagerel stbi__jpeg_load
	DD	imagerel stbi__jpeg_load+203
	DD	imagerel $unwind$stbi__jpeg_load
$pdata$load_jpeg_image DD imagerel load_jpeg_image
	DD	imagerel load_jpeg_image+4862
	DD	imagerel $unwind$load_jpeg_image
$pdata$stbi__blinn_8x8 DD imagerel stbi__blinn_8x8
	DD	imagerel stbi__blinn_8x8+71
	DD	imagerel $unwind$stbi__blinn_8x8
$pdata$stbi__cleanup_jpeg DD imagerel stbi__cleanup_jpeg
	DD	imagerel stbi__cleanup_jpeg+53
	DD	imagerel $unwind$stbi__cleanup_jpeg
$pdata$stbi__setup_jpeg DD imagerel stbi__setup_jpeg
	DD	imagerel stbi__setup_jpeg+151
	DD	imagerel $unwind$stbi__setup_jpeg
$pdata$stbi__YCbCr_to_RGB_simd DD imagerel stbi__YCbCr_to_RGB_simd
	DD	imagerel stbi__YCbCr_to_RGB_simd+1507
	DD	imagerel $unwind$stbi__YCbCr_to_RGB_simd
$pdata$stbi__YCbCr_to_RGB_row DD imagerel stbi__YCbCr_to_RGB_row
	DD	imagerel stbi__YCbCr_to_RGB_row+474
	DD	imagerel $unwind$stbi__YCbCr_to_RGB_row
$pdata$stbi__resample_row_generic DD imagerel stbi__resample_row_generic
	DD	imagerel stbi__resample_row_generic+152
	DD	imagerel $unwind$stbi__resample_row_generic
$pdata$stbi__resample_row_hv_2_simd DD imagerel stbi__resample_row_hv_2_simd
	DD	imagerel stbi__resample_row_hv_2_simd+1292
	DD	imagerel $unwind$stbi__resample_row_hv_2_simd
$pdata$stbi__resample_row_hv_2 DD imagerel stbi__resample_row_hv_2
	DD	imagerel stbi__resample_row_hv_2+408
	DD	imagerel $unwind$stbi__resample_row_hv_2
$pdata$stbi__resample_row_h_2 DD imagerel stbi__resample_row_h_2
	DD	imagerel stbi__resample_row_h_2+499
	DD	imagerel $unwind$stbi__resample_row_h_2
$pdata$stbi__resample_row_v_2 DD imagerel stbi__resample_row_v_2
	DD	imagerel stbi__resample_row_v_2+132
	DD	imagerel $unwind$stbi__resample_row_v_2
$pdata$resample_row_1 DD imagerel resample_row_1
	DD	imagerel resample_row_1+48
	DD	imagerel $unwind$resample_row_1
$pdata$stbi__decode_jpeg_image DD imagerel stbi__decode_jpeg_image
	DD	imagerel stbi__decode_jpeg_image+526
	DD	imagerel $unwind$stbi__decode_jpeg_image
$pdata$stbi__skip_jpeg_junk_at_end DD imagerel stbi__skip_jpeg_junk_at_end
	DD	imagerel stbi__skip_jpeg_junk_at_end+763
	DD	imagerel $unwind$stbi__skip_jpeg_junk_at_end
$pdata$stbi__decode_jpeg_header DD imagerel stbi__decode_jpeg_header
	DD	imagerel stbi__decode_jpeg_header+498
	DD	imagerel $unwind$stbi__decode_jpeg_header
$pdata$stbi__process_frame_header DD imagerel stbi__process_frame_header
	DD	imagerel stbi__process_frame_header+3336
	DD	imagerel $unwind$stbi__process_frame_header
$pdata$stbi__free_jpeg_components DD imagerel stbi__free_jpeg_components
	DD	imagerel stbi__free_jpeg_components+370
	DD	imagerel $unwind$stbi__free_jpeg_components
$pdata$stbi__process_scan_header DD imagerel stbi__process_scan_header
	DD	imagerel stbi__process_scan_header+1969
	DD	imagerel $unwind$stbi__process_scan_header
$pdata$stbi__process_marker DD imagerel stbi__process_marker
	DD	imagerel stbi__process_marker+4046
	DD	imagerel $unwind$stbi__process_marker
$pdata$stbi__jpeg_finish DD imagerel stbi__jpeg_finish
	DD	imagerel stbi__jpeg_finish+472
	DD	imagerel $unwind$stbi__jpeg_finish
$pdata$stbi__jpeg_dequantize DD imagerel stbi__jpeg_dequantize
	DD	imagerel stbi__jpeg_dequantize+108
	DD	imagerel $unwind$stbi__jpeg_dequantize
$pdata$stbi__parse_entropy_coded_data DD imagerel stbi__parse_entropy_coded_data
	DD	imagerel stbi__parse_entropy_coded_data+3486
	DD	imagerel $unwind$stbi__parse_entropy_coded_data
$pdata$stbi__jpeg_reset DD imagerel stbi__jpeg_reset
	DD	imagerel stbi__jpeg_reset+254
	DD	imagerel $unwind$stbi__jpeg_reset
$pdata$stbi__get_marker DD imagerel stbi__get_marker
	DD	imagerel stbi__get_marker+506
	DD	imagerel $unwind$stbi__get_marker
$pdata$stbi__idct_simd DD imagerel stbi__idct_simd
	DD	imagerel stbi__idct_simd+6495
	DD	imagerel $unwind$stbi__idct_simd
$pdata$stbi__idct_block DD imagerel stbi__idct_block
	DD	imagerel stbi__idct_block+4112
	DD	imagerel $unwind$stbi__idct_block
$pdata$stbi__clamp DD imagerel stbi__clamp
	DD	imagerel stbi__clamp+67
	DD	imagerel $unwind$stbi__clamp
$pdata$stbi__jpeg_decode_block_prog_ac DD imagerel stbi__jpeg_decode_block_prog_ac
	DD	imagerel stbi__jpeg_decode_block_prog_ac+4626
	DD	imagerel $unwind$stbi__jpeg_decode_block_prog_ac
$pdata$stbi__jpeg_decode_block_prog_dc DD imagerel stbi__jpeg_decode_block_prog_dc
	DD	imagerel stbi__jpeg_decode_block_prog_dc+1769
	DD	imagerel $unwind$stbi__jpeg_decode_block_prog_dc
$pdata$stbi__jpeg_decode_block DD imagerel stbi__jpeg_decode_block
	DD	imagerel stbi__jpeg_decode_block+3068
	DD	imagerel $unwind$stbi__jpeg_decode_block
$pdata$stbi__jpeg_get_bit DD imagerel stbi__jpeg_get_bit
	DD	imagerel stbi__jpeg_get_bit+143
	DD	imagerel $unwind$stbi__jpeg_get_bit
$pdata$stbi__jpeg_get_bits DD imagerel stbi__jpeg_get_bits
	DD	imagerel stbi__jpeg_get_bits+213
	DD	imagerel $unwind$stbi__jpeg_get_bits
$pdata$stbi__extend_receive DD imagerel stbi__extend_receive
	DD	imagerel stbi__extend_receive+258
	DD	imagerel $unwind$stbi__extend_receive
$pdata$stbi__jpeg_huff_decode DD imagerel stbi__jpeg_huff_decode
	DD	imagerel stbi__jpeg_huff_decode+704
	DD	imagerel $unwind$stbi__jpeg_huff_decode
$pdata$stbi__grow_buffer_unsafe DD imagerel stbi__grow_buffer_unsafe
	DD	imagerel stbi__grow_buffer_unsafe+806
	DD	imagerel $unwind$stbi__grow_buffer_unsafe
$pdata$stbi__build_fast_ac DD imagerel stbi__build_fast_ac
	DD	imagerel stbi__build_fast_ac+386
	DD	imagerel $unwind$stbi__build_fast_ac
$pdata$stbi__build_huffman DD imagerel stbi__build_huffman
	DD	imagerel stbi__build_huffman+687
	DD	imagerel $unwind$stbi__build_huffman
$pdata$stbi__hdr_to_ldr DD imagerel stbi__hdr_to_ldr
	DD	imagerel stbi__hdr_to_ldr+567
	DD	imagerel $unwind$stbi__hdr_to_ldr
$pdata$stbi__ldr_to_hdr DD imagerel stbi__ldr_to_hdr
	DD	imagerel stbi__ldr_to_hdr+484
	DD	imagerel $unwind$stbi__ldr_to_hdr
$pdata$stbi__convert_format16 DD imagerel stbi__convert_format16
	DD	imagerel stbi__convert_format16+2760
	DD	imagerel $unwind$stbi__convert_format16
$pdata$stbi__compute_y_16 DD imagerel stbi__compute_y_16
	DD	imagerel stbi__compute_y_16+61
	DD	imagerel $unwind$stbi__compute_y_16
$pdata$stbi__convert_format DD imagerel stbi__convert_format
	DD	imagerel stbi__convert_format+2708
	DD	imagerel $unwind$stbi__convert_format
$pdata$stbi__compute_y DD imagerel stbi__compute_y
	DD	imagerel stbi__compute_y+61
	DD	imagerel $unwind$stbi__compute_y
$pdata$stbi__get32le DD imagerel stbi__get32le
	DD	imagerel stbi__get32le+71
	DD	imagerel $unwind$stbi__get32le
$pdata$stbi__get16le DD imagerel stbi__get16le
	DD	imagerel stbi__get16le+391
	DD	imagerel $unwind$stbi__get16le
$pdata$stbi__get32be DD imagerel stbi__get32be
	DD	imagerel stbi__get32be+71
	DD	imagerel $unwind$stbi__get32be
$pdata$stbi__get16be DD imagerel stbi__get16be
	DD	imagerel stbi__get16be+389
	DD	imagerel $unwind$stbi__get16be
$pdata$stbi__getn DD imagerel stbi__getn
	DD	imagerel stbi__getn+355
	DD	imagerel $unwind$stbi__getn
$pdata$stbi__skip DD imagerel stbi__skip
	DD	imagerel stbi__skip+220
	DD	imagerel $unwind$stbi__skip
$pdata$stbi__at_eof DD imagerel stbi__at_eof
	DD	imagerel stbi__at_eof+131
	DD	imagerel $unwind$stbi__at_eof
$pdata$stbi__get8 DD imagerel stbi__get8
	DD	imagerel stbi__get8+183
	DD	imagerel $unwind$stbi__get8
$pdata$stbi__refill_buffer DD imagerel stbi__refill_buffer
	DD	imagerel stbi__refill_buffer+245
	DD	imagerel $unwind$stbi__refill_buffer
$pdata$stbi_hdr_to_ldr_scale DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$stbi_hdr_to_ldr_scale
$pdata$stbi_hdr_to_ldr_gamma DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$stbi_hdr_to_ldr_gamma
$pdata$stbi_ldr_to_hdr_scale DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$stbi_ldr_to_hdr_scale
$pdata$stbi_ldr_to_hdr_gamma DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$stbi_ldr_to_hdr_gamma
$pdata$stbi_is_hdr_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+155
	DD	imagerel $unwind$stbi_is_hdr_from_callbacks
$pdata$stbi_is_hdr_from_file DD imagerel $LN3
	DD	imagerel $LN3+187
	DD	imagerel $unwind$stbi_is_hdr_from_file
$pdata$stbi_is_hdr DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$stbi_is_hdr
$pdata$stbi_is_hdr_from_memory DD imagerel $LN3
	DD	imagerel $LN3+154
	DD	imagerel $unwind$stbi_is_hdr_from_memory
$pdata$stbi_loadf_from_file DD imagerel $LN3
	DD	imagerel $LN3+192
	DD	imagerel $unwind$stbi_loadf_from_file
$pdata$stbi_loadf DD imagerel $LN6
	DD	imagerel $LN6+173
	DD	imagerel $unwind$stbi_loadf
$pdata$stbi_loadf_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+200
	DD	imagerel $unwind$stbi_loadf_from_callbacks
$pdata$stbi_loadf_from_memory DD imagerel $LN3
	DD	imagerel $LN3+199
	DD	imagerel $unwind$stbi_loadf_from_memory
$pdata$stbi__loadf_main DD imagerel stbi__loadf_main
	DD	imagerel stbi__loadf_main+459
	DD	imagerel $unwind$stbi__loadf_main
$pdata$stbi_load_gif_from_memory DD imagerel $LN6
	DD	imagerel $LN6+371
	DD	imagerel $unwind$stbi_load_gif_from_memory
$pdata$stbi_load_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+200
	DD	imagerel $unwind$stbi_load_from_callbacks
$pdata$stbi_load_from_memory DD imagerel $LN3
	DD	imagerel $LN3+199
	DD	imagerel $unwind$stbi_load_from_memory
$pdata$stbi_load_16_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+200
	DD	imagerel $unwind$stbi_load_16_from_callbacks
$pdata$stbi_load_16_from_memory DD imagerel $LN3
	DD	imagerel $LN3+199
	DD	imagerel $unwind$stbi_load_16_from_memory
$pdata$stbi_load_16 DD imagerel $LN6
	DD	imagerel $LN6+173
	DD	imagerel $unwind$stbi_load_16
$pdata$stbi_load_from_file_16 DD imagerel $LN4
	DD	imagerel $LN4+257
	DD	imagerel $unwind$stbi_load_from_file_16
$pdata$stbi_load_from_file DD imagerel $LN4
	DD	imagerel $LN4+257
	DD	imagerel $unwind$stbi_load_from_file
$pdata$stbi_load DD imagerel $LN6
	DD	imagerel $LN6+173
	DD	imagerel $unwind$stbi_load
$pdata$stbi__fopen DD imagerel stbi__fopen
	DD	imagerel stbi__fopen+143
	DD	imagerel $unwind$stbi__fopen
$pdata$stbi__float_postprocess DD imagerel stbi__float_postprocess
	DD	imagerel stbi__float_postprocess+195
	DD	imagerel $unwind$stbi__float_postprocess
$pdata$stbi__load_and_postprocess_16bit DD imagerel stbi__load_and_postprocess_16bit
	DD	imagerel stbi__load_and_postprocess_16bit+540
	DD	imagerel $unwind$stbi__load_and_postprocess_16bit
$pdata$stbi__load_and_postprocess_8bit DD imagerel stbi__load_and_postprocess_8bit
	DD	imagerel stbi__load_and_postprocess_8bit+534
	DD	imagerel $unwind$stbi__load_and_postprocess_8bit
$pdata$stbi__vertical_flip_slices DD imagerel stbi__vertical_flip_slices
	DD	imagerel stbi__vertical_flip_slices+147
	DD	imagerel $unwind$stbi__vertical_flip_slices
$pdata$stbi__vertical_flip DD imagerel stbi__vertical_flip
	DD	imagerel stbi__vertical_flip+550
	DD	imagerel $unwind$stbi__vertical_flip
$pdata$stbi__convert_8_to_16 DD imagerel stbi__convert_8_to_16
	DD	imagerel stbi__convert_8_to_16+227
	DD	imagerel $unwind$stbi__convert_8_to_16
$pdata$stbi__convert_16_to_8 DD imagerel stbi__convert_16_to_8
	DD	imagerel stbi__convert_16_to_8+212
	DD	imagerel $unwind$stbi__convert_16_to_8
$pdata$stbi__load_main DD imagerel stbi__load_main
	DD	imagerel stbi__load_main+895
	DD	imagerel $unwind$stbi__load_main
$pdata$stbi_set_flip_vertically_on_load_thread DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$stbi_set_flip_vertically_on_load_thread
$pdata$stbi_set_flip_vertically_on_load DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$stbi_set_flip_vertically_on_load
$pdata$stbi_image_free DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$stbi_image_free
$pdata$stbi__mul2shorts_valid DD imagerel stbi__mul2shorts_valid
	DD	imagerel stbi__mul2shorts_valid+295
	DD	imagerel $unwind$stbi__mul2shorts_valid
$pdata$stbi__addints_valid DD imagerel stbi__addints_valid
	DD	imagerel stbi__addints_valid+188
	DD	imagerel $unwind$stbi__addints_valid
$pdata$stbi__malloc_mad4 DD imagerel stbi__malloc_mad4
	DD	imagerel stbi__malloc_mad4+113
	DD	imagerel $unwind$stbi__malloc_mad4
$pdata$stbi__malloc_mad3 DD imagerel stbi__malloc_mad3
	DD	imagerel stbi__malloc_mad3+100
	DD	imagerel $unwind$stbi__malloc_mad3
$pdata$stbi__malloc_mad2 DD imagerel stbi__malloc_mad2
	DD	imagerel stbi__malloc_mad2+85
	DD	imagerel $unwind$stbi__malloc_mad2
$pdata$stbi__mad4sizes_valid DD imagerel stbi__mad4sizes_valid
	DD	imagerel stbi__mad4sizes_valid+167
	DD	imagerel $unwind$stbi__mad4sizes_valid
$pdata$stbi__mad3sizes_valid DD imagerel stbi__mad3sizes_valid
	DD	imagerel stbi__mad3sizes_valid+133
	DD	imagerel $unwind$stbi__mad3sizes_valid
$pdata$stbi__mad2sizes_valid DD imagerel stbi__mad2sizes_valid
	DD	imagerel stbi__mad2sizes_valid+99
	DD	imagerel $unwind$stbi__mad2sizes_valid
$pdata$stbi__mul2sizes_valid DD imagerel stbi__mul2sizes_valid
	DD	imagerel stbi__mul2sizes_valid+101
	DD	imagerel $unwind$stbi__mul2sizes_valid
$pdata$stbi__addsizes_valid DD imagerel stbi__addsizes_valid
	DD	imagerel stbi__addsizes_valid+79
	DD	imagerel $unwind$stbi__addsizes_valid
$pdata$stbi__malloc DD imagerel stbi__malloc
	DD	imagerel stbi__malloc+39
	DD	imagerel $unwind$stbi__malloc
$pdata$stbi__err DD imagerel stbi__err
	DD	imagerel stbi__err+58
	DD	imagerel $unwind$stbi__err
$pdata$stbi__rewind DD imagerel stbi__rewind
	DD	imagerel stbi__rewind+76
	DD	imagerel $unwind$stbi__rewind
$pdata$stbi__start_file DD imagerel stbi__start_file
	DD	imagerel stbi__start_file+56
	DD	imagerel $unwind$stbi__start_file
$pdata$stbi__stdio_eof DD imagerel stbi__stdio_eof
	DD	imagerel stbi__stdio_eof+80
	DD	imagerel $unwind$stbi__stdio_eof
$pdata$stbi__stdio_skip DD imagerel stbi__stdio_skip
	DD	imagerel stbi__stdio_skip+91
	DD	imagerel $unwind$stbi__stdio_skip
$pdata$stbi__stdio_read DD imagerel stbi__stdio_read
	DD	imagerel stbi__stdio_read+67
	DD	imagerel $unwind$stbi__stdio_read
$pdata$stbi__start_callbacks DD imagerel stbi__start_callbacks
	DD	imagerel stbi__start_callbacks+196
	DD	imagerel $unwind$stbi__start_callbacks
$pdata$stbi__start_mem DD imagerel stbi__start_mem
	DD	imagerel stbi__start_mem+164
	DD	imagerel $unwind$stbi__start_mem
$pdata$stbi__sse2_available DD imagerel stbi__sse2_available
	DD	imagerel stbi__sse2_available+69
	DD	imagerel $unwind$stbi__sse2_available
$pdata$stbi__cpuid3 DD imagerel stbi__cpuid3
	DD	imagerel stbi__cpuid3+132
	DD	imagerel $unwind$stbi__cpuid3
$pdata$TryGetFrame2 DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$TryGetFrame2
$pdata$stbi_failure_reason DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$stbi_failure_reason
?invalid_chunk@?BP@??stbi__parse_png_file@@9@9 DB 'XXXX PNG chunk not kno'
	DB	'wn', 00H					; `stbi__parse_png_file'::`31'::invalid_chunk
	ORG $+3
stbi__h2l_scale_i DD 03f800000r			; 1
stbi__h2l_gamma_i DD 03ee8ba2er			; 0.454545
stbi__l2h_gamma DD 0400ccccdr			; 2.2
?mul_table@?1??stbi__shiftsigned@@9@9 DD 00H		; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
stbi__l2h_scale DD 03f800000r			; 1
?shift_table@?1??stbi__shiftsigned@@9@9 DD 00H		; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
first_row_filter DB 00H
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+7
stbi__stdio_callbacks DQ FLAT:stbi__stdio_read
	DQ	FLAT:stbi__stdio_skip
	DQ	FLAT:stbi__stdio_eof
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$NugRand DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UAbs DD	020a01H
	DD	07006520aH
xdata	ENDS
xdata	SEGMENT
$unwind$NugHash DD 020a01H
	DD	07006720aH
$unwind$GetFrame DD 020f01H
	DD	0700b520fH
$unwind$TryGetFrame DD 022f19H
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$AddFrameData DD 020f01H
	DD	0700b920fH
$unwind$AddLocVal2 DD 020a01H
	DD	07006720aH
$unwind$GetLocVal2 DD 020a01H
	DD	07006520aH
$unwind$AddUintVal2 DD 020e01H
	DD	0700ab20eH
$unwind$GetUintVal2 DD 020a01H
	DD	07006b20aH
$unwind$stbi_is_16_bit_from_callbacks DD 033d19H
	DD	0260112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_is_16_bit_from_memory DD 033c19H
	DD	0260111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_info_from_callbacks DD 034719H
	DD	026011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_info_from_memory DD 034619H
	DD	026011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_is_16_bit_from_file DD 033819H
	DD	028010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_is_16_bit DD 020a01H
	DD	07006520aH
$unwind$stbi_info_from_file DD 034719H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_info DD 021901H
	DD	070155219H
$unwind$stbi__is_16_main DD 020a01H
	DD	07006320aH
$unwind$stbi__info_main DD 021901H
	DD	070153219H
$unwind$stbi__pnm_is16 DD 020a01H
	DD	07006320aH
$unwind$stbi__pnm_info DD 034719H
	DD	012011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$stbi__pnm_getinteger DD 020f01H
	DD	0700b720fH
$unwind$stbi__pnm_isdigit DD 020901H
	DD	070055209H
$unwind$stbi__pnm_skip_whitespace DD 020f01H
	DD	0700b920fH
$unwind$stbi__pnm_isspace DD 020901H
	DD	070055209H
$unwind$stbi__pnm_load DD 021901H
	DD	07015d219H
$unwind$stbi__pnm_test DD 020a01H
	DD	07006520aH
$unwind$stbi__pic_info DD 034719H
	DD	018011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$stbi__psd_is16 DD 020a01H
	DD	07006520aH
$unwind$stbi__psd_info DD 023e19H
	DD	07015b219H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$stbi__bmp_info DD 024419H
	DD	07015f21cH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$stbi__hdr_info DD 034719H
	DD	092011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0480H
$unwind$stbi__hdr_load DD 034719H
	DD	0b0011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0578H
$unwind$stbi__hdr_convert DD 021401H
	DD	070105214H
$unwind$stbi__hdr_gettoken DD 020f01H
	DD	0700b720fH
$unwind$stbi__hdr_test DD 020a01H
	DD	07006520aH
$unwind$stbi__hdr_test_core DD 020f01H
	DD	0700b520fH
$unwind$stbi__gif_info DD 021901H
	DD	070153219H
$unwind$stbi__gif_load DD 034d19H
	DD	0111c0122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	088d0H
$unwind$stbi__load_gif_main DD 044e19H
	DD	011230123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	08908H
$unwind$stbi__load_gif_main_outofmem DD 021401H
	DD	070105214H
$unwind$stbi__gif_load_next DD 041d01H
	DD	01b011dH
	DD	060157016H
$unwind$stbi__process_gif_raster DD 031201H
	DD	0160112H
	DD	0700bH
$unwind$stbi__out_gif_code DD 020f01H
	DD	0700b720fH
$unwind$stbi__gif_info_raw DD 021901H
	DD	070155219H
$unwind$stbi__gif_header DD 021901H
	DD	070157219H
$unwind$stbi__gif_parse_colortable DD 021901H
	DD	070157219H
$unwind$stbi__gif_test DD 020a01H
	DD	07006520aH
$unwind$stbi__gif_test_raw DD 020a01H
	DD	07006720aH
$unwind$stbi__pic_test DD 020a01H
	DD	07006520aH
$unwind$stbi__pic_load DD 034719H
	DD	018011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$stbi__pic_load_core DD 034619H
	DD	02e011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$stbi__copyval DD 021301H
	DD	0700f5213H
$unwind$stbi__readval DD 021301H
	DD	0700f9213H
$unwind$stbi__pic_test_core DD 020a01H
	DD	07006520aH
$unwind$stbi__pic_is4 DD 020f01H
	DD	0700b520fH
$unwind$stbi__psd_load DD 031c01H
	DD	026011cH
	DD	07015H
$unwind$stbi__psd_decode_rle DD 021401H
	DD	070107214H
$unwind$stbi__psd_test DD 020a01H
	DD	07006520aH
$unwind$stbi__tga_load DD 034719H
	DD	032011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$stbi__tga_read_rgb16 DD 020f01H
	DD	0700b720fH
$unwind$stbi__tga_test DD 020a01H
	DD	07006720aH
$unwind$stbi__tga_info DD 021901H
	DD	07015b219H
$unwind$stbi__tga_get_comp DD 021201H
	DD	0700e5212H
$unwind$stbi__bmp_load DD 034719H
	DD	0bc011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	05d0H
$unwind$stbi__bmp_parse_header DD 031201H
	DD	0120112H
	DD	0700bH
$unwind$stbi__bmp_set_mask_defaults DD 020e01H
	DD	0700a320eH
$unwind$stbi__shiftsigned DD 021201H
	DD	0700e3212H
$unwind$stbi__bitcount DD 020901H
	DD	070053209H
$unwind$stbi__high_bit DD 020901H
	DD	070055209H
$unwind$stbi__bmp_test DD 020a01H
	DD	07006520aH
$unwind$stbi__bmp_test_raw DD 020a01H
	DD	07006720aH
$unwind$stbi__png_is16 DD 023219H
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$stbi__png_info DD 024119H
	DD	07015d219H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$stbi__png_info_raw DD 021901H
	DD	070153219H
$unwind$stbi__png_test DD 020a01H
	DD	07006520aH
$unwind$stbi__png_load DD 024419H
	DD	07015f21cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$stbi__do_png DD 021901H
	DD	070159219H
$unwind$stbi__parse_png_file DD 034119H
	DD	0aa0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0548H
$unwind$stbi__de_iphone DD 020a01H
	DD	07006920aH
$unwind$stbi_convert_iphone_png_to_rgb_thread DD 020901H
	DD	070053209H
$unwind$stbi_set_unpremultiply_on_load_thread DD 020901H
	DD	070053209H
$unwind$stbi_convert_iphone_png_to_rgb DD 020901H
	DD	070053209H
$unwind$stbi_set_unpremultiply_on_load DD 020901H
	DD	070053209H
$unwind$stbi__expand_png_palette DD 021901H
	DD	070159219H
$unwind$stbi__compute_transparency16 DD 021401H
	DD	070107214H
$unwind$stbi__compute_transparency DD 021401H
	DD	070107214H
$unwind$stbi__create_png_image DD 043601H
	DD	031011dH
	DD	060157016H
$unwind$stbi__create_png_image_raw DD 041d01H
	DD	019011dH
	DD	060157016H
$unwind$stbi__paeth DD 021201H
	DD	0700e5212H
$unwind$stbi__check_png_header DD 020a01H
	DD	07006520aH
$unwind$stbi__get_chunk_header DD 022001H
	DD	07006720aH
$unwind$stbi_zlib_decode_noheader_buffer DD 034c19H
	DD	020c0121H
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$stbi_zlib_decode_noheader_malloc DD 034719H
	DD	020c011cH
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	01058H
$unwind$stbi_zlib_decode_buffer DD 034c19H
	DD	020c0121H
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 034c19H
	DD	020c0121H
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	01058H
$unwind$stbi_zlib_decode_malloc DD 021301H
	DD	0700f3213H
$unwind$stbi_zlib_decode_malloc_guesssize DD 034c19H
	DD	020c0121H
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	01058H
$unwind$stbi__do_zlib DD 021901H
	DD	070153219H
$unwind$stbi__parse_zlib DD 020e01H
	DD	0700a720eH
$unwind$stbi__parse_zlib_header DD 020a01H
	DD	07006b20aH
$unwind$stbi__parse_uncompressed_block DD 032401H
	DD	07007e20bH
	DD	06006H
$unwind$stbi__compute_huffman_codes DD 033819H
	DD	015c010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0ad0H
$unwind$stbi__parse_huffman_block DD 030d01H
	DD	01c010dH
	DD	07006H
$unwind$stbi__zexpand DD 021401H
	DD	070107214H
$unwind$stbi__zhuffman_decode DD 020f01H
	DD	0700b720fH
$unwind$stbi__zhuffman_decode_slowpath DD 020f01H
	DD	0700b920fH
$unwind$stbi__zreceive DD 020e01H
	DD	0700a520eH
$unwind$stbi__fill_bits DD 020a01H
	DD	07006720aH
$unwind$stbi__zget8 DD 020a01H
	DD	07006520aH
$unwind$stbi__zeof DD 020a01H
	DD	07006520aH
$unwind$stbi__zbuild_huffman DD 034219H
	DD	0280117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi__bit_reverse DD 020d01H
	DD	07009520dH
$unwind$stbi__bitreverse16 DD 020901H
	DD	070053209H
$unwind$stbi__jpeg_info DD 021901H
	DD	070155219H
$unwind$stbi__jpeg_info_raw DD 021901H
	DD	070155219H
$unwind$stbi__jpeg_test DD 020a01H
	DD	07006520aH
$unwind$stbi__jpeg_load DD 021901H
	DD	070159219H
$unwind$load_jpeg_image DD 034719H
	DD	044011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0218H
$unwind$stbi__blinn_8x8 DD 020d01H
	DD	07009520dH
$unwind$stbi__cleanup_jpeg DD 020a01H
	DD	07006320aH
$unwind$stbi__setup_jpeg DD 020a01H
	DD	07006320aH
$unwind$stbi__YCbCr_to_RGB_simd DD 031c01H
	DD	04c011cH
	DD	07015H
$unwind$stbi__YCbCr_to_RGB_row DD 021901H
	DD	070157219H
$unwind$stbi__resample_row_generic DD 021901H
	DD	070155219H
$unwind$stbi__resample_row_hv_2_simd DD 031c01H
	DD	038011cH
	DD	07015H
$unwind$stbi__resample_row_hv_2 DD 021901H
	DD	070155219H
$unwind$stbi__resample_row_h_2 DD 021901H
	DD	070157219H
$unwind$stbi__resample_row_v_2 DD 021901H
	DD	070155219H
$unwind$resample_row_1 DD 021901H
	DD	070153219H
$unwind$stbi__decode_jpeg_image DD 020a01H
	DD	07006520aH
$unwind$stbi__skip_jpeg_junk_at_end DD 020a01H
	DD	07006d20aH
$unwind$stbi__decode_jpeg_header DD 020e01H
	DD	0700a720eH
$unwind$stbi__process_frame_header DD 020e01H
	DD	0700ad20eH
$unwind$stbi__free_jpeg_components DD 021301H
	DD	0700f5213H
$unwind$stbi__process_scan_header DD 020d01H
	DD	07006f20dH
$unwind$stbi__process_marker DD 033c19H
	DD	02a0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$stbi__jpeg_finish DD 020a01H
	DD	07006720aH
$unwind$stbi__jpeg_dequantize DD 020f01H
	DD	0700b520fH
$unwind$stbi__parse_entropy_coded_data DD 033819H
	DD	044010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0218H
$unwind$stbi__jpeg_reset DD 020a01H
	DD	07006520aH
$unwind$stbi__get_marker DD 020a01H
	DD	07006720aH
$unwind$stbi__idct_simd DD 031601H
	DD	01520116H
	DD	0700fH
$unwind$stbi__idct_block DD 034119H
	DD	0460116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$stbi__clamp DD 020901H
	DD	070053209H
$unwind$stbi__jpeg_decode_block_prog_ac DD 031c01H
	DD	028011cH
	DD	07015H
$unwind$stbi__jpeg_decode_block_prog_dc DD 031c01H
	DD	012011cH
	DD	07015H
$unwind$stbi__jpeg_decode_block DD 031c01H
	DD	01e011cH
	DD	07015H
$unwind$stbi__jpeg_get_bit DD 020a01H
	DD	07006520aH
$unwind$stbi__jpeg_get_bits DD 020e01H
	DD	0700a520eH
$unwind$stbi__extend_receive DD 020e01H
	DD	0700a520eH
$unwind$stbi__jpeg_huff_decode DD 020f01H
	DD	0700b920fH
$unwind$stbi__grow_buffer_unsafe DD 020a01H
	DD	07006b20aH
$unwind$stbi__build_fast_ac DD 020f01H
	DD	0700b920fH
$unwind$stbi__build_huffman DD 020f01H
	DD	0700b720fH
$unwind$stbi__hdr_to_ldr DD 021801H
	DD	070149218H
$unwind$stbi__ldr_to_hdr DD 021801H
	DD	070149218H
$unwind$stbi__convert_format16 DD 021801H
	DD	07014d218H
$unwind$stbi__compute_y_16 DD 021201H
	DD	0700e3212H
$unwind$stbi__convert_format DD 021801H
	DD	07014d218H
$unwind$stbi__compute_y DD 021201H
	DD	0700e3212H
$unwind$stbi__get32le DD 020a01H
	DD	07006520aH
$unwind$stbi__get16le DD 020a01H
	DD	07006520aH
$unwind$stbi__get32be DD 020a01H
	DD	07006520aH
$unwind$stbi__get16be DD 020a01H
	DD	07006520aH
$unwind$stbi__getn DD 031501H
	DD	070116215H
	DD	06010H
$unwind$stbi__skip DD 020e01H
	DD	0700a520eH
$unwind$stbi__at_eof DD 020a01H
	DD	07006520aH
$unwind$stbi__get8 DD 020a01H
	DD	07006520aH
$unwind$stbi__refill_buffer DD 020a01H
	DD	07006520aH
$unwind$stbi_hdr_to_ldr_scale DD 020b01H
	DD	07007320bH
$unwind$stbi_hdr_to_ldr_gamma DD 020b01H
	DD	07007320bH
$unwind$stbi_ldr_to_hdr_scale DD 020b01H
	DD	07007320bH
$unwind$stbi_ldr_to_hdr_gamma DD 020b01H
	DD	07007320bH
$unwind$stbi_is_hdr_from_callbacks DD 033d19H
	DD	0260112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_is_hdr_from_file DD 033819H
	DD	028010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_is_hdr DD 020a01H
	DD	07006520aH
$unwind$stbi_is_hdr_from_memory DD 033c19H
	DD	0260111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_loadf_from_file DD 034719H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_loadf DD 021901H
	DD	070159219H
$unwind$stbi_loadf_from_callbacks DD 034719H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_loadf_from_memory DD 034619H
	DD	028011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi__loadf_main DD 034719H
	DD	012011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$stbi_load_gif_from_memory DD 034619H
	DD	02c011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0158H
$unwind$stbi_load_from_callbacks DD 034719H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_from_memory DD 034619H
	DD	028011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_16_from_callbacks DD 034719H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_16_from_memory DD 034619H
	DD	028011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_16 DD 021901H
	DD	070159219H
$unwind$stbi_load_from_file_16 DD 034719H
	DD	02a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$stbi_load_from_file DD 034719H
	DD	02a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$stbi_load DD 021901H
	DD	070159219H
$unwind$stbi__fopen DD 023419H
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$stbi__float_postprocess DD 021901H
	DD	070155219H
$unwind$stbi__load_and_postprocess_16bit DD 034719H
	DD	014011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$stbi__load_and_postprocess_8bit DD 034719H
	DD	014011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$stbi__vertical_flip_slices DD 021801H
	DD	070145218H
$unwind$stbi__vertical_flip DD 044719H
	DD	0113011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0880H
$unwind$stbi__convert_8_to_16 DD 021801H
	DD	070147218H
$unwind$stbi__convert_16_to_8 DD 021801H
	DD	070147218H
$unwind$stbi__load_main DD 021901H
	DD	07015b219H
$unwind$stbi_set_flip_vertically_on_load_thread DD 020901H
	DD	070053209H
$unwind$stbi_set_flip_vertically_on_load DD 020901H
	DD	070053209H
$unwind$stbi_image_free DD 020a01H
	DD	07006320aH
$unwind$stbi__mul2shorts_valid DD 020f01H
	DD	0700b720fH
$unwind$stbi__addints_valid DD 020d01H
	DD	07009520dH
$unwind$stbi__malloc_mad4 DD 021701H
	DD	070135217H
$unwind$stbi__malloc_mad3 DD 021701H
	DD	070133217H
$unwind$stbi__malloc_mad2 DD 021201H
	DD	0700e3212H
$unwind$stbi__mad4sizes_valid DD 021701H
	DD	070135217H
$unwind$stbi__mad3sizes_valid DD 021701H
	DD	070135217H
$unwind$stbi__mad2sizes_valid DD 021201H
	DD	0700e5212H
$unwind$stbi__mul2sizes_valid DD 020d01H
	DD	07009520dH
$unwind$stbi__addsizes_valid DD 020d01H
	DD	07009520dH
$unwind$stbi__malloc DD 020a01H
	DD	07006320aH
$unwind$stbi__err DD 020a01H
	DD	07006320aH
$unwind$stbi__rewind DD 020a01H
	DD	07006320aH
$unwind$stbi__start_file DD 020f01H
	DD	0700b320fH
$unwind$stbi__stdio_eof DD 020a01H
	DD	07006520aH
$unwind$stbi__stdio_skip DD 020e01H
	DD	0700a520eH
$unwind$stbi__stdio_read DD 021401H
	DD	070103214H
$unwind$stbi__start_callbacks DD 031501H
	DD	070116215H
	DD	06010H
$unwind$stbi__start_mem DD 021401H
	DD	070105214H
$unwind$stbi__sse2_available DD 020601H
	DD	070025206H
$unwind$stbi__cpuid3 DD 032719H
	DD	07003c207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$TryGetFrame2 DD 023419H
	DD	0700bb20fH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$stbi_failure_reason DD 020601H
	DD	070023206H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:TryGetFrame2
	DD	02fH
	DD	0aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__cpuid3
	DD	022H
	DD	070H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__vertical_flip
	DD	03fH
	DD	020cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__load_and_postprocess_8bit
	DD	03fH
	DD	01fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__load_and_postprocess_16bit
	DD	03fH
	DD	0203H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__fopen
	DD	02fH
	DD	07cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_file
	DD	03fH
	DD	0e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_file_16
	DD	03fH
	DD	0e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_16_from_memory
	DD	03eH
	DD	0aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_16_from_callbacks
	DD	03fH
	DD	0afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_memory
	DD	03eH
	DD	0aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_callbacks
	DD	03fH
	DD	0afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_gif_from_memory
	DD	03eH
	DD	015aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__loadf_main
	DD	03fH
	DD	01b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_memory
	DD	03eH
	DD	0aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_callbacks
	DD	03fH
	DD	0afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_file
	DD	03fH
	DD	0a7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_memory
	DD	034H
	DD	081H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_file
	DD	030H
	DD	0a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_callbacks
	DD	035H
	DD	082H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__idct_block
	DD	039H
	DD	0ff7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__parse_entropy_coded_data
	DD	030H
	DD	0d85H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__process_marker
	DD	034H
	DD	0fb5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:load_jpeg_image
	DD	03fH
	DD	012e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__zbuild_huffman
	DD	03aH
	DD	04f9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__compute_huffman_codes
	DD	030H
	DD	081fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize
	DD	044H
	DD	0126H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag
	DD	044H
	DD	0129H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_buffer
	DD	044H
	DD	0d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_malloc
	DD	03fH
	DD	0119H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_buffer
	DD	044H
	DD	0d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__parse_png_file
	DD	039H
	DD	0172cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__png_load
	DD	03fH
	DD	0acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__png_info
	DD	03cH
	DD	091H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__png_is16
	DD	02dH
	DD	094H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__bmp_load
	DD	03fH
	DD	01e85H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__tga_load
	DD	03fH
	DD	0135cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__pic_load_core
	DD	03eH
	DD	0df4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__pic_load
	DD	03fH
	DD	045aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__load_gif_main
	DD	046H
	DD	0484H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__gif_load
	DD	045H
	DD	0162H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__hdr_load
	DD	03fH
	DD	011efH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__hdr_info
	DD	03fH
	DD	029aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__bmp_info
	DD	03fH
	DD	0137H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__psd_info
	DD	039H
	DD	019bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__pic_info
	DD	03fH
	DD	0741H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi__pnm_info
	DD	03fH
	DD	046fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_file
	DD	03fH
	DD	0cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_file
	DD	030H
	DD	0a8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_memory
	DD	03eH
	DD	0a3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_callbacks
	DD	03fH
	DD	0a4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_memory
	DD	034H
	DD	081H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_callbacks
	DD	035H
	DD	082H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:TryGetFrame
	DD	02aH
	DD	082H
TryGetFrame$rtcName$0 DB 068H
	DB	061H
	DB	073H
	DB	068H
	DB	00H
	ORG $+11
TryGetFrame$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:TryGetFrame$rtcName$0
	ORG $+48
TryGetFrame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:TryGetFrame$rtcVarDesc
stbi_is_16_bit_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_callbacks$rtcName$0
	ORG $+48
stbi_is_16_bit_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_callbacks$rtcVarDesc
stbi_is_16_bit_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_memory$rtcName$0
	ORG $+48
stbi_is_16_bit_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_memory$rtcVarDesc
stbi_info_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_info_from_callbacks$rtcName$0
	ORG $+48
stbi_info_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_callbacks$rtcVarDesc
stbi_info_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_info_from_memory$rtcName$0
	ORG $+48
stbi_info_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_memory$rtcVarDesc
stbi_is_16_bit_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_16_bit_from_file$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_is_16_bit_from_file$rtcName$0
	ORG $+48
stbi_is_16_bit_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_16_bit_from_file$rtcVarDesc
stbi_info_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_info_from_file$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_info_from_file$rtcName$0
	ORG $+48
stbi_info_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_info_from_file$rtcVarDesc
stbi__pnm_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+2
stbi__pnm_info$rtcName$1 DB 063H
	DB	00H
	ORG $+6
stbi__pnm_info$rtcVarDesc DD 054H
	DD	01H
	DQ	FLAT:stbi__pnm_info$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:stbi__pnm_info$rtcName$0
	ORG $+96
stbi__pnm_info$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__pnm_info$rtcVarDesc
stbi__pic_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+2
stbi__pic_info$rtcName$1 DB 070H
	DB	061H
	DB	063H
	DB	06bH
	DB	065H
	DB	074H
	DB	073H
	DB	00H
stbi__pic_info$rtcVarDesc DD 058H
	DD	01eH
	DQ	FLAT:stbi__pic_info$rtcName$1
	DD	034H
	DD	04H
	DQ	FLAT:stbi__pic_info$rtcName$0
	ORG $+96
stbi__pic_info$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__pic_info$rtcVarDesc
stbi__psd_info$rtcName$0 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+10
stbi__psd_info$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:stbi__psd_info$rtcName$0
	ORG $+48
stbi__psd_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__psd_info$rtcVarDesc
stbi__bmp_info$rtcName$0 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+11
stbi__bmp_info$rtcVarDesc DD 038H
	DD	024H
	DQ	FLAT:stbi__bmp_info$rtcName$0
	ORG $+48
stbi__bmp_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__bmp_info$rtcVarDesc
stbi__hdr_info$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
stbi__hdr_info$rtcName$1 DB 074H
	DB	06fH
	DB	06bH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+2
stbi__hdr_info$rtcName$2 DB 064H
	DB	075H
	DB	06dH
	DB	06dH
	DB	079H
	DB	00H
	ORG $+10
stbi__hdr_info$rtcVarDesc DD 0464H
	DD	04H
	DQ	FLAT:stbi__hdr_info$rtcName$2
	DD	0448H
	DD	08H
	DQ	FLAT:stbi__hdr_info$rtcName$1
	DD	030H
	DD	0400H
	DQ	FLAT:stbi__hdr_info$rtcName$0
	ORG $+144
stbi__hdr_info$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__hdr_info$rtcVarDesc
stbi__hdr_load$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
stbi__hdr_load$rtcName$1 DB 074H
	DB	06fH
	DB	06bH
	DB	065H
	DB	06eH
	DB	00H
	ORG $+2
stbi__hdr_load$rtcName$2 DB 072H
	DB	067H
	DB	062H
	DB	065H
	DB	00H
	ORG $+3
stbi__hdr_load$rtcName$3 DB 072H
	DB	067H
	DB	062H
	DB	065H
	DB	00H
	ORG $+3
stbi__hdr_load$rtcVarDesc DD 04d4H
	DD	04H
	DQ	FLAT:stbi__hdr_load$rtcName$3
	DD	04b4H
	DD	04H
	DQ	FLAT:stbi__hdr_load$rtcName$2
	DD	0458H
	DD	08H
	DQ	FLAT:stbi__hdr_load$rtcName$1
	DD	040H
	DD	0400H
	DQ	FLAT:stbi__hdr_load$rtcName$0
	ORG $+192
stbi__hdr_load$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:stbi__hdr_load$rtcVarDesc
stbi__gif_load$rtcName$0 DB 067H
	DB	00H
	ORG $+14
stbi__gif_load$rtcVarDesc DD 050H
	DD	08870H
	DQ	FLAT:stbi__gif_load$rtcName$0
	ORG $+48
stbi__gif_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__gif_load$rtcVarDesc
stbi__load_gif_main$rtcName$0 DB 067H
	DB	00H
	ORG $+14
stbi__load_gif_main$rtcVarDesc DD 060H
	DD	08870H
	DQ	FLAT:stbi__load_gif_main$rtcName$0
	ORG $+48
stbi__load_gif_main$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_gif_main$rtcVarDesc
stbi__pic_load$rtcName$0 DB 069H
	DB	06eH
	DB	074H
	DB	065H
	DB	072H
	DB	06eH
	DB	061H
	DB	06cH
	DB	05fH
	DB	063H
	DB	06fH
	DB	06dH
	DB	070H
	DB	00H
	ORG $+2
stbi__pic_load$rtcVarDesc DD 054H
	DD	04H
	DQ	FLAT:stbi__pic_load$rtcName$0
	ORG $+48
stbi__pic_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__pic_load$rtcVarDesc
stbi__pic_load_core$rtcName$0 DB 070H
	DB	061H
	DB	063H
	DB	06bH
	DB	065H
	DB	074H
	DB	073H
	DB	00H
stbi__pic_load_core$rtcName$1 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+2
stbi__pic_load_core$rtcName$2 DB 076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+10
stbi__pic_load_core$rtcVarDesc DD 0c4H
	DD	04H
	DQ	FLAT:stbi__pic_load_core$rtcName$2
	DD	0a4H
	DD	04H
	DQ	FLAT:stbi__pic_load_core$rtcName$1
	DD	038H
	DD	01eH
	DQ	FLAT:stbi__pic_load_core$rtcName$0
	ORG $+144
stbi__pic_load_core$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__pic_load_core$rtcVarDesc
stbi__tga_load$rtcName$0 DB 074H
	DB	067H
	DB	061H
	DB	05fH
	DB	072H
	DB	067H
	DB	062H
	DB	031H
	DB	036H
	DB	00H
	ORG $+6
stbi__tga_load$rtcName$1 DB 072H
	DB	061H
	DB	077H
	DB	05fH
	DB	064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+7
stbi__tga_load$rtcVarDesc DD 0a4H
	DD	04H
	DQ	FLAT:stbi__tga_load$rtcName$1
	DD	074H
	DD	04H
	DQ	FLAT:stbi__tga_load$rtcName$0
	ORG $+96
stbi__tga_load$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__tga_load$rtcVarDesc
stbi__bmp_load$rtcName$0 DB 070H
	DB	061H
	DB	06cH
	DB	00H
stbi__bmp_load$rtcName$1 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+7
stbi__bmp_load$rtcVarDesc DD 0488H
	DD	024H
	DQ	FLAT:stbi__bmp_load$rtcName$1
	DD	060H
	DD	0400H
	DQ	FLAT:stbi__bmp_load$rtcName$0
	ORG $+96
stbi__bmp_load$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__bmp_load$rtcVarDesc
stbi__png_is16$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_is16$rtcVarDesc DD 028H
	DD	028H
	DQ	FLAT:stbi__png_is16$rtcName$0
	ORG $+48
stbi__png_is16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_is16$rtcVarDesc
stbi__png_info$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_info$rtcVarDesc DD 028H
	DD	028H
	DQ	FLAT:stbi__png_info$rtcName$0
	ORG $+48
stbi__png_info$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_info$rtcVarDesc
stbi__png_load$rtcName$0 DB 070H
	DB	00H
	ORG $+14
stbi__png_load$rtcVarDesc DD 038H
	DD	028H
	DQ	FLAT:stbi__png_load$rtcName$0
	ORG $+48
stbi__png_load$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__png_load$rtcVarDesc
stbi__parse_png_file$rtcName$0 DB 070H
	DB	061H
	DB	06cH
	DB	065H
	DB	074H
	DB	074H
	DB	065H
	DB	00H
stbi__parse_png_file$rtcName$1 DB 074H
	DB	063H
	DB	00H
	ORG $+1
stbi__parse_png_file$rtcName$2 DB 074H
	DB	063H
	DB	031H
	DB	036H
	DB	00H
	ORG $+3
stbi__parse_png_file$rtcName$3 DB 063H
	DB	00H
	ORG $+2
stbi__parse_png_file$rtcName$4 DB 072H
	DB	061H
	DB	077H
	DB	05fH
	DB	06cH
	DB	065H
	DB	06eH
	DB	00H
stbi__parse_png_file$rtcVarDesc DD 04f4H
	DD	04H
	DQ	FLAT:stbi__parse_png_file$rtcName$4
	DD	04c8H
	DD	08H
	DQ	FLAT:stbi__parse_png_file$rtcName$3
	DD	0484H
	DD	06H
	DQ	FLAT:stbi__parse_png_file$rtcName$2
	DD	0464H
	DD	03H
	DQ	FLAT:stbi__parse_png_file$rtcName$1
	DD	050H
	DD	0400H
	DQ	FLAT:stbi__parse_png_file$rtcName$0
	ORG $+240
stbi__parse_png_file$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:stbi__parse_png_file$rtcVarDesc
stbi__create_png_image$rtcName$0 DB 078H
	DB	06fH
	DB	072H
	DB	069H
	DB	067H
	DB	00H
	ORG $+2
stbi__create_png_image$rtcName$1 DB 079H
	DB	06fH
	DB	072H
	DB	069H
	DB	067H
	DB	00H
	ORG $+2
stbi__create_png_image$rtcName$2 DB 078H
	DB	073H
	DB	070H
	DB	063H
	DB	00H
	ORG $+3
stbi__create_png_image$rtcName$3 DB 079H
	DB	073H
	DB	070H
	DB	063H
	DB	00H
	ORG $+3
stbi__create_png_image$rtcVarDesc DD 0128H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$3
	DD	0e8H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$2
	DD	0a8H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$1
	DD	068H
	DD	01cH
	DQ	FLAT:stbi__create_png_image$rtcName$0
	ORG $+192
stbi__create_png_image$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:stbi__create_png_image$rtcVarDesc
stbi__get_chunk_header$rtcName$0 DB 063H
	DB	00H
	ORG $+14
stbi__get_chunk_header$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:stbi__get_chunk_header$rtcName$0
	ORG $+48
stbi__get_chunk_header$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__get_chunk_header$rtcVarDesc
stbi_zlib_decode_noheader_buffer$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_noheader_buffer$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_noheader_buffer$rtcName$0
	ORG $+48
stbi_zlib_decode_noheader_buffer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_noheader_buffer$rtcVarDesc
stbi_zlib_decode_noheader_malloc$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_noheader_malloc$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_noheader_malloc$rtcName$0
	ORG $+48
stbi_zlib_decode_noheader_malloc$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_noheader_malloc$rtcVarDesc
stbi_zlib_decode_buffer$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_buffer$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_buffer$rtcName$0
	ORG $+48
stbi_zlib_decode_buffer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_buffer$rtcVarDesc
stbi_zlib_decode_malloc_guesssize_headerflag$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_malloc_guesssize_headerflag$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcName$0
	ORG $+48
stbi_zlib_decode_malloc_guesssize_headerflag$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcVarDesc
stbi_zlib_decode_malloc_guesssize$rtcName$0 DB 061H
	DB	00H
	ORG $+14
stbi_zlib_decode_malloc_guesssize$rtcVarDesc DD 040H
	DD	01000H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize$rtcName$0
	ORG $+48
stbi_zlib_decode_malloc_guesssize$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_zlib_decode_malloc_guesssize$rtcVarDesc
stbi__parse_uncompressed_block$rtcName$0 DB 068H
	DB	065H
	DB	061H
	DB	064H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
stbi__parse_uncompressed_block$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:stbi__parse_uncompressed_block$rtcName$0
	ORG $+48
stbi__parse_uncompressed_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__parse_uncompressed_block$rtcVarDesc
stbi__compute_huffman_codes$rtcName$0 DB 07aH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	06cH
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	00H
	ORG $+3
stbi__compute_huffman_codes$rtcName$1 DB 06cH
	DB	065H
	DB	06eH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	073H
	DB	00H
	ORG $+7
stbi__compute_huffman_codes$rtcName$2 DB 063H
	DB	06fH
	DB	064H
	DB	065H
	DB	06cH
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+15
stbi__compute_huffman_codes$rtcVarDesc DD 0a28H
	DD	013H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$2
	DD	0840H
	DD	01c7H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$1
	DD	030H
	DD	07e4H
	DQ	FLAT:stbi__compute_huffman_codes$rtcName$0
	ORG $+144
stbi__compute_huffman_codes$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:stbi__compute_huffman_codes$rtcVarDesc
stbi__zbuild_huffman$rtcName$0 DB 06eH
	DB	065H
	DB	078H
	DB	074H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+2
stbi__zbuild_huffman$rtcName$1 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+14
stbi__zbuild_huffman$rtcVarDesc DD 0a0H
	DD	044H
	DQ	FLAT:stbi__zbuild_huffman$rtcName$1
	DD	040H
	DD	040H
	DQ	FLAT:stbi__zbuild_huffman$rtcName$0
	ORG $+96
stbi__zbuild_huffman$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__zbuild_huffman$rtcVarDesc
load_jpeg_image$rtcName$0 DB 063H
	DB	06fH
	DB	075H
	DB	074H
	DB	070H
	DB	075H
	DB	074H
	DB	00H
load_jpeg_image$rtcName$1 DB 072H
	DB	065H
	DB	073H
	DB	05fH
	DB	063H
	DB	06fH
	DB	06dH
	DB	070H
	DB	00H
	ORG $+15
load_jpeg_image$rtcVarDesc DD 0a0H
	DD	0c0H
	DQ	FLAT:load_jpeg_image$rtcName$1
	DD	058H
	DD	020H
	DQ	FLAT:load_jpeg_image$rtcName$0
	ORG $+96
load_jpeg_image$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:load_jpeg_image$rtcVarDesc
stbi__process_marker$rtcName$0 DB 073H
	DB	069H
	DB	07aH
	DB	065H
	DB	073H
	DB	00H
	ORG $+10
stbi__process_marker$rtcVarDesc DD 050H
	DD	040H
	DQ	FLAT:stbi__process_marker$rtcName$0
	ORG $+48
stbi__process_marker$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__process_marker$rtcVarDesc
stbi__parse_entropy_coded_data$rtcName$0 DB 064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
stbi__parse_entropy_coded_data$rtcName$1 DB 064H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
stbi__parse_entropy_coded_data$rtcVarDesc DD 0120H
	DD	080H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcName$1
	DD	060H
	DD	080H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcName$0
	ORG $+96
stbi__parse_entropy_coded_data$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:stbi__parse_entropy_coded_data$rtcVarDesc
stbi__idct_block$rtcName$0 DB 076H
	DB	061H
	DB	06cH
	DB	00H
	ORG $+12
stbi__idct_block$rtcVarDesc DD 040H
	DD	0100H
	DQ	FLAT:stbi__idct_block$rtcName$0
	ORG $+48
stbi__idct_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__idct_block$rtcVarDesc
stbi_is_hdr_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_callbacks$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_callbacks$rtcName$0
	ORG $+48
stbi_is_hdr_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_callbacks$rtcVarDesc
stbi_is_hdr_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_file$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_file$rtcName$0
	ORG $+48
stbi_is_hdr_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_file$rtcVarDesc
stbi_is_hdr_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_is_hdr_from_memory$rtcVarDesc DD 030H
	DD	0e0H
	DQ	FLAT:stbi_is_hdr_from_memory$rtcName$0
	ORG $+48
stbi_is_hdr_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_is_hdr_from_memory$rtcVarDesc
stbi_loadf_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_file$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_file$rtcName$0
	ORG $+48
stbi_loadf_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_file$rtcVarDesc
stbi_loadf_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_callbacks$rtcName$0
	ORG $+48
stbi_loadf_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_callbacks$rtcVarDesc
stbi_loadf_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_loadf_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_loadf_from_memory$rtcName$0
	ORG $+48
stbi_loadf_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_loadf_from_memory$rtcVarDesc
stbi__loadf_main$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__loadf_main$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:stbi__loadf_main$rtcName$0
	ORG $+48
stbi__loadf_main$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__loadf_main$rtcVarDesc
stbi_load_gif_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_gif_from_memory$rtcVarDesc DD 060H
	DD	0e0H
	DQ	FLAT:stbi_load_gif_from_memory$rtcName$0
	ORG $+48
stbi_load_gif_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_gif_from_memory$rtcVarDesc
stbi_load_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_from_callbacks$rtcName$0
	ORG $+48
stbi_load_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_callbacks$rtcVarDesc
stbi_load_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_from_memory$rtcName$0
	ORG $+48
stbi_load_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_memory$rtcVarDesc
stbi_load_16_from_callbacks$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_16_from_callbacks$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_16_from_callbacks$rtcName$0
	ORG $+48
stbi_load_16_from_callbacks$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_16_from_callbacks$rtcVarDesc
stbi_load_16_from_memory$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_16_from_memory$rtcVarDesc DD 040H
	DD	0e0H
	DQ	FLAT:stbi_load_16_from_memory$rtcName$0
	ORG $+48
stbi_load_16_from_memory$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_16_from_memory$rtcVarDesc
stbi_load_from_file_16$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_file_16$rtcVarDesc DD 050H
	DD	0e0H
	DQ	FLAT:stbi_load_from_file_16$rtcName$0
	ORG $+48
stbi_load_from_file_16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_file_16$rtcVarDesc
stbi_load_from_file$rtcName$0 DB 073H
	DB	00H
	ORG $+14
stbi_load_from_file$rtcVarDesc DD 050H
	DD	0e0H
	DQ	FLAT:stbi_load_from_file$rtcName$0
	ORG $+48
stbi_load_from_file$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi_load_from_file$rtcVarDesc
stbi__fopen$rtcName$0 DB 066H
	DB	00H
	ORG $+14
stbi__fopen$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:stbi__fopen$rtcName$0
	ORG $+48
stbi__fopen$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__fopen$rtcVarDesc
stbi__load_and_postprocess_16bit$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__load_and_postprocess_16bit$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:stbi__load_and_postprocess_16bit$rtcName$0
	ORG $+48
stbi__load_and_postprocess_16bit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_and_postprocess_16bit$rtcVarDesc
stbi__load_and_postprocess_8bit$rtcName$0 DB 072H
	DB	069H
	DB	00H
	ORG $+13
stbi__load_and_postprocess_8bit$rtcVarDesc DD 048H
	DD	0cH
	DQ	FLAT:stbi__load_and_postprocess_8bit$rtcName$0
	ORG $+48
stbi__load_and_postprocess_8bit$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__load_and_postprocess_8bit$rtcVarDesc
stbi__vertical_flip$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+11
stbi__vertical_flip$rtcVarDesc DD 040H
	DD	0800H
	DQ	FLAT:stbi__vertical_flip$rtcName$0
	ORG $+48
stbi__vertical_flip$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__vertical_flip$rtcVarDesc
stbi__cpuid3$rtcName$0 DB 069H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
	ORG $+11
stbi__cpuid3$rtcVarDesc DD 028H
	DD	010H
	DQ	FLAT:stbi__cpuid3$rtcName$0
	ORG $+48
stbi__cpuid3$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:stbi__cpuid3$rtcVarDesc
TryGetFrame2$rtcName$0 DB 068H
	DB	061H
	DB	073H
	DB	068H
	DB	00H
	ORG $+11
TryGetFrame2$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:TryGetFrame2$rtcName$0
	ORG $+48
TryGetFrame2$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:TryGetFrame2$rtcVarDesc
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
stbi_failure_reason PROC

; 971  : {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0000d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 972  :    return stbi__g_failure_reason;

  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  00017	8b c0		 mov	 eax, eax
  00019	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00022	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00025	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]

; 973  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
hash$ = 40
frame$ = 56
tv68 = 72
__$ArrayPad$ = 80
path$ = 112
wasNull$ = 120
TryGetFrame2 PROC

; 153  : byte* TryGetFrame2(char *path, bool *wasNull) {//only use if you are unsure if the value is in the map. kinda slow because of the linear probing. will add to the map if the key isn't already in it.

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00014	b9 10 00 00 00	 mov	 ecx, 16
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  0003b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 154  : 	ULONGLONG hash;
; 155  : 	byte* frame = GetFrame(path, &hash);

  00040	48 8d 54 24 28	 lea	 rdx, QWORD PTR hash$[rsp]
  00045	48 8b 4c 24 70	 mov	 rcx, QWORD PTR path$[rsp]
  0004a	e8 00 00 00 00	 call	 GetFrame
  0004f	48 89 44 24 38	 mov	 QWORD PTR frame$[rsp], rax

; 156  : 	if (*wasNull = !frame) {

  00054	48 83 7c 24 38
	00		 cmp	 QWORD PTR frame$[rsp], 0
  0005a	75 0a		 jne	 SHORT $LN4@TryGetFram
  0005c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN5@TryGetFram
$LN4@TryGetFram:
  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN5@TryGetFram:
  0006e	48 8b 44 24 78	 mov	 rax, QWORD PTR wasNull$[rsp]
  00073	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv68[rsp]
  00078	88 08		 mov	 BYTE PTR [rax], cl
  0007a	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv68[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	74 11		 je	 SHORT $LN2@TryGetFram

; 157  : 		//printf("returned new frame for \"%s\"\n", path);
; 158  : 		return AddFrameData(hash, path);

  00083	48 8b 54 24 70	 mov	 rdx, QWORD PTR path$[rsp]
  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  0008d	e8 00 00 00 00	 call	 AddFrameData
  00092	eb 05		 jmp	 SHORT $LN1@TryGetFram
$LN2@TryGetFram:

; 159  : 	}
; 160  : 	//printf("returned %zu for path \"%s\"\n", frame, path);
; 161  : 	return frame;

  00094	48 8b 44 24 38	 mov	 rax, QWORD PTR frame$[rsp]
$LN1@TryGetFram:

; 162  : }

  00099	48 8b f8	 mov	 rdi, rax
  0009c	48 8b cc	 mov	 rcx, rsp
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TryGetFrame2$rtcFrameData
  000a6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ab	48 8b c7	 mov	 rax, rdi
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
TryGetFrame2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
info$ = 40
__$ArrayPad$ = 80
stbi__cpuid3 PROC

; 731  : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00007	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000c	b9 12 00 00 00	 mov	 ecx, 18
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 732  :    int info[4];
; 733  :    __cpuid(info,1);

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	33 c9		 xor	 ecx, ecx
  0003a	0f a2		 cpuid
  0003c	4c 8d 44 24 28	 lea	 r8, QWORD PTR info$[rsp]
  00041	41 89 00	 mov	 DWORD PTR [r8], eax
  00044	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  00048	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  0004c	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 734  :    return info[3];

  00050	b8 04 00 00 00	 mov	 eax, 4
  00055	48 6b c0 03	 imul	 rax, rax, 3
  00059	8b 44 04 28	 mov	 eax, DWORD PTR info$[rsp+rax]

; 735  : }

  0005d	8b f8		 mov	 edi, eax
  0005f	48 8b cc	 mov	 rcx, rsp
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__cpuid3$rtcFrameData
  00069	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0006e	8b c7		 mov	 eax, edi
  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00075	48 33 cc	 xor	 rcx, rsp
  00078	e8 00 00 00 00	 call	 __security_check_cookie
  0007d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00081	5f		 pop	 rdi
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
stbi__cpuid3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
info3$ = 32
tv68 = 36
stbi__sse2_available PROC

; 753  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0000d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 754  :    int info3 = stbi__cpuid3();

  00012	e8 00 00 00 00	 call	 stbi__cpuid3
  00017	89 44 24 20	 mov	 DWORD PTR info3$[rsp], eax

; 755  :    return ((info3 >> 26) & 1) != 0;

  0001b	8b 44 24 20	 mov	 eax, DWORD PTR info3$[rsp]
  0001f	c1 f8 1a	 sar	 eax, 26
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN3@stbi__sse2
  00029	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
  00033	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__sse2:
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR tv68[rsp]

; 756  : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
stbi__sse2_available ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv72 = 32
s$ = 64
buffer$ = 72
len$ = 80
stbi__start_mem PROC

; 825  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 826  :    s->io.read = NULL;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 827  :    s->read_from_callbacks = 0;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00032	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 828  :    s->callback_already_read = 0;

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0003e	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 829  :    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00052	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00063	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 830  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

  0006a	48 63 44 24 50	 movsxd	 rax, DWORD PTR len$[rsp]
  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00074	48 03 c8	 add	 rcx, rax
  00077	48 89 4c 24 20	 mov	 QWORD PTR tv72[rsp], rcx
  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00086	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00097	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 831  : }

  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
stbi__start_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv72 = 32
s$ = 80
c$ = 88
user$ = 96
stbi__start_callbacks PROC

; 835  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 836  :    s->io = *c;

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00026	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0002a	48 8b 74 24 58	 mov	 rsi, QWORD PTR c$[rsp]
  0002f	b9 18 00 00 00	 mov	 ecx, 24
  00034	f3 a4		 rep movsb

; 837  :    s->io_user_data = user;

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR user$[rsp]
  00040	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 838  :    s->buflen = sizeof(s->buffer_start);

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00049	c7 40 34 80 00
	00 00		 mov	 DWORD PTR [rax+52], 128	; 00000080H

; 839  :    s->read_from_callbacks = 1;

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00055	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [rax+48], 1

; 840  :    s->callback_already_read = 0;

  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00061	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 841  :    s->img_buffer = s->img_buffer_original = s->buffer_start;

  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00070	48 83 c0 38	 add	 rax, 56			; 00000038H
  00074	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00083	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00094	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 842  :    stbi__refill_buffer(s);

  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a0	e8 00 00 00 00	 call	 stbi__refill_buffer

; 843  :    s->img_buffer_original_end = s->img_buffer_end;

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000af	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000b6	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 844  : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	5f		 pop	 rdi
  000c2	5e		 pop	 rsi
  000c3	c3		 ret	 0
stbi__start_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
user$ = 48
data$ = 56
size$ = 64
stbi__stdio_read PROC

; 849  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 850  :    return (int) fread(data,1,size,(FILE*) user);

  00020	48 63 44 24 40	 movsxd	 rax, DWORD PTR size$[rsp]
  00025	4c 8b 4c 24 30	 mov	 r9, QWORD PTR user$[rsp]
  0002a	4c 8b c0	 mov	 r8, rax
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 851  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
stbi__stdio_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
ch$ = 32
user$ = 64
n$ = 72
stbi__stdio_skip PROC

; 854  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 855  :    int ch;
; 856  :    fseek((FILE*) user, n, SEEK_CUR);

  0001a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00020	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 857  :    ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */

  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  0003a	89 44 24 20	 mov	 DWORD PTR ch$[rsp], eax

; 858  :    if (ch != EOF) {

  0003e	83 7c 24 20 ff	 cmp	 DWORD PTR ch$[rsp], -1
  00043	74 10		 je	 SHORT $LN2@stbi__stdi

; 859  :       ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */

  00045	48 8b 54 24 40	 mov	 rdx, QWORD PTR user$[rsp]
  0004a	8b 4c 24 20	 mov	 ecx, DWORD PTR ch$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00054	90		 npad	 1
$LN2@stbi__stdi:

; 860  :    }
; 861  : }

  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
stbi__stdio_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv70 = 32
user$ = 64
stbi__stdio_eof PROC

; 864  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 865  :    return feof((FILE*) user) || ferror((FILE *) user);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00021	85 c0		 test	 eax, eax
  00023	75 19		 jne	 SHORT $LN3@stbi__stdi
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00030	85 c0		 test	 eax, eax
  00032	75 0a		 jne	 SHORT $LN3@stbi__stdi
  00034	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0003c	eb 08		 jmp	 SHORT $LN4@stbi__stdi
$LN3@stbi__stdi:
  0003e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN4@stbi__stdi:
  00046	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]

; 866  : }

  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
stbi__stdio_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
f$ = 56
stbi__start_file PROC

; 876  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 877  :    stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);

  0001b	4c 8b 44 24 38	 mov	 r8, QWORD PTR f$[rsp]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__stdio_callbacks
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 stbi__start_callbacks
  00031	90		 npad	 1

; 878  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
stbi__start_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
stbi__rewind PROC

; 885  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 886  :    // conceptually rewind SHOULD rewind to the beginning of the stream,
; 887  :    // but we just rewind to the beginning of the initial buffer, because
; 888  :    // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 889  :    s->img_buffer = s->img_buffer_original;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00027	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 890  :    s->img_buffer_end = s->img_buffer_original_end;

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00038	48 8b 89 d8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+216]
  0003f	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 891  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
stbi__rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
str$ = 48
stbi__err PROC

; 977  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 978  :    stbi__g_failure_reason = str;

  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  0001b	8b c0		 mov	 eax, eax
  0001d	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00026	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00029	48 8b 54 24 30	 mov	 rdx, QWORD PTR str$[rsp]
  0002e	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 979  :    return 0;

  00032	33 c0		 xor	 eax, eax

; 980  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
stbi__err ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
size$ = 48
stbi__malloc PROC

; 984  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 985  :     return STBI_MALLOC(size);

  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 986  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
stbi__malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv67 = 32
a$ = 64
b$ = 72
stbi__addsizes_valid PROC

; 1001 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1002 :    if (b < 0) return 0;

  00019	83 7c 24 48 00	 cmp	 DWORD PTR b$[rsp], 0
  0001e	7d 04		 jge	 SHORT $LN2@stbi__adds
  00020	33 c0		 xor	 eax, eax
  00022	eb 25		 jmp	 SHORT $LN1@stbi__adds
$LN2@stbi__adds:

; 1003 :    // now 0 <= b <= INT_MAX, hence also
; 1004 :    // 0 <= INT_MAX - b <= INTMAX.
; 1005 :    // And "a + b <= INT_MAX" (which might overflow) is the
; 1006 :    // same as a <= INT_MAX - b (no overflow)
; 1007 :    return a <= INT_MAX - b;

  00024	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00029	2b 44 24 48	 sub	 eax, DWORD PTR b$[rsp]
  0002d	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  00031	7f 0a		 jg	 SHORT $LN4@stbi__adds
  00033	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0003b	eb 08		 jmp	 SHORT $LN5@stbi__adds
$LN4@stbi__adds:
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN5@stbi__adds:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]
$LN1@stbi__adds:

; 1008 : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
stbi__addsizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv69 = 32
a$ = 64
b$ = 72
stbi__mul2sizes_valid PROC

; 1013 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1014 :    if (a < 0 || b < 0) return 0;

  00019	83 7c 24 40 00	 cmp	 DWORD PTR a$[rsp], 0
  0001e	7c 07		 jl	 SHORT $LN3@stbi__mul2
  00020	83 7c 24 48 00	 cmp	 DWORD PTR b$[rsp], 0
  00025	7d 04		 jge	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  00027	33 c0		 xor	 eax, eax
  00029	eb 34		 jmp	 SHORT $LN1@stbi__mul2
$LN2@stbi__mul2:

; 1015 :    if (b == 0) return 1; // mul-by-0 is always safe

  0002b	83 7c 24 48 00	 cmp	 DWORD PTR b$[rsp], 0
  00030	75 07		 jne	 SHORT $LN4@stbi__mul2
  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	eb 26		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 1016 :    // portable way to check for no overflows in a*b
; 1017 :    return a <= INT_MAX/b;

  00039	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0003e	99		 cdq
  0003f	f7 7c 24 48	 idiv	 DWORD PTR b$[rsp]
  00043	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  00047	7f 0a		 jg	 SHORT $LN6@stbi__mul2
  00049	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00051	eb 08		 jmp	 SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
  00053	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN7@stbi__mul2:
  0005b	8b 44 24 20	 mov	 eax, DWORD PTR tv69[rsp]
$LN1@stbi__mul2:

; 1018 : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
stbi__mul2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv73 = 32
a$ = 64
b$ = 72
add$ = 80
stbi__mad2sizes_valid PROC

; 1023 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1024 :    return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

  0001e	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00026	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  0002b	85 c0		 test	 eax, eax
  0002d	74 22		 je	 SHORT $LN3@stbi__mad2
  0002f	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00033	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00038	8b 54 24 50	 mov	 edx, DWORD PTR add$[rsp]
  0003c	8b c8		 mov	 ecx, eax
  0003e	e8 00 00 00 00	 call	 stbi__addsizes_valid
  00043	85 c0		 test	 eax, eax
  00045	74 0a		 je	 SHORT $LN3@stbi__mad2
  00047	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0004f	eb 08		 jmp	 SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
  00051	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN4@stbi__mad2:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]

; 1025 : }

  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
stbi__mad2sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv79 = 32
a$ = 64
b$ = 72
c$ = 80
add$ = 88
stbi__mad3sizes_valid PROC

; 1030 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1031 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00023	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00027	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0002b	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00030	85 c0		 test	 eax, eax
  00032	74 3f		 je	 SHORT $LN3@stbi__mad3
  00034	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00038	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  0003d	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00048	85 c0		 test	 eax, eax
  0004a	74 27		 je	 SHORT $LN3@stbi__mad3
  0004c	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00050	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00055	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0005a	8b 54 24 58	 mov	 edx, DWORD PTR add$[rsp]
  0005e	8b c8		 mov	 ecx, eax
  00060	e8 00 00 00 00	 call	 stbi__addsizes_valid
  00065	85 c0		 test	 eax, eax
  00067	74 0a		 je	 SHORT $LN3@stbi__mad3
  00069	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
  00073	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN4@stbi__mad3:
  0007b	8b 44 24 20	 mov	 eax, DWORD PTR tv79[rsp]

; 1032 :       stbi__addsizes_valid(a*b*c, add);
; 1033 : }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
stbi__mad3sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv86 = 32
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
stbi__mad4sizes_valid PROC

; 1038 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1039 :    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00023	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00027	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0002b	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00030	85 c0		 test	 eax, eax
  00032	74 61		 je	 SHORT $LN3@stbi__mad4
  00034	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00038	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  0003d	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00048	85 c0		 test	 eax, eax
  0004a	74 49		 je	 SHORT $LN3@stbi__mad4
  0004c	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00050	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00055	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0005a	8b 54 24 58	 mov	 edx, DWORD PTR d$[rsp]
  0005e	8b c8		 mov	 ecx, eax
  00060	e8 00 00 00 00	 call	 stbi__mul2sizes_valid
  00065	85 c0		 test	 eax, eax
  00067	74 2c		 je	 SHORT $LN3@stbi__mad4
  00069	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0006d	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00072	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  00077	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  0007c	8b 54 24 60	 mov	 edx, DWORD PTR add$[rsp]
  00080	8b c8		 mov	 ecx, eax
  00082	e8 00 00 00 00	 call	 stbi__addsizes_valid
  00087	85 c0		 test	 eax, eax
  00089	74 0a		 je	 SHORT $LN3@stbi__mad4
  0008b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00093	eb 08		 jmp	 SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
  00095	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN4@stbi__mad4:
  0009d	8b 44 24 20	 mov	 eax, DWORD PTR tv86[rsp]

; 1040 :       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1041 : }

  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
stbi__mad4sizes_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
add$ = 64
stbi__malloc_mad2 PROC

; 1047 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1048 :    if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

  0001e	44 8b 44 24 40	 mov	 r8d, DWORD PTR add$[rsp]
  00023	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  00027	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  0002b	e8 00 00 00 00	 call	 stbi__mad2sizes_valid
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $LN2@stbi__mall
  00034	33 c0		 xor	 eax, eax
  00036	eb 17		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1049 :    return stbi__malloc(a*b + add);

  00038	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  0003c	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  00041	03 44 24 40	 add	 eax, DWORD PTR add$[rsp]
  00045	48 98		 cdqe
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 1050 : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
stbi__malloc_mad2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
c$ = 64
add$ = 72
stbi__malloc_mad3 PROC

; 1054 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1055 :    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

  00023	44 8b 4c 24 48	 mov	 r9d, DWORD PTR add$[rsp]
  00028	44 8b 44 24 40	 mov	 r8d, DWORD PTR c$[rsp]
  0002d	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  00031	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00035	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN2@stbi__mall
  0003e	33 c0		 xor	 eax, eax
  00040	eb 1c		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1056 :    return stbi__malloc(a*b*c + add);

  00042	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00046	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  0004b	0f af 44 24 40	 imul	 eax, DWORD PTR c$[rsp]
  00050	03 44 24 48	 add	 eax, DWORD PTR add$[rsp]
  00054	48 98		 cdqe
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 1057 : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
stbi__malloc_mad3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
stbi__malloc_mad4 PROC

; 1061 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1062 :    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

  00023	8b 44 24 60	 mov	 eax, DWORD PTR add$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	44 8b 4c 24 58	 mov	 r9d, DWORD PTR d$[rsp]
  00030	44 8b 44 24 50	 mov	 r8d, DWORD PTR c$[rsp]
  00035	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00039	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0003d	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00042	85 c0		 test	 eax, eax
  00044	75 04		 jne	 SHORT $LN2@stbi__mall
  00046	33 c0		 xor	 eax, eax
  00048	eb 21		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1063 :    return stbi__malloc(a*b*c*d + add);

  0004a	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0004e	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00053	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  00058	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  0005d	03 44 24 60	 add	 eax, DWORD PTR add$[rsp]
  00061	48 98		 cdqe
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 stbi__malloc
$LN1@stbi__mall:

; 1064 : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
stbi__malloc_mad4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv67 = 32
tv66 = 36
tv73 = 40
tv76 = 44
a$ = 64
b$ = 72
stbi__addints_valid PROC

; 1069 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1070 :    if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

  00019	83 7c 24 40 00	 cmp	 DWORD PTR a$[rsp], 0
  0001e	7c 0a		 jl	 SHORT $LN7@stbi__addi
  00020	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN8@stbi__addi
$LN7@stbi__addi:
  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN8@stbi__addi:
  00032	83 7c 24 48 00	 cmp	 DWORD PTR b$[rsp], 0
  00037	7c 0a		 jl	 SHORT $LN5@stbi__addi
  00039	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN6@stbi__addi
$LN5@stbi__addi:
  00043	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@stbi__addi:
  0004b	8b 44 24 24	 mov	 eax, DWORD PTR tv66[rsp]
  0004f	39 44 24 20	 cmp	 DWORD PTR tv67[rsp], eax
  00053	74 07		 je	 SHORT $LN2@stbi__addi
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	eb 5a		 jmp	 SHORT $LN1@stbi__addi
$LN2@stbi__addi:

; 1071 :    if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.

  0005c	83 7c 24 40 00	 cmp	 DWORD PTR a$[rsp], 0
  00061	7d 2e		 jge	 SHORT $LN3@stbi__addi
  00063	83 7c 24 48 00	 cmp	 DWORD PTR b$[rsp], 0
  00068	7d 27		 jge	 SHORT $LN3@stbi__addi
  0006a	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0006f	2b 44 24 48	 sub	 eax, DWORD PTR b$[rsp]
  00073	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  00077	7c 0a		 jl	 SHORT $LN9@stbi__addi
  00079	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00081	eb 08		 jmp	 SHORT $LN10@stbi__addi
$LN9@stbi__addi:
  00083	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN10@stbi__addi:
  0008b	8b 44 24 28	 mov	 eax, DWORD PTR tv73[rsp]
  0008f	eb 25		 jmp	 SHORT $LN1@stbi__addi
$LN3@stbi__addi:

; 1072 :    return a <= INT_MAX - b;

  00091	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00096	2b 44 24 48	 sub	 eax, DWORD PTR b$[rsp]
  0009a	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  0009e	7f 0a		 jg	 SHORT $LN11@stbi__addi
  000a0	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  000a8	eb 08		 jmp	 SHORT $LN12@stbi__addi
$LN11@stbi__addi:
  000aa	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN12@stbi__addi:
  000b2	8b 44 24 2c	 mov	 eax, DWORD PTR tv76[rsp]
$LN1@stbi__addi:

; 1073 : }

  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
stbi__addints_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv73 = 32
tv72 = 36
tv75 = 40
tv79 = 44
tv82 = 48
tv86 = 52
tv87 = 56
tv91 = 60
a$ = 80
b$ = 88
stbi__mul2shorts_valid PROC

; 1077 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1078 :    if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow

  0001b	0f bf 44 24 58	 movsx	 eax, WORD PTR b$[rsp]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN3@stbi__mul2
  00024	0f bf 44 24 58	 movsx	 eax, WORD PTR b$[rsp]
  00029	83 f8 ff	 cmp	 eax, -1
  0002c	75 0a		 jne	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	e9 e9 00 00 00	 jmp	 $LN1@stbi__mul2
$LN2@stbi__mul2:

; 1079 :    if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid

  00038	0f bf 44 24 50	 movsx	 eax, WORD PTR a$[rsp]
  0003d	85 c0		 test	 eax, eax
  0003f	7c 0a		 jl	 SHORT $LN9@stbi__mul2
  00041	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00049	eb 08		 jmp	 SHORT $LN10@stbi__mul2
$LN9@stbi__mul2:
  0004b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN10@stbi__mul2:
  00053	0f bf 44 24 58	 movsx	 eax, WORD PTR b$[rsp]
  00058	85 c0		 test	 eax, eax
  0005a	7c 0a		 jl	 SHORT $LN7@stbi__mul2
  0005c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN8@stbi__mul2
$LN7@stbi__mul2:
  00066	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN8@stbi__mul2:
  0006e	8b 44 24 24	 mov	 eax, DWORD PTR tv72[rsp]
  00072	39 44 24 20	 cmp	 DWORD PTR tv73[rsp], eax
  00076	75 36		 jne	 SHORT $LN4@stbi__mul2
  00078	0f bf 44 24 50	 movsx	 eax, WORD PTR a$[rsp]
  0007d	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  00081	0f bf 4c 24 58	 movsx	 ecx, WORD PTR b$[rsp]
  00086	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0008b	99		 cdq
  0008c	f7 f9		 idiv	 ecx
  0008e	8b 4c 24 28	 mov	 ecx, DWORD PTR tv75[rsp]
  00092	3b c8		 cmp	 ecx, eax
  00094	7f 0a		 jg	 SHORT $LN11@stbi__mul2
  00096	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  0009e	eb 08		 jmp	 SHORT $LN12@stbi__mul2
$LN11@stbi__mul2:
  000a0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@stbi__mul2:
  000a8	8b 44 24 2c	 mov	 eax, DWORD PTR tv79[rsp]
  000ac	eb 73		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 1080 :    if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN

  000ae	0f bf 44 24 58	 movsx	 eax, WORD PTR b$[rsp]
  000b3	85 c0		 test	 eax, eax
  000b5	7d 36		 jge	 SHORT $LN5@stbi__mul2
  000b7	0f bf 44 24 50	 movsx	 eax, WORD PTR a$[rsp]
  000bc	89 44 24 30	 mov	 DWORD PTR tv82[rsp], eax
  000c0	0f bf 4c 24 58	 movsx	 ecx, WORD PTR b$[rsp]
  000c5	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  000ca	99		 cdq
  000cb	f7 f9		 idiv	 ecx
  000cd	8b 4c 24 30	 mov	 ecx, DWORD PTR tv82[rsp]
  000d1	3b c8		 cmp	 ecx, eax
  000d3	7f 0a		 jg	 SHORT $LN13@stbi__mul2
  000d5	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000dd	eb 08		 jmp	 SHORT $LN14@stbi__mul2
$LN13@stbi__mul2:
  000df	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN14@stbi__mul2:
  000e7	8b 44 24 34	 mov	 eax, DWORD PTR tv86[rsp]
  000eb	eb 34		 jmp	 SHORT $LN1@stbi__mul2
$LN5@stbi__mul2:

; 1081 :    return a >= SHRT_MIN / b;

  000ed	0f bf 44 24 50	 movsx	 eax, WORD PTR a$[rsp]
  000f2	89 44 24 38	 mov	 DWORD PTR tv87[rsp], eax
  000f6	0f bf 4c 24 58	 movsx	 ecx, WORD PTR b$[rsp]
  000fb	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  00100	99		 cdq
  00101	f7 f9		 idiv	 ecx
  00103	8b 4c 24 38	 mov	 ecx, DWORD PTR tv87[rsp]
  00107	3b c8		 cmp	 ecx, eax
  00109	7c 0a		 jl	 SHORT $LN15@stbi__mul2
  0010b	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  00113	eb 08		 jmp	 SHORT $LN16@stbi__mul2
$LN15@stbi__mul2:
  00115	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN16@stbi__mul2:
  0011d	8b 44 24 3c	 mov	 eax, DWORD PTR tv91[rsp]
$LN1@stbi__mul2:

; 1082 : }

  00121	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00125	5f		 pop	 rdi
  00126	c3		 ret	 0
stbi__mul2shorts_valid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
retval_from_stbi_load$ = 48
stbi_image_free PROC

; 1100 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1101 :    STBI_FREE(retval_from_stbi_load);

  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retval_from_stbi_load$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00021	90		 npad	 1

; 1102 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 48
stbi_set_flip_vertically_on_load PROC

; 1115 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1116 :    stbi__vertically_flip_on_load_global = flag_true_if_should_flip;

  00015	8b 44 24 30	 mov	 eax, DWORD PTR flag_true_if_should_flip$[rsp]
  00019	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__vertically_flip_on_load_global, eax

; 1117 : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 48
stbi_set_flip_vertically_on_load_thread PROC

; 1125 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1126 :    stbi__vertically_flip_on_load_local = flag_true_if_should_flip;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  0001a	8b c0		 mov	 eax, eax
  0001c	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	8b 54 24 30	 mov	 edx, DWORD PTR flag_true_if_should_flip$[rsp]
  0002c	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 1127 :    stbi__vertically_flip_on_load_set = 1;

  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  00034	8b c0		 mov	 eax, eax
  00036	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 1128 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
stbi_set_flip_vertically_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
hdr$1 = 64
tv186 = 72
tv204 = 80
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
ri$ = 152
bpc$ = 160
stbi__load_main PROC

; 1136 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1137 :    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

  00025	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR ri$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 0c 00 00 00	 mov	 ecx, 12
  00034	f3 aa		 rep stosb

; 1138 :    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

  00036	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0003e	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1139 :    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

  00044	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0004c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1140 :    ri->num_channels = 0;

  00053	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0005b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1141 : 
; 1142 :    // test the formats with a very explicit header first (at least a FOURCC
; 1143 :    // or distinctive magic number first)
; 1144 :    #ifndef STBI_NO_PNG
; 1145 :    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__png_test
  0006c	85 c0		 test	 eax, eax
  0006e	74 3c		 je	 SHORT $LN2@stbi__load
  00070	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00078	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00084	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00088	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00090	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00098	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0009d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	e8 00 00 00 00	 call	 stbi__png_load
  000a7	e9 cd 02 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1146 :    #endif
; 1147 :    #ifndef STBI_NO_BMP
; 1148 :    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

  000ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000b1	e8 00 00 00 00	 call	 stbi__bmp_test
  000b6	85 c0		 test	 eax, eax
  000b8	74 3c		 je	 SHORT $LN3@stbi__load
  000ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000c2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000ce	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d2	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  000da	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  000e2	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  000e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000ec	e8 00 00 00 00	 call	 stbi__bmp_load
  000f1	e9 83 02 00 00	 jmp	 $LN1@stbi__load
$LN3@stbi__load:

; 1149 :    #endif
; 1150 :    #ifndef STBI_NO_GIF
; 1151 :    if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);

  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000fb	e8 00 00 00 00	 call	 stbi__gif_test
  00100	85 c0		 test	 eax, eax
  00102	74 3c		 je	 SHORT $LN4@stbi__load
  00104	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0010c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00111	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00118	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0011c	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00124	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0012c	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00131	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00136	e8 00 00 00 00	 call	 stbi__gif_load
  0013b	e9 39 02 00 00	 jmp	 $LN1@stbi__load
$LN4@stbi__load:

; 1152 :    #endif
; 1153 :    #ifndef STBI_NO_PSD
; 1154 :    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);

  00140	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00145	e8 00 00 00 00	 call	 stbi__psd_test
  0014a	85 c0		 test	 eax, eax
  0014c	74 47		 je	 SHORT $LN5@stbi__load
  0014e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR bpc$[rsp]
  00155	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00159	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00161	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00166	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0016d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00171	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00179	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00181	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00186	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0018b	e8 00 00 00 00	 call	 stbi__psd_load
  00190	e9 e4 01 00 00	 jmp	 $LN1@stbi__load
$LN5@stbi__load:

; 1155 :    #else
; 1156 :    STBI_NOTUSED(bpc);
; 1157 :    #endif
; 1158 :    #ifndef STBI_NO_PIC
; 1159 :    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

  00195	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0019a	e8 00 00 00 00	 call	 stbi__pic_test
  0019f	85 c0		 test	 eax, eax
  001a1	74 3c		 je	 SHORT $LN6@stbi__load
  001a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  001ab	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  001b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001bb	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  001c3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  001cb	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  001d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001d5	e8 00 00 00 00	 call	 stbi__pic_load
  001da	e9 9a 01 00 00	 jmp	 $LN1@stbi__load
$LN6@stbi__load:

; 1160 :    #endif
; 1161 : 
; 1162 :    // then the formats that can end up attempting to load with just 1 or 2
; 1163 :    // bytes matching expectations; these are prone to false positives, so
; 1164 :    // try them later
; 1165 :    #ifndef STBI_NO_JPEG
; 1166 :    if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

  001df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001e4	e8 00 00 00 00	 call	 stbi__jpeg_test
  001e9	85 c0		 test	 eax, eax
  001eb	74 3c		 je	 SHORT $LN7@stbi__load
  001ed	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  001f5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001fa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00201	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00205	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0020d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00215	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0021a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0021f	e8 00 00 00 00	 call	 stbi__jpeg_load
  00224	e9 50 01 00 00	 jmp	 $LN1@stbi__load
$LN7@stbi__load:

; 1167 :    #endif
; 1168 :    #ifndef STBI_NO_PNM
; 1169 :    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);

  00229	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0022e	e8 00 00 00 00	 call	 stbi__pnm_test
  00233	85 c0		 test	 eax, eax
  00235	74 3c		 je	 SHORT $LN8@stbi__load
  00237	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0023f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00244	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0024b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0024f	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00257	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0025f	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00264	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00269	e8 00 00 00 00	 call	 stbi__pnm_load
  0026e	e9 06 01 00 00	 jmp	 $LN1@stbi__load
$LN8@stbi__load:

; 1170 :    #endif
; 1171 : 
; 1172 :    #ifndef STBI_NO_HDR
; 1173 :    if (stbi__hdr_test(s)) {

  00273	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00278	e8 00 00 00 00	 call	 stbi__hdr_test
  0027d	85 c0		 test	 eax, eax
  0027f	0f 84 84 00 00
	00		 je	 $LN9@stbi__load

; 1174 :       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);

  00285	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0028d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00292	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00299	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0029d	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  002a5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  002ad	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  002b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002b7	e8 00 00 00 00	 call	 stbi__hdr_load
  002bc	48 89 44 24 40	 mov	 QWORD PTR hdr$1[rsp], rax

; 1175 :       return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

  002c1	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  002c9	74 0d		 je	 SHORT $LN12@stbi__load
  002cb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  002d2	89 44 24 48	 mov	 DWORD PTR tv186[rsp], eax
  002d6	eb 0e		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:
  002d8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  002e0	8b 00		 mov	 eax, DWORD PTR [rax]
  002e2	89 44 24 48	 mov	 DWORD PTR tv186[rsp], eax
$LN13@stbi__load:
  002e6	44 8b 4c 24 48	 mov	 r9d, DWORD PTR tv186[rsp]
  002eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  002f3	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  002f6	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  002fb	8b 10		 mov	 edx, DWORD PTR [rax]
  002fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hdr$1[rsp]
  00302	e8 00 00 00 00	 call	 stbi__hdr_to_ldr
  00307	eb 70		 jmp	 SHORT $LN1@stbi__load
$LN9@stbi__load:

; 1176 :    }
; 1177 :    #endif
; 1178 : 
; 1179 :    #ifndef STBI_NO_TGA
; 1180 :    // test tga last because it's a crappy test!
; 1181 :    if (stbi__tga_test(s))

  00309	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0030e	e8 00 00 00 00	 call	 stbi__tga_test
  00313	85 c0		 test	 eax, eax
  00315	74 39		 je	 SHORT $LN10@stbi__load

; 1182 :       return stbi__tga_load(s,x,y,comp,req_comp, ri);

  00317	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0031f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00324	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0032b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0032f	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00337	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0033f	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00344	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00349	e8 00 00 00 00	 call	 stbi__tga_load
  0034e	eb 29		 jmp	 SHORT $LN1@stbi__load
$LN10@stbi__load:

; 1183 :    #endif
; 1184 : 
; 1185 :    return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  00357	e8 00 00 00 00	 call	 stbi__err
  0035c	85 c0		 test	 eax, eax
  0035e	74 0b		 je	 SHORT $LN14@stbi__load
  00360	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv204[rsp], 0
  00369	eb 09		 jmp	 SHORT $LN15@stbi__load
$LN14@stbi__load:
  0036b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv204[rsp], 0
$LN15@stbi__load:
  00374	48 8b 44 24 50	 mov	 rax, QWORD PTR tv204[rsp]
$LN1@stbi__load:

; 1186 : }

  00379	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0037d	5f		 pop	 rdi
  0037e	c3		 ret	 0
stbi__load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
img_len$ = 36
reduced$ = 40
tv73 = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
stbi__convert_16_to_8 PROC

; 1189 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1190 :    int i;
; 1191 :    int img_len = w * h * channels;

  00024	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  00028	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  0002d	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00032	89 44 24 24	 mov	 DWORD PTR img_len$[rsp], eax

; 1192 :    stbi_uc *reduced;
; 1193 : 
; 1194 :    reduced = (stbi_uc *) stbi__malloc(img_len);

  00036	48 63 44 24 24	 movsxd	 rax, DWORD PTR img_len$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 stbi__malloc
  00043	48 89 44 24 28	 mov	 QWORD PTR reduced$[rsp], rax

; 1195 :    if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

  00048	48 83 7c 24 28
	00		 cmp	 QWORD PTR reduced$[rsp], 0
  0004e	75 2b		 jne	 SHORT $LN5@stbi__conv
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00057	e8 00 00 00 00	 call	 stbi__err
  0005c	85 c0		 test	 eax, eax
  0005e	74 0b		 je	 SHORT $LN7@stbi__conv
  00060	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
  00069	eb 09		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  0006b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN8@stbi__conv:
  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR tv73[rsp]
  00079	eb 53		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1196 : 
; 1197 :    for (i = 0; i < img_len; ++i)

  0007b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00083	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00085	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00089	ff c0		 inc	 eax
  0008b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  0008f	8b 44 24 24	 mov	 eax, DWORD PTR img_len$[rsp]
  00093	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00097	7d 25		 jge	 SHORT $LN3@stbi__conv

; 1198 :       reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000a3	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000a7	c1 f8 08	 sar	 eax, 8
  000aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000af	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR reduced$[rsp]
  000b9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000bc	eb c7		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1199 : 
; 1200 :    STBI_FREE(orig);

  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1201 :    return reduced;

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR reduced$[rsp]
$LN1@stbi__conv:

; 1202 : }

  000ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
stbi__convert_16_to_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
img_len$ = 36
enlarged$ = 40
tv74 = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
stbi__convert_8_to_16 PROC

; 1205 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1206 :    int i;
; 1207 :    int img_len = w * h * channels;

  00024	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  00028	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  0002d	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00032	89 44 24 24	 mov	 DWORD PTR img_len$[rsp], eax

; 1208 :    stbi__uint16 *enlarged;
; 1209 : 
; 1210 :    enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);

  00036	8b 44 24 24	 mov	 eax, DWORD PTR img_len$[rsp]
  0003a	d1 e0		 shl	 eax, 1
  0003c	48 98		 cdqe
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 stbi__malloc
  00046	48 89 44 24 28	 mov	 QWORD PTR enlarged$[rsp], rax

; 1211 :    if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  0004b	48 83 7c 24 28
	00		 cmp	 QWORD PTR enlarged$[rsp], 0
  00051	75 2b		 jne	 SHORT $LN5@stbi__conv
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0005a	e8 00 00 00 00	 call	 stbi__err
  0005f	85 c0		 test	 eax, eax
  00061	74 0b		 je	 SHORT $LN7@stbi__conv
  00063	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv74[rsp], 0
  0006c	eb 09		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  0006e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv74[rsp], 0
$LN8@stbi__conv:
  00077	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  0007c	eb 5f		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1212 : 
; 1213 :    for (i = 0; i < img_len; ++i)

  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00086	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00088	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  00092	8b 44 24 24	 mov	 eax, DWORD PTR img_len$[rsp]
  00096	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0009a	7d 31		 jge	 SHORT $LN3@stbi__conv

; 1214 :       enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000aa	c1 e0 08	 shl	 eax, 8
  000ad	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b2	48 8b 54 24 50	 mov	 rdx, QWORD PTR orig$[rsp]
  000b7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000bb	03 c1		 add	 eax, ecx
  000bd	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000c2	48 8b 54 24 28	 mov	 rdx, QWORD PTR enlarged$[rsp]
  000c7	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  000cb	eb bb		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1215 : 
; 1216 :    STBI_FREE(orig);

  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1217 :    return enlarged;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR enlarged$[rsp]
$LN1@stbi__conv:

; 1218 : }

  000dd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
stbi__convert_8_to_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
row$ = 32
bytes_per_row$ = 40
temp$ = 64
bytes$ = 2120
row0$4 = 2128
row1$5 = 2136
bytes_left$6 = 2144
bytes_copy$7 = 2152
tv80 = 2168
__$ArrayPad$ = 2176
image$ = 2224
w$ = 2232
h$ = 2240
bytes_per_pixel$ = 2248
stbi__vertical_flip PROC

; 1221 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 08
	00 00		 sub	 rsp, 2200		; 00000898H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 1e 02 00 00	 mov	 ecx, 542		; 0000021eH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 b0
	08 00 00	 mov	 rcx, QWORD PTR [rsp+2224]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 80
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1222 :    int row;
; 1223 :    size_t bytes_per_row = (size_t)w * bytes_per_pixel;

  00053	48 63 84 24 b8
	08 00 00	 movsxd	 rax, DWORD PTR w$[rsp]
  0005b	48 63 8c 24 c8
	08 00 00	 movsxd	 rcx, DWORD PTR bytes_per_pixel$[rsp]
  00063	48 0f af c1	 imul	 rax, rcx
  00067	48 89 44 24 28	 mov	 QWORD PTR bytes_per_row$[rsp], rax

; 1224 :    stbi_uc temp[2048];
; 1225 :    stbi_uc *bytes = (stbi_uc *)image;

  0006c	48 8b 84 24 b0
	08 00 00	 mov	 rax, QWORD PTR image$[rsp]
  00074	48 89 84 24 48
	08 00 00	 mov	 QWORD PTR bytes$[rsp], rax

; 1226 : 
; 1227 :    for (row = 0; row < (h>>1); row++) {

  0007c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR row$[rsp], 0
  00084	eb 0a		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  00086	8b 44 24 20	 mov	 eax, DWORD PTR row$[rsp]
  0008a	ff c0		 inc	 eax
  0008c	89 44 24 20	 mov	 DWORD PTR row$[rsp], eax
$LN4@stbi__vert:
  00090	8b 84 24 c0 08
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  00097	d1 f8		 sar	 eax, 1
  00099	39 44 24 20	 cmp	 DWORD PTR row$[rsp], eax
  0009d	0f 8d 5a 01 00
	00		 jge	 $LN3@stbi__vert

; 1228 :       stbi_uc *row0 = bytes + row*bytes_per_row;

  000a3	48 63 44 24 20	 movsxd	 rax, DWORD PTR row$[rsp]
  000a8	48 0f af 44 24
	28		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  000ae	48 8b 8c 24 48
	08 00 00	 mov	 rcx, QWORD PTR bytes$[rsp]
  000b6	48 03 c8	 add	 rcx, rax
  000b9	48 8b c1	 mov	 rax, rcx
  000bc	48 89 84 24 50
	08 00 00	 mov	 QWORD PTR row0$4[rsp], rax

; 1229 :       stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

  000c4	8b 44 24 20	 mov	 eax, DWORD PTR row$[rsp]
  000c8	8b 8c 24 c0 08
	00 00		 mov	 ecx, DWORD PTR h$[rsp]
  000cf	2b c8		 sub	 ecx, eax
  000d1	8b c1		 mov	 eax, ecx
  000d3	ff c8		 dec	 eax
  000d5	48 98		 cdqe
  000d7	48 0f af 44 24
	28		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  000dd	48 8b 8c 24 48
	08 00 00	 mov	 rcx, QWORD PTR bytes$[rsp]
  000e5	48 03 c8	 add	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 89 84 24 58
	08 00 00	 mov	 QWORD PTR row1$5[rsp], rax

; 1230 :       // swap row0 with row1
; 1231 :       size_t bytes_left = bytes_per_row;

  000f3	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes_per_row$[rsp]
  000f8	48 89 84 24 60
	08 00 00	 mov	 QWORD PTR bytes_left$6[rsp], rax
$LN5@stbi__vert:

; 1232 :       while (bytes_left) {

  00100	48 83 bc 24 60
	08 00 00 00	 cmp	 QWORD PTR bytes_left$6[rsp], 0
  00109	0f 84 e9 00 00
	00		 je	 $LN6@stbi__vert

; 1233 :          size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

  0010f	48 81 bc 24 60
	08 00 00 00 08
	00 00		 cmp	 QWORD PTR bytes_left$6[rsp], 2048 ; 00000800H
  0011b	73 12		 jae	 SHORT $LN8@stbi__vert
  0011d	48 8b 84 24 60
	08 00 00	 mov	 rax, QWORD PTR bytes_left$6[rsp]
  00125	48 89 84 24 78
	08 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0012d	eb 0c		 jmp	 SHORT $LN9@stbi__vert
$LN8@stbi__vert:
  0012f	48 c7 84 24 78
	08 00 00 00 08
	00 00		 mov	 QWORD PTR tv80[rsp], 2048 ; 00000800H
$LN9@stbi__vert:
  0013b	48 8b 84 24 78
	08 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  00143	48 89 84 24 68
	08 00 00	 mov	 QWORD PTR bytes_copy$7[rsp], rax

; 1234 :          memcpy(temp, row0, bytes_copy);

  0014b	48 8d 44 24 40	 lea	 rax, QWORD PTR temp$[rsp]
  00150	48 8b f8	 mov	 rdi, rax
  00153	48 8b b4 24 50
	08 00 00	 mov	 rsi, QWORD PTR row0$4[rsp]
  0015b	48 8b 8c 24 68
	08 00 00	 mov	 rcx, QWORD PTR bytes_copy$7[rsp]
  00163	f3 a4		 rep movsb

; 1235 :          memcpy(row0, row1, bytes_copy);

  00165	48 8b bc 24 50
	08 00 00	 mov	 rdi, QWORD PTR row0$4[rsp]
  0016d	48 8b b4 24 58
	08 00 00	 mov	 rsi, QWORD PTR row1$5[rsp]
  00175	48 8b 8c 24 68
	08 00 00	 mov	 rcx, QWORD PTR bytes_copy$7[rsp]
  0017d	f3 a4		 rep movsb

; 1236 :          memcpy(row1, temp, bytes_copy);

  0017f	48 8d 44 24 40	 lea	 rax, QWORD PTR temp$[rsp]
  00184	48 8b bc 24 58
	08 00 00	 mov	 rdi, QWORD PTR row1$5[rsp]
  0018c	48 8b f0	 mov	 rsi, rax
  0018f	48 8b 8c 24 68
	08 00 00	 mov	 rcx, QWORD PTR bytes_copy$7[rsp]
  00197	f3 a4		 rep movsb

; 1237 :          row0 += bytes_copy;

  00199	48 8b 84 24 68
	08 00 00	 mov	 rax, QWORD PTR bytes_copy$7[rsp]
  001a1	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR row0$4[rsp]
  001a9	48 03 c8	 add	 rcx, rax
  001ac	48 8b c1	 mov	 rax, rcx
  001af	48 89 84 24 50
	08 00 00	 mov	 QWORD PTR row0$4[rsp], rax

; 1238 :          row1 += bytes_copy;

  001b7	48 8b 84 24 68
	08 00 00	 mov	 rax, QWORD PTR bytes_copy$7[rsp]
  001bf	48 8b 8c 24 58
	08 00 00	 mov	 rcx, QWORD PTR row1$5[rsp]
  001c7	48 03 c8	 add	 rcx, rax
  001ca	48 8b c1	 mov	 rax, rcx
  001cd	48 89 84 24 58
	08 00 00	 mov	 QWORD PTR row1$5[rsp], rax

; 1239 :          bytes_left -= bytes_copy;

  001d5	48 8b 84 24 68
	08 00 00	 mov	 rax, QWORD PTR bytes_copy$7[rsp]
  001dd	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR bytes_left$6[rsp]
  001e5	48 2b c8	 sub	 rcx, rax
  001e8	48 8b c1	 mov	 rax, rcx
  001eb	48 89 84 24 60
	08 00 00	 mov	 QWORD PTR bytes_left$6[rsp], rax

; 1240 :       }

  001f3	e9 08 ff ff ff	 jmp	 $LN5@stbi__vert
$LN6@stbi__vert:

; 1241 :    }

  001f8	e9 89 fe ff ff	 jmp	 $LN2@stbi__vert
$LN3@stbi__vert:

; 1242 : }

  001fd	48 8b cc	 mov	 rcx, rsp
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__vertical_flip$rtcFrameData
  00207	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0020c	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00214	48 33 cc	 xor	 rcx, rsp
  00217	e8 00 00 00 00	 call	 __security_check_cookie
  0021c	48 81 c4 98 08
	00 00		 add	 rsp, 2200		; 00000898H
  00223	5f		 pop	 rdi
  00224	5e		 pop	 rsi
  00225	c3		 ret	 0
stbi__vertical_flip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
slice$ = 32
slice_size$ = 36
bytes$ = 40
image$ = 64
w$ = 72
h$ = 80
z$ = 88
bytes_per_pixel$ = 96
stbi__vertical_flip_slices PROC

; 1246 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1247 :    int slice;
; 1248 :    int slice_size = w * h * bytes_per_pixel;

  00024	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  00028	0f af 44 24 50	 imul	 eax, DWORD PTR h$[rsp]
  0002d	0f af 44 24 60	 imul	 eax, DWORD PTR bytes_per_pixel$[rsp]
  00032	89 44 24 24	 mov	 DWORD PTR slice_size$[rsp], eax

; 1249 : 
; 1250 :    stbi_uc *bytes = (stbi_uc *)image;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR image$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1251 :    for (slice = 0; slice < z; ++slice) {

  00040	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR slice$[rsp], 0
  00048	eb 0a		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  0004a	8b 44 24 20	 mov	 eax, DWORD PTR slice$[rsp]
  0004e	ff c0		 inc	 eax
  00050	89 44 24 20	 mov	 DWORD PTR slice$[rsp], eax
$LN4@stbi__vert:
  00054	8b 44 24 58	 mov	 eax, DWORD PTR z$[rsp]
  00058	39 44 24 20	 cmp	 DWORD PTR slice$[rsp], eax
  0005c	7d 2f		 jge	 SHORT $LN3@stbi__vert

; 1252 :       stbi__vertical_flip(bytes, w, h, bytes_per_pixel);

  0005e	44 8b 4c 24 60	 mov	 r9d, DWORD PTR bytes_per_pixel$[rsp]
  00063	44 8b 44 24 50	 mov	 r8d, DWORD PTR h$[rsp]
  00068	8b 54 24 48	 mov	 edx, DWORD PTR w$[rsp]
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00071	e8 00 00 00 00	 call	 stbi__vertical_flip

; 1253 :       bytes += slice_size;

  00076	48 63 44 24 24	 movsxd	 rax, DWORD PTR slice_size$[rsp]
  0007b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1254 :    }

  0008b	eb bd		 jmp	 SHORT $LN2@stbi__vert
$LN3@stbi__vert:

; 1255 : }

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
stbi__vertical_flip_slices ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
ri$ = 72
result$ = 104
channels$4 = 112
tv82 = 128
tv94 = 132
tv129 = 136
__$ArrayPad$ = 144
s$ = 176
x$ = 184
y$ = 192
comp$ = 200
req_comp$ = 208
stbi__load_and_postprocess_8bit PROC

; 1259 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0001c	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00021	b9 18 00 00 00	 mov	 ecx, 24
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+176]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1260 :    stbi__result_info ri;
; 1261 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

  00053	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  0005b	48 8d 44 24 48	 lea	 rax, QWORD PTR ri$[rsp]
  00060	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00065	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00080	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 stbi__load_main
  00095	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 1262 : 
; 1263 :    if (result == NULL)

  0009a	48 83 7c 24 68
	00		 cmp	 QWORD PTR result$[rsp], 0
  000a0	75 07		 jne	 SHORT $LN2@stbi__load

; 1264 :       return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 3f 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1265 : 
; 1266 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1267 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  000a9	83 7c 24 48 08	 cmp	 DWORD PTR ri$[rsp], 8
  000ae	74 23		 je	 SHORT $LN6@stbi__load
  000b0	83 7c 24 48 10	 cmp	 DWORD PTR ri$[rsp], 16
  000b5	74 1c		 je	 SHORT $LN6@stbi__load
  000b7	41 b8 f3 04 00
	00		 mov	 r8d, 1267		; 000004f3H
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 1268 : 
; 1269 :    if (ri.bits_per_channel != 8) {

  000d3	83 7c 24 48 08	 cmp	 DWORD PTR ri$[rsp], 8
  000d8	74 5f		 je	 SHORT $LN3@stbi__load

; 1270 :       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000da	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000e2	75 13		 jne	 SHORT $LN7@stbi__load
  000e4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000ec	8b 00		 mov	 eax, DWORD PTR [rax]
  000ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000f5	eb 0e		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000f7	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000fe	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
$LN8@stbi__load:
  00105	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR tv82[rsp]
  0010d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00115	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00118	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00120	8b 10		 mov	 edx, DWORD PTR [rax]
  00122	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  00127	e8 00 00 00 00	 call	 stbi__convert_16_to_8
  0012c	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 1271 :       ri.bits_per_channel = 8;

  00131	c7 44 24 48 08
	00 00 00	 mov	 DWORD PTR ri$[rsp], 8
$LN3@stbi__load:

; 1272 :    }
; 1273 : 
; 1274 :    // @TODO: move stbi__convert_format to here
; 1275 : 
; 1276 :    if (stbi__vertically_flip_on_load) {

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  0013e	8b c0		 mov	 eax, eax
  00140	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00149	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014c	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00150	74 1f		 je	 SHORT $LN9@stbi__load
  00152	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  00157	8b c0		 mov	 eax, eax
  00159	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00162	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00165	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00168	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  0016f	eb 0d		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00171	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00177	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
$LN10@stbi__load:
  0017e	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv94[rsp], 0
  00186	74 5b		 je	 SHORT $LN4@stbi__load

; 1277 :       int channels = req_comp ? req_comp : *comp;

  00188	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00190	74 10		 je	 SHORT $LN11@stbi__load
  00192	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00199	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  001a0	eb 11		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  001a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  001aa	8b 00		 mov	 eax, DWORD PTR [rax]
  001ac	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
$LN12@stbi__load:
  001b3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv129[rsp]
  001ba	89 44 24 70	 mov	 DWORD PTR channels$4[rsp], eax

; 1278 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

  001be	44 8b 4c 24 70	 mov	 r9d, DWORD PTR channels$4[rsp]
  001c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  001cb	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  001ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001d6	8b 10		 mov	 edx, DWORD PTR [rax]
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  001dd	e8 00 00 00 00	 call	 stbi__vertical_flip
  001e2	90		 npad	 1
$LN4@stbi__load:

; 1279 :    }
; 1280 : 
; 1281 :    return (unsigned char *) result;

  001e3	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1282 : }

  001e8	48 8b f8	 mov	 rdi, rax
  001eb	48 8b cc	 mov	 rcx, rsp
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_and_postprocess_8bit$rtcFrameData
  001f5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001fa	48 8b c7	 mov	 rax, rdi
  001fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00205	48 33 cc	 xor	 rcx, rsp
  00208	e8 00 00 00 00	 call	 __security_check_cookie
  0020d	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00214	5f		 pop	 rdi
  00215	c3		 ret	 0
stbi__load_and_postprocess_8bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
ri$ = 72
result$ = 104
channels$4 = 112
tv82 = 128
tv94 = 132
tv129 = 136
__$ArrayPad$ = 144
s$ = 176
x$ = 184
y$ = 192
comp$ = 200
req_comp$ = 208
stbi__load_and_postprocess_16bit PROC

; 1285 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0001c	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00021	b9 18 00 00 00	 mov	 ecx, 24
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+176]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1286 :    stbi__result_info ri;
; 1287 :    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

  00053	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  0005b	48 8d 44 24 48	 lea	 rax, QWORD PTR ri$[rsp]
  00060	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00065	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00080	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 stbi__load_main
  00095	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 1288 : 
; 1289 :    if (result == NULL)

  0009a	48 83 7c 24 68
	00		 cmp	 QWORD PTR result$[rsp], 0
  000a0	75 07		 jne	 SHORT $LN2@stbi__load

; 1290 :       return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 45 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1291 : 
; 1292 :    // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1293 :    STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  000a9	83 7c 24 48 08	 cmp	 DWORD PTR ri$[rsp], 8
  000ae	74 23		 je	 SHORT $LN6@stbi__load
  000b0	83 7c 24 48 10	 cmp	 DWORD PTR ri$[rsp], 16
  000b5	74 1c		 je	 SHORT $LN6@stbi__load
  000b7	41 b8 0d 05 00
	00		 mov	 r8d, 1293		; 0000050dH
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@LFNCFCEN@?$AAr?$AAi?$AA?4?$AAb?$AAi?$AAt?$AAs?$AA_?$AAp?$AAe?$AAr?$AA_?$AAc?$AAh?$AAa@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 1294 : 
; 1295 :    if (ri.bits_per_channel != 16) {

  000d3	83 7c 24 48 10	 cmp	 DWORD PTR ri$[rsp], 16
  000d8	74 5f		 je	 SHORT $LN3@stbi__load

; 1296 :       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000da	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000e2	75 13		 jne	 SHORT $LN7@stbi__load
  000e4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000ec	8b 00		 mov	 eax, DWORD PTR [rax]
  000ee	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000f5	eb 0e		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000f7	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000fe	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
$LN8@stbi__load:
  00105	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR tv82[rsp]
  0010d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00115	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00118	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00120	8b 10		 mov	 edx, DWORD PTR [rax]
  00122	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  00127	e8 00 00 00 00	 call	 stbi__convert_8_to_16
  0012c	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 1297 :       ri.bits_per_channel = 16;

  00131	c7 44 24 48 10
	00 00 00	 mov	 DWORD PTR ri$[rsp], 16
$LN3@stbi__load:

; 1298 :    }
; 1299 : 
; 1300 :    // @TODO: move stbi__convert_format16 to here
; 1301 :    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1302 : 
; 1303 :    if (stbi__vertically_flip_on_load) {

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  0013e	8b c0		 mov	 eax, eax
  00140	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00149	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014c	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00150	74 1f		 je	 SHORT $LN9@stbi__load
  00152	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  00157	8b c0		 mov	 eax, eax
  00159	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00162	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00165	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00168	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  0016f	eb 0d		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00171	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00177	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
$LN10@stbi__load:
  0017e	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv94[rsp], 0
  00186	74 61		 je	 SHORT $LN4@stbi__load

; 1304 :       int channels = req_comp ? req_comp : *comp;

  00188	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00190	74 10		 je	 SHORT $LN11@stbi__load
  00192	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00199	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  001a0	eb 11		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  001a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  001aa	8b 00		 mov	 eax, DWORD PTR [rax]
  001ac	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
$LN12@stbi__load:
  001b3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv129[rsp]
  001ba	89 44 24 70	 mov	 DWORD PTR channels$4[rsp], eax

; 1305 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

  001be	48 63 44 24 70	 movsxd	 rax, DWORD PTR channels$4[rsp]
  001c3	48 d1 e0	 shl	 rax, 1
  001c6	44 8b c8	 mov	 r9d, eax
  001c9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  001d1	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  001d4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001dc	8b 10		 mov	 edx, DWORD PTR [rax]
  001de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  001e3	e8 00 00 00 00	 call	 stbi__vertical_flip
  001e8	90		 npad	 1
$LN4@stbi__load:

; 1306 :    }
; 1307 : 
; 1308 :    return (stbi__uint16 *) result;

  001e9	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1309 : }

  001ee	48 8b f8	 mov	 rdi, rax
  001f1	48 8b cc	 mov	 rcx, rsp
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_and_postprocess_16bit$rtcFrameData
  001fb	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00200	48 8b c7	 mov	 rax, rdi
  00203	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020b	48 33 cc	 xor	 rcx, rsp
  0020e	e8 00 00 00 00	 call	 __security_check_cookie
  00213	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0021a	5f		 pop	 rdi
  0021b	c3		 ret	 0
stbi__load_and_postprocess_16bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
channels$1 = 32
tv71 = 36
tv75 = 40
result$ = 64
x$ = 72
y$ = 80
comp$ = 88
req_comp$ = 96
stbi__float_postprocess PROC

; 1313 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1314 :    if (stbi__vertically_flip_on_load && result != NULL) {

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  0002a	8b c0		 mov	 eax, eax
  0002c	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00035	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00038	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  0003c	74 1c		 je	 SHORT $LN4@stbi__floa
  0003e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  00043	8b c0		 mov	 eax, eax
  00045	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00054	89 44 24 24	 mov	 DWORD PTR tv71[rsp], eax
  00058	eb 0a		 jmp	 SHORT $LN5@stbi__floa
$LN4@stbi__floa:
  0005a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  00060	89 44 24 24	 mov	 DWORD PTR tv71[rsp], eax
$LN5@stbi__floa:
  00064	83 7c 24 24 00	 cmp	 DWORD PTR tv71[rsp], 0
  00069	74 52		 je	 SHORT $LN2@stbi__floa
  0006b	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00071	74 4a		 je	 SHORT $LN2@stbi__floa

; 1315 :       int channels = req_comp ? req_comp : *comp;

  00073	83 7c 24 60 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00078	74 0a		 je	 SHORT $LN6@stbi__floa
  0007a	8b 44 24 60	 mov	 eax, DWORD PTR req_comp$[rsp]
  0007e	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  00082	eb 0b		 jmp	 SHORT $LN7@stbi__floa
$LN6@stbi__floa:
  00084	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  00089	8b 00		 mov	 eax, DWORD PTR [rax]
  0008b	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
$LN7@stbi__floa:
  0008f	8b 44 24 28	 mov	 eax, DWORD PTR tv75[rsp]
  00093	89 44 24 20	 mov	 DWORD PTR channels$1[rsp], eax

; 1316 :       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));

  00097	48 63 44 24 20	 movsxd	 rax, DWORD PTR channels$1[rsp]
  0009c	48 c1 e0 02	 shl	 rax, 2
  000a0	44 8b c8	 mov	 r9d, eax
  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  000a8	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000ab	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  000b0	8b 10		 mov	 edx, DWORD PTR [rax]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  000b7	e8 00 00 00 00	 call	 stbi__vertical_flip
  000bc	90		 npad	 1
$LN2@stbi__floa:

; 1317 :    }
; 1318 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
stbi__float_postprocess ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 40
__$ArrayPad$ = 64
filename$ = 96
mode$ = 104
stbi__fopen PROC

; 1336 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00014	b9 0c 00 00 00	 mov	 ecx, 12
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1337 :    FILE *f;
; 1338 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1339 :    wchar_t wMode[64];
; 1340 :    wchar_t wFilename[1024];
; 1341 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1342 :       return 0;
; 1343 : 
; 1344 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1345 :       return 0;
; 1346 : 
; 1347 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1348 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1349 : 		f = 0;
; 1350 : #else
; 1351 :    f = _wfopen(wFilename, wMode);
; 1352 : #endif
; 1353 : 
; 1354 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1355 :    if (0 != fopen_s(&f, filename, mode))

  00040	4c 8b 44 24 68	 mov	 r8, QWORD PTR mode$[rsp]
  00045	48 8b 54 24 60	 mov	 rdx, QWORD PTR filename$[rsp]
  0004a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR f$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen_s
  00055	85 c0		 test	 eax, eax
  00057	74 09		 je	 SHORT $LN2@stbi__fope

; 1356 :       f=0;

  00059	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR f$[rsp], 0
$LN2@stbi__fope:

; 1357 : #else
; 1358 :    f = fopen(filename, mode);
; 1359 : #endif
; 1360 :    return f;

  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR f$[rsp]

; 1361 : }

  00067	48 8b f8	 mov	 rdi, rax
  0006a	48 8b cc	 mov	 rcx, rsp
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__fopen$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	48 8b c7	 mov	 rax, rdi
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00081	48 33 cc	 xor	 rcx, rsp
  00084	e8 00 00 00 00	 call	 __security_check_cookie
  00089	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
stbi__fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 48
result$ = 56
tv71 = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load PROC

; 1365 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1366 :    FILE *f = stbi__fopen(filename, "rb");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00031	e8 00 00 00 00	 call	 stbi__fopen
  00036	48 89 44 24 30	 mov	 QWORD PTR f$[rsp], rax

; 1367 :    unsigned char *result;
; 1368 :    if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

  0003b	48 83 7c 24 30
	00		 cmp	 QWORD PTR f$[rsp], 0
  00041	75 2b		 jne	 SHORT $LN2@stbi_load
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0b		 je	 SHORT $LN4@stbi_load
  00053	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
  0005c	eb 09		 jmp	 SHORT $LN5@stbi_load
$LN4@stbi_load:
  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
$LN5@stbi_load:
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR tv71[rsp]
  0006c	eb 39		 jmp	 SHORT $LN1@stbi_load
$LN2@stbi_load:

; 1369 :    result = stbi_load_from_file(f,x,y,comp,req_comp);

  0006e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00083	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi_load_from_file
  00092	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 1370 :    fclose(f);

  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1371 :    return result;

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load:

; 1372 : }

  000a7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 80
__$ArrayPad$ = 320
f$ = 352
x$ = 360
y$ = 368
comp$ = 376
req_comp$ = 384
stbi_load_from_file PROC

; 1375 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR [rsp+352]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1376 :    unsigned char *result;
; 1377 :    stbi__context s;
; 1378 :    stbi__start_file(&s,f);

  00053	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  0005b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00060	e8 00 00 00 00	 call	 stbi__start_file

; 1379 :    result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  00065	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00080	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit
  00092	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1380 :    if (result) {

  00097	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  0009d	74 2f		 je	 SHORT $LN2@stbi_load_

; 1381 :       // need to 'unget' all the characters in the IO buffer
; 1382 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  0009f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  000a7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  000af	48 2b c8	 sub	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	f7 d8		 neg	 eax
  000b7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000bd	8b d0		 mov	 edx, eax
  000bf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  000cd	90		 npad	 1
$LN2@stbi_load_:

; 1383 :    }
; 1384 :    return result;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1385 : }

  000d3	48 8b f8	 mov	 rdi, rax
  000d6	48 8b cc	 mov	 rcx, rsp
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_file$rtcFrameData
  000e0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e5	48 8b c7	 mov	 rax, rdi
  000e8	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f0	48 33 cc	 xor	 rcx, rsp
  000f3	e8 00 00 00 00	 call	 __security_check_cookie
  000f8	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 80
__$ArrayPad$ = 320
f$ = 352
x$ = 360
y$ = 368
comp$ = 376
req_comp$ = 384
stbi_load_from_file_16 PROC

; 1388 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR [rsp+352]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1389 :    stbi__uint16 *result;
; 1390 :    stbi__context s;
; 1391 :    stbi__start_file(&s,f);

  00053	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  0005b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00060	e8 00 00 00 00	 call	 stbi__start_file

; 1392 :    result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);

  00065	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00080	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit
  00092	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1393 :    if (result) {

  00097	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  0009d	74 2f		 je	 SHORT $LN2@stbi_load_

; 1394 :       // need to 'unget' all the characters in the IO buffer
; 1395 :       fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  0009f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  000a7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  000af	48 2b c8	 sub	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	f7 d8		 neg	 eax
  000b7	41 b8 01 00 00
	00		 mov	 r8d, 1
  000bd	8b d0		 mov	 edx, eax
  000bf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  000cd	90		 npad	 1
$LN2@stbi_load_:

; 1396 :    }
; 1397 :    return result;

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1398 : }

  000d3	48 8b f8	 mov	 rdi, rax
  000d6	48 8b cc	 mov	 rcx, rsp
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_file_16$rtcFrameData
  000e0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e5	48 8b c7	 mov	 rax, rdi
  000e8	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f0	48 33 cc	 xor	 rcx, rsp
  000f3	e8 00 00 00 00	 call	 __security_check_cookie
  000f8	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 48
result$ = 56
tv71 = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load_16 PROC

; 1401 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1402 :    FILE *f = stbi__fopen(filename, "rb");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00031	e8 00 00 00 00	 call	 stbi__fopen
  00036	48 89 44 24 30	 mov	 QWORD PTR f$[rsp], rax

; 1403 :    stbi__uint16 *result;
; 1404 :    if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");

  0003b	48 83 7c 24 30
	00		 cmp	 QWORD PTR f$[rsp], 0
  00041	75 2b		 jne	 SHORT $LN2@stbi_load_
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0b		 je	 SHORT $LN4@stbi_load_
  00053	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
  0005c	eb 09		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
$LN5@stbi_load_:
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR tv71[rsp]
  0006c	eb 39		 jmp	 SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 1405 :    result = stbi_load_from_file_16(f,x,y,comp,req_comp);

  0006e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00083	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi_load_from_file_16
  00092	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 1406 :    fclose(f);

  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1407 :    return result;

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load_:

; 1408 : }

  000a7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
buffer$ = 336
len$ = 344
x$ = 352
y$ = 360
channels_in_file$ = 368
desired_channels$ = 376
stbi_load_16_from_memory PROC

; 1414 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001b	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1415 :    stbi__context s;
; 1416 :    stbi__start_mem(&s,buffer,len);

  00052	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0005a	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__start_mem

; 1417 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  0006c	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00077	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  0007f	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00087	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0008f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit

; 1418 : }

  00099	48 8b f8	 mov	 rdi, rax
  0009c	48 8b cc	 mov	 rcx, rsp
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_16_from_memory$rtcFrameData
  000a6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ab	48 8b c7	 mov	 rax, rdi
  000ae	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b6	48 33 cc	 xor	 rcx, rsp
  000b9	e8 00 00 00 00	 call	 __security_check_cookie
  000be	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
clbk$ = 336
user$ = 344
x$ = 352
y$ = 360
channels_in_file$ = 368
desired_channels$ = 376
stbi_load_16_from_callbacks PROC

; 1421 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1422 :    stbi__context s;
; 1423 :    stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);

  00053	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0005b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00063	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__start_callbacks

; 1424 :    return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  0006d	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  00080	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00088	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00090	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00095	e8 00 00 00 00	 call	 stbi__load_and_postprocess_16bit

; 1425 : }

  0009a	48 8b f8	 mov	 rdi, rax
  0009d	48 8b cc	 mov	 rcx, rsp
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_16_from_callbacks$rtcFrameData
  000a7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ac	48 8b c7	 mov	 rax, rdi
  000af	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b7	48 33 cc	 xor	 rcx, rsp
  000ba	e8 00 00 00 00	 call	 __security_check_cookie
  000bf	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
buffer$ = 336
len$ = 344
x$ = 352
y$ = 360
comp$ = 368
req_comp$ = 376
stbi_load_from_memory PROC

; 1428 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001b	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1429 :    stbi__context s;
; 1430 :    stbi__start_mem(&s,buffer,len);

  00052	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0005a	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__start_mem

; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  0006c	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00077	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0007f	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00087	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0008f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit

; 1432 : }

  00099	48 8b f8	 mov	 rdi, rax
  0009c	48 8b cc	 mov	 rcx, rsp
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_memory$rtcFrameData
  000a6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ab	48 8b c7	 mov	 rax, rdi
  000ae	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b6	48 33 cc	 xor	 rcx, rsp
  000b9	e8 00 00 00 00	 call	 __security_check_cookie
  000be	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
clbk$ = 336
user$ = 344
x$ = 352
y$ = 360
comp$ = 368
req_comp$ = 376
stbi_load_from_callbacks PROC

; 1435 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1436 :    stbi__context s;
; 1437 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00053	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0005b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00063	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__start_callbacks

; 1438 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  0006d	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00080	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00088	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00090	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00095	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit

; 1439 : }

  0009a	48 8b f8	 mov	 rdi, rax
  0009d	48 8b cc	 mov	 rcx, rsp
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_from_callbacks$rtcFrameData
  000a7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ac	48 8b c7	 mov	 rax, rdi
  000af	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b7	48 33 cc	 xor	 rcx, rsp
  000ba	e8 00 00 00 00	 call	 __security_check_cookie
  000bf	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 64
s$ = 96
tv82 = 336
__$ArrayPad$ = 344
buffer$ = 368
len$ = 376
delays$ = 384
x$ = 392
y$ = 400
z$ = 408
comp$ = 416
req_comp$ = 424
stbi_load_gif_from_memory PROC

; 1443 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  0001b	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00020	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR [rsp+368]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1444 :    unsigned char *result;
; 1445 :    stbi__context s;
; 1446 :    stbi__start_mem(&s,buffer,len);

  00052	44 8b 84 24 78
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0005a	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00062	48 8d 4c 24 60	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__start_mem

; 1447 : 
; 1448 :    result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);

  0006c	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00073	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00077	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0007f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00084	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8b 8c 24 90
	01 00 00	 mov	 r9, QWORD PTR y$[rsp]
  00099	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR x$[rsp]
  000a1	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR delays$[rsp]
  000a9	48 8d 4c 24 60	 lea	 rcx, QWORD PTR s$[rsp]
  000ae	e8 00 00 00 00	 call	 stbi__load_gif_main
  000b3	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1449 :    if (stbi__vertically_flip_on_load) {

  000b8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_set
  000bd	8b c0		 mov	 eax, eax
  000bf	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  000c8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000cb	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  000cf	74 1f		 je	 SHORT $LN4@stbi_load_
  000d1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__vertically_flip_on_load_local
  000d6	8b c0		 mov	 eax, eax
  000d8	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  000e1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e4	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000e7	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000ee	eb 0d		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  000f0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__vertically_flip_on_load_global
  000f6	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv82[rsp], eax
$LN5@stbi_load_:
  000fd	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR tv82[rsp], 0
  00105	74 39		 je	 SHORT $LN2@stbi_load_

; 1450 :       stbi__vertical_flip_slices( result, *x, *y, *z, *comp );

  00107	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0010f	8b 00		 mov	 eax, DWORD PTR [rax]
  00111	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00115	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0011d	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00120	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00128	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0012b	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00133	8b 10		 mov	 edx, DWORD PTR [rax]
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0013a	e8 00 00 00 00	 call	 stbi__vertical_flip_slices
  0013f	90		 npad	 1
$LN2@stbi_load_:

; 1451 :    }
; 1452 : 
; 1453 :    return result;

  00140	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 1454 : }

  00145	48 8b f8	 mov	 rdi, rax
  00148	48 8b cc	 mov	 rcx, rsp
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_load_gif_from_memory$rtcFrameData
  00152	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00157	48 8b c7	 mov	 rax, rdi
  0015a	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00162	48 33 cc	 xor	 rcx, rsp
  00165	e8 00 00 00 00	 call	 __security_check_cookie
  0016a	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  00171	5f		 pop	 rdi
  00172	c3		 ret	 0
stbi_load_gif_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
data$ = 48
ri$4 = 72
hdr_data$5 = 104
tv89 = 120
tv129 = 128
__$ArrayPad$ = 136
s$ = 160
x$ = 168
y$ = 176
comp$ = 184
req_comp$ = 192
stbi__loadf_main PROC

; 1459 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 18 00 00 00	 mov	 ecx, 24
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1460 :    unsigned char *data;
; 1461 :    #ifndef STBI_NO_HDR
; 1462 :    if (stbi__hdr_test(s)) {

  00053	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	e8 00 00 00 00	 call	 stbi__hdr_test
  00060	85 c0		 test	 eax, eax
  00062	74 7f		 je	 SHORT $LN2@stbi__load

; 1463 :       stbi__result_info ri;
; 1464 :       float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);

  00064	48 8d 44 24 48	 lea	 rax, QWORD PTR ri$4[rsp]
  00069	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00081	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00089	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00091	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00099	e8 00 00 00 00	 call	 stbi__hdr_load
  0009e	48 89 44 24 68	 mov	 QWORD PTR hdr_data$5[rsp], rax

; 1465 :       if (hdr_data)

  000a3	48 83 7c 24 68
	00		 cmp	 QWORD PTR hdr_data$5[rsp], 0
  000a9	74 2e		 je	 SHORT $LN3@stbi__load

; 1466 :          stbi__float_postprocess(hdr_data,x,y,comp,req_comp);

  000ab	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000b2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b6	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  000be	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  000c6	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hdr_data$5[rsp]
  000d3	e8 00 00 00 00	 call	 stbi__float_postprocess
  000d8	90		 npad	 1
$LN3@stbi__load:

; 1467 :       return hdr_data;

  000d9	48 8b 44 24 68	 mov	 rax, QWORD PTR hdr_data$5[rsp]
  000de	e9 ba 00 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1468 :    }
; 1469 :    #endif
; 1470 :    data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

  000e3	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000ea	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ee	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  000f6	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  000fe	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00106	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0010e	e8 00 00 00 00	 call	 stbi__load_and_postprocess_8bit
  00113	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 1471 :    if (data)

  00118	48 83 7c 24 30
	00		 cmp	 QWORD PTR data$[rsp], 0
  0011e	74 4b		 je	 SHORT $LN4@stbi__load

; 1472 :       return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

  00120	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00128	74 0d		 je	 SHORT $LN6@stbi__load
  0012a	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00131	89 44 24 78	 mov	 DWORD PTR tv89[rsp], eax
  00135	eb 0e		 jmp	 SHORT $LN7@stbi__load
$LN6@stbi__load:
  00137	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0013f	8b 00		 mov	 eax, DWORD PTR [rax]
  00141	89 44 24 78	 mov	 DWORD PTR tv89[rsp], eax
$LN7@stbi__load:
  00145	44 8b 4c 24 78	 mov	 r9d, DWORD PTR tv89[rsp]
  0014a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00152	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00155	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0015d	8b 10		 mov	 edx, DWORD PTR [rax]
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00164	e8 00 00 00 00	 call	 stbi__ldr_to_hdr
  00169	eb 32		 jmp	 SHORT $LN1@stbi__load
$LN4@stbi__load:

; 1473 :    return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  00172	e8 00 00 00 00	 call	 stbi__err
  00177	85 c0		 test	 eax, eax
  00179	74 0e		 je	 SHORT $LN8@stbi__load
  0017b	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv129[rsp], 0
  00187	eb 0c		 jmp	 SHORT $LN9@stbi__load
$LN8@stbi__load:
  00189	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv129[rsp], 0
$LN9@stbi__load:
  00195	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv129[rsp]
$LN1@stbi__load:

; 1474 : }

  0019d	48 8b f8	 mov	 rdi, rax
  001a0	48 8b cc	 mov	 rcx, rsp
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__loadf_main$rtcFrameData
  001aa	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001af	48 8b c7	 mov	 rax, rdi
  001b2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ba	48 33 cc	 xor	 rcx, rsp
  001bd	e8 00 00 00 00	 call	 __security_check_cookie
  001c2	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  001c9	5f		 pop	 rdi
  001ca	c3		 ret	 0
stbi__loadf_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
buffer$ = 336
len$ = 344
x$ = 352
y$ = 360
comp$ = 368
req_comp$ = 376
stbi_loadf_from_memory PROC

; 1477 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001b	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1478 :    stbi__context s;
; 1479 :    stbi__start_mem(&s,buffer,len);

  00052	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0005a	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__start_mem

; 1480 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

  0006c	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00077	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0007f	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00087	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0008f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 stbi__loadf_main

; 1481 : }

  00099	48 8b f8	 mov	 rdi, rax
  0009c	48 8b cc	 mov	 rcx, rsp
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_memory$rtcFrameData
  000a6	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ab	48 8b c7	 mov	 rax, rdi
  000ae	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b6	48 33 cc	 xor	 rcx, rsp
  000b9	e8 00 00 00 00	 call	 __security_check_cookie
  000be	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
clbk$ = 336
user$ = 344
x$ = 352
y$ = 360
comp$ = 368
req_comp$ = 376
stbi_loadf_from_callbacks PROC

; 1484 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1485 :    stbi__context s;
; 1486 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00053	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0005b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00063	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__start_callbacks

; 1487 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

  0006d	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00074	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00078	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00080	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00088	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00090	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00095	e8 00 00 00 00	 call	 stbi__loadf_main

; 1488 : }

  0009a	48 8b f8	 mov	 rdi, rax
  0009d	48 8b cc	 mov	 rcx, rsp
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_callbacks$rtcFrameData
  000a7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000ac	48 8b c7	 mov	 rax, rdi
  000af	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b7	48 33 cc	 xor	 rcx, rsp
  000ba	e8 00 00 00 00	 call	 __security_check_cookie
  000bf	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
f$ = 56
tv71 = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_loadf PROC

; 1492 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1493 :    float *result;
; 1494 :    FILE *f = stbi__fopen(filename, "rb");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0002c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00031	e8 00 00 00 00	 call	 stbi__fopen
  00036	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1495 :    if (!f) return stbi__errpf("can't fopen", "Unable to open file");

  0003b	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00041	75 2b		 jne	 SHORT $LN2@stbi_loadf
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0b		 je	 SHORT $LN4@stbi_loadf
  00053	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
  0005c	eb 09		 jmp	 SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv71[rsp], 0
$LN5@stbi_loadf:
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR tv71[rsp]
  0006c	eb 39		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 1496 :    result = stbi_loadf_from_file(f,x,y,comp,req_comp);

  0006e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00079	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00083	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi_loadf_from_file
  00092	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1497 :    fclose(f);

  00097	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1498 :    return result;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_loadf:

; 1499 : }

  000a7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 64
__$ArrayPad$ = 304
f$ = 336
x$ = 344
y$ = 352
comp$ = 360
req_comp$ = 368
stbi_loadf_from_file PROC

; 1502 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1503 :    stbi__context s;
; 1504 :    stbi__start_file(&s,f);

  00053	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  0005b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00060	e8 00 00 00 00	 call	 stbi__start_file

; 1505 :    return stbi__loadf_main(&s,x,y,comp,req_comp);

  00065	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00080	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00088	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0008d	e8 00 00 00 00	 call	 stbi__loadf_main

; 1506 : }

  00092	48 8b f8	 mov	 rdi, rax
  00095	48 8b cc	 mov	 rcx, rsp
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_loadf_from_file$rtcFrameData
  0009f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a4	48 8b c7	 mov	 rax, rdi
  000a7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000af	48 33 cc	 xor	 rcx, rsp
  000b2	e8 00 00 00 00	 call	 __security_check_cookie
  000b7	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
buffer$ = 320
len$ = 328
stbi_is_hdr_from_memory PROC

; 1516 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00043	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1517 :    #ifndef STBI_NO_HDR
; 1518 :    stbi__context s;
; 1519 :    stbi__start_mem(&s,buffer,len);

  00048	44 8b 84 24 48
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00050	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0005d	e8 00 00 00 00	 call	 stbi__start_mem

; 1520 :    return stbi__hdr_test(&s);

  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__hdr_test

; 1521 :    #else
; 1522 :    STBI_NOTUSED(buffer);
; 1523 :    STBI_NOTUSED(len);
; 1524 :    return 0;
; 1525 :    #endif
; 1526 : }

  0006c	48 8b f8	 mov	 rdi, rax
  0006f	48 8b cc	 mov	 rcx, rsp
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_memory$rtcFrameData
  00079	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007e	48 8b c7	 mov	 rax, rdi
  00081	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00089	48 33 cc	 xor	 rcx, rsp
  0008c	e8 00 00 00 00	 call	 __security_check_cookie
  00091	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 32
result$ = 40
filename$ = 64
stbi_is_hdr PROC

; 1530 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1531 :    FILE *f = stbi__fopen(filename, "rb");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00022	e8 00 00 00 00	 call	 stbi__fopen
  00027	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax

; 1532 :    int result=0;

  0002c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 1533 :    if (f) {

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR f$[rsp], 0
  0003a	74 1a		 je	 SHORT $LN2@stbi_is_hd

; 1534 :       result = stbi_is_hdr_from_file(f);

  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00041	e8 00 00 00 00	 call	 stbi_is_hdr_from_file
  00046	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 1535 :       fclose(f);

  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00055	90		 npad	 1
$LN2@stbi_is_hd:

; 1536 :    }
; 1537 :    return result;

  00056	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]

; 1538 : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
pos$ = 32
res$ = 36
s$ = 64
__$ArrayPad$ = 304
f$ = 336
stbi_is_hdr_from_file PROC

; 1541 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0000d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1542 :    #ifndef STBI_NO_HDR
; 1543 :    long pos = ftell(f);

  00044	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00052	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 1544 :    int res;
; 1545 :    stbi__context s;
; 1546 :    stbi__start_file(&s,f);

  00056	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  0005e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 stbi__start_file

; 1547 :    res = stbi__hdr_test(&s);

  00068	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 stbi__hdr_test
  00072	89 44 24 24	 mov	 DWORD PTR res$[rsp], eax

; 1548 :    fseek(f, pos, SEEK_SET);

  00076	45 33 c0	 xor	 r8d, r8d
  00079	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  0007d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1549 :    return res;

  0008b	8b 44 24 24	 mov	 eax, DWORD PTR res$[rsp]

; 1550 :    #else
; 1551 :    STBI_NOTUSED(f);
; 1552 :    return 0;
; 1553 :    #endif
; 1554 : }

  0008f	8b f8		 mov	 edi, eax
  00091	48 8b cc	 mov	 rcx, rsp
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_file$rtcFrameData
  0009b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a0	8b c7		 mov	 eax, edi
  000a2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000aa	48 33 cc	 xor	 rcx, rsp
  000ad	e8 00 00 00 00	 call	 __security_check_cookie
  000b2	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
clbk$ = 320
user$ = 328
stbi_is_hdr_from_callbacks PROC

; 1558 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1559 :    #ifndef STBI_NO_HDR
; 1560 :    stbi__context s;
; 1561 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00049	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00051	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 stbi__start_callbacks

; 1562 :    return stbi__hdr_test(&s);

  00063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__hdr_test

; 1563 :    #else
; 1564 :    STBI_NOTUSED(clbk);
; 1565 :    STBI_NOTUSED(user);
; 1566 :    return 0;
; 1567 :    #endif
; 1568 : }

  0006d	48 8b f8	 mov	 rdi, rax
  00070	48 8b cc	 mov	 rcx, rsp
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_hdr_from_callbacks$rtcFrameData
  0007a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007f	48 8b c7	 mov	 rax, rdi
  00082	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008a	48 33 cc	 xor	 rcx, rsp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
gamma$ = 48
stbi_ldr_to_hdr_gamma PROC

; 1573 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	57		 push	 rdi
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR gamma$[rsp]
  0001d	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__l2h_gamma, xmm0
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
scale$ = 48
stbi_ldr_to_hdr_scale PROC

; 1574 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	57		 push	 rdi
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR scale$[rsp]
  0001d	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__l2h_scale, xmm0
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
gamma$ = 48
stbi_hdr_to_ldr_gamma PROC

; 1579 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	57		 push	 rdi
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001f	f3 0f 5e 44 24
	30		 divss	 xmm0, DWORD PTR gamma$[rsp]
  00025	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__h2l_gamma_i, xmm0
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
scale$ = 48
stbi_hdr_to_ldr_scale PROC

; 1580 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	57		 push	 rdi
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00012	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00017	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001f	f3 0f 5e 44 24
	30		 divss	 xmm0, DWORD PTR scale$[rsp]
  00025	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR stbi__h2l_scale_i, xmm0
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
n$ = 32
s$ = 64
stbi__refill_buffer PROC

; 1596 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1597 :    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00024	44 8b 41 34	 mov	 r8d, DWORD PTR [rcx+52]
  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00030	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00039	ff 50 10	 call	 QWORD PTR [rax+16]
  0003c	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1598 :    s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00051	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00058	48 2b c1	 sub	 rax, rcx
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00060	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1599 :    if (n == 0) {

  00071	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00076	75 47		 jne	 SHORT $LN2@stbi__refi

; 1600 :       // at end of file, treat same as if from memory, but need to handle case
; 1601 :       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1602 :       s->read_from_callbacks = 0;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0007d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1603 :       s->img_buffer = s->buffer_start;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00089	48 83 c0 38	 add	 rax, 56			; 00000038H
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00092	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1604 :       s->img_buffer_end = s->buffer_start+1;

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0009e	48 83 c0 39	 add	 rax, 57			; 00000039H
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a7	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1605 :       *s->img_buffer = 0;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ba	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1606 :    } else {

  000bd	eb 30		 jmp	 SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1607 :       s->img_buffer = s->buffer_start;

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000c4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000cd	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1608 :       s->img_buffer_end = s->buffer_start + n;

  000d4	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000de	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  000e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax
$LN3@stbi__refi:

; 1609 :    }
; 1610 : }

  000ef	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
stbi__refill_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv72 = 32
tv81 = 33
s$ = 64
stbi__get8 PROC

; 1613 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 35		 jae	 SHORT $LN2@stbi__get8

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 20	 mov	 BYTE PTR tv72[rsp], al
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv72[rsp]
  00063	eb 4c		 jmp	 SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1616 :    if (s->read_from_callbacks) {

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0006e	74 3f		 je	 SHORT $LN3@stbi__get8

; 1617 :       stbi__refill_buffer(s);

  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0007f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00086	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00089	88 44 24 21	 mov	 BYTE PTR tv81[rsp], al
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00099	48 ff c0	 inc	 rax
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000a8	0f b6 44 24 21	 movzx	 eax, BYTE PTR tv81[rsp]
  000ad	eb 02		 jmp	 SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1619 :    }
; 1620 :    return 0;

  000af	32 c0		 xor	 al, al
$LN1@stbi__get8:

; 1621 : }

  000b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
stbi__get8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv76 = 32
s$ = 64
stbi__at_eof PROC

; 1627 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1628 :    if (s->io.read) {

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00020	74 2b		 je	 SHORT $LN2@stbi__at_e

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00027	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00030	ff 50 20	 call	 QWORD PTR [rax+32]
  00033	85 c0		 test	 eax, eax
  00035	75 04		 jne	 SHORT $LN3@stbi__at_e
  00037	33 c0		 xor	 eax, eax
  00039	eb 42		 jmp	 SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00040	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00044	75 07		 jne	 SHORT $LN4@stbi__at_e
  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	eb 30		 jmp	 SHORT $LN1@stbi__at_e
$LN4@stbi__at_e:
$LN2@stbi__at_e:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0005e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00065	72 0a		 jb	 SHORT $LN6@stbi__at_e
  00067	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0006f	eb 08		 jmp	 SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
  00071	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN7@stbi__at_e:
  00079	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]
$LN1@stbi__at_e:

; 1636 : }

  0007d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
stbi__at_eof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
s$ = 64
n$ = 72
stbi__skip PROC

; 1643 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1644 :    if (n == 0) return;  // already there!

  0001a	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  0001f	75 05		 jne	 SHORT $LN2@stbi__skip
  00021	e9 b0 00 00 00	 jmp	 $LN1@stbi__skip
$LN2@stbi__skip:

; 1645 :    if (n < 0) {

  00026	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  0002b	7d 1d		 jge	 SHORT $LN3@stbi__skip

; 1646 :       s->img_buffer = s->img_buffer_end;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0003e	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1647 :       return;

  00045	e9 8c 00 00 00	 jmp	 $LN1@stbi__skip
$LN3@stbi__skip:

; 1648 :    }
; 1649 :    if (s->io.read) {

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00054	74 63		 je	 SHORT $LN4@stbi__skip

; 1650 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00060	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00067	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0006e	48 2b c1	 sub	 rax, rcx
  00071	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1651 :       if (blen < n) {

  00075	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00079	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  0007d	7d 3a		 jge	 SHORT $LN5@stbi__skip

; 1652 :          s->img_buffer = s->img_buffer_end;

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00089	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00090	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1653 :          (s->io.skip)(s->io_user_data, n - blen);

  00097	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  0009b	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0009f	2b c8		 sub	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	8b d0		 mov	 edx, eax
  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b3	ff 50 18	 call	 QWORD PTR [rax+24]
  000b6	90		 npad	 1

; 1654 :          return;

  000b7	eb 1d		 jmp	 SHORT $LN1@stbi__skip
$LN5@stbi__skip:
$LN4@stbi__skip:

; 1655 :       }
; 1656 :    }
; 1657 :    s->img_buffer += n;

  000b9	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c3	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN1@stbi__skip:

; 1658 : }

  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
stbi__skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
res$2 = 36
count$3 = 40
tv89 = 44
s$ = 80
buffer$ = 88
n$ = 96
stbi__getn PROC

; 1665 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1666 :    if (s->io.read) {

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00026	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002b	0f 84 c9 00 00
	00		 je	 $LN2@stbi__getn

; 1667 :       int blen = (int) (s->img_buffer_end - s->img_buffer);

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00042	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00049	48 2b c1	 sub	 rax, rcx
  0004c	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1668 :       if (blen < n) {

  00050	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  00054	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  00058	0f 8d 9c 00 00
	00		 jge	 $LN3@stbi__getn

; 1669 :          int res, count;
; 1670 : 
; 1671 :          memcpy(buffer, s->img_buffer, blen);

  0005e	48 63 44 24 20	 movsxd	 rax, DWORD PTR blen$1[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00068	48 8b 7c 24 58	 mov	 rdi, QWORD PTR buffer$[rsp]
  0006d	48 8b b1 c0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+192]
  00074	48 8b c8	 mov	 rcx, rax
  00077	f3 a4		 rep movsb

; 1672 : 
; 1673 :          count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

  00079	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  0007d	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  00081	2b c8		 sub	 ecx, eax
  00083	8b c1		 mov	 eax, ecx
  00085	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR blen$1[rsp]
  0008a	48 8b 54 24 58	 mov	 rdx, QWORD PTR buffer$[rsp]
  0008f	48 03 d1	 add	 rdx, rcx
  00092	48 8b ca	 mov	 rcx, rdx
  00095	44 8b c0	 mov	 r8d, eax
  00098	48 8b d1	 mov	 rdx, rcx
  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a9	ff 50 10	 call	 QWORD PTR [rax+16]
  000ac	89 44 24 28	 mov	 DWORD PTR count$3[rsp], eax

; 1674 :          res = (count == (n-blen));

  000b0	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	2b c8		 sub	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	39 44 24 28	 cmp	 DWORD PTR count$3[rsp], eax
  000c0	75 0a		 jne	 SHORT $LN7@stbi__getn
  000c2	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  000ca	eb 08		 jmp	 SHORT $LN8@stbi__getn
$LN7@stbi__getn:
  000cc	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN8@stbi__getn:
  000d4	8b 44 24 2c	 mov	 eax, DWORD PTR tv89[rsp]
  000d8	89 44 24 24	 mov	 DWORD PTR res$2[rsp], eax

; 1675 :          s->img_buffer = s->img_buffer_end;

  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000e6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000ed	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1676 :          return res;

  000f4	8b 44 24 24	 mov	 eax, DWORD PTR res$2[rsp]
  000f8	eb 62		 jmp	 SHORT $LN1@stbi__getn
$LN3@stbi__getn:
$LN2@stbi__getn:

; 1677 :       }
; 1678 :    }
; 1679 : 
; 1680 :    if (s->img_buffer+n <= s->img_buffer_end) {

  000fa	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00104	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00110	48 3b 81 c8 00
	00 00		 cmp	 rax, QWORD PTR [rcx+200]
  00117	77 41		 ja	 SHORT $LN4@stbi__getn

; 1681 :       memcpy(buffer, s->img_buffer, n);

  00119	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00123	48 8b 7c 24 58	 mov	 rdi, QWORD PTR buffer$[rsp]
  00128	48 8b b1 c0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+192]
  0012f	48 8b c8	 mov	 rcx, rax
  00132	f3 a4		 rep movsb

; 1682 :       s->img_buffer += n;

  00134	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0014a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1683 :       return 1;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	eb 04		 jmp	 SHORT $LN1@stbi__getn

; 1684 :    } else

  00158	eb 02		 jmp	 SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1685 :       return 0;

  0015a	33 c0		 xor	 eax, eax
$LN5@stbi__getn:
$LN1@stbi__getn:

; 1686 : }

  0015c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00160	5f		 pop	 rdi
  00161	5e		 pop	 rsi
  00162	c3		 ret	 0
stbi__getn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
z$ = 32
$T1 = 36
$T2 = 37
tv81 = 38
tv90 = 39
tv130 = 40
tv139 = 41
s$ = 64
stbi__get16be PROC

; 1693 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 39		 jae	 SHORT $LN4@stbi__get1

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 26	 mov	 BYTE PTR tv81[rsp], al
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv81[rsp]
  00063	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00067	eb 53		 jmp	 SHORT $LN3@stbi__get1
$LN4@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00072	74 43		 je	 SHORT $LN5@stbi__get1

; 1617 :       stbi__refill_buffer(s);

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	88 44 24 27	 mov	 BYTE PTR tv90[rsp], al
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00096	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009d	48 ff c0	 inc	 rax
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ac	0f b6 44 24 27	 movzx	 eax, BYTE PTR tv90[rsp]
  000b1	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000b5	eb 05		 jmp	 SHORT $LN3@stbi__get1
$LN5@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

  000b7	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN3@stbi__get1:

; 1694 :    int z = stbi__get8(s);

  000bc	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000c1	0f b6 c0	 movzx	 eax, al
  000c4	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000d9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000e0	73 39		 jae	 SHORT $LN8@stbi__get1

; 1615 :       return *s->img_buffer++;

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000e7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ee	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f1	88 44 24 28	 mov	 BYTE PTR tv130[rsp], al
  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00101	48 ff c0	 inc	 rax
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00109	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00110	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv130[rsp]
  00115	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  00119	eb 53		 jmp	 SHORT $LN7@stbi__get1
$LN8@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00120	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00124	74 43		 je	 SHORT $LN9@stbi__get1

; 1617 :       stbi__refill_buffer(s);

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00135	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0013c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013f	88 44 24 29	 mov	 BYTE PTR tv139[rsp], al
  00143	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00148	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0014f	48 ff c0	 inc	 rax
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00157	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0015e	0f b6 44 24 29	 movzx	 eax, BYTE PTR tv139[rsp]
  00163	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  00167	eb 05		 jmp	 SHORT $LN7@stbi__get1
$LN9@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

  00169	c6 44 24 25 00	 mov	 BYTE PTR $T2[rsp], 0
$LN7@stbi__get1:

; 1695 :    return (z << 8) + stbi__get8(s);

  0016e	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00172	c1 e0 08	 shl	 eax, 8
  00175	0f b6 4c 24 25	 movzx	 ecx, BYTE PTR $T2[rsp]
  0017a	0f b6 c9	 movzx	 ecx, cl
  0017d	03 c1		 add	 eax, ecx

; 1696 : }

  0017f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00183	5f		 pop	 rdi
  00184	c3		 ret	 0
stbi__get16be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv66 = 36
s$ = 64
stbi__get32be PROC

; 1703 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1704 :    stbi__uint32 z = stbi__get16be(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__get16be
  00020	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1705 :    return (z << 16) + stbi__get16be(s);

  00024	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00028	c1 e0 10	 shl	 eax, 16
  0002b	89 44 24 24	 mov	 DWORD PTR tv66[rsp], eax
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00034	e8 00 00 00 00	 call	 stbi__get16be
  00039	8b 4c 24 24	 mov	 ecx, DWORD PTR tv66[rsp]
  0003d	03 c8		 add	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx

; 1706 : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
stbi__get32be ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
z$ = 32
$T1 = 36
$T2 = 37
tv81 = 38
tv90 = 39
tv130 = 40
tv139 = 41
s$ = 64
stbi__get16le PROC

; 1713 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 39		 jae	 SHORT $LN4@stbi__get1

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 26	 mov	 BYTE PTR tv81[rsp], al
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv81[rsp]
  00063	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00067	eb 53		 jmp	 SHORT $LN3@stbi__get1
$LN4@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00072	74 43		 je	 SHORT $LN5@stbi__get1

; 1617 :       stbi__refill_buffer(s);

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	88 44 24 27	 mov	 BYTE PTR tv90[rsp], al
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00096	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009d	48 ff c0	 inc	 rax
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ac	0f b6 44 24 27	 movzx	 eax, BYTE PTR tv90[rsp]
  000b1	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000b5	eb 05		 jmp	 SHORT $LN3@stbi__get1
$LN5@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

  000b7	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN3@stbi__get1:

; 1714 :    int z = stbi__get8(s);

  000bc	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000c1	0f b6 c0	 movzx	 eax, al
  000c4	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000d9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000e0	73 39		 jae	 SHORT $LN8@stbi__get1

; 1615 :       return *s->img_buffer++;

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000e7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ee	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f1	88 44 24 28	 mov	 BYTE PTR tv130[rsp], al
  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00101	48 ff c0	 inc	 rax
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00109	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00110	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv130[rsp]
  00115	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  00119	eb 53		 jmp	 SHORT $LN7@stbi__get1
$LN8@stbi__get1:

; 1616 :    if (s->read_from_callbacks) {

  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00120	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00124	74 43		 je	 SHORT $LN9@stbi__get1

; 1617 :       stbi__refill_buffer(s);

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00135	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0013c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013f	88 44 24 29	 mov	 BYTE PTR tv139[rsp], al
  00143	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00148	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0014f	48 ff c0	 inc	 rax
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00157	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0015e	0f b6 44 24 29	 movzx	 eax, BYTE PTR tv139[rsp]
  00163	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  00167	eb 05		 jmp	 SHORT $LN7@stbi__get1
$LN9@stbi__get1:

; 1619 :    }
; 1620 :    return 0;

  00169	c6 44 24 25 00	 mov	 BYTE PTR $T2[rsp], 0
$LN7@stbi__get1:

; 1715 :    return z + (stbi__get8(s) << 8);

  0016e	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T2[rsp]
  00173	0f b6 c0	 movzx	 eax, al
  00176	c1 e0 08	 shl	 eax, 8
  00179	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  0017d	03 c8		 add	 ecx, eax
  0017f	8b c1		 mov	 eax, ecx

; 1716 : }

  00181	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00185	5f		 pop	 rdi
  00186	c3		 ret	 0
stbi__get16le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
stbi__get32le PROC

; 1721 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1722 :    stbi__uint32 z = stbi__get16le(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__get16le
  00020	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1723 :    z += (stbi__uint32)stbi__get16le(s) << 16;

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__get16le
  0002e	c1 e0 10	 shl	 eax, 16
  00031	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  00035	03 c8		 add	 ecx, eax
  00037	8b c1		 mov	 eax, ecx
  00039	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1724 :    return z;

  0003d	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]

; 1725 : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
stbi__get32le ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 48
g$ = 56
b$ = 64
stbi__compute_y PROC

; 1745 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1746 :    return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

  0001e	6b 44 24 30 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00023	69 4c 24 38 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0002b	03 c1		 add	 eax, ecx
  0002d	6b 4c 24 40 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00032	03 c1		 add	 eax, ecx
  00034	c1 f8 08	 sar	 eax, 8

; 1747 : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
stbi__compute_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
j$ = 36
good$ = 40
src$1 = 48
dest$2 = 56
tv81 = 64
tv94 = 72
tv258 = 76
tv278 = 80
tv300 = 84
tv320 = 88
tv353 = 96
data$ = 128
img_n$ = 136
req_comp$ = 144
x$ = 152
y$ = 160
stbi__convert_format PROC

; 1754 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1755 :    int i,j;
; 1756 :    unsigned char *good;
; 1757 : 
; 1758 :    if (req_comp == img_n) return data;

  00024	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR img_n$[rsp]
  0002b	39 84 24 90 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00032	75 0d		 jne	 SHORT $LN43@stbi__conv
  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0003c	e9 e5 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1759 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  00041	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00049	7c 0a		 jl	 SHORT $LN59@stbi__conv
  0004b	83 bc 24 90 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00053	7e 1c		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00055	41 b8 df 06 00
	00		 mov	 r8d, 1759		; 000006dfH
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1760 : 
; 1761 :    good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);

  00071	45 33 c9	 xor	 r9d, r9d
  00074	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR y$[rsp]
  0007c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  00083	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  0008a	e8 00 00 00 00	 call	 stbi__malloc_mad3
  0008f	48 89 44 24 28	 mov	 QWORD PTR good$[rsp], rax

; 1762 :    if (good == NULL) {

  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR good$[rsp], 0
  0009a	75 3c		 jne	 SHORT $LN44@stbi__conv

; 1763 :       STBI_FREE(data);

  0009c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1764 :       return stbi__errpuc("outofmem", "Out of memory");

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000b1	e8 00 00 00 00	 call	 stbi__err
  000b6	85 c0		 test	 eax, eax
  000b8	74 0b		 je	 SHORT $LN61@stbi__conv
  000ba	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
  000c3	eb 09		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000c5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
$LN62@stbi__conv:
  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000d3	e9 4e 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1765 :    }
; 1766 : 
; 1767 :    for (j=0; j < (int) y; ++j) {

  000d8	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000e0	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000e2	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000e6	ff c0		 inc	 eax
  000e8	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000ec	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000f3	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  000f7	0f 8d 16 09 00
	00		 jge	 $LN3@stbi__conv

; 1768 :       unsigned char *src  = data + j * x * img_n   ;

  000fd	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00101	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00109	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR img_n$[rsp]
  00111	8b c0		 mov	 eax, eax
  00113	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0011b	48 03 c8	 add	 rcx, rax
  0011e	48 8b c1	 mov	 rax, rcx
  00121	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax

; 1769 :       unsigned char *dest = good + j * x * req_comp;

  00126	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0012a	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00132	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0013a	8b c0		 mov	 eax, eax
  0013c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR good$[rsp]
  00141	48 03 c8	 add	 rcx, rax
  00144	48 8b c1	 mov	 rax, rcx
  00147	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax

; 1770 : 
; 1771 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1772 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1773 :       // convert source image with img_n components to one with req_comp components;
; 1774 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1775 :       switch (STBI__COMBO(img_n, req_comp)) {

  0014c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00153	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR img_n$[rsp]
  0015a	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0015d	89 44 24 48	 mov	 DWORD PTR tv94[rsp], eax
  00161	8b 44 24 48	 mov	 eax, DWORD PTR tv94[rsp]
  00165	83 e8 0a	 sub	 eax, 10
  00168	89 44 24 48	 mov	 DWORD PTR tv94[rsp], eax
  0016c	83 7c 24 48 19	 cmp	 DWORD PTR tv94[rsp], 25
  00171	0f 87 31 08 00
	00		 ja	 $LN57@stbi__conv
  00177	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv94[rsp]
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00183	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  0018a	48 03 c1	 add	 rax, rcx
  0018d	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1776 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;

  0018f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00196	ff c8		 dec	 eax
  00198	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0019c	eb 25		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0019e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a2	ff c8		 dec	 eax
  001a4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  001ad	48 ff c0	 inc	 rax
  001b0	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  001b5	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  001ba	48 83 c0 02	 add	 rax, 2
  001be	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN9@stbi__conv:
  001c3	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001c8	7c 38		 jl	 SHORT $LN8@stbi__conv
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	48 6b c0 00	 imul	 rax, rax, 0
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	48 6b c9 00	 imul	 rcx, rcx, 0
  001dc	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  001e1	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  001e6	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001eb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001ee	b8 01 00 00 00	 mov	 eax, 1
  001f3	48 6b c0 01	 imul	 rax, rax, 1
  001f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$2[rsp]
  001fc	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00200	eb 9c		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  00202	e9 07 08 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1777 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  00207	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0020e	ff c8		 dec	 eax
  00210	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00214	eb 25		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  00216	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0021a	ff c8		 dec	 eax
  0021c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00220	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00225	48 ff c0	 inc	 rax
  00228	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  0022d	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00232	48 83 c0 03	 add	 rax, 3
  00236	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN12@stbi__conv:
  0023b	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00240	7c 71		 jl	 SHORT $LN11@stbi__conv
  00242	b8 01 00 00 00	 mov	 eax, 1
  00247	48 6b c0 00	 imul	 rax, rax, 0
  0024b	b9 01 00 00 00	 mov	 ecx, 1
  00250	48 6b c9 02	 imul	 rcx, rcx, 2
  00254	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00259	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0025e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00263	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00266	b8 01 00 00 00	 mov	 eax, 1
  0026b	48 6b c0 02	 imul	 rax, rax, 2
  0026f	b9 01 00 00 00	 mov	 ecx, 1
  00274	48 6b c9 01	 imul	 rcx, rcx, 1
  00278	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0027d	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00282	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00287	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0028a	b8 01 00 00 00	 mov	 eax, 1
  0028f	48 6b c0 01	 imul	 rax, rax, 1
  00293	b9 01 00 00 00	 mov	 ecx, 1
  00298	48 6b c9 00	 imul	 rcx, rcx, 0
  0029c	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  002a1	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  002a6	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002ab	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002ae	e9 63 ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  002b3	e9 56 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1778 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;

  002b8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  002bf	ff c8		 dec	 eax
  002c1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002c5	eb 25		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002c7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002cb	ff c8		 dec	 eax
  002cd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002d1	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  002d6	48 ff c0	 inc	 rax
  002d9	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  002de	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  002e3	48 83 c0 04	 add	 rax, 4
  002e7	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN15@stbi__conv:
  002ec	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002f1	0f 8c 83 00 00
	00		 jl	 $LN14@stbi__conv
  002f7	b8 01 00 00 00	 mov	 eax, 1
  002fc	48 6b c0 00	 imul	 rax, rax, 0
  00300	b9 01 00 00 00	 mov	 ecx, 1
  00305	48 6b c9 02	 imul	 rcx, rcx, 2
  00309	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0030e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00313	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00318	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0031b	b8 01 00 00 00	 mov	 eax, 1
  00320	48 6b c0 02	 imul	 rax, rax, 2
  00324	b9 01 00 00 00	 mov	 ecx, 1
  00329	48 6b c9 01	 imul	 rcx, rcx, 1
  0032d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00332	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00337	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0033c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0033f	b8 01 00 00 00	 mov	 eax, 1
  00344	48 6b c0 01	 imul	 rax, rax, 1
  00348	b9 01 00 00 00	 mov	 ecx, 1
  0034d	48 6b c9 00	 imul	 rcx, rcx, 0
  00351	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00356	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  0035b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00360	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00363	b8 01 00 00 00	 mov	 eax, 1
  00368	48 6b c0 03	 imul	 rax, rax, 3
  0036c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$2[rsp]
  00371	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00375	e9 4d ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  0037a	e9 8f 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1779 :          STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;

  0037f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00386	ff c8		 dec	 eax
  00388	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0038c	eb 25		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0038e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00392	ff c8		 dec	 eax
  00394	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00398	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0039d	48 83 c0 02	 add	 rax, 2
  003a1	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  003ab	48 ff c0	 inc	 rax
  003ae	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN18@stbi__conv:
  003b3	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003b8	7c 26		 jl	 SHORT $LN17@stbi__conv
  003ba	b8 01 00 00 00	 mov	 eax, 1
  003bf	48 6b c0 00	 imul	 rax, rax, 0
  003c3	b9 01 00 00 00	 mov	 ecx, 1
  003c8	48 6b c9 00	 imul	 rcx, rcx, 0
  003cc	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  003d1	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  003d6	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  003db	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003de	eb ae		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003e0	e9 29 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1780 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  003e5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003ec	ff c8		 dec	 eax
  003ee	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003f2	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003f4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003f8	ff c8		 dec	 eax
  003fa	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003fe	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00403	48 83 c0 02	 add	 rax, 2
  00407	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  0040c	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00411	48 83 c0 03	 add	 rax, 3
  00415	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN21@stbi__conv:
  0041a	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0041f	7c 71		 jl	 SHORT $LN20@stbi__conv
  00421	b8 01 00 00 00	 mov	 eax, 1
  00426	48 6b c0 00	 imul	 rax, rax, 0
  0042a	b9 01 00 00 00	 mov	 ecx, 1
  0042f	48 6b c9 02	 imul	 rcx, rcx, 2
  00433	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00438	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0043d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00442	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00445	b8 01 00 00 00	 mov	 eax, 1
  0044a	48 6b c0 02	 imul	 rax, rax, 2
  0044e	b9 01 00 00 00	 mov	 ecx, 1
  00453	48 6b c9 01	 imul	 rcx, rcx, 1
  00457	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0045c	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00461	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00466	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00469	b8 01 00 00 00	 mov	 eax, 1
  0046e	48 6b c0 01	 imul	 rax, rax, 1
  00472	b9 01 00 00 00	 mov	 ecx, 1
  00477	48 6b c9 00	 imul	 rcx, rcx, 0
  0047b	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00480	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00485	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0048a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0048d	e9 62 ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  00492	e9 77 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1781 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;

  00497	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0049e	ff c8		 dec	 eax
  004a0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  004a4	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  004a6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  004aa	ff c8		 dec	 eax
  004ac	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  004b0	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  004b5	48 83 c0 02	 add	 rax, 2
  004b9	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  004be	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  004c3	48 83 c0 04	 add	 rax, 4
  004c7	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN24@stbi__conv:
  004cc	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  004d1	0f 8c 95 00 00
	00		 jl	 $LN23@stbi__conv
  004d7	b8 01 00 00 00	 mov	 eax, 1
  004dc	48 6b c0 00	 imul	 rax, rax, 0
  004e0	b9 01 00 00 00	 mov	 ecx, 1
  004e5	48 6b c9 02	 imul	 rcx, rcx, 2
  004e9	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  004ee	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  004f3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004fb	b8 01 00 00 00	 mov	 eax, 1
  00500	48 6b c0 02	 imul	 rax, rax, 2
  00504	b9 01 00 00 00	 mov	 ecx, 1
  00509	48 6b c9 01	 imul	 rcx, rcx, 1
  0050d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00512	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00517	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0051c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0051f	b8 01 00 00 00	 mov	 eax, 1
  00524	48 6b c0 01	 imul	 rax, rax, 1
  00528	b9 01 00 00 00	 mov	 ecx, 1
  0052d	48 6b c9 00	 imul	 rcx, rcx, 0
  00531	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00536	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  0053b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00540	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00543	b8 01 00 00 00	 mov	 eax, 1
  00548	48 6b c0 01	 imul	 rax, rax, 1
  0054c	b9 01 00 00 00	 mov	 ecx, 1
  00551	48 6b c9 03	 imul	 rcx, rcx, 3
  00555	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0055a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0055f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00564	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00567	e9 3a ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  0056c	e9 9d 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1782 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;

  00571	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00578	ff c8		 dec	 eax
  0057a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0057e	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  00580	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00584	ff c8		 dec	 eax
  00586	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0058a	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0058f	48 83 c0 03	 add	 rax, 3
  00593	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00598	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0059d	48 83 c0 04	 add	 rax, 4
  005a1	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN27@stbi__conv:
  005a6	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  005ab	0f 8c 83 00 00
	00		 jl	 $LN26@stbi__conv
  005b1	b8 01 00 00 00	 mov	 eax, 1
  005b6	48 6b c0 00	 imul	 rax, rax, 0
  005ba	b9 01 00 00 00	 mov	 ecx, 1
  005bf	48 6b c9 00	 imul	 rcx, rcx, 0
  005c3	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  005c8	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  005cd	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005d2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005d5	b8 01 00 00 00	 mov	 eax, 1
  005da	48 6b c0 01	 imul	 rax, rax, 1
  005de	b9 01 00 00 00	 mov	 ecx, 1
  005e3	48 6b c9 01	 imul	 rcx, rcx, 1
  005e7	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  005ec	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  005f1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005f9	b8 01 00 00 00	 mov	 eax, 1
  005fe	48 6b c0 02	 imul	 rax, rax, 2
  00602	b9 01 00 00 00	 mov	 ecx, 1
  00607	48 6b c9 02	 imul	 rcx, rcx, 2
  0060b	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00610	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00615	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0061a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0061d	b8 01 00 00 00	 mov	 eax, 1
  00622	48 6b c0 03	 imul	 rax, rax, 3
  00626	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$2[rsp]
  0062b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0062f	e9 4c ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00634	e9 d5 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1783 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  00639	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00640	ff c8		 dec	 eax
  00642	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00646	eb 25		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  00648	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0064c	ff c8		 dec	 eax
  0064e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00652	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00657	48 83 c0 03	 add	 rax, 3
  0065b	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00660	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00665	48 ff c0	 inc	 rax
  00668	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN30@stbi__conv:
  0066d	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00672	7c 61		 jl	 SHORT $LN29@stbi__conv
  00674	b8 01 00 00 00	 mov	 eax, 1
  00679	48 6b c0 02	 imul	 rax, rax, 2
  0067d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  00682	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00686	b9 01 00 00 00	 mov	 ecx, 1
  0068b	48 6b c9 01	 imul	 rcx, rcx, 1
  0068f	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  00694	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00698	ba 01 00 00 00	 mov	 edx, 1
  0069d	48 6b d2 00	 imul	 rdx, rdx, 0
  006a1	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  006a6	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  006ab	89 54 24 4c	 mov	 DWORD PTR tv258[rsp], edx
  006af	44 8b c0	 mov	 r8d, eax
  006b2	8b d1		 mov	 edx, ecx
  006b4	8b 44 24 4c	 mov	 eax, DWORD PTR tv258[rsp]
  006b8	8b c8		 mov	 ecx, eax
  006ba	e8 00 00 00 00	 call	 stbi__compute_y
  006bf	b9 01 00 00 00	 mov	 ecx, 1
  006c4	48 6b c9 00	 imul	 rcx, rcx, 0
  006c8	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  006cd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006d0	e9 73 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006d5	e9 34 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1784 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

  006da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  006e1	ff c8		 dec	 eax
  006e3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006e7	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  006e9	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006ed	ff c8		 dec	 eax
  006ef	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006f3	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  006f8	48 83 c0 03	 add	 rax, 3
  006fc	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00701	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00706	48 83 c0 02	 add	 rax, 2
  0070a	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN33@stbi__conv:
  0070f	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00714	7c 73		 jl	 SHORT $LN32@stbi__conv
  00716	b8 01 00 00 00	 mov	 eax, 1
  0071b	48 6b c0 02	 imul	 rax, rax, 2
  0071f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  00724	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00728	b9 01 00 00 00	 mov	 ecx, 1
  0072d	48 6b c9 01	 imul	 rcx, rcx, 1
  00731	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  00736	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0073a	ba 01 00 00 00	 mov	 edx, 1
  0073f	48 6b d2 00	 imul	 rdx, rdx, 0
  00743	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00748	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0074d	89 54 24 50	 mov	 DWORD PTR tv278[rsp], edx
  00751	44 8b c0	 mov	 r8d, eax
  00754	8b d1		 mov	 edx, ecx
  00756	8b 44 24 50	 mov	 eax, DWORD PTR tv278[rsp]
  0075a	8b c8		 mov	 ecx, eax
  0075c	e8 00 00 00 00	 call	 stbi__compute_y
  00761	b9 01 00 00 00	 mov	 ecx, 1
  00766	48 6b c9 00	 imul	 rcx, rcx, 0
  0076a	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0076f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00772	b8 01 00 00 00	 mov	 eax, 1
  00777	48 6b c0 01	 imul	 rax, rax, 1
  0077b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dest$2[rsp]
  00780	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00784	e9 60 ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  00789	e9 80 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1785 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  0078e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00795	ff c8		 dec	 eax
  00797	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0079b	eb 25		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  0079d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  007a1	ff c8		 dec	 eax
  007a3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007a7	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  007ac	48 83 c0 04	 add	 rax, 4
  007b0	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  007b5	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  007ba	48 ff c0	 inc	 rax
  007bd	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN36@stbi__conv:
  007c2	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  007c7	7c 61		 jl	 SHORT $LN35@stbi__conv
  007c9	b8 01 00 00 00	 mov	 eax, 1
  007ce	48 6b c0 02	 imul	 rax, rax, 2
  007d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  007d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007db	b9 01 00 00 00	 mov	 ecx, 1
  007e0	48 6b c9 01	 imul	 rcx, rcx, 1
  007e4	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  007e9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  007ed	ba 01 00 00 00	 mov	 edx, 1
  007f2	48 6b d2 00	 imul	 rdx, rdx, 0
  007f6	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  007fb	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00800	89 54 24 54	 mov	 DWORD PTR tv300[rsp], edx
  00804	44 8b c0	 mov	 r8d, eax
  00807	8b d1		 mov	 edx, ecx
  00809	8b 44 24 54	 mov	 eax, DWORD PTR tv300[rsp]
  0080d	8b c8		 mov	 ecx, eax
  0080f	e8 00 00 00 00	 call	 stbi__compute_y
  00814	b9 01 00 00 00	 mov	 ecx, 1
  00819	48 6b c9 00	 imul	 rcx, rcx, 0
  0081d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00822	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00825	e9 73 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  0082a	e9 df 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1786 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  0082f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00836	ff c8		 dec	 eax
  00838	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0083c	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0083e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00842	ff c8		 dec	 eax
  00844	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00848	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0084d	48 83 c0 04	 add	 rax, 4
  00851	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00856	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0085b	48 83 c0 02	 add	 rax, 2
  0085f	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN39@stbi__conv:
  00864	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00869	0f 8c 85 00 00
	00		 jl	 $LN38@stbi__conv
  0086f	b8 01 00 00 00	 mov	 eax, 1
  00874	48 6b c0 02	 imul	 rax, rax, 2
  00878	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  0087d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00881	b9 01 00 00 00	 mov	 ecx, 1
  00886	48 6b c9 01	 imul	 rcx, rcx, 1
  0088a	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  0088f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00893	ba 01 00 00 00	 mov	 edx, 1
  00898	48 6b d2 00	 imul	 rdx, rdx, 0
  0089c	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  008a1	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  008a6	89 54 24 58	 mov	 DWORD PTR tv320[rsp], edx
  008aa	44 8b c0	 mov	 r8d, eax
  008ad	8b d1		 mov	 edx, ecx
  008af	8b 44 24 58	 mov	 eax, DWORD PTR tv320[rsp]
  008b3	8b c8		 mov	 ecx, eax
  008b5	e8 00 00 00 00	 call	 stbi__compute_y
  008ba	b9 01 00 00 00	 mov	 ecx, 1
  008bf	48 6b c9 00	 imul	 rcx, rcx, 0
  008c3	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  008c8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008cb	b8 01 00 00 00	 mov	 eax, 1
  008d0	48 6b c0 03	 imul	 rax, rax, 3
  008d4	b9 01 00 00 00	 mov	 ecx, 1
  008d9	48 6b c9 01	 imul	 rcx, rcx, 1
  008dd	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  008e2	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  008e7	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  008ec	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008ef	e9 4a ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  008f4	e9 15 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1787 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;

  008f9	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00900	ff c8		 dec	 eax
  00902	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00906	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00908	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0090c	ff c8		 dec	 eax
  0090e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00912	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00917	48 83 c0 04	 add	 rax, 4
  0091b	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00920	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00925	48 83 c0 03	 add	 rax, 3
  00929	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN42@stbi__conv:
  0092e	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00933	7c 71		 jl	 SHORT $LN41@stbi__conv
  00935	b8 01 00 00 00	 mov	 eax, 1
  0093a	48 6b c0 00	 imul	 rax, rax, 0
  0093e	b9 01 00 00 00	 mov	 ecx, 1
  00943	48 6b c9 00	 imul	 rcx, rcx, 0
  00947	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0094c	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00951	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00956	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00959	b8 01 00 00 00	 mov	 eax, 1
  0095e	48 6b c0 01	 imul	 rax, rax, 1
  00962	b9 01 00 00 00	 mov	 ecx, 1
  00967	48 6b c9 01	 imul	 rcx, rcx, 1
  0096b	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00970	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00975	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0097a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0097d	b8 01 00 00 00	 mov	 eax, 1
  00982	48 6b c0 02	 imul	 rax, rax, 2
  00986	b9 01 00 00 00	 mov	 ecx, 1
  0098b	48 6b c9 02	 imul	 rcx, rcx, 2
  0098f	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00994	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00999	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0099e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  009a1	e9 62 ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009a6	eb 66		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1788 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

  009a8	33 c0		 xor	 eax, eax
  009aa	85 c0		 test	 eax, eax
  009ac	75 1c		 jne	 SHORT $LN63@stbi__conv
  009ae	41 b8 fc 06 00
	00		 mov	 r8d, 1788		; 000006fcH
  009b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  009bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  009c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009c8	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  009ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  009d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR good$[rsp]
  009dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
  009ea	e8 00 00 00 00	 call	 stbi__err
  009ef	85 c0		 test	 eax, eax
  009f1	74 0b		 je	 SHORT $LN64@stbi__conv
  009f3	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv353[rsp], 0
  009fc	eb 09		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  009fe	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv353[rsp], 0
$LN65@stbi__conv:
  00a07	48 8b 44 24 60	 mov	 rax, QWORD PTR tv353[rsp]
  00a0c	eb 18		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1789 :       }
; 1790 :       #undef STBI__CASE
; 1791 :    }

  00a0e	e9 cf f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1792 : 
; 1793 :    STBI_FREE(data);

  00a13	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00a1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1794 :    return good;

  00a21	48 8b 44 24 28	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1795 : }

  00a26	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00a2a	5f		 pop	 rdi
  00a2b	c3		 ret	 0
$LN66@stbi__conv:
  00a2c	00 00 00 00	 DD	 $LN45@stbi__conv
  00a30	00 00 00 00	 DD	 $LN46@stbi__conv
  00a34	00 00 00 00	 DD	 $LN47@stbi__conv
  00a38	00 00 00 00	 DD	 $LN57@stbi__conv
  00a3c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a40	00 00 00 00	 DD	 $LN57@stbi__conv
  00a44	00 00 00 00	 DD	 $LN57@stbi__conv
  00a48	00 00 00 00	 DD	 $LN48@stbi__conv
  00a4c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a50	00 00 00 00	 DD	 $LN49@stbi__conv
  00a54	00 00 00 00	 DD	 $LN50@stbi__conv
  00a58	00 00 00 00	 DD	 $LN57@stbi__conv
  00a5c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a60	00 00 00 00	 DD	 $LN57@stbi__conv
  00a64	00 00 00 00	 DD	 $LN57@stbi__conv
  00a68	00 00 00 00	 DD	 $LN52@stbi__conv
  00a6c	00 00 00 00	 DD	 $LN53@stbi__conv
  00a70	00 00 00 00	 DD	 $LN57@stbi__conv
  00a74	00 00 00 00	 DD	 $LN51@stbi__conv
  00a78	00 00 00 00	 DD	 $LN57@stbi__conv
  00a7c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a80	00 00 00 00	 DD	 $LN57@stbi__conv
  00a84	00 00 00 00	 DD	 $LN57@stbi__conv
  00a88	00 00 00 00	 DD	 $LN54@stbi__conv
  00a8c	00 00 00 00	 DD	 $LN55@stbi__conv
  00a90	00 00 00 00	 DD	 $LN56@stbi__conv
stbi__convert_format ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 48
g$ = 56
b$ = 64
stbi__compute_y_16 PROC

; 1802 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1803 :    return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

  0001e	6b 44 24 30 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00023	69 4c 24 38 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0002b	03 c1		 add	 eax, ecx
  0002d	6b 4c 24 40 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00032	03 c1		 add	 eax, ecx
  00034	c1 f8 08	 sar	 eax, 8

; 1804 : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
stbi__compute_y_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
j$ = 36
good$ = 40
src$1 = 48
dest$2 = 56
tv82 = 64
tv129 = 72
tv261 = 76
tv281 = 80
tv303 = 84
tv323 = 88
tv356 = 96
data$ = 128
img_n$ = 136
req_comp$ = 144
x$ = 152
y$ = 160
stbi__convert_format16 PROC

; 1811 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1812 :    int i,j;
; 1813 :    stbi__uint16 *good;
; 1814 : 
; 1815 :    if (req_comp == img_n) return data;

  00024	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR img_n$[rsp]
  0002b	39 84 24 90 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00032	75 0d		 jne	 SHORT $LN43@stbi__conv
  00034	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0003c	e9 19 0a 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1816 :    STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  00041	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00049	7c 0a		 jl	 SHORT $LN59@stbi__conv
  0004b	83 bc 24 90 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00053	7e 1c		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00055	41 b8 18 07 00
	00		 mov	 r8d, 1816		; 00000718H
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@MABJBNAJ@?$AAr?$AAe?$AAq?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1817 : 
; 1818 :    good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);

  00071	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00078	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00080	0f af 84 24 a0
	00 00 00	 imul	 eax, DWORD PTR y$[rsp]
  00088	d1 e0		 shl	 eax, 1
  0008a	8b c0		 mov	 eax, eax
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 stbi__malloc
  00093	48 89 44 24 28	 mov	 QWORD PTR good$[rsp], rax

; 1819 :    if (good == NULL) {

  00098	48 83 7c 24 28
	00		 cmp	 QWORD PTR good$[rsp], 0
  0009e	75 3c		 jne	 SHORT $LN44@stbi__conv

; 1820 :       STBI_FREE(data);

  000a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1821 :       return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000b5	e8 00 00 00 00	 call	 stbi__err
  000ba	85 c0		 test	 eax, eax
  000bc	74 0b		 je	 SHORT $LN61@stbi__conv
  000be	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
  000c7	eb 09		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000c9	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN62@stbi__conv:
  000d2	48 8b 44 24 40	 mov	 rax, QWORD PTR tv82[rsp]
  000d7	e9 7e 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1822 :    }
; 1823 : 
; 1824 :    for (j=0; j < (int) y; ++j) {

  000dc	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000e4	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000e6	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000f0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000f7	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  000fb	0f 8d 46 09 00
	00		 jge	 $LN3@stbi__conv

; 1825 :       stbi__uint16 *src  = data + j * x * img_n   ;

  00101	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00105	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  0010d	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR img_n$[rsp]
  00115	8b c0		 mov	 eax, eax
  00117	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0011f	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00123	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax

; 1826 :       stbi__uint16 *dest = good + j * x * req_comp;

  00128	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0012c	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00134	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0013c	8b c0		 mov	 eax, eax
  0013e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR good$[rsp]
  00143	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00147	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax

; 1827 : 
; 1828 :       #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1829 :       #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1830 :       // convert source image with img_n components to one with req_comp components;
; 1831 :       // avoid switch per pixel, so use switch per scanline and massive macros
; 1832 :       switch (STBI__COMBO(img_n, req_comp)) {

  0014c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00153	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR img_n$[rsp]
  0015a	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0015d	89 44 24 48	 mov	 DWORD PTR tv129[rsp], eax
  00161	8b 44 24 48	 mov	 eax, DWORD PTR tv129[rsp]
  00165	83 e8 0a	 sub	 eax, 10
  00168	89 44 24 48	 mov	 DWORD PTR tv129[rsp], eax
  0016c	83 7c 24 48 19	 cmp	 DWORD PTR tv129[rsp], 25
  00171	0f 87 65 08 00
	00		 ja	 $LN57@stbi__conv
  00177	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv129[rsp]
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00183	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  0018a	48 03 c1	 add	 rax, rcx
  0018d	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1833 :          STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;

  0018f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00196	ff c8		 dec	 eax
  00198	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0019c	eb 26		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0019e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a2	ff c8		 dec	 eax
  001a4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  001ad	48 83 c0 02	 add	 rax, 2
  001b1	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  001b6	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  001bb	48 83 c0 04	 add	 rax, 4
  001bf	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN9@stbi__conv:
  001c4	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001c9	7c 3e		 jl	 SHORT $LN8@stbi__conv
  001cb	b8 02 00 00 00	 mov	 eax, 2
  001d0	48 6b c0 00	 imul	 rax, rax, 0
  001d4	b9 02 00 00 00	 mov	 ecx, 2
  001d9	48 6b c9 00	 imul	 rcx, rcx, 0
  001dd	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  001e2	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  001e7	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  001ec	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  001f0	b8 02 00 00 00	 mov	 eax, 2
  001f5	48 6b c0 01	 imul	 rax, rax, 1
  001f9	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001fe	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00203	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00207	eb 95		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  00209	e9 34 08 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1834 :          STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  0020e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00215	ff c8		 dec	 eax
  00217	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0021b	eb 26		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  0021d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00221	ff c8		 dec	 eax
  00223	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00227	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0022c	48 83 c0 02	 add	 rax, 2
  00230	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00235	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0023a	48 83 c0 06	 add	 rax, 6
  0023e	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN12@stbi__conv:
  00243	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00248	7c 74		 jl	 SHORT $LN11@stbi__conv
  0024a	b8 02 00 00 00	 mov	 eax, 2
  0024f	48 6b c0 00	 imul	 rax, rax, 0
  00253	b9 02 00 00 00	 mov	 ecx, 2
  00258	48 6b c9 02	 imul	 rcx, rcx, 2
  0025c	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00261	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00266	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0026b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0026f	b8 02 00 00 00	 mov	 eax, 2
  00274	48 6b c0 02	 imul	 rax, rax, 2
  00278	b9 02 00 00 00	 mov	 ecx, 2
  0027d	48 6b c9 01	 imul	 rcx, rcx, 1
  00281	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00286	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  0028b	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00290	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00294	b8 02 00 00 00	 mov	 eax, 2
  00299	48 6b c0 01	 imul	 rax, rax, 1
  0029d	b9 02 00 00 00	 mov	 ecx, 2
  002a2	48 6b c9 00	 imul	 rcx, rcx, 0
  002a6	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  002ab	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  002b0	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  002b5	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  002b9	e9 5f ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  002be	e9 7f 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1835 :          STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;

  002c3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  002ca	ff c8		 dec	 eax
  002cc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002d0	eb 26		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002d2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002d6	ff c8		 dec	 eax
  002d8	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002dc	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  002e1	48 83 c0 02	 add	 rax, 2
  002e5	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  002ea	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  002ef	48 83 c0 08	 add	 rax, 8
  002f3	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN15@stbi__conv:
  002f8	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002fd	0f 8c 8b 00 00
	00		 jl	 $LN14@stbi__conv
  00303	b8 02 00 00 00	 mov	 eax, 2
  00308	48 6b c0 00	 imul	 rax, rax, 0
  0030c	b9 02 00 00 00	 mov	 ecx, 2
  00311	48 6b c9 02	 imul	 rcx, rcx, 2
  00315	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0031a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0031f	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00324	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00328	b8 02 00 00 00	 mov	 eax, 2
  0032d	48 6b c0 02	 imul	 rax, rax, 2
  00331	b9 02 00 00 00	 mov	 ecx, 2
  00336	48 6b c9 01	 imul	 rcx, rcx, 1
  0033a	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0033f	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00344	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00349	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0034d	b8 02 00 00 00	 mov	 eax, 2
  00352	48 6b c0 01	 imul	 rax, rax, 1
  00356	b9 02 00 00 00	 mov	 ecx, 2
  0035b	48 6b c9 00	 imul	 rcx, rcx, 0
  0035f	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00364	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00369	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0036e	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00372	b8 02 00 00 00	 mov	 eax, 2
  00377	48 6b c0 03	 imul	 rax, rax, 3
  0037b	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00380	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00385	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00389	e9 44 ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  0038e	e9 af 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1836 :          STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;

  00393	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0039a	ff c8		 dec	 eax
  0039c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003a0	eb 26		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  003a2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003a6	ff c8		 dec	 eax
  003a8	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003ac	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  003b1	48 83 c0 04	 add	 rax, 4
  003b5	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  003ba	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  003bf	48 83 c0 02	 add	 rax, 2
  003c3	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN18@stbi__conv:
  003c8	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003cd	7c 27		 jl	 SHORT $LN17@stbi__conv
  003cf	b8 02 00 00 00	 mov	 eax, 2
  003d4	48 6b c0 00	 imul	 rax, rax, 0
  003d8	b9 02 00 00 00	 mov	 ecx, 2
  003dd	48 6b c9 00	 imul	 rcx, rcx, 0
  003e1	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  003e6	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  003eb	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  003f0	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  003f4	eb ac		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003f6	e9 47 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1837 :          STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  003fb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00402	ff c8		 dec	 eax
  00404	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00408	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  0040a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0040e	ff c8		 dec	 eax
  00410	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00414	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00419	48 83 c0 04	 add	 rax, 4
  0041d	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00422	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00427	48 83 c0 06	 add	 rax, 6
  0042b	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN21@stbi__conv:
  00430	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00435	7c 74		 jl	 SHORT $LN20@stbi__conv
  00437	b8 02 00 00 00	 mov	 eax, 2
  0043c	48 6b c0 00	 imul	 rax, rax, 0
  00440	b9 02 00 00 00	 mov	 ecx, 2
  00445	48 6b c9 02	 imul	 rcx, rcx, 2
  00449	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0044e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00453	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00458	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0045c	b8 02 00 00 00	 mov	 eax, 2
  00461	48 6b c0 02	 imul	 rax, rax, 2
  00465	b9 02 00 00 00	 mov	 ecx, 2
  0046a	48 6b c9 01	 imul	 rcx, rcx, 1
  0046e	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00473	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00478	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0047d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00481	b8 02 00 00 00	 mov	 eax, 2
  00486	48 6b c0 01	 imul	 rax, rax, 1
  0048a	b9 02 00 00 00	 mov	 ecx, 2
  0048f	48 6b c9 00	 imul	 rcx, rcx, 0
  00493	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00498	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  0049d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  004a2	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  004a6	e9 5f ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  004ab	e9 92 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1838 :          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;

  004b0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  004b7	ff c8		 dec	 eax
  004b9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  004bd	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  004bf	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  004c3	ff c8		 dec	 eax
  004c5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  004c9	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  004ce	48 83 c0 04	 add	 rax, 4
  004d2	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  004d7	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  004dc	48 83 c0 08	 add	 rax, 8
  004e0	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN24@stbi__conv:
  004e5	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  004ea	0f 8c 99 00 00
	00		 jl	 $LN23@stbi__conv
  004f0	b8 02 00 00 00	 mov	 eax, 2
  004f5	48 6b c0 00	 imul	 rax, rax, 0
  004f9	b9 02 00 00 00	 mov	 ecx, 2
  004fe	48 6b c9 02	 imul	 rcx, rcx, 2
  00502	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00507	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0050c	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00511	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00515	b8 02 00 00 00	 mov	 eax, 2
  0051a	48 6b c0 02	 imul	 rax, rax, 2
  0051e	b9 02 00 00 00	 mov	 ecx, 2
  00523	48 6b c9 01	 imul	 rcx, rcx, 1
  00527	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0052c	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00531	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00536	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0053a	b8 02 00 00 00	 mov	 eax, 2
  0053f	48 6b c0 01	 imul	 rax, rax, 1
  00543	b9 02 00 00 00	 mov	 ecx, 2
  00548	48 6b c9 00	 imul	 rcx, rcx, 0
  0054c	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00551	4c 8b 44 24 38	 mov	 r8, QWORD PTR dest$2[rsp]
  00556	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0055b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0055f	b8 02 00 00 00	 mov	 eax, 2
  00564	48 6b c0 01	 imul	 rax, rax, 1
  00568	b9 02 00 00 00	 mov	 ecx, 2
  0056d	48 6b c9 03	 imul	 rcx, rcx, 3
  00571	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00576	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0057b	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00580	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00584	e9 36 ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00589	e9 b4 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1839 :          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;

  0058e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00595	ff c8		 dec	 eax
  00597	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0059b	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  0059d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  005a1	ff c8		 dec	 eax
  005a3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  005a7	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  005ac	48 83 c0 06	 add	 rax, 6
  005b0	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  005b5	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  005ba	48 83 c0 08	 add	 rax, 8
  005be	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN27@stbi__conv:
  005c3	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  005c8	0f 8c 8b 00 00
	00		 jl	 $LN26@stbi__conv
  005ce	b8 02 00 00 00	 mov	 eax, 2
  005d3	48 6b c0 00	 imul	 rax, rax, 0
  005d7	b9 02 00 00 00	 mov	 ecx, 2
  005dc	48 6b c9 00	 imul	 rcx, rcx, 0
  005e0	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  005e5	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  005ea	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  005ef	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  005f3	b8 02 00 00 00	 mov	 eax, 2
  005f8	48 6b c0 01	 imul	 rax, rax, 1
  005fc	b9 02 00 00 00	 mov	 ecx, 2
  00601	48 6b c9 01	 imul	 rcx, rcx, 1
  00605	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0060a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0060f	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00614	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00618	b8 02 00 00 00	 mov	 eax, 2
  0061d	48 6b c0 02	 imul	 rax, rax, 2
  00621	b9 02 00 00 00	 mov	 ecx, 2
  00626	48 6b c9 02	 imul	 rcx, rcx, 2
  0062a	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0062f	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00634	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00639	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0063d	b8 02 00 00 00	 mov	 eax, 2
  00642	48 6b c0 03	 imul	 rax, rax, 3
  00646	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0064b	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00650	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00654	e9 44 ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00659	e9 e4 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1840 :          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  0065e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00665	ff c8		 dec	 eax
  00667	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0066b	eb 26		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  0066d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00671	ff c8		 dec	 eax
  00673	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00677	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0067c	48 83 c0 06	 add	 rax, 6
  00680	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00685	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0068a	48 83 c0 02	 add	 rax, 2
  0068e	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN30@stbi__conv:
  00693	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00698	7c 62		 jl	 SHORT $LN29@stbi__conv
  0069a	b8 02 00 00 00	 mov	 eax, 2
  0069f	48 6b c0 02	 imul	 rax, rax, 2
  006a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  006a8	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  006ac	b9 02 00 00 00	 mov	 ecx, 2
  006b1	48 6b c9 01	 imul	 rcx, rcx, 1
  006b5	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  006ba	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  006be	ba 02 00 00 00	 mov	 edx, 2
  006c3	48 6b d2 00	 imul	 rdx, rdx, 0
  006c7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  006cc	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  006d1	89 54 24 4c	 mov	 DWORD PTR tv261[rsp], edx
  006d5	44 8b c0	 mov	 r8d, eax
  006d8	8b d1		 mov	 edx, ecx
  006da	8b 44 24 4c	 mov	 eax, DWORD PTR tv261[rsp]
  006de	8b c8		 mov	 ecx, eax
  006e0	e8 00 00 00 00	 call	 stbi__compute_y_16
  006e5	b9 02 00 00 00	 mov	 ecx, 2
  006ea	48 6b c9 00	 imul	 rcx, rcx, 0
  006ee	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  006f3	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  006f7	e9 71 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006fc	e9 41 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1841 :          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

  00701	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00708	ff c8		 dec	 eax
  0070a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0070e	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  00710	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00714	ff c8		 dec	 eax
  00716	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0071a	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0071f	48 83 c0 06	 add	 rax, 6
  00723	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00728	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0072d	48 83 c0 04	 add	 rax, 4
  00731	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN33@stbi__conv:
  00736	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0073b	7c 79		 jl	 SHORT $LN32@stbi__conv
  0073d	b8 02 00 00 00	 mov	 eax, 2
  00742	48 6b c0 02	 imul	 rax, rax, 2
  00746	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  0074b	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0074f	b9 02 00 00 00	 mov	 ecx, 2
  00754	48 6b c9 01	 imul	 rcx, rcx, 1
  00758	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  0075d	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00761	ba 02 00 00 00	 mov	 edx, 2
  00766	48 6b d2 00	 imul	 rdx, rdx, 0
  0076a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  0076f	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  00774	89 54 24 50	 mov	 DWORD PTR tv281[rsp], edx
  00778	44 8b c0	 mov	 r8d, eax
  0077b	8b d1		 mov	 edx, ecx
  0077d	8b 44 24 50	 mov	 eax, DWORD PTR tv281[rsp]
  00781	8b c8		 mov	 ecx, eax
  00783	e8 00 00 00 00	 call	 stbi__compute_y_16
  00788	b9 02 00 00 00	 mov	 ecx, 2
  0078d	48 6b c9 00	 imul	 rcx, rcx, 0
  00791	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00796	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0079a	b8 02 00 00 00	 mov	 eax, 2
  0079f	48 6b c0 01	 imul	 rax, rax, 1
  007a3	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  007a8	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  007ad	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  007b1	e9 5a ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  007b6	e9 87 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1842 :          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  007bb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  007c2	ff c8		 dec	 eax
  007c4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007c8	eb 26		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  007ca	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  007ce	ff c8		 dec	 eax
  007d0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007d4	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  007d9	48 83 c0 08	 add	 rax, 8
  007dd	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  007e2	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  007e7	48 83 c0 02	 add	 rax, 2
  007eb	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN36@stbi__conv:
  007f0	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  007f5	7c 62		 jl	 SHORT $LN35@stbi__conv
  007f7	b8 02 00 00 00	 mov	 eax, 2
  007fc	48 6b c0 02	 imul	 rax, rax, 2
  00800	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  00805	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00809	b9 02 00 00 00	 mov	 ecx, 2
  0080e	48 6b c9 01	 imul	 rcx, rcx, 1
  00812	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  00817	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0081b	ba 02 00 00 00	 mov	 edx, 2
  00820	48 6b d2 00	 imul	 rdx, rdx, 0
  00824	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00829	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  0082e	89 54 24 54	 mov	 DWORD PTR tv303[rsp], edx
  00832	44 8b c0	 mov	 r8d, eax
  00835	8b d1		 mov	 edx, ecx
  00837	8b 44 24 54	 mov	 eax, DWORD PTR tv303[rsp]
  0083b	8b c8		 mov	 ecx, eax
  0083d	e8 00 00 00 00	 call	 stbi__compute_y_16
  00842	b9 02 00 00 00	 mov	 ecx, 2
  00847	48 6b c9 00	 imul	 rcx, rcx, 0
  0084b	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00850	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00854	e9 71 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00859	e9 e4 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1843 :          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  0085e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00865	ff c8		 dec	 eax
  00867	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0086b	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0086d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00871	ff c8		 dec	 eax
  00873	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00877	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  0087c	48 83 c0 08	 add	 rax, 8
  00880	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00885	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  0088a	48 83 c0 04	 add	 rax, 4
  0088e	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN39@stbi__conv:
  00893	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00898	0f 8c 87 00 00
	00		 jl	 $LN38@stbi__conv
  0089e	b8 02 00 00 00	 mov	 eax, 2
  008a3	48 6b c0 02	 imul	 rax, rax, 2
  008a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$1[rsp]
  008ac	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008b0	b9 02 00 00 00	 mov	 ecx, 2
  008b5	48 6b c9 01	 imul	 rcx, rcx, 1
  008b9	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$1[rsp]
  008be	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  008c2	ba 02 00 00 00	 mov	 edx, 2
  008c7	48 6b d2 00	 imul	 rdx, rdx, 0
  008cb	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  008d0	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  008d5	89 54 24 58	 mov	 DWORD PTR tv323[rsp], edx
  008d9	44 8b c0	 mov	 r8d, eax
  008dc	8b d1		 mov	 edx, ecx
  008de	8b 44 24 58	 mov	 eax, DWORD PTR tv323[rsp]
  008e2	8b c8		 mov	 ecx, eax
  008e4	e8 00 00 00 00	 call	 stbi__compute_y_16
  008e9	b9 02 00 00 00	 mov	 ecx, 2
  008ee	48 6b c9 00	 imul	 rcx, rcx, 0
  008f2	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  008f7	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  008fb	b8 02 00 00 00	 mov	 eax, 2
  00900	48 6b c0 03	 imul	 rax, rax, 3
  00904	b9 02 00 00 00	 mov	 ecx, 2
  00909	48 6b c9 01	 imul	 rcx, rcx, 1
  0090d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  00912	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00917	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0091c	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00920	e9 48 ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  00925	e9 18 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1844 :          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;

  0092a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00931	ff c8		 dec	 eax
  00933	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00937	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00939	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0093d	ff c8		 dec	 eax
  0093f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00943	48 8b 44 24 30	 mov	 rax, QWORD PTR src$1[rsp]
  00948	48 83 c0 08	 add	 rax, 8
  0094c	48 89 44 24 30	 mov	 QWORD PTR src$1[rsp], rax
  00951	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$2[rsp]
  00956	48 83 c0 06	 add	 rax, 6
  0095a	48 89 44 24 38	 mov	 QWORD PTR dest$2[rsp], rax
$LN42@stbi__conv:
  0095f	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00964	7c 74		 jl	 SHORT $LN41@stbi__conv
  00966	b8 02 00 00 00	 mov	 eax, 2
  0096b	48 6b c0 00	 imul	 rax, rax, 0
  0096f	b9 02 00 00 00	 mov	 ecx, 2
  00974	48 6b c9 00	 imul	 rcx, rcx, 0
  00978	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  0097d	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  00982	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00987	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0098b	b8 02 00 00 00	 mov	 eax, 2
  00990	48 6b c0 01	 imul	 rax, rax, 1
  00994	b9 02 00 00 00	 mov	 ecx, 2
  00999	48 6b c9 01	 imul	 rcx, rcx, 1
  0099d	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  009a2	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  009a7	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009ac	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009b0	b8 02 00 00 00	 mov	 eax, 2
  009b5	48 6b c0 02	 imul	 rax, rax, 2
  009b9	b9 02 00 00 00	 mov	 ecx, 2
  009be	48 6b c9 02	 imul	 rcx, rcx, 2
  009c2	48 8b 54 24 38	 mov	 rdx, QWORD PTR dest$2[rsp]
  009c7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$1[rsp]
  009cc	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009d1	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009d5	e9 5f ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009da	eb 66		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1845 :          default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");

  009dc	33 c0		 xor	 eax, eax
  009de	85 c0		 test	 eax, eax
  009e0	75 1c		 jne	 SHORT $LN63@stbi__conv
  009e2	41 b8 35 07 00
	00		 mov	 r8d, 1845		; 00000735H
  009e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  009ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  009f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009fc	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  009fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00a06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00a0c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR good$[rsp]
  00a11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00a17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MHDBFHD@unsupported@
  00a1e	e8 00 00 00 00	 call	 stbi__err
  00a23	85 c0		 test	 eax, eax
  00a25	74 0b		 je	 SHORT $LN64@stbi__conv
  00a27	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv356[rsp], 0
  00a30	eb 09		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  00a32	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv356[rsp], 0
$LN65@stbi__conv:
  00a3b	48 8b 44 24 60	 mov	 rax, QWORD PTR tv356[rsp]
  00a40	eb 18		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1846 :       }
; 1847 :       #undef STBI__CASE
; 1848 :    }

  00a42	e9 9f f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1849 : 
; 1850 :    STBI_FREE(data);

  00a47	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00a4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1851 :    return good;

  00a55	48 8b 44 24 28	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1852 : }

  00a5a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00a5e	5f		 pop	 rdi
  00a5f	c3		 ret	 0
$LN66@stbi__conv:
  00a60	00 00 00 00	 DD	 $LN45@stbi__conv
  00a64	00 00 00 00	 DD	 $LN46@stbi__conv
  00a68	00 00 00 00	 DD	 $LN47@stbi__conv
  00a6c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a70	00 00 00 00	 DD	 $LN57@stbi__conv
  00a74	00 00 00 00	 DD	 $LN57@stbi__conv
  00a78	00 00 00 00	 DD	 $LN57@stbi__conv
  00a7c	00 00 00 00	 DD	 $LN48@stbi__conv
  00a80	00 00 00 00	 DD	 $LN57@stbi__conv
  00a84	00 00 00 00	 DD	 $LN49@stbi__conv
  00a88	00 00 00 00	 DD	 $LN50@stbi__conv
  00a8c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a90	00 00 00 00	 DD	 $LN57@stbi__conv
  00a94	00 00 00 00	 DD	 $LN57@stbi__conv
  00a98	00 00 00 00	 DD	 $LN57@stbi__conv
  00a9c	00 00 00 00	 DD	 $LN52@stbi__conv
  00aa0	00 00 00 00	 DD	 $LN53@stbi__conv
  00aa4	00 00 00 00	 DD	 $LN57@stbi__conv
  00aa8	00 00 00 00	 DD	 $LN51@stbi__conv
  00aac	00 00 00 00	 DD	 $LN57@stbi__conv
  00ab0	00 00 00 00	 DD	 $LN57@stbi__conv
  00ab4	00 00 00 00	 DD	 $LN57@stbi__conv
  00ab8	00 00 00 00	 DD	 $LN57@stbi__conv
  00abc	00 00 00 00	 DD	 $LN54@stbi__conv
  00ac0	00 00 00 00	 DD	 $LN55@stbi__conv
  00ac4	00 00 00 00	 DD	 $LN56@stbi__conv
stbi__convert_format16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 48
k$ = 52
n$ = 56
output$ = 64
tv76 = 72
data$ = 96
x$ = 104
y$ = 112
comp$ = 120
stbi__ldr_to_hdr PROC

; 1857 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1858 :    int i,k,n;
; 1859 :    float *output;
; 1860 :    if (!data) return NULL;

  00024	48 83 7c 24 60
	00		 cmp	 QWORD PTR data$[rsp], 0
  0002a	75 07		 jne	 SHORT $LN11@stbi__ldr_
  0002c	33 c0		 xor	 eax, eax
  0002e	e9 ab 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN11@stbi__ldr_:

; 1861 :    output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0003b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00041	44 8b 44 24 78	 mov	 r8d, DWORD PTR comp$[rsp]
  00046	8b 54 24 70	 mov	 edx, DWORD PTR y$[rsp]
  0004a	8b 4c 24 68	 mov	 ecx, DWORD PTR x$[rsp]
  0004e	e8 00 00 00 00	 call	 stbi__malloc_mad4
  00053	48 89 44 24 40	 mov	 QWORD PTR output$[rsp], rax

; 1862 :    if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

  00058	48 83 7c 24 40
	00		 cmp	 QWORD PTR output$[rsp], 0
  0005e	75 39		 jne	 SHORT $LN12@stbi__ldr_
  00060	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00072	e8 00 00 00 00	 call	 stbi__err
  00077	85 c0		 test	 eax, eax
  00079	74 0b		 je	 SHORT $LN17@stbi__ldr_
  0007b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
  00084	eb 09		 jmp	 SHORT $LN18@stbi__ldr_
$LN17@stbi__ldr_:
  00086	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
$LN18@stbi__ldr_:
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR tv76[rsp]
  00094	e9 45 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN12@stbi__ldr_:

; 1863 :    // compute number of non-alpha components
; 1864 :    if (comp & 1) n = comp; else n = comp-1;

  00099	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  0009d	83 e0 01	 and	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	74 0a		 je	 SHORT $LN13@stbi__ldr_
  000a4	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  000a8	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  000ac	eb 0a		 jmp	 SHORT $LN14@stbi__ldr_
$LN13@stbi__ldr_:
  000ae	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  000b2	ff c8		 dec	 eax
  000b4	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
$LN14@stbi__ldr_:

; 1865 :    for (i=0; i < x*y; ++i) {

  000b8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c0	eb 0a		 jmp	 SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
  000c2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__ldr_:
  000cc	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  000d0	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  000d5	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000d9	0f 8d 83 00 00
	00		 jge	 $LN3@stbi__ldr_

; 1866 :       for (k=0; k < n; ++k) {

  000df	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000e7	eb 0a		 jmp	 SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
  000e9	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  000ed	ff c0		 inc	 eax
  000ef	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__ldr_:
  000f3	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  000f7	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  000fb	7d 60		 jge	 SHORT $LN6@stbi__ldr_

; 1867 :          output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

  000fd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00101	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  00106	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  0010a	48 98		 cdqe
  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00111	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00115	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00119	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  00121	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00125	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR stbi__l2h_gamma
  0012d	e8 00 00 00 00	 call	 pow
  00132	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR stbi__l2h_scale
  0013a	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0013e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00142	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00146	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  0014b	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  0014f	48 98		 cdqe
  00151	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00156	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1868 :       }

  0015b	eb 8c		 jmp	 SHORT $LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1869 :    }

  0015d	e9 60 ff ff ff	 jmp	 $LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1870 :    if (n < comp) {

  00162	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00166	39 44 24 38	 cmp	 DWORD PTR n$[rsp], eax
  0016a	7d 62		 jge	 SHORT $LN15@stbi__ldr_

; 1871 :       for (i=0; i < x*y; ++i) {

  0016c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00174	eb 0a		 jmp	 SHORT $LN10@stbi__ldr_
$LN8@stbi__ldr_:
  00176	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__ldr_:
  00180	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  00184	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  00189	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0018d	7d 3f		 jge	 SHORT $LN9@stbi__ldr_

; 1872 :          output[i*comp + n] = data[i*comp + n]/255.0f;

  0018f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00193	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  00198	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  0019c	48 98		 cdqe
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  001a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001ab	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  001b3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001b7	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  001bc	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  001c0	48 98		 cdqe
  001c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001c7	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1873 :       }

  001cc	eb a8		 jmp	 SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:
$LN15@stbi__ldr_:

; 1874 :    }
; 1875 :    STBI_FREE(data);

  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1876 :    return output;

  001d9	48 8b 44 24 40	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__ldr_:

; 1877 : }

  001de	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001e2	5f		 pop	 rdi
  001e3	c3		 ret	 0
stbi__ldr_to_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
k$ = 36
n$ = 40
output$ = 48
z$1 = 56
z$2 = 60
tv75 = 64
data$ = 96
x$ = 104
y$ = 112
comp$ = 120
stbi__hdr_to_ldr PROC

; 1883 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1884 :    int i,k,n;
; 1885 :    stbi_uc *output;
; 1886 :    if (!data) return NULL;

  00024	48 83 7c 24 60
	00		 cmp	 QWORD PTR data$[rsp], 0
  0002a	75 07		 jne	 SHORT $LN8@stbi__hdr_
  0002c	33 c0		 xor	 eax, eax
  0002e	e9 fe 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1887 :    output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);

  00033	45 33 c9	 xor	 r9d, r9d
  00036	44 8b 44 24 78	 mov	 r8d, DWORD PTR comp$[rsp]
  0003b	8b 54 24 70	 mov	 edx, DWORD PTR y$[rsp]
  0003f	8b 4c 24 68	 mov	 ecx, DWORD PTR x$[rsp]
  00043	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00048	48 89 44 24 30	 mov	 QWORD PTR output$[rsp], rax

; 1888 :    if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

  0004d	48 83 7c 24 30
	00		 cmp	 QWORD PTR output$[rsp], 0
  00053	75 39		 jne	 SHORT $LN9@stbi__hdr_
  00055	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00067	e8 00 00 00 00	 call	 stbi__err
  0006c	85 c0		 test	 eax, eax
  0006e	74 0b		 je	 SHORT $LN18@stbi__hdr_
  00070	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
  00079	eb 09		 jmp	 SHORT $LN19@stbi__hdr_
$LN18@stbi__hdr_:
  0007b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
$LN19@stbi__hdr_:
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR tv75[rsp]
  00089	e9 a3 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN9@stbi__hdr_:

; 1889 :    // compute number of non-alpha components
; 1890 :    if (comp & 1) n = comp; else n = comp-1;

  0008e	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00092	83 e0 01	 and	 eax, 1
  00095	85 c0		 test	 eax, eax
  00097	74 0a		 je	 SHORT $LN10@stbi__hdr_
  00099	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  0009d	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  000a1	eb 0a		 jmp	 SHORT $LN11@stbi__hdr_
$LN10@stbi__hdr_:
  000a3	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  000a7	ff c8		 dec	 eax
  000a9	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__hdr_:

; 1891 :    for (i=0; i < x*y; ++i) {

  000ad	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b5	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  000b7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000bb	ff c0		 inc	 eax
  000bd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  000c1	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  000c5	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  000ca	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000ce	0f 8d 4d 01 00
	00		 jge	 $LN3@stbi__hdr_

; 1892 :       for (k=0; k < n; ++k) {

  000d4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000dc	eb 0a		 jmp	 SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
  000de	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  000e2	ff c0		 inc	 eax
  000e4	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__hdr_:
  000e8	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000ec	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  000f0	0f 8d 9f 00 00
	00		 jge	 $LN6@stbi__hdr_

; 1893 :          float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

  000f6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000fa	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  000ff	03 44 24 24	 add	 eax, DWORD PTR k$[rsp]
  00103	48 98		 cdqe
  00105	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  0010a	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  0010f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR stbi__h2l_scale_i
  00117	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0011b	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR stbi__h2l_gamma_i
  00123	e8 00 00 00 00	 call	 pow
  00128	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0012c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00134	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0013c	f3 0f 11 44 24
	38		 movss	 DWORD PTR z$1[rsp], xmm0

; 1894 :          if (z < 0) z = 0;

  00142	0f 57 c0	 xorps	 xmm0, xmm0
  00145	0f 2f 44 24 38	 comiss	 xmm0, DWORD PTR z$1[rsp]
  0014a	76 09		 jbe	 SHORT $LN12@stbi__hdr_
  0014c	0f 57 c0	 xorps	 xmm0, xmm0
  0014f	f3 0f 11 44 24
	38		 movss	 DWORD PTR z$1[rsp], xmm0
$LN12@stbi__hdr_:

; 1895 :          if (z > 255) z = 255;

  00155	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR z$1[rsp]
  0015b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00162	76 0e		 jbe	 SHORT $LN13@stbi__hdr_
  00164	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0016c	f3 0f 11 44 24
	38		 movss	 DWORD PTR z$1[rsp], xmm0
$LN13@stbi__hdr_:

; 1896 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  00172	f3 0f 2c 44 24
	38		 cvttss2si eax, DWORD PTR z$1[rsp]
  00178	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0017c	0f af 4c 24 78	 imul	 ecx, DWORD PTR comp$[rsp]
  00181	03 4c 24 24	 add	 ecx, DWORD PTR k$[rsp]
  00185	48 63 c9	 movsxd	 rcx, ecx
  00188	48 8b 54 24 30	 mov	 rdx, QWORD PTR output$[rsp]
  0018d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1897 :       }

  00190	e9 49 ff ff ff	 jmp	 $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1898 :       if (k < comp) {

  00195	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00199	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  0019d	7d 7d		 jge	 SHORT $LN14@stbi__hdr_

; 1899 :          float z = data[i*comp+k] * 255 + 0.5f;

  0019f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a3	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  001a8	03 44 24 24	 add	 eax, DWORD PTR k$[rsp]
  001ac	48 98		 cdqe
  001ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  001b3	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  001b8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001c0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001c8	f3 0f 11 44 24
	3c		 movss	 DWORD PTR z$2[rsp], xmm0

; 1900 :          if (z < 0) z = 0;

  001ce	0f 57 c0	 xorps	 xmm0, xmm0
  001d1	0f 2f 44 24 3c	 comiss	 xmm0, DWORD PTR z$2[rsp]
  001d6	76 09		 jbe	 SHORT $LN15@stbi__hdr_
  001d8	0f 57 c0	 xorps	 xmm0, xmm0
  001db	f3 0f 11 44 24
	3c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN15@stbi__hdr_:

; 1901 :          if (z > 255) z = 255;

  001e1	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR z$2[rsp]
  001e7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  001ee	76 0e		 jbe	 SHORT $LN16@stbi__hdr_
  001f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  001f8	f3 0f 11 44 24
	3c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN16@stbi__hdr_:

; 1902 :          output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  001fe	f3 0f 2c 44 24
	3c		 cvttss2si eax, DWORD PTR z$2[rsp]
  00204	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00208	0f af 4c 24 78	 imul	 ecx, DWORD PTR comp$[rsp]
  0020d	03 4c 24 24	 add	 ecx, DWORD PTR k$[rsp]
  00211	48 63 c9	 movsxd	 rcx, ecx
  00214	48 8b 54 24 30	 mov	 rdx, QWORD PTR output$[rsp]
  00219	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@stbi__hdr_:

; 1903 :       }
; 1904 :    }

  0021c	e9 96 fe ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1905 :    STBI_FREE(data);

  00221	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1906 :    return output;

  0022c	48 8b 44 24 30	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__hdr_:

; 1907 : }

  00231	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00235	5f		 pop	 rdi
  00236	c3		 ret	 0
stbi__hdr_to_ldr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
j$ = 36
k$ = 40
code$ = 44
s$1 = 48
c$2 = 52
m$3 = 56
tv242 = 60
h$ = 80
count$ = 88
stbi__build_huffman PROC

; 2002 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2003 :    int i,j,k=0;

  0001b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 2004 :    unsigned int code;
; 2005 :    // build size list for each symbol (from JPEG spec)
; 2006 :    for (i=0; i < 16; ++i) {

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00031	ff c0		 inc	 eax
  00033	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  00037	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  0003c	7d 67		 jge	 SHORT $LN3@stbi__buil

; 2007 :       for (j=0; j < count[i]; ++j) {

  0003e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@stbi__buil
$LN5@stbi__buil:
  00048	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__buil:
  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR count$[rsp]
  0005c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0005f	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00063	7d 3e		 jge	 SHORT $LN6@stbi__buil

; 2008 :          h->size[k++] = (stbi_uc) (i+1);

  00065	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00069	ff c0		 inc	 eax
  0006b	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR k$[rsp]
  00070	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  00075	88 84 0a 00 05
	00 00		 mov	 BYTE PTR [rdx+rcx+1280], al
  0007c	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00080	ff c0		 inc	 eax
  00082	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2009 :          if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");

  00086	81 7c 24 28 01
	01 00 00	 cmp	 DWORD PTR k$[rsp], 257	; 00000101H
  0008e	7c 11		 jl	 SHORT $LN19@stbi__buil
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DEFOLMLB@bad?5size?5list@
  00097	e8 00 00 00 00	 call	 stbi__err
  0009c	e9 08 02 00 00	 jmp	 $LN1@stbi__buil
$LN19@stbi__buil:

; 2010 :       }

  000a1	eb a5		 jmp	 SHORT $LN5@stbi__buil
$LN6@stbi__buil:

; 2011 :    }

  000a3	eb 88		 jmp	 SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 2012 :    h->size[k] = 0;

  000a5	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  000af	c6 84 01 00 05
	00 00 00	 mov	 BYTE PTR [rcx+rax+1280], 0

; 2013 : 
; 2014 :    // compute actual symbols (from jpeg spec)
; 2015 :    code = 0;

  000b7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 2016 :    k = 0;

  000bf	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 2017 :    for(j=1; j <= 16; ++j) {

  000c7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
  000cf	eb 0a		 jmp	 SHORT $LN10@stbi__buil
$LN8@stbi__buil:
  000d1	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000d5	ff c0		 inc	 eax
  000d7	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN10@stbi__buil:
  000db	83 7c 24 24 10	 cmp	 DWORD PTR j$[rsp], 16
  000e0	0f 8f d4 00 00
	00		 jg	 $LN9@stbi__buil

; 2018 :       // compute delta to add to code to compute symbol id
; 2019 :       h->delta[j] = k - code;

  000e6	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  000ea	8b 4c 24 28	 mov	 ecx, DWORD PTR k$[rsp]
  000ee	2b c8		 sub	 ecx, eax
  000f0	8b c1		 mov	 eax, ecx
  000f2	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000f7	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  000fc	89 84 8a 4c 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1612], eax

; 2020 :       if (h->size[k] == j) {

  00103	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00108	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0010d	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00115	3b 44 24 24	 cmp	 eax, DWORD PTR j$[rsp]
  00119	75 6d		 jne	 SHORT $LN20@stbi__buil
$LN11@stbi__buil:

; 2021 :          while (h->size[k] == j)

  0011b	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00125	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0012d	3b 44 24 24	 cmp	 eax, DWORD PTR j$[rsp]
  00131	75 2d		 jne	 SHORT $LN12@stbi__buil

; 2022 :             h->code[k++] = (stbi__uint16) (code++);

  00133	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00138	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0013d	0f b7 54 24 2c	 movzx	 edx, WORD PTR code$[rsp]
  00142	66 89 94 41 00
	02 00 00	 mov	 WORD PTR [rcx+rax*2+512], dx
  0014a	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  0014e	ff c0		 inc	 eax
  00150	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax
  00154	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00158	ff c0		 inc	 eax
  0015a	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax
  0015e	eb bb		 jmp	 SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 2023 :          if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");

  00160	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00164	ff c8		 dec	 eax
  00166	8b 4c 24 24	 mov	 ecx, DWORD PTR j$[rsp]
  0016a	ba 01 00 00 00	 mov	 edx, 1
  0016f	d3 e2		 shl	 edx, cl
  00171	8b ca		 mov	 ecx, edx
  00173	3b c1		 cmp	 eax, ecx
  00175	72 11		 jb	 SHORT $LN21@stbi__buil
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FOKGPEKG@bad?5code?5lengths@
  0017e	e8 00 00 00 00	 call	 stbi__err
  00183	e9 21 01 00 00	 jmp	 $LN1@stbi__buil
$LN21@stbi__buil:
$LN20@stbi__buil:

; 2024 :       }
; 2025 :       // compute largest code + 1 for this size, preshifted as needed later
; 2026 :       h->maxcode[j] = code << (16-j);

  00188	b8 10 00 00 00	 mov	 eax, 16
  0018d	2b 44 24 24	 sub	 eax, DWORD PTR j$[rsp]
  00191	0f b6 c8	 movzx	 ecx, al
  00194	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00198	d3 e0		 shl	 eax, cl
  0019a	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0019f	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  001a4	89 84 8a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1540], eax

; 2027 :       code <<= 1;

  001ab	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  001af	d1 e0		 shl	 eax, 1
  001b1	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax

; 2028 :    }

  001b5	e9 17 ff ff ff	 jmp	 $LN8@stbi__buil
$LN9@stbi__buil:

; 2029 :    h->maxcode[j] = 0xffffffff;

  001ba	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  001bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  001c4	c7 84 81 04 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+1540], -1 ; ffffffffH

; 2030 : 
; 2031 :    // build non-spec acceleration table; 255 is flag for not-accelerated
; 2032 :    memset(h->fast, 255, 1 << FAST_BITS);

  001cf	48 8b 44 24 50	 mov	 rax, QWORD PTR h$[rsp]
  001d4	48 8b 7c 24 50	 mov	 rdi, QWORD PTR h$[rsp]
  001d9	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001de	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e3	f3 aa		 rep stosb

; 2033 :    for (i=0; i < k; ++i) {

  001e5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001ed	eb 0a		 jmp	 SHORT $LN15@stbi__buil
$LN13@stbi__buil:
  001ef	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001f3	ff c0		 inc	 eax
  001f5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN15@stbi__buil:
  001f9	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  001fd	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00201	0f 8d 9d 00 00
	00		 jge	 $LN14@stbi__buil

; 2034 :       int s = h->size[i];

  00207	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00211	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00219	89 44 24 30	 mov	 DWORD PTR s$1[rsp], eax

; 2035 :       if (s <= FAST_BITS) {

  0021d	83 7c 24 30 09	 cmp	 DWORD PTR s$1[rsp], 9
  00222	7f 7b		 jg	 SHORT $LN22@stbi__buil

; 2036 :          int c = h->code[i] << (FAST_BITS-s);

  00224	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00229	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0022e	0f b7 84 41 00
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+512]
  00236	b9 09 00 00 00	 mov	 ecx, 9
  0023b	2b 4c 24 30	 sub	 ecx, DWORD PTR s$1[rsp]
  0023f	d3 e0		 shl	 eax, cl
  00241	89 44 24 34	 mov	 DWORD PTR c$2[rsp], eax

; 2037 :          int m = 1 << (FAST_BITS-s);

  00245	b8 09 00 00 00	 mov	 eax, 9
  0024a	2b 44 24 30	 sub	 eax, DWORD PTR s$1[rsp]
  0024e	b9 01 00 00 00	 mov	 ecx, 1
  00253	89 4c 24 3c	 mov	 DWORD PTR tv242[rsp], ecx
  00257	0f b6 c8	 movzx	 ecx, al
  0025a	8b 44 24 3c	 mov	 eax, DWORD PTR tv242[rsp]
  0025e	d3 e0		 shl	 eax, cl
  00260	89 44 24 38	 mov	 DWORD PTR m$3[rsp], eax

; 2038 :          for (j=0; j < m; ++j) {

  00264	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0026c	eb 0a		 jmp	 SHORT $LN18@stbi__buil
$LN16@stbi__buil:
  0026e	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00272	ff c0		 inc	 eax
  00274	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN18@stbi__buil:
  00278	8b 44 24 38	 mov	 eax, DWORD PTR m$3[rsp]
  0027c	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00280	7d 1d		 jge	 SHORT $LN17@stbi__buil

; 2039 :             h->fast[c+j] = (stbi_uc) i;

  00282	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00286	8b 4c 24 34	 mov	 ecx, DWORD PTR c$2[rsp]
  0028a	03 c8		 add	 ecx, eax
  0028c	8b c1		 mov	 eax, ecx
  0028e	48 98		 cdqe
  00290	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00295	0f b6 54 24 20	 movzx	 edx, BYTE PTR i$[rsp]
  0029a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2040 :          }

  0029d	eb cf		 jmp	 SHORT $LN16@stbi__buil
$LN17@stbi__buil:
$LN22@stbi__buil:

; 2041 :       }
; 2042 :    }

  0029f	e9 4b ff ff ff	 jmp	 $LN13@stbi__buil
$LN14@stbi__buil:

; 2043 :    return 1;

  002a4	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__buil:

; 2044 : }

  002a9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002ad	5f		 pop	 rdi
  002ae	c3		 ret	 0
stbi__build_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
fast$1 = 36
rs$2 = 40
run$3 = 44
magbits$4 = 48
len$5 = 52
k$6 = 56
m$7 = 60
tv174 = 64
tv178 = 68
fast_ac$ = 96
h$ = 104
stbi__build_fast_ac PROC

; 2049 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	90		 npad	 1

; 2050 :    int i;
; 2051 :    for (i=0; i < (1 << FAST_BITS); ++i) {

  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00024	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00026	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  00030	81 7c 24 20 00
	02 00 00	 cmp	 DWORD PTR i$[rsp], 512	; 00000200H
  00038	0f 8d 3e 01 00
	00		 jge	 $LN3@stbi__buil

; 2052 :       stbi_uc fast = h->fast[i];

  0003e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00048	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004c	88 44 24 24	 mov	 BYTE PTR fast$1[rsp], al

; 2053 :       fast_ac[i] = 0;

  00050	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00055	33 c9		 xor	 ecx, ecx
  00057	48 8b 54 24 60	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  0005c	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 2054 :       if (fast < 255) {

  00060	0f b6 44 24 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00065	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0006a	0f 8d 07 01 00
	00		 jge	 $LN5@stbi__buil

; 2055 :          int rs = h->values[fast];

  00070	0f b6 44 24 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00075	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  0007a	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00082	89 44 24 28	 mov	 DWORD PTR rs$2[rsp], eax

; 2056 :          int run = (rs >> 4) & 15;

  00086	8b 44 24 28	 mov	 eax, DWORD PTR rs$2[rsp]
  0008a	c1 f8 04	 sar	 eax, 4
  0008d	83 e0 0f	 and	 eax, 15
  00090	89 44 24 2c	 mov	 DWORD PTR run$3[rsp], eax

; 2057 :          int magbits = rs & 15;

  00094	8b 44 24 28	 mov	 eax, DWORD PTR rs$2[rsp]
  00098	83 e0 0f	 and	 eax, 15
  0009b	89 44 24 30	 mov	 DWORD PTR magbits$4[rsp], eax

; 2058 :          int len = h->size[fast];

  0009f	0f b6 44 24 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  000a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  000a9	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  000b1	89 44 24 34	 mov	 DWORD PTR len$5[rsp], eax

; 2059 : 
; 2060 :          if (magbits && len + magbits <= FAST_BITS) {

  000b5	83 7c 24 30 00	 cmp	 DWORD PTR magbits$4[rsp], 0
  000ba	0f 84 b7 00 00
	00		 je	 $LN6@stbi__buil
  000c0	8b 44 24 30	 mov	 eax, DWORD PTR magbits$4[rsp]
  000c4	8b 4c 24 34	 mov	 ecx, DWORD PTR len$5[rsp]
  000c8	03 c8		 add	 ecx, eax
  000ca	8b c1		 mov	 eax, ecx
  000cc	83 f8 09	 cmp	 eax, 9
  000cf	0f 8f a2 00 00
	00		 jg	 $LN6@stbi__buil

; 2061 :             // magnitude code followed by receive_extend code
; 2062 :             int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

  000d5	8b 44 24 34	 mov	 eax, DWORD PTR len$5[rsp]
  000d9	0f b6 c8	 movzx	 ecx, al
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e0	d3 e0		 shl	 eax, cl
  000e2	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000e7	b9 09 00 00 00	 mov	 ecx, 9
  000ec	2b 4c 24 30	 sub	 ecx, DWORD PTR magbits$4[rsp]
  000f0	d3 f8		 sar	 eax, cl
  000f2	89 44 24 38	 mov	 DWORD PTR k$6[rsp], eax

; 2063 :             int m = 1 << (magbits - 1);

  000f6	8b 44 24 30	 mov	 eax, DWORD PTR magbits$4[rsp]
  000fa	ff c8		 dec	 eax
  000fc	b9 01 00 00 00	 mov	 ecx, 1
  00101	89 4c 24 40	 mov	 DWORD PTR tv174[rsp], ecx
  00105	0f b6 c8	 movzx	 ecx, al
  00108	8b 44 24 40	 mov	 eax, DWORD PTR tv174[rsp]
  0010c	d3 e0		 shl	 eax, cl
  0010e	89 44 24 3c	 mov	 DWORD PTR m$7[rsp], eax

; 2064 :             if (k < m) k += (~0U << magbits) + 1;

  00112	8b 44 24 3c	 mov	 eax, DWORD PTR m$7[rsp]
  00116	39 44 24 38	 cmp	 DWORD PTR k$6[rsp], eax
  0011a	7d 22		 jge	 SHORT $LN7@stbi__buil
  0011c	8b 44 24 30	 mov	 eax, DWORD PTR magbits$4[rsp]
  00120	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00125	89 4c 24 44	 mov	 DWORD PTR tv178[rsp], ecx
  00129	0f b6 c8	 movzx	 ecx, al
  0012c	8b 44 24 44	 mov	 eax, DWORD PTR tv178[rsp]
  00130	d3 e0		 shl	 eax, cl
  00132	8b 4c 24 38	 mov	 ecx, DWORD PTR k$6[rsp]
  00136	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  0013a	89 44 24 38	 mov	 DWORD PTR k$6[rsp], eax
$LN7@stbi__buil:

; 2065 :             // if the result is small enough, we can fit it in fast_ac table
; 2066 :             if (k >= -128 && k <= 127)

  0013e	83 7c 24 38 80	 cmp	 DWORD PTR k$6[rsp], -128 ; ffffffffffffff80H
  00143	7c 32		 jl	 SHORT $LN8@stbi__buil
  00145	83 7c 24 38 7f	 cmp	 DWORD PTR k$6[rsp], 127	; 0000007fH
  0014a	7f 2b		 jg	 SHORT $LN8@stbi__buil

; 2067 :                fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));

  0014c	69 44 24 38 00
	01 00 00	 imul	 eax, DWORD PTR k$6[rsp], 256 ; 00000100H
  00154	6b 4c 24 2c 10	 imul	 ecx, DWORD PTR run$3[rsp], 16
  00159	03 c1		 add	 eax, ecx
  0015b	8b 4c 24 30	 mov	 ecx, DWORD PTR magbits$4[rsp]
  0015f	8b 54 24 34	 mov	 edx, DWORD PTR len$5[rsp]
  00163	03 d1		 add	 edx, ecx
  00165	8b ca		 mov	 ecx, edx
  00167	03 c1		 add	 eax, ecx
  00169	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0016e	48 8b 54 24 60	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  00173	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN8@stbi__buil:
$LN6@stbi__buil:
$LN5@stbi__buil:

; 2068 :          }
; 2069 :       }
; 2070 :    }

  00177	e9 aa fe ff ff	 jmp	 $LN2@stbi__buil
$LN3@stbi__buil:

; 2071 : }

  0017c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00180	5f		 pop	 rdi
  00181	c3		 ret	 0
stbi__build_fast_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
b$1 = 32
c$2 = 36
$T3 = 40
$T4 = 41
$T5 = 42
s$ = 48
s$ = 56
s$ = 64
tv70 = 72
tv136 = 76
tv145 = 77
tv153 = 78
tv162 = 79
tv170 = 80
tv179 = 81
j$ = 112
stbi__grow_buffer_unsafe PROC

; 2074 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00016	90		 npad	 1
$LN4@stbi__grow:

; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0001c	83 b8 2c 48 00
	00 00		 cmp	 DWORD PTR [rax+18476], 0
  00023	74 0d		 je	 SHORT $LN10@stbi__grow
  00025	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0002d	e9 bf 00 00 00	 jmp	 $LN11@stbi__grow
$LN10@stbi__grow:
  00032	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  00037	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003a	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00049	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00050	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00057	73 39		 jae	 SHORT $LN13@stbi__grow

; 1615 :       return *s->img_buffer++;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 44 24 4c	 mov	 BYTE PTR tv136[rsp], al
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00071	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00078	48 ff c0	 inc	 rax
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00080	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00087	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv136[rsp]
  0008c	88 44 24 28	 mov	 BYTE PTR $T3[rsp], al
  00090	eb 53		 jmp	 SHORT $LN12@stbi__grow
$LN13@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00097	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0009b	74 43		 je	 SHORT $LN14@stbi__grow

; 1617 :       stbi__refill_buffer(s);

  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000ac	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b6	88 44 24 4d	 mov	 BYTE PTR tv145[rsp], al
  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000bf	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000c6	48 ff c0	 inc	 rax
  000c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d5	0f b6 44 24 4d	 movzx	 eax, BYTE PTR tv145[rsp]
  000da	88 44 24 28	 mov	 BYTE PTR $T3[rsp], al
  000de	eb 05		 jmp	 SHORT $LN12@stbi__grow
$LN14@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

  000e0	c6 44 24 28 00	 mov	 BYTE PTR $T3[rsp], 0
$LN12@stbi__grow:

; 2075 :    do {
; 2076 :       unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

  000e5	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T3[rsp]
  000ea	0f b6 c0	 movzx	 eax, al
  000ed	89 44 24 48	 mov	 DWORD PTR tv70[rsp], eax
$LN11@stbi__grow:
  000f1	8b 44 24 48	 mov	 eax, DWORD PTR tv70[rsp]
  000f5	89 44 24 20	 mov	 DWORD PTR b$1[rsp], eax

; 2077 :       if (b == 0xff) {

  000f9	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR b$1[rsp], 255	; 000000ffH
  00101	0f 85 b9 01 00
	00		 jne	 $LN7@stbi__grow

; 2078 :          int c = stbi__get8(j->s);

  00107	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0010c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010f	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00114	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00125	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0012c	73 39		 jae	 SHORT $LN17@stbi__grow

; 1615 :       return *s->img_buffer++;

  0012e	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00133	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0013a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013d	88 44 24 4e	 mov	 BYTE PTR tv153[rsp], al
  00141	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00146	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0014d	48 ff c0	 inc	 rax
  00150	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00155	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0015c	0f b6 44 24 4e	 movzx	 eax, BYTE PTR tv153[rsp]
  00161	88 44 24 29	 mov	 BYTE PTR $T4[rsp], al
  00165	eb 53		 jmp	 SHORT $LN16@stbi__grow
$LN17@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

  00167	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0016c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00170	74 43		 je	 SHORT $LN18@stbi__grow

; 1617 :       stbi__refill_buffer(s);

  00172	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00177	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0017c	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00181	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00188	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018b	88 44 24 4f	 mov	 BYTE PTR tv162[rsp], al
  0018f	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00194	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0019b	48 ff c0	 inc	 rax
  0019e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  001a3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001aa	0f b6 44 24 4f	 movzx	 eax, BYTE PTR tv162[rsp]
  001af	88 44 24 29	 mov	 BYTE PTR $T4[rsp], al
  001b3	eb 05		 jmp	 SHORT $LN16@stbi__grow
$LN18@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

  001b5	c6 44 24 29 00	 mov	 BYTE PTR $T4[rsp], 0
$LN16@stbi__grow:

; 2078 :          int c = stbi__get8(j->s);

  001ba	0f b6 44 24 29	 movzx	 eax, BYTE PTR $T4[rsp]
  001bf	0f b6 c0	 movzx	 eax, al
  001c2	89 44 24 24	 mov	 DWORD PTR c$2[rsp], eax
$LN5@stbi__grow:

; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

  001c6	81 7c 24 24 ff
	00 00 00	 cmp	 DWORD PTR c$2[rsp], 255	; 000000ffH
  001ce	0f 85 c4 00 00
	00		 jne	 $LN6@stbi__grow
  001d4	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  001d9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001dc	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001e1	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  001e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  001eb	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001f2	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001f9	73 39		 jae	 SHORT $LN21@stbi__grow

; 1615 :       return *s->img_buffer++;

  001fb	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00200	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	88 44 24 50	 mov	 BYTE PTR tv170[rsp], al
  0020e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00213	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0021a	48 ff c0	 inc	 rax
  0021d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00222	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00229	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv170[rsp]
  0022e	88 44 24 2a	 mov	 BYTE PTR $T5[rsp], al
  00232	eb 53		 jmp	 SHORT $LN20@stbi__grow
$LN21@stbi__grow:

; 1616 :    if (s->read_from_callbacks) {

  00234	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00239	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0023d	74 43		 je	 SHORT $LN22@stbi__grow

; 1617 :       stbi__refill_buffer(s);

  0023f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00244	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00249	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0024e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00255	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00258	88 44 24 51	 mov	 BYTE PTR tv179[rsp], al
  0025c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00261	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00268	48 ff c0	 inc	 rax
  0026b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00270	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00277	0f b6 44 24 51	 movzx	 eax, BYTE PTR tv179[rsp]
  0027c	88 44 24 2a	 mov	 BYTE PTR $T5[rsp], al
  00280	eb 05		 jmp	 SHORT $LN20@stbi__grow
$LN22@stbi__grow:

; 1619 :    }
; 1620 :    return 0;

  00282	c6 44 24 2a 00	 mov	 BYTE PTR $T5[rsp], 0
$LN20@stbi__grow:

; 2079 :          while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

  00287	0f b6 44 24 2a	 movzx	 eax, BYTE PTR $T5[rsp]
  0028c	0f b6 c0	 movzx	 eax, al
  0028f	89 44 24 24	 mov	 DWORD PTR c$2[rsp], eax
  00293	e9 2e ff ff ff	 jmp	 $LN5@stbi__grow
$LN6@stbi__grow:

; 2080 :          if (c != 0) {

  00298	83 7c 24 24 00	 cmp	 DWORD PTR c$2[rsp], 0
  0029d	74 21		 je	 SHORT $LN8@stbi__grow

; 2081 :             j->marker = (unsigned char) c;

  0029f	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  002a4	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR c$2[rsp]
  002a9	88 88 28 48 00
	00		 mov	 BYTE PTR [rax+18472], cl

; 2082 :             j->nomore = 1;

  002af	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  002b4	c7 80 2c 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18476], 1

; 2083 :             return;

  002be	eb 60		 jmp	 SHORT $LN1@stbi__grow
$LN8@stbi__grow:
$LN7@stbi__grow:

; 2084 :          }
; 2085 :       }
; 2086 :       j->code_buffer |= b << (24 - j->code_bits);

  002c0	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  002c5	b9 18 00 00 00	 mov	 ecx, 24
  002ca	2b 88 24 48 00
	00		 sub	 ecx, DWORD PTR [rax+18468]
  002d0	8b c1		 mov	 eax, ecx
  002d2	0f b6 c8	 movzx	 ecx, al
  002d5	8b 44 24 20	 mov	 eax, DWORD PTR b$1[rsp]
  002d9	d3 e0		 shl	 eax, cl
  002db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  002e0	8b 89 20 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18464]
  002e6	0b c8		 or	 ecx, eax
  002e8	8b c1		 mov	 eax, ecx
  002ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  002ef	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2087 :       j->code_bits += 8;

  002f5	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  002fa	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00300	83 c0 08	 add	 eax, 8
  00303	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  00308	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2088 :    } while (j->code_bits <= 24);

  0030e	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  00313	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  0031a	0f 8e f7 fc ff
	ff		 jle	 $LN4@stbi__grow
$LN1@stbi__grow:

; 2089 : }

  00320	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00324	5f		 pop	 rdi
  00325	c3		 ret	 0
stbi__grow_buffer_unsafe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
temp$ = 32
c$ = 36
k$ = 40
s$1 = 44
tv212 = 48
tv233 = 56
tv242 = 64
tv253 = 72
j$ = 96
h$ = 104
stbi__jpeg_huff_decode PROC

; 2096 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2097 :    unsigned int temp;
; 2098 :    int c,k;
; 2099 : 
; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00020	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00027	7d 0b		 jge	 SHORT $LN5@stbi__jpeg
  00029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0002e	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00033	90		 npad	 1
$LN5@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00034	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00039	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0003f	c1 e8 17	 shr	 eax, 23
  00042	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00047	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2105 :    k = h->fast[c];

  0004b	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  00050	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00055	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00059	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2106 :    if (k < 255) {

  0005d	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR k$[rsp], 255	; 000000ffH
  00065	0f 8d 8d 00 00
	00		 jge	 $LN6@stbi__jpeg

; 2107 :       int s = h->size[k];

  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00070	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00075	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0007d	89 44 24 2c	 mov	 DWORD PTR s$1[rsp], eax

; 2108 :       if (s > j->code_bits)

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00086	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0008c	39 44 24 2c	 cmp	 DWORD PTR s$1[rsp], eax
  00090	7e 0a		 jle	 SHORT $LN7@stbi__jpeg

; 2109 :          return -1;

  00092	b8 ff ff ff ff	 mov	 eax, -1
  00097	e9 1e 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  0009c	8b 44 24 2c	 mov	 eax, DWORD PTR s$1[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000a5	48 89 4c 24 30	 mov	 QWORD PTR tv212[rsp], rcx
  000aa	0f b6 c8	 movzx	 ecx, al
  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR tv212[rsp]
  000b2	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000b8	d3 e0		 shl	 eax, cl
  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000bf	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  000c5	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000ca	8b 4c 24 2c	 mov	 ecx, DWORD PTR s$1[rsp]
  000ce	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000d4	2b c1		 sub	 eax, ecx
  000d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000db	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  000e1	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  000e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  000eb	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  000f3	e9 c2 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000fd	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00103	c1 e8 10	 shr	 eax, 16
  00106	89 44 24 20	 mov	 DWORD PTR temp$[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  0010a	c7 44 24 28 0a
	00 00 00	 mov	 DWORD PTR k$[rsp], 10
  00112	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00114	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00118	ff c0		 inc	 eax
  0011a	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  0011e	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00123	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00128	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  0012f	39 44 24 20	 cmp	 DWORD PTR temp$[rsp], eax
  00133	73 02		 jae	 SHORT $LN8@stbi__jpeg

; 2124 :          break;

  00135	eb 02		 jmp	 SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
  00137	eb db		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 2125 :    if (k == 17) {

  00139	83 7c 24 28 11	 cmp	 DWORD PTR k$[rsp], 17
  0013e	75 23		 jne	 SHORT $LN9@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  00140	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00145	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0014b	83 e8 10	 sub	 eax, 16
  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00153	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 57 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00168	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0016e	39 44 24 28	 cmp	 DWORD PTR k$[rsp], eax
  00172	7e 0a		 jle	 SHORT $LN10@stbi__jpeg

; 2132 :       return -1;

  00174	b8 ff ff ff ff	 mov	 eax, -1
  00179	e9 3c 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  0017e	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00183	2b 44 24 28	 sub	 eax, DWORD PTR k$[rsp]
  00187	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0018c	48 89 4c 24 38	 mov	 QWORD PTR tv233[rsp], rcx
  00191	0f b6 c8	 movzx	 ecx, al
  00194	48 8b 44 24 38	 mov	 rax, QWORD PTR tv233[rsp]
  00199	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0019f	d3 e8		 shr	 eax, cl
  001a1	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR k$[rsp]
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  001ad	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  001b0	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR k$[rsp]
  001b5	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  001ba	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  001c1	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  001c5	83 7c 24 24 00	 cmp	 DWORD PTR c$[rsp], 0
  001ca	7c 0a		 jl	 SHORT $LN12@stbi__jpeg
  001cc	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR c$[rsp], 256	; 00000100H
  001d4	7c 0a		 jl	 SHORT $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 2137 :        return -1;

  001d6	b8 ff ff ff ff	 mov	 eax, -1
  001db	e9 da 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN11@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  001e0	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  001e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  001ea	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  001f2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001f7	2b c8		 sub	 ecx, eax
  001f9	8b c1		 mov	 eax, ecx
  001fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00200	48 89 4c 24 40	 mov	 QWORD PTR tv242[rsp], rcx
  00205	0f b6 c8	 movzx	 ecx, al
  00208	48 8b 44 24 40	 mov	 rax, QWORD PTR tv242[rsp]
  0020d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00213	d3 e8		 shr	 eax, cl
  00215	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  0021a	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  0021f	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  00227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  0022e	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00231	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  00236	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  0023b	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00243	3b c1		 cmp	 eax, ecx
  00245	74 1c		 je	 SHORT $LN14@stbi__jpeg
  00247	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  0024d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00261	33 c0		 xor	 eax, eax
$LN14@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  00263	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00268	8b 4c 24 28	 mov	 ecx, DWORD PTR k$[rsp]
  0026c	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00272	2b c1		 sub	 eax, ecx
  00274	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00279	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  0027f	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00283	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00288	48 89 4c 24 48	 mov	 QWORD PTR tv253[rsp], rcx
  0028d	0f b6 c8	 movzx	 ecx, al
  00290	48 8b 44 24 48	 mov	 rax, QWORD PTR tv253[rsp]
  00295	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0029b	d3 e0		 shl	 eax, cl
  0029d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  002a2	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  002a8	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  002ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  002b2	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
$LN1@stbi__jpeg:

; 2144 : }

  002ba	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002be	5f		 pop	 rdi
  002bf	c3		 ret	 0
stbi__jpeg_huff_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
k$ = 32
sgn$ = 36
tv138 = 40
j$ = 64
n$ = 72
stbi__extend_receive PROC

; 2152 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2153 :    unsigned int k;
; 2154 :    int sgn;
; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0001f	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00023	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00029	7d 0b		 jge	 SHORT $LN2@stbi__exte
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00030	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00035	90		 npad	 1
$LN2@stbi__exte:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0003b	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0003f	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00045	7d 07		 jge	 SHORT $LN3@stbi__exte
  00047	33 c0		 xor	 eax, eax
  00049	e9 ae 00 00 00	 jmp	 $LN1@stbi__exte
$LN3@stbi__exte:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00053	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00059	c1 e8 1f	 shr	 eax, 31
  0005c	89 44 24 24	 mov	 DWORD PTR sgn$[rsp], eax

; 2159 :    k = stbi_lrot(j->code_buffer, n);

  00060	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00069	48 89 4c 24 28	 mov	 QWORD PTR tv138[rsp], rcx
  0006e	0f b6 c8	 movzx	 ecx, al
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR tv138[rsp]
  00076	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0007c	d3 c0		 rol	 eax, cl
  0007e	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

  00082	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  0008e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00091	f7 d0		 not	 eax
  00093	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00097	23 c8		 and	 ecx, eax
  00099	8b c1		 mov	 eax, ecx
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000a0	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2161 :    k &= stbi__bmask[n];

  000a6	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  000b2	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000b5	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000b9	23 c8		 and	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2162 :    j->code_bits -= n;

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000c6	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  000ca	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000d0	2b c1		 sub	 eax, ecx
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000d7	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

  000dd	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  000e9	8b 54 24 24	 mov	 edx, DWORD PTR sgn$[rsp]
  000ed	ff ca		 dec	 edx
  000ef	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000f2	23 c2		 and	 eax, edx
  000f4	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000f8	03 c8		 add	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
$LN1@stbi__exte:

; 2164 : }

  000fc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00100	5f		 pop	 rdi
  00101	c3		 ret	 0
stbi__extend_receive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
k$ = 32
tv95 = 40
j$ = 64
n$ = 72
stbi__jpeg_get_bits PROC

; 2168 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2169 :    unsigned int k;
; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0001f	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00023	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00029	7d 0b		 jge	 SHORT $LN2@stbi__jpeg
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00030	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00035	90		 npad	 1
$LN2@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0003b	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0003f	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00045	7d 07		 jge	 SHORT $LN3@stbi__jpeg
  00047	33 c0		 xor	 eax, eax
  00049	e9 81 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

  0004e	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00057	48 89 4c 24 28	 mov	 QWORD PTR tv95[rsp], rcx
  0005c	0f b6 c8	 movzx	 ecx, al
  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR tv95[rsp]
  00064	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0006a	d3 c0		 rol	 eax, cl
  0006c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];

  00070	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  0007c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0007f	f7 d0		 not	 eax
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00085	23 c8		 and	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0008e	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2174 :    k &= stbi__bmask[n];

  00094	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  000a0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000a3	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000a7	23 c8		 and	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2175 :    j->code_bits -= n;

  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000b4	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000be	2b c1		 sub	 eax, ecx
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c5	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2176 :    return k;

  000cb	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
$LN1@stbi__jpeg:

; 2177 : }

  000cf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
stbi__jpeg_get_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
stbi__jpeg_get_bit PROC

; 2180 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2181 :    unsigned int k;
; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0001b	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00022	7d 0b		 jge	 SHORT $LN2@stbi__jpeg
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  0002e	90		 npad	 1
$LN2@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00034	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  0003b	7d 04		 jge	 SHORT $LN3@stbi__jpeg
  0003d	33 c0		 xor	 eax, eax
  0003f	eb 48		 jmp	 SHORT $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 2184 :    k = j->code_buffer;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00046	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0004c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2185 :    j->code_buffer <<= 1;

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00055	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0005b	d1 e0		 shl	 eax, 1
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00062	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2186 :    --j->code_bits;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006d	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00073	ff c8		 dec	 eax
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0007a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2187 :    return k & 0x80000000;

  00080	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00084	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
$LN1@stbi__jpeg:

; 2188 : }

  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
stbi__jpeg_get_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
diff$ = 32
dc$ = 36
k$ = 40
t$ = 44
zig$1 = 48
c$2 = 52
r$3 = 56
s$4 = 60
rs$5 = 64
$T6 = 68
$T7 = 72
$T8 = 76
$T9 = 80
k$10 = 84
sgn$11 = 88
temp$12 = 92
c$13 = 96
k$14 = 100
s$15 = 104
k$16 = 108
sgn$17 = 112
temp$18 = 116
c$19 = 120
k$20 = 124
s$21 = 128
tv559 = 136
tv580 = 144
tv589 = 152
tv600 = 160
tv614 = 168
tv82 = 176
tv654 = 184
tv675 = 192
tv696 = 200
tv705 = 208
tv716 = 216
tv733 = 224
j$ = 256
data$ = 264
hdc$ = 272
hac$ = 280
fac$ = 288
b$ = 296
dequant$ = 304
stbi__jpeg_decode_block PROC

; 2209 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2210 :    int diff,dc,k;
; 2211 :    int t;
; 2212 : 
; 2213 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00028	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00030	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00037	7d 0e		 jge	 SHORT $LN5@stbi__jpeg
  00039	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00041	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00046	90		 npad	 1
$LN5@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00047	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0004f	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00056	7d 0e		 jge	 SHORT $LN25@stbi__jpeg
  00058	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00060	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00065	90		 npad	 1
$LN25@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00066	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0006e	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00074	c1 e8 17	 shr	 eax, 23
  00077	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0007c	89 44 24 78	 mov	 DWORD PTR c$19[rsp], eax

; 2105 :    k = h->fast[c];

  00080	48 63 44 24 78	 movsxd	 rax, DWORD PTR c$19[rsp]
  00085	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  0008d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00091	89 44 24 7c	 mov	 DWORD PTR k$20[rsp], eax

; 2106 :    if (k < 255) {

  00095	81 7c 24 7c ff
	00 00 00	 cmp	 DWORD PTR k$20[rsp], 255 ; 000000ffH
  0009d	0f 8d bb 00 00
	00		 jge	 $LN26@stbi__jpeg

; 2107 :       int s = h->size[k];

  000a3	48 63 44 24 7c	 movsxd	 rax, DWORD PTR k$20[rsp]
  000a8	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  000b0	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  000b8	89 84 24 80 00
	00 00		 mov	 DWORD PTR s$21[rsp], eax

; 2108 :       if (s > j->code_bits)

  000bf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000c7	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000cd	39 84 24 80 00
	00 00		 cmp	 DWORD PTR s$21[rsp], eax
  000d4	7e 0d		 jle	 SHORT $LN27@stbi__jpeg

; 2109 :          return -1;

  000d6	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR $T6[rsp], -1
  000de	e9 8c 02 00 00	 jmp	 $LN21@stbi__jpeg
$LN27@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  000e3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR s$21[rsp]
  000ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  000f2	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv559[rsp], rcx
  000fa	0f b6 c8	 movzx	 ecx, al
  000fd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv559[rsp]
  00105	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0010b	d3 e0		 shl	 eax, cl
  0010d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00115	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  0011b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00123	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR s$21[rsp]
  0012a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00130	2b c1		 sub	 eax, ecx
  00132	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0013a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  00140	48 63 44 24 7c	 movsxd	 rax, DWORD PTR k$20[rsp]
  00145	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  0014d	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00155	89 44 24 44	 mov	 DWORD PTR $T6[rsp], eax
  00159	e9 11 02 00 00	 jmp	 $LN21@stbi__jpeg
$LN26@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  0015e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00166	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0016c	c1 e8 10	 shr	 eax, 16
  0016f	89 44 24 74	 mov	 DWORD PTR temp$18[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  00173	c7 44 24 7c 0a
	00 00 00	 mov	 DWORD PTR k$20[rsp], 10
  0017b	eb 0a		 jmp	 SHORT $LN24@stbi__jpeg
$LN22@stbi__jpeg:
  0017d	8b 44 24 7c	 mov	 eax, DWORD PTR k$20[rsp]
  00181	ff c0		 inc	 eax
  00183	89 44 24 7c	 mov	 DWORD PTR k$20[rsp], eax
$LN24@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  00187	48 63 44 24 7c	 movsxd	 rax, DWORD PTR k$20[rsp]
  0018c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  00194	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  0019b	39 44 24 74	 cmp	 DWORD PTR temp$18[rsp], eax
  0019f	73 02		 jae	 SHORT $LN28@stbi__jpeg

; 2124 :          break;

  001a1	eb 02		 jmp	 SHORT $LN23@stbi__jpeg
$LN28@stbi__jpeg:
  001a3	eb d8		 jmp	 SHORT $LN22@stbi__jpeg
$LN23@stbi__jpeg:

; 2125 :    if (k == 17) {

  001a5	83 7c 24 7c 11	 cmp	 DWORD PTR k$20[rsp], 17
  001aa	75 2c		 jne	 SHORT $LN29@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  001ac	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001b4	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001ba	83 e8 10	 sub	 eax, 16
  001bd	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001c5	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  001cb	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR $T6[rsp], -1
  001d3	e9 97 01 00 00	 jmp	 $LN21@stbi__jpeg
$LN29@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  001d8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001e0	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001e6	39 44 24 7c	 cmp	 DWORD PTR k$20[rsp], eax
  001ea	7e 0d		 jle	 SHORT $LN30@stbi__jpeg

; 2132 :       return -1;

  001ec	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR $T6[rsp], -1
  001f4	e9 76 01 00 00	 jmp	 $LN21@stbi__jpeg
$LN30@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  001f9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  001fe	2b 44 24 7c	 sub	 eax, DWORD PTR k$20[rsp]
  00202	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0020a	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv580[rsp], rcx
  00212	0f b6 c8	 movzx	 ecx, al
  00215	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv580[rsp]
  0021d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00223	d3 e8		 shr	 eax, cl
  00225	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR k$20[rsp]
  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00231	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00234	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR k$20[rsp]
  00239	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  00241	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  00248	89 44 24 78	 mov	 DWORD PTR c$19[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  0024c	83 7c 24 78 00	 cmp	 DWORD PTR c$19[rsp], 0
  00251	7c 0a		 jl	 SHORT $LN32@stbi__jpeg
  00253	81 7c 24 78 00
	01 00 00	 cmp	 DWORD PTR c$19[rsp], 256 ; 00000100H
  0025b	7c 0d		 jl	 SHORT $LN31@stbi__jpeg
$LN32@stbi__jpeg:

; 2137 :        return -1;

  0025d	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR $T6[rsp], -1
  00265	e9 05 01 00 00	 jmp	 $LN21@stbi__jpeg
$LN31@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  0026a	48 63 44 24 78	 movsxd	 rax, DWORD PTR c$19[rsp]
  0026f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  00277	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0027f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00284	2b c8		 sub	 ecx, eax
  00286	8b c1		 mov	 eax, ecx
  00288	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00290	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv589[rsp], rcx
  00298	0f b6 c8	 movzx	 ecx, al
  0029b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv589[rsp]
  002a3	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  002a9	d3 e8		 shr	 eax, cl
  002ab	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR c$19[rsp]
  002b0	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  002b8	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  002c7	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  002ca	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR c$19[rsp]
  002cf	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  002d7	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  002df	3b c1		 cmp	 eax, ecx
  002e1	74 1c		 je	 SHORT $LN34@stbi__jpeg
  002e3	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  002e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  002f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002fd	33 c0		 xor	 eax, eax
$LN34@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  002ff	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00307	8b 4c 24 7c	 mov	 ecx, DWORD PTR k$20[rsp]
  0030b	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00311	2b c1		 sub	 eax, ecx
  00313	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0031b	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  00321	8b 44 24 7c	 mov	 eax, DWORD PTR k$20[rsp]
  00325	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0032d	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv600[rsp], rcx
  00335	0f b6 c8	 movzx	 ecx, al
  00338	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv600[rsp]
  00340	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00346	d3 e0		 shl	 eax, cl
  00348	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00350	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  00356	48 63 44 24 78	 movsxd	 rax, DWORD PTR c$19[rsp]
  0035b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  00363	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0036b	89 44 24 44	 mov	 DWORD PTR $T6[rsp], eax
$LN21@stbi__jpeg:

; 2214 :    t = stbi__jpeg_huff_decode(j, hdc);

  0036f	8b 44 24 44	 mov	 eax, DWORD PTR $T6[rsp]
  00373	89 44 24 2c	 mov	 DWORD PTR t$[rsp], eax

; 2215 :    if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

  00377	83 7c 24 2c 00	 cmp	 DWORD PTR t$[rsp], 0
  0037c	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  0037e	83 7c 24 2c 0f	 cmp	 DWORD PTR t$[rsp], 15
  00383	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  0038c	e8 00 00 00 00	 call	 stbi__err
  00391	e9 5d 08 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2216 : 
; 2217 :    // 0 all the ac values now so we can do it 32-bits at a time
; 2218 :    memset(data,0,64*sizeof(data[0]));

  00396	48 8b bc 24 08
	01 00 00	 mov	 rdi, QWORD PTR data$[rsp]
  0039e	33 c0		 xor	 eax, eax
  003a0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003a5	f3 aa		 rep stosb

; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;

  003a7	83 7c 24 2c 00	 cmp	 DWORD PTR t$[rsp], 0
  003ac	0f 84 17 01 00
	00		 je	 $LN19@stbi__jpeg

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  003b2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003ba	8b 4c 24 2c	 mov	 ecx, DWORD PTR t$[rsp]
  003be	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  003c4	7d 0e		 jge	 SHORT $LN36@stbi__jpeg
  003c6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  003ce	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  003d3	90		 npad	 1
$LN36@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  003d4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003dc	8b 4c 24 2c	 mov	 ecx, DWORD PTR t$[rsp]
  003e0	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  003e6	7d 0d		 jge	 SHORT $LN37@stbi__jpeg
  003e8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR $T7[rsp], 0
  003f0	e9 c7 00 00 00	 jmp	 $LN35@stbi__jpeg
$LN37@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  003f5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003fd	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00403	c1 e8 1f	 shr	 eax, 31
  00406	89 44 24 70	 mov	 DWORD PTR sgn$17[rsp], eax

; 2159 :    k = stbi_lrot(j->code_buffer, n);

  0040a	8b 44 24 2c	 mov	 eax, DWORD PTR t$[rsp]
  0040e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00416	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv614[rsp], rcx
  0041e	0f b6 c8	 movzx	 ecx, al
  00421	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv614[rsp]
  00429	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0042f	d3 c0		 rol	 eax, cl
  00431	89 44 24 6c	 mov	 DWORD PTR k$16[rsp], eax

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

  00435	48 63 44 24 2c	 movsxd	 rax, DWORD PTR t$[rsp]
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00441	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00444	f7 d0		 not	 eax
  00446	8b 4c 24 6c	 mov	 ecx, DWORD PTR k$16[rsp]
  0044a	23 c8		 and	 ecx, eax
  0044c	8b c1		 mov	 eax, ecx
  0044e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00456	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2161 :    k &= stbi__bmask[n];

  0045c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR t$[rsp]
  00461	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00468	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0046b	8b 4c 24 6c	 mov	 ecx, DWORD PTR k$16[rsp]
  0046f	23 c8		 and	 ecx, eax
  00471	8b c1		 mov	 eax, ecx
  00473	89 44 24 6c	 mov	 DWORD PTR k$16[rsp], eax

; 2162 :    j->code_bits -= n;

  00477	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0047f	8b 4c 24 2c	 mov	 ecx, DWORD PTR t$[rsp]
  00483	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00489	2b c1		 sub	 eax, ecx
  0048b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00493	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

  00499	48 63 44 24 2c	 movsxd	 rax, DWORD PTR t$[rsp]
  0049e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  004a5	8b 54 24 70	 mov	 edx, DWORD PTR sgn$17[rsp]
  004a9	ff ca		 dec	 edx
  004ab	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  004ae	23 c2		 and	 eax, edx
  004b0	8b 4c 24 6c	 mov	 ecx, DWORD PTR k$16[rsp]
  004b4	03 c8		 add	 ecx, eax
  004b6	8b c1		 mov	 eax, ecx
  004b8	89 44 24 48	 mov	 DWORD PTR $T7[rsp], eax
$LN35@stbi__jpeg:

; 2219 : 
; 2220 :    diff = t ? stbi__extend_receive(j, t) : 0;

  004bc	8b 44 24 48	 mov	 eax, DWORD PTR $T7[rsp]
  004c0	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  004c7	eb 0b		 jmp	 SHORT $LN20@stbi__jpeg
$LN19@stbi__jpeg:
  004c9	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv82[rsp], 0
$LN20@stbi__jpeg:
  004d4	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  004db	89 44 24 20	 mov	 DWORD PTR diff$[rsp], eax

; 2221 :    if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

  004df	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  004e7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004eb	8b 54 24 20	 mov	 edx, DWORD PTR diff$[rsp]
  004ef	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004f7	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  004fe	e8 00 00 00 00	 call	 stbi__addints_valid
  00503	85 c0		 test	 eax, eax
  00505	75 11		 jne	 SHORT $LN8@stbi__jpeg
  00507	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
  0050e	e8 00 00 00 00	 call	 stbi__err
  00513	e9 db 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 2222 :    dc = j->img_comp[b].dc_pred + diff;

  00518	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  00520	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00524	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0052c	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  00533	03 44 24 20	 add	 eax, DWORD PTR diff$[rsp]
  00537	89 44 24 24	 mov	 DWORD PTR dc$[rsp], eax

; 2223 :    j->img_comp[b].dc_pred = dc;

  0053b	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  00543	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00547	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0054f	8b 54 24 24	 mov	 edx, DWORD PTR dc$[rsp]
  00553	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2224 :    if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0055a	b8 02 00 00 00	 mov	 eax, 2
  0055f	48 6b c0 00	 imul	 rax, rax, 0
  00563	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dequant$[rsp]
  0056b	0f b7 14 01	 movzx	 edx, WORD PTR [rcx+rax]
  0056f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dc$[rsp]
  00574	e8 00 00 00 00	 call	 stbi__mul2shorts_valid
  00579	85 c0		 test	 eax, eax
  0057b	75 11		 jne	 SHORT $LN9@stbi__jpeg
  0057d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  00584	e8 00 00 00 00	 call	 stbi__err
  00589	e9 65 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2225 :    data[0] = (short) (dc * dequant[0]);

  0058e	b8 02 00 00 00	 mov	 eax, 2
  00593	48 6b c0 00	 imul	 rax, rax, 0
  00597	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dequant$[rsp]
  0059f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  005a3	8b 4c 24 24	 mov	 ecx, DWORD PTR dc$[rsp]
  005a7	0f af c8	 imul	 ecx, eax
  005aa	8b c1		 mov	 eax, ecx
  005ac	b9 02 00 00 00	 mov	 ecx, 2
  005b1	48 6b c9 00	 imul	 rcx, rcx, 0
  005b5	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  005bd	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2226 : 
; 2227 :    // decode AC components, see JPEG spec
; 2228 :    k = 1;

  005c1	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR k$[rsp], 1
$LN4@stbi__jpeg:

; 2229 :    do {
; 2230 :       unsigned int zig;
; 2231 :       int c,r,s;
; 2232 :       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  005c9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005d1	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  005d8	7d 0e		 jge	 SHORT $LN10@stbi__jpeg
  005da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  005e2	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  005e7	90		 npad	 1
$LN10@stbi__jpeg:

; 2233 :       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  005e8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005f0	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  005f6	c1 e8 17	 shr	 eax, 23
  005f9	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  005fe	89 44 24 34	 mov	 DWORD PTR c$2[rsp], eax

; 2234 :       r = fac[c];

  00602	48 63 44 24 34	 movsxd	 rax, DWORD PTR c$2[rsp]
  00607	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  0060f	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  00613	89 44 24 38	 mov	 DWORD PTR r$3[rsp], eax

; 2235 :       if (r) { // fast-AC path

  00617	83 7c 24 38 00	 cmp	 DWORD PTR r$3[rsp], 0
  0061c	0f 84 ea 00 00
	00		 je	 $LN11@stbi__jpeg

; 2236 :          k += (r >> 4) & 15; // run

  00622	8b 44 24 38	 mov	 eax, DWORD PTR r$3[rsp]
  00626	c1 f8 04	 sar	 eax, 4
  00629	83 e0 0f	 and	 eax, 15
  0062c	8b 4c 24 28	 mov	 ecx, DWORD PTR k$[rsp]
  00630	03 c8		 add	 ecx, eax
  00632	8b c1		 mov	 eax, ecx
  00634	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2237 :          s = r & 15; // combined length

  00638	8b 44 24 38	 mov	 eax, DWORD PTR r$3[rsp]
  0063c	83 e0 0f	 and	 eax, 15
  0063f	89 44 24 3c	 mov	 DWORD PTR s$4[rsp], eax

; 2238 :          if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  00643	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0064b	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00651	39 44 24 3c	 cmp	 DWORD PTR s$4[rsp], eax
  00655	7e 11		 jle	 SHORT $LN13@stbi__jpeg
  00657	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  0065e	e8 00 00 00 00	 call	 stbi__err
  00663	e9 8b 05 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2239 :          j->code_buffer <<= s;

  00668	8b 44 24 3c	 mov	 eax, DWORD PTR s$4[rsp]
  0066c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00674	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv654[rsp], rcx
  0067c	0f b6 c8	 movzx	 ecx, al
  0067f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv654[rsp]
  00687	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0068d	d3 e0		 shl	 eax, cl
  0068f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00697	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2240 :          j->code_bits -= s;

  0069d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  006a5	8b 4c 24 3c	 mov	 ecx, DWORD PTR s$4[rsp]
  006a9	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  006af	2b c1		 sub	 eax, ecx
  006b1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  006b9	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2241 :          // decode into unzigzag'd location
; 2242 :          zig = stbi__jpeg_dezigzag[k++];

  006bf	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  006c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  006cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006cf	89 44 24 30	 mov	 DWORD PTR zig$1[rsp], eax
  006d3	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  006d7	ff c0		 inc	 eax
  006d9	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2243 :          data[zig] = (short) ((r >> 8) * dequant[zig]);

  006dd	8b 44 24 38	 mov	 eax, DWORD PTR r$3[rsp]
  006e1	c1 f8 08	 sar	 eax, 8
  006e4	8b 4c 24 30	 mov	 ecx, DWORD PTR zig$1[rsp]
  006e8	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  006f0	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  006f4	0f af c1	 imul	 eax, ecx
  006f7	8b 4c 24 30	 mov	 ecx, DWORD PTR zig$1[rsp]
  006fb	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00703	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2244 :       } else {

  00707	e9 d7 04 00 00	 jmp	 $LN12@stbi__jpeg
$LN11@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0070c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00714	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0071b	7d 0e		 jge	 SHORT $LN43@stbi__jpeg
  0071d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00725	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  0072a	90		 npad	 1
$LN43@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  0072b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00733	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00739	c1 e8 17	 shr	 eax, 23
  0073c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00741	89 44 24 60	 mov	 DWORD PTR c$13[rsp], eax

; 2105 :    k = h->fast[c];

  00745	48 63 44 24 60	 movsxd	 rax, DWORD PTR c$13[rsp]
  0074a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00752	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00756	89 44 24 64	 mov	 DWORD PTR k$14[rsp], eax

; 2106 :    if (k < 255) {

  0075a	81 7c 24 64 ff
	00 00 00	 cmp	 DWORD PTR k$14[rsp], 255 ; 000000ffH
  00762	0f 8d af 00 00
	00		 jge	 $LN44@stbi__jpeg

; 2107 :       int s = h->size[k];

  00768	48 63 44 24 64	 movsxd	 rax, DWORD PTR k$14[rsp]
  0076d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00775	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0077d	89 44 24 68	 mov	 DWORD PTR s$15[rsp], eax

; 2108 :       if (s > j->code_bits)

  00781	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00789	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0078f	39 44 24 68	 cmp	 DWORD PTR s$15[rsp], eax
  00793	7e 0d		 jle	 SHORT $LN45@stbi__jpeg

; 2109 :          return -1;

  00795	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR $T8[rsp], -1
  0079d	e9 86 02 00 00	 jmp	 $LN39@stbi__jpeg
$LN45@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  007a2	8b 44 24 68	 mov	 eax, DWORD PTR s$15[rsp]
  007a6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  007ae	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv675[rsp], rcx
  007b6	0f b6 c8	 movzx	 ecx, al
  007b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv675[rsp]
  007c1	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  007c7	d3 e0		 shl	 eax, cl
  007c9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  007d1	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  007d7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  007df	8b 4c 24 68	 mov	 ecx, DWORD PTR s$15[rsp]
  007e3	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  007e9	2b c1		 sub	 eax, ecx
  007eb	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  007f3	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  007f9	48 63 44 24 64	 movsxd	 rax, DWORD PTR k$14[rsp]
  007fe	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00806	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0080e	89 44 24 4c	 mov	 DWORD PTR $T8[rsp], eax
  00812	e9 11 02 00 00	 jmp	 $LN39@stbi__jpeg
$LN44@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  00817	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0081f	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00825	c1 e8 10	 shr	 eax, 16
  00828	89 44 24 5c	 mov	 DWORD PTR temp$12[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  0082c	c7 44 24 64 0a
	00 00 00	 mov	 DWORD PTR k$14[rsp], 10
  00834	eb 0a		 jmp	 SHORT $LN42@stbi__jpeg
$LN40@stbi__jpeg:
  00836	8b 44 24 64	 mov	 eax, DWORD PTR k$14[rsp]
  0083a	ff c0		 inc	 eax
  0083c	89 44 24 64	 mov	 DWORD PTR k$14[rsp], eax
$LN42@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  00840	48 63 44 24 64	 movsxd	 rax, DWORD PTR k$14[rsp]
  00845	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  0084d	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00854	39 44 24 5c	 cmp	 DWORD PTR temp$12[rsp], eax
  00858	73 02		 jae	 SHORT $LN46@stbi__jpeg

; 2124 :          break;

  0085a	eb 02		 jmp	 SHORT $LN41@stbi__jpeg
$LN46@stbi__jpeg:
  0085c	eb d8		 jmp	 SHORT $LN40@stbi__jpeg
$LN41@stbi__jpeg:

; 2125 :    if (k == 17) {

  0085e	83 7c 24 64 11	 cmp	 DWORD PTR k$14[rsp], 17
  00863	75 2c		 jne	 SHORT $LN47@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  00865	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0086d	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00873	83 e8 10	 sub	 eax, 16
  00876	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0087e	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  00884	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR $T8[rsp], -1
  0088c	e9 97 01 00 00	 jmp	 $LN39@stbi__jpeg
$LN47@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  00891	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00899	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0089f	39 44 24 64	 cmp	 DWORD PTR k$14[rsp], eax
  008a3	7e 0d		 jle	 SHORT $LN48@stbi__jpeg

; 2132 :       return -1;

  008a5	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR $T8[rsp], -1
  008ad	e9 76 01 00 00	 jmp	 $LN39@stbi__jpeg
$LN48@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  008b2	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  008b7	2b 44 24 64	 sub	 eax, DWORD PTR k$14[rsp]
  008bb	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  008c3	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv696[rsp], rcx
  008cb	0f b6 c8	 movzx	 ecx, al
  008ce	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv696[rsp]
  008d6	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  008dc	d3 e8		 shr	 eax, cl
  008de	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR k$14[rsp]
  008e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  008ea	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  008ed	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR k$14[rsp]
  008f2	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  008fa	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  00901	89 44 24 60	 mov	 DWORD PTR c$13[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  00905	83 7c 24 60 00	 cmp	 DWORD PTR c$13[rsp], 0
  0090a	7c 0a		 jl	 SHORT $LN50@stbi__jpeg
  0090c	81 7c 24 60 00
	01 00 00	 cmp	 DWORD PTR c$13[rsp], 256 ; 00000100H
  00914	7c 0d		 jl	 SHORT $LN49@stbi__jpeg
$LN50@stbi__jpeg:

; 2137 :        return -1;

  00916	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR $T8[rsp], -1
  0091e	e9 05 01 00 00	 jmp	 $LN39@stbi__jpeg
$LN49@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  00923	48 63 44 24 60	 movsxd	 rax, DWORD PTR c$13[rsp]
  00928	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00930	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00938	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0093d	2b c8		 sub	 ecx, eax
  0093f	8b c1		 mov	 eax, ecx
  00941	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00949	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv705[rsp], rcx
  00951	0f b6 c8	 movzx	 ecx, al
  00954	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv705[rsp]
  0095c	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00962	d3 e8		 shr	 eax, cl
  00964	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR c$13[rsp]
  00969	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00971	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  00979	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00980	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00983	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR c$13[rsp]
  00988	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00990	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00998	3b c1		 cmp	 eax, ecx
  0099a	74 1c		 je	 SHORT $LN52@stbi__jpeg
  0099c	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  009a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  009a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  009b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009b6	33 c0		 xor	 eax, eax
$LN52@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  009b8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  009c0	8b 4c 24 64	 mov	 ecx, DWORD PTR k$14[rsp]
  009c4	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  009ca	2b c1		 sub	 eax, ecx
  009cc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  009d4	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  009da	8b 44 24 64	 mov	 eax, DWORD PTR k$14[rsp]
  009de	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  009e6	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv716[rsp], rcx
  009ee	0f b6 c8	 movzx	 ecx, al
  009f1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv716[rsp]
  009f9	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  009ff	d3 e0		 shl	 eax, cl
  00a01	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00a09	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  00a0f	48 63 44 24 60	 movsxd	 rax, DWORD PTR c$13[rsp]
  00a14	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00a1c	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00a24	89 44 24 4c	 mov	 DWORD PTR $T8[rsp], eax
$LN39@stbi__jpeg:

; 2245 :          int rs = stbi__jpeg_huff_decode(j, hac);

  00a28	8b 44 24 4c	 mov	 eax, DWORD PTR $T8[rsp]
  00a2c	89 44 24 40	 mov	 DWORD PTR rs$5[rsp], eax

; 2246 :          if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00a30	83 7c 24 40 00	 cmp	 DWORD PTR rs$5[rsp], 0
  00a35	7d 11		 jge	 SHORT $LN14@stbi__jpeg
  00a37	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00a3e	e8 00 00 00 00	 call	 stbi__err
  00a43	e9 ab 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN14@stbi__jpeg:

; 2247 :          s = rs & 15;

  00a48	8b 44 24 40	 mov	 eax, DWORD PTR rs$5[rsp]
  00a4c	83 e0 0f	 and	 eax, 15
  00a4f	89 44 24 3c	 mov	 DWORD PTR s$4[rsp], eax

; 2248 :          r = rs >> 4;

  00a53	8b 44 24 40	 mov	 eax, DWORD PTR rs$5[rsp]
  00a57	c1 f8 04	 sar	 eax, 4
  00a5a	89 44 24 38	 mov	 DWORD PTR r$3[rsp], eax

; 2249 :          if (s == 0) {

  00a5e	83 7c 24 3c 00	 cmp	 DWORD PTR s$4[rsp], 0
  00a63	75 1f		 jne	 SHORT $LN15@stbi__jpeg

; 2250 :             if (rs != 0xf0) break; // end block

  00a65	81 7c 24 40 f0
	00 00 00	 cmp	 DWORD PTR rs$5[rsp], 240 ; 000000f0H
  00a6d	74 05		 je	 SHORT $LN17@stbi__jpeg
  00a6f	e9 7a 01 00 00	 jmp	 $LN3@stbi__jpeg
$LN17@stbi__jpeg:

; 2251 :             k += 16;

  00a74	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00a78	83 c0 10	 add	 eax, 16
  00a7b	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2252 :          } else {

  00a7f	e9 5f 01 00 00	 jmp	 $LN16@stbi__jpeg
$LN15@stbi__jpeg:

; 2253 :             k += r;

  00a84	8b 44 24 38	 mov	 eax, DWORD PTR r$3[rsp]
  00a88	8b 4c 24 28	 mov	 ecx, DWORD PTR k$[rsp]
  00a8c	03 c8		 add	 ecx, eax
  00a8e	8b c1		 mov	 eax, ecx
  00a90	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2254 :             // decode into unzigzag'd location
; 2255 :             zig = stbi__jpeg_dezigzag[k++];

  00a94	48 63 44 24 28	 movsxd	 rax, DWORD PTR k$[rsp]
  00a99	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  00aa0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00aa4	89 44 24 30	 mov	 DWORD PTR zig$1[rsp], eax
  00aa8	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00aac	ff c0		 inc	 eax
  00aae	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  00ab2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00aba	8b 4c 24 3c	 mov	 ecx, DWORD PTR s$4[rsp]
  00abe	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00ac4	7d 0e		 jge	 SHORT $LN54@stbi__jpeg
  00ac6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00ace	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00ad3	90		 npad	 1
$LN54@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00ad4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00adc	8b 4c 24 3c	 mov	 ecx, DWORD PTR s$4[rsp]
  00ae0	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00ae6	7d 0d		 jge	 SHORT $LN55@stbi__jpeg
  00ae8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR $T9[rsp], 0
  00af0	e9 c7 00 00 00	 jmp	 $LN53@stbi__jpeg
$LN55@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  00af5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00afd	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00b03	c1 e8 1f	 shr	 eax, 31
  00b06	89 44 24 58	 mov	 DWORD PTR sgn$11[rsp], eax

; 2159 :    k = stbi_lrot(j->code_buffer, n);

  00b0a	8b 44 24 3c	 mov	 eax, DWORD PTR s$4[rsp]
  00b0e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b16	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv733[rsp], rcx
  00b1e	0f b6 c8	 movzx	 ecx, al
  00b21	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv733[rsp]
  00b29	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00b2f	d3 c0		 rol	 eax, cl
  00b31	89 44 24 54	 mov	 DWORD PTR k$10[rsp], eax

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

  00b35	48 63 44 24 3c	 movsxd	 rax, DWORD PTR s$4[rsp]
  00b3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00b41	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00b44	f7 d0		 not	 eax
  00b46	8b 4c 24 54	 mov	 ecx, DWORD PTR k$10[rsp]
  00b4a	23 c8		 and	 ecx, eax
  00b4c	8b c1		 mov	 eax, ecx
  00b4e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b56	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2161 :    k &= stbi__bmask[n];

  00b5c	48 63 44 24 3c	 movsxd	 rax, DWORD PTR s$4[rsp]
  00b61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00b68	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00b6b	8b 4c 24 54	 mov	 ecx, DWORD PTR k$10[rsp]
  00b6f	23 c8		 and	 ecx, eax
  00b71	8b c1		 mov	 eax, ecx
  00b73	89 44 24 54	 mov	 DWORD PTR k$10[rsp], eax

; 2162 :    j->code_bits -= n;

  00b77	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00b7f	8b 4c 24 3c	 mov	 ecx, DWORD PTR s$4[rsp]
  00b83	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00b89	2b c1		 sub	 eax, ecx
  00b8b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b93	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

  00b99	48 63 44 24 3c	 movsxd	 rax, DWORD PTR s$4[rsp]
  00b9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  00ba5	8b 54 24 58	 mov	 edx, DWORD PTR sgn$11[rsp]
  00ba9	ff ca		 dec	 edx
  00bab	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00bae	23 c2		 and	 eax, edx
  00bb0	8b 4c 24 54	 mov	 ecx, DWORD PTR k$10[rsp]
  00bb4	03 c8		 add	 ecx, eax
  00bb6	8b c1		 mov	 eax, ecx
  00bb8	89 44 24 50	 mov	 DWORD PTR $T9[rsp], eax
$LN53@stbi__jpeg:

; 2256 :             data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);

  00bbc	8b 44 24 50	 mov	 eax, DWORD PTR $T9[rsp]
  00bc0	8b 4c 24 30	 mov	 ecx, DWORD PTR zig$1[rsp]
  00bc4	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  00bcc	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00bd0	0f af c1	 imul	 eax, ecx
  00bd3	8b 4c 24 30	 mov	 ecx, DWORD PTR zig$1[rsp]
  00bd7	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00bdf	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN16@stbi__jpeg:
$LN12@stbi__jpeg:

; 2257 :          }
; 2258 :       }
; 2259 :    } while (k < 64);

  00be3	83 7c 24 28 40	 cmp	 DWORD PTR k$[rsp], 64	; 00000040H
  00be8	0f 8c db f9 ff
	ff		 jl	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2260 :    return 1;

  00bee	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2261 : }

  00bf3	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  00bfa	5f		 pop	 rdi
  00bfb	c3		 ret	 0
stbi__jpeg_decode_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
diff$ = 32
dc$ = 36
t$ = 40
$T1 = 44
$T2 = 48
$T3 = 52
k$4 = 56
k$5 = 60
sgn$6 = 64
temp$7 = 68
c$8 = 72
k$9 = 76
s$10 = 80
tv358 = 88
tv379 = 96
tv388 = 104
tv399 = 112
tv410 = 120
tv88 = 128
tv432 = 132
tv436 = 136
j$ = 160
data$ = 168
hdc$ = 176
b$ = 184
stbi__jpeg_decode_block_prog_dc PROC

; 2264 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2265 :    int diff,dc;
; 2266 :    int t;
; 2267 :    if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00030	83 b8 38 48 00
	00 00		 cmp	 DWORD PTR [rax+18488], 0
  00037	74 11		 je	 SHORT $LN2@stbi__jpeg
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  00040	e8 00 00 00 00	 call	 stbi__err
  00045	e9 96 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 2268 : 
; 2269 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0004a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00052	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00059	7d 0e		 jge	 SHORT $LN3@stbi__jpeg
  0005b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00063	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00068	90		 npad	 1
$LN3@stbi__jpeg:

; 2270 : 
; 2271 :    if (j->succ_high == 0) {

  00069	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00071	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  00078	0f 85 7a 05 00
	00		 jne	 $LN4@stbi__jpeg

; 2272 :       // first scan for DC coefficient, must be first
; 2273 :       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now

  0007e	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR data$[rsp]
  00086	33 c0		 xor	 eax, eax
  00088	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0008d	f3 aa		 rep stosb

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0008f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00097	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0009e	7d 0e		 jge	 SHORT $LN18@stbi__jpeg
  000a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  000a8	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  000ad	90		 npad	 1
$LN18@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000b6	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000bc	c1 e8 17	 shr	 eax, 23
  000bf	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000c4	89 44 24 48	 mov	 DWORD PTR c$8[rsp], eax

; 2105 :    k = h->fast[c];

  000c8	48 63 44 24 48	 movsxd	 rax, DWORD PTR c$8[rsp]
  000cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  000d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d9	89 44 24 4c	 mov	 DWORD PTR k$9[rsp], eax

; 2106 :    if (k < 255) {

  000dd	81 7c 24 4c ff
	00 00 00	 cmp	 DWORD PTR k$9[rsp], 255	; 000000ffH
  000e5	0f 8d a9 00 00
	00		 jge	 $LN19@stbi__jpeg

; 2107 :       int s = h->size[k];

  000eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR k$9[rsp]
  000f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  000f8	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00100	89 44 24 50	 mov	 DWORD PTR s$10[rsp], eax

; 2108 :       if (s > j->code_bits)

  00104	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0010c	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00112	39 44 24 50	 cmp	 DWORD PTR s$10[rsp], eax
  00116	7e 0d		 jle	 SHORT $LN20@stbi__jpeg

; 2109 :          return -1;

  00118	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR $T1[rsp], -1
  00120	e9 6e 02 00 00	 jmp	 $LN14@stbi__jpeg
$LN20@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  00125	8b 44 24 50	 mov	 eax, DWORD PTR s$10[rsp]
  00129	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00131	48 89 4c 24 58	 mov	 QWORD PTR tv358[rsp], rcx
  00136	0f b6 c8	 movzx	 ecx, al
  00139	48 8b 44 24 58	 mov	 rax, QWORD PTR tv358[rsp]
  0013e	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00144	d3 e0		 shl	 eax, cl
  00146	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0014e	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  00154	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0015c	8b 4c 24 50	 mov	 ecx, DWORD PTR s$10[rsp]
  00160	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00166	2b c1		 sub	 eax, ecx
  00168	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00170	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  00176	48 63 44 24 4c	 movsxd	 rax, DWORD PTR k$9[rsp]
  0017b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  00183	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0018b	89 44 24 2c	 mov	 DWORD PTR $T1[rsp], eax
  0018f	e9 ff 01 00 00	 jmp	 $LN14@stbi__jpeg
$LN19@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  00194	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0019c	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  001a2	c1 e8 10	 shr	 eax, 16
  001a5	89 44 24 44	 mov	 DWORD PTR temp$7[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  001a9	c7 44 24 4c 0a
	00 00 00	 mov	 DWORD PTR k$9[rsp], 10
  001b1	eb 0a		 jmp	 SHORT $LN17@stbi__jpeg
$LN15@stbi__jpeg:
  001b3	8b 44 24 4c	 mov	 eax, DWORD PTR k$9[rsp]
  001b7	ff c0		 inc	 eax
  001b9	89 44 24 4c	 mov	 DWORD PTR k$9[rsp], eax
$LN17@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  001bd	48 63 44 24 4c	 movsxd	 rax, DWORD PTR k$9[rsp]
  001c2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  001ca	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  001d1	39 44 24 44	 cmp	 DWORD PTR temp$7[rsp], eax
  001d5	73 02		 jae	 SHORT $LN21@stbi__jpeg

; 2124 :          break;

  001d7	eb 02		 jmp	 SHORT $LN16@stbi__jpeg
$LN21@stbi__jpeg:
  001d9	eb d8		 jmp	 SHORT $LN15@stbi__jpeg
$LN16@stbi__jpeg:

; 2125 :    if (k == 17) {

  001db	83 7c 24 4c 11	 cmp	 DWORD PTR k$9[rsp], 17
  001e0	75 2c		 jne	 SHORT $LN22@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  001e2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001ea	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001f0	83 e8 10	 sub	 eax, 16
  001f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001fb	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  00201	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR $T1[rsp], -1
  00209	e9 85 01 00 00	 jmp	 $LN14@stbi__jpeg
$LN22@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  0020e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00216	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0021c	39 44 24 4c	 cmp	 DWORD PTR k$9[rsp], eax
  00220	7e 0d		 jle	 SHORT $LN23@stbi__jpeg

; 2132 :       return -1;

  00222	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR $T1[rsp], -1
  0022a	e9 64 01 00 00	 jmp	 $LN14@stbi__jpeg
$LN23@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  0022f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00234	2b 44 24 4c	 sub	 eax, DWORD PTR k$9[rsp]
  00238	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00240	48 89 4c 24 60	 mov	 QWORD PTR tv379[rsp], rcx
  00245	0f b6 c8	 movzx	 ecx, al
  00248	48 8b 44 24 60	 mov	 rax, QWORD PTR tv379[rsp]
  0024d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00253	d3 e8		 shr	 eax, cl
  00255	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR k$9[rsp]
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00261	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00264	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR k$9[rsp]
  00269	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  00271	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  00278	89 44 24 48	 mov	 DWORD PTR c$8[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  0027c	83 7c 24 48 00	 cmp	 DWORD PTR c$8[rsp], 0
  00281	7c 0a		 jl	 SHORT $LN25@stbi__jpeg
  00283	81 7c 24 48 00
	01 00 00	 cmp	 DWORD PTR c$8[rsp], 256	; 00000100H
  0028b	7c 0d		 jl	 SHORT $LN24@stbi__jpeg
$LN25@stbi__jpeg:

; 2137 :        return -1;

  0028d	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR $T1[rsp], -1
  00295	e9 f9 00 00 00	 jmp	 $LN14@stbi__jpeg
$LN24@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  0029a	48 63 44 24 48	 movsxd	 rax, DWORD PTR c$8[rsp]
  0029f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  002a7	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  002af	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002b4	2b c8		 sub	 ecx, eax
  002b6	8b c1		 mov	 eax, ecx
  002b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002c0	48 89 4c 24 68	 mov	 QWORD PTR tv388[rsp], rcx
  002c5	0f b6 c8	 movzx	 ecx, al
  002c8	48 8b 44 24 68	 mov	 rax, QWORD PTR tv388[rsp]
  002cd	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  002d3	d3 e8		 shr	 eax, cl
  002d5	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR c$8[rsp]
  002da	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  002e2	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  002f1	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  002f4	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR c$8[rsp]
  002f9	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR hdc$[rsp]
  00301	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00309	3b c1		 cmp	 eax, ecx
  0030b	74 1c		 je	 SHORT $LN27@stbi__jpeg
  0030d	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  00313	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  0031a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00327	33 c0		 xor	 eax, eax
$LN27@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  00329	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00331	8b 4c 24 4c	 mov	 ecx, DWORD PTR k$9[rsp]
  00335	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0033b	2b c1		 sub	 eax, ecx
  0033d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00345	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  0034b	8b 44 24 4c	 mov	 eax, DWORD PTR k$9[rsp]
  0034f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00357	48 89 4c 24 70	 mov	 QWORD PTR tv399[rsp], rcx
  0035c	0f b6 c8	 movzx	 ecx, al
  0035f	48 8b 44 24 70	 mov	 rax, QWORD PTR tv399[rsp]
  00364	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0036a	d3 e0		 shl	 eax, cl
  0036c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00374	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  0037a	48 63 44 24 48	 movsxd	 rax, DWORD PTR c$8[rsp]
  0037f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdc$[rsp]
  00387	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0038f	89 44 24 2c	 mov	 DWORD PTR $T1[rsp], eax
$LN14@stbi__jpeg:

; 2274 :       t = stbi__jpeg_huff_decode(j, hdc);

  00393	8b 44 24 2c	 mov	 eax, DWORD PTR $T1[rsp]
  00397	89 44 24 28	 mov	 DWORD PTR t$[rsp], eax

; 2275 :       if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0039b	83 7c 24 28 00	 cmp	 DWORD PTR t$[rsp], 0
  003a0	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  003a2	83 7c 24 28 0f	 cmp	 DWORD PTR t$[rsp], 15
  003a7	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  003a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  003b0	e8 00 00 00 00	 call	 stbi__err
  003b5	e9 26 03 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;

  003ba	83 7c 24 28 00	 cmp	 DWORD PTR t$[rsp], 0
  003bf	0f 84 11 01 00
	00		 je	 $LN12@stbi__jpeg

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  003c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003cd	8b 4c 24 28	 mov	 ecx, DWORD PTR t$[rsp]
  003d1	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  003d7	7d 0e		 jge	 SHORT $LN29@stbi__jpeg
  003d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  003e1	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  003e6	90		 npad	 1
$LN29@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  003e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003ef	8b 4c 24 28	 mov	 ecx, DWORD PTR t$[rsp]
  003f3	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  003f9	7d 0d		 jge	 SHORT $LN30@stbi__jpeg
  003fb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0
  00403	e9 c1 00 00 00	 jmp	 $LN28@stbi__jpeg
$LN30@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  00408	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00410	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00416	c1 e8 1f	 shr	 eax, 31
  00419	89 44 24 40	 mov	 DWORD PTR sgn$6[rsp], eax

; 2159 :    k = stbi_lrot(j->code_buffer, n);

  0041d	8b 44 24 28	 mov	 eax, DWORD PTR t$[rsp]
  00421	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00429	48 89 4c 24 78	 mov	 QWORD PTR tv410[rsp], rcx
  0042e	0f b6 c8	 movzx	 ecx, al
  00431	48 8b 44 24 78	 mov	 rax, QWORD PTR tv410[rsp]
  00436	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0043c	d3 c0		 rol	 eax, cl
  0043e	89 44 24 3c	 mov	 DWORD PTR k$5[rsp], eax

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

  00442	48 63 44 24 28	 movsxd	 rax, DWORD PTR t$[rsp]
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  0044e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00451	f7 d0		 not	 eax
  00453	8b 4c 24 3c	 mov	 ecx, DWORD PTR k$5[rsp]
  00457	23 c8		 and	 ecx, eax
  00459	8b c1		 mov	 eax, ecx
  0045b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00463	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2161 :    k &= stbi__bmask[n];

  00469	48 63 44 24 28	 movsxd	 rax, DWORD PTR t$[rsp]
  0046e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00475	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00478	8b 4c 24 3c	 mov	 ecx, DWORD PTR k$5[rsp]
  0047c	23 c8		 and	 ecx, eax
  0047e	8b c1		 mov	 eax, ecx
  00480	89 44 24 3c	 mov	 DWORD PTR k$5[rsp], eax

; 2162 :    j->code_bits -= n;

  00484	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0048c	8b 4c 24 28	 mov	 ecx, DWORD PTR t$[rsp]
  00490	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00496	2b c1		 sub	 eax, ecx
  00498	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004a0	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

  004a6	48 63 44 24 28	 movsxd	 rax, DWORD PTR t$[rsp]
  004ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  004b2	8b 54 24 40	 mov	 edx, DWORD PTR sgn$6[rsp]
  004b6	ff ca		 dec	 edx
  004b8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  004bb	23 c2		 and	 eax, edx
  004bd	8b 4c 24 3c	 mov	 ecx, DWORD PTR k$5[rsp]
  004c1	03 c8		 add	 ecx, eax
  004c3	8b c1		 mov	 eax, ecx
  004c5	89 44 24 30	 mov	 DWORD PTR $T2[rsp], eax
$LN28@stbi__jpeg:

; 2276 :       diff = t ? stbi__extend_receive(j, t) : 0;

  004c9	8b 44 24 30	 mov	 eax, DWORD PTR $T2[rsp]
  004cd	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv88[rsp], eax
  004d4	eb 0b		 jmp	 SHORT $LN13@stbi__jpeg
$LN12@stbi__jpeg:
  004d6	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv88[rsp], 0
$LN13@stbi__jpeg:
  004e1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv88[rsp]
  004e8	89 44 24 20	 mov	 DWORD PTR diff$[rsp], eax

; 2277 : 
; 2278 :       if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

  004ec	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  004f4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004f8	8b 54 24 20	 mov	 edx, DWORD PTR diff$[rsp]
  004fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00504	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  0050b	e8 00 00 00 00	 call	 stbi__addints_valid
  00510	85 c0		 test	 eax, eax
  00512	75 11		 jne	 SHORT $LN8@stbi__jpeg
  00514	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09IFDKCGFO@bad?5delta@
  0051b	e8 00 00 00 00	 call	 stbi__err
  00520	e9 bb 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 2279 :       dc = j->img_comp[b].dc_pred + diff;

  00525	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  0052d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00531	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00539	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  00540	03 44 24 20	 add	 eax, DWORD PTR diff$[rsp]
  00544	89 44 24 24	 mov	 DWORD PTR dc$[rsp], eax

; 2280 :       j->img_comp[b].dc_pred = dc;

  00548	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  00550	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00554	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0055c	8b 54 24 24	 mov	 edx, DWORD PTR dc$[rsp]
  00560	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2281 :       if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00567	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0056f	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00575	b9 01 00 00 00	 mov	 ecx, 1
  0057a	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv432[rsp], ecx
  00581	0f b6 c8	 movzx	 ecx, al
  00584	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv432[rsp]
  0058b	d3 e0		 shl	 eax, cl
  0058d	0f b7 d0	 movzx	 edx, ax
  00590	0f b7 4c 24 24	 movzx	 ecx, WORD PTR dc$[rsp]
  00595	e8 00 00 00 00	 call	 stbi__mul2shorts_valid
  0059a	85 c0		 test	 eax, eax
  0059c	75 11		 jne	 SHORT $LN9@stbi__jpeg
  0059e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  005a5	e8 00 00 00 00	 call	 stbi__err
  005aa	e9 31 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2282 :       data[0] = (short) (dc * (1 << j->succ_low));

  005af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005b7	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  005bd	b9 01 00 00 00	 mov	 ecx, 1
  005c2	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv436[rsp], ecx
  005c9	0f b6 c8	 movzx	 ecx, al
  005cc	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv436[rsp]
  005d3	d3 e0		 shl	 eax, cl
  005d5	8b 4c 24 24	 mov	 ecx, DWORD PTR dc$[rsp]
  005d9	0f af c8	 imul	 ecx, eax
  005dc	8b c1		 mov	 eax, ecx
  005de	b9 02 00 00 00	 mov	 ecx, 2
  005e3	48 6b c9 00	 imul	 rcx, rcx, 0
  005e7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  005ef	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2283 :    } else {

  005f3	e9 e3 00 00 00	 jmp	 $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  005f8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00600	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00607	7d 0e		 jge	 SHORT $LN33@stbi__jpeg
  00609	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00611	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00616	90		 npad	 1
$LN33@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  00617	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0061f	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00626	7d 0a		 jge	 SHORT $LN34@stbi__jpeg
  00628	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR $T3[rsp], 0
  00630	eb 5b		 jmp	 SHORT $LN32@stbi__jpeg
$LN34@stbi__jpeg:

; 2184 :    k = j->code_buffer;

  00632	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0063a	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00640	89 44 24 38	 mov	 DWORD PTR k$4[rsp], eax

; 2185 :    j->code_buffer <<= 1;

  00644	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0064c	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00652	d1 e0		 shl	 eax, 1
  00654	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0065c	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2186 :    --j->code_bits;

  00662	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0066a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00670	ff c8		 dec	 eax
  00672	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0067a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2187 :    return k & 0x80000000;

  00680	8b 44 24 38	 mov	 eax, DWORD PTR k$4[rsp]
  00684	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00689	89 44 24 34	 mov	 DWORD PTR $T3[rsp], eax
$LN32@stbi__jpeg:

; 2284 :       // refinement scan for DC coefficient
; 2285 :       if (stbi__jpeg_get_bit(j))

  0068d	8b 44 24 34	 mov	 eax, DWORD PTR $T3[rsp]
  00691	85 c0		 test	 eax, eax
  00693	74 46		 je	 SHORT $LN10@stbi__jpeg

; 2286 :          data[0] += (short) (1 << j->succ_low);

  00695	b8 02 00 00 00	 mov	 eax, 2
  0069a	48 6b c0 00	 imul	 rax, rax, 0
  0069e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  006a6	8b 89 40 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18496]
  006ac	ba 01 00 00 00	 mov	 edx, 1
  006b1	d3 e2		 shl	 edx, cl
  006b3	8b ca		 mov	 ecx, edx
  006b5	0f bf c9	 movsx	 ecx, cx
  006b8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  006c0	0f bf 04 02	 movsx	 eax, WORD PTR [rdx+rax]
  006c4	03 c1		 add	 eax, ecx
  006c6	b9 02 00 00 00	 mov	 ecx, 2
  006cb	48 6b c9 00	 imul	 rcx, rcx, 0
  006cf	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  006d7	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN10@stbi__jpeg:
$LN5@stbi__jpeg:

; 2287 :    }
; 2288 :    return 1;

  006db	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2289 : }

  006e0	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  006e7	5f		 pop	 rdi
  006e8	c3		 ret	 0
stbi__jpeg_decode_block_prog_dc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
k$ = 32
shift$1 = 36
zig$2 = 40
c$3 = 44
r$4 = 48
s$5 = 52
rs$6 = 56
bit$7 = 60
p$8 = 64
r$9 = 72
s$10 = 76
rs$11 = 80
p$12 = 88
$T13 = 96
$T14 = 100
$T15 = 104
$T16 = 108
$T17 = 112
$T18 = 116
$T19 = 120
$T20 = 124
k$21 = 128
k$22 = 132
k$23 = 136
temp$24 = 140
c$25 = 144
k$26 = 148
s$27 = 152
k$28 = 156
k$29 = 160
sgn$30 = 164
k$31 = 168
temp$32 = 172
c$33 = 176
k$34 = 180
s$35 = 184
tv703 = 192
tv726 = 200
tv747 = 208
tv756 = 216
tv767 = 224
tv774 = 232
tv782 = 240
tv812 = 248
tv835 = 256
tv879 = 264
tv900 = 272
tv909 = 280
tv920 = 288
tv927 = 296
tv936 = 304
j$ = 336
data$ = 344
hac$ = 352
fac$ = 360
stbi__jpeg_decode_block_prog_ac PROC

; 2294 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2295 :    int k;
; 2296 :    if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00028	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00030	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  00037	75 11		 jne	 SHORT $LN13@stbi__jpeg
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PJBJDAGM@can?8t?5merge?5dc?5and?5ac@
  00040	e8 00 00 00 00	 call	 stbi__err
  00045	e9 bf 11 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2297 : 
; 2298 :    if (j->succ_high == 0) {

  0004a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00052	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  00059	0f 85 62 08 00
	00		 jne	 $LN14@stbi__jpeg

; 2299 :       int shift = j->succ_low;

  0005f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00067	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  0006d	89 44 24 24	 mov	 DWORD PTR shift$1[rsp], eax

; 2300 : 
; 2301 :       if (j->eob_run) {

  00071	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00079	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00080	74 28		 je	 SHORT $LN16@stbi__jpeg

; 2302 :          --j->eob_run;

  00082	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0008a	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00090	ff c8		 dec	 eax
  00092	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0009a	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2303 :          return 1;

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	e9 5f 11 00 00	 jmp	 $LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 2304 :       }
; 2305 : 
; 2306 :       k = j->spec_start;

  000aa	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000b2	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  000b8	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2307 :       do {
; 2308 :          unsigned int zig;
; 2309 :          int c,r,s;
; 2310 :          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  000bc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000c4	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  000cb	7d 0e		 jge	 SHORT $LN17@stbi__jpeg
  000cd	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  000d5	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  000da	90		 npad	 1
$LN17@stbi__jpeg:

; 2311 :          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  000db	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000e3	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000e9	c1 e8 17	 shr	 eax, 23
  000ec	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000f1	89 44 24 2c	 mov	 DWORD PTR c$3[rsp], eax

; 2312 :          r = fac[c];

  000f5	48 63 44 24 2c	 movsxd	 rax, DWORD PTR c$3[rsp]
  000fa	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  00102	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  00106	89 44 24 30	 mov	 DWORD PTR r$4[rsp], eax

; 2313 :          if (r) { // fast-AC path

  0010a	83 7c 24 30 00	 cmp	 DWORD PTR r$4[rsp], 0
  0010f	0f 84 e7 00 00
	00		 je	 $LN18@stbi__jpeg

; 2314 :             k += (r >> 4) & 15; // run

  00115	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  00119	c1 f8 04	 sar	 eax, 4
  0011c	83 e0 0f	 and	 eax, 15
  0011f	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00123	03 c8		 add	 ecx, eax
  00125	8b c1		 mov	 eax, ecx
  00127	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2315 :             s = r & 15; // combined length

  0012b	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  0012f	83 e0 0f	 and	 eax, 15
  00132	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax

; 2316 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  00136	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0013e	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00144	39 44 24 34	 cmp	 DWORD PTR s$5[rsp], eax
  00148	7e 11		 jle	 SHORT $LN20@stbi__jpeg
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00151	e8 00 00 00 00	 call	 stbi__err
  00156	e9 ae 10 00 00	 jmp	 $LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 2317 :             j->code_buffer <<= s;

  0015b	8b 44 24 34	 mov	 eax, DWORD PTR s$5[rsp]
  0015f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00167	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv703[rsp], rcx
  0016f	0f b6 c8	 movzx	 ecx, al
  00172	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv703[rsp]
  0017a	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00180	d3 e0		 shl	 eax, cl
  00182	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0018a	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2318 :             j->code_bits -= s;

  00190	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00198	8b 4c 24 34	 mov	 ecx, DWORD PTR s$5[rsp]
  0019c	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001a2	2b c1		 sub	 eax, ecx
  001a4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001ac	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2319 :             zig = stbi__jpeg_dezigzag[k++];

  001b2	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  001be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c2	89 44 24 28	 mov	 DWORD PTR zig$2[rsp], eax
  001c6	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  001ca	ff c0		 inc	 eax
  001cc	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2320 :             data[zig] = (short) ((r >> 8) * (1 << shift));

  001d0	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  001d4	c1 f8 08	 sar	 eax, 8
  001d7	8b 4c 24 24	 mov	 ecx, DWORD PTR shift$1[rsp]
  001db	ba 01 00 00 00	 mov	 edx, 1
  001e0	d3 e2		 shl	 edx, cl
  001e2	8b ca		 mov	 ecx, edx
  001e4	0f af c1	 imul	 eax, ecx
  001e7	8b 4c 24 28	 mov	 ecx, DWORD PTR zig$2[rsp]
  001eb	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  001f3	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2321 :          } else {

  001f7	e9 a8 06 00 00	 jmp	 $LN19@stbi__jpeg
$LN18@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  001fc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00204	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0020b	7d 0e		 jge	 SHORT $LN54@stbi__jpeg
  0020d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00215	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  0021a	90		 npad	 1
$LN54@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  0021b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00223	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00229	c1 e8 17	 shr	 eax, 23
  0022c	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00231	89 84 24 b0 00
	00 00		 mov	 DWORD PTR c$33[rsp], eax

; 2105 :    k = h->fast[c];

  00238	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR c$33[rsp]
  00240	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00248	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR k$34[rsp], eax

; 2106 :    if (k < 255) {

  00253	81 bc 24 b4 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR k$34[rsp], 255 ; 000000ffH
  0025e	0f 8d c1 00 00
	00		 jge	 $LN55@stbi__jpeg

; 2107 :       int s = h->size[k];

  00264	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR k$34[rsp]
  0026c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00274	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0027c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR s$35[rsp], eax

; 2108 :       if (s > j->code_bits)

  00283	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0028b	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00291	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR s$35[rsp], eax
  00298	7e 0d		 jle	 SHORT $LN56@stbi__jpeg

; 2109 :          return -1;

  0029a	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR $T13[rsp], -1
  002a2	e9 cb 02 00 00	 jmp	 $LN50@stbi__jpeg
$LN56@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  002a7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR s$35[rsp]
  002ae	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002b6	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv726[rsp], rcx
  002be	0f b6 c8	 movzx	 ecx, al
  002c1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv726[rsp]
  002c9	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  002cf	d3 e0		 shl	 eax, cl
  002d1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002d9	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  002df	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  002e7	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR s$35[rsp]
  002ee	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  002f4	2b c1		 sub	 eax, ecx
  002f6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002fe	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  00304	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR k$34[rsp]
  0030c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00314	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0031c	89 44 24 60	 mov	 DWORD PTR $T13[rsp], eax
  00320	e9 4d 02 00 00	 jmp	 $LN50@stbi__jpeg
$LN55@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  00325	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0032d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00333	c1 e8 10	 shr	 eax, 16
  00336	89 84 24 ac 00
	00 00		 mov	 DWORD PTR temp$32[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  0033d	c7 84 24 b4 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR k$34[rsp], 10
  00348	eb 10		 jmp	 SHORT $LN53@stbi__jpeg
$LN51@stbi__jpeg:
  0034a	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR k$34[rsp]
  00351	ff c0		 inc	 eax
  00353	89 84 24 b4 00
	00 00		 mov	 DWORD PTR k$34[rsp], eax
$LN53@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  0035a	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR k$34[rsp]
  00362	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  0036a	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00371	39 84 24 ac 00
	00 00		 cmp	 DWORD PTR temp$32[rsp], eax
  00378	73 02		 jae	 SHORT $LN57@stbi__jpeg

; 2124 :          break;

  0037a	eb 02		 jmp	 SHORT $LN52@stbi__jpeg
$LN57@stbi__jpeg:
  0037c	eb cc		 jmp	 SHORT $LN51@stbi__jpeg
$LN52@stbi__jpeg:

; 2125 :    if (k == 17) {

  0037e	83 bc 24 b4 00
	00 00 11	 cmp	 DWORD PTR k$34[rsp], 17
  00386	75 2c		 jne	 SHORT $LN58@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  00388	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00390	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00396	83 e8 10	 sub	 eax, 16
  00399	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  003a1	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  003a7	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR $T13[rsp], -1
  003af	e9 be 01 00 00	 jmp	 $LN50@stbi__jpeg
$LN58@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  003b4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003bc	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  003c2	39 84 24 b4 00
	00 00		 cmp	 DWORD PTR k$34[rsp], eax
  003c9	7e 0d		 jle	 SHORT $LN59@stbi__jpeg

; 2132 :       return -1;

  003cb	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR $T13[rsp], -1
  003d3	e9 9a 01 00 00	 jmp	 $LN50@stbi__jpeg
$LN59@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  003d8	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  003dd	2b 84 24 b4 00
	00 00		 sub	 eax, DWORD PTR k$34[rsp]
  003e4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  003ec	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv747[rsp], rcx
  003f4	0f b6 c8	 movzx	 ecx, al
  003f7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv747[rsp]
  003ff	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00405	d3 e8		 shr	 eax, cl
  00407	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR k$34[rsp]
  0040f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00416	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00419	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR k$34[rsp]
  00421	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00429	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  00430	89 84 24 b0 00
	00 00		 mov	 DWORD PTR c$33[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  00437	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR c$33[rsp], 0
  0043f	7c 0d		 jl	 SHORT $LN61@stbi__jpeg
  00441	81 bc 24 b0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR c$33[rsp], 256 ; 00000100H
  0044c	7c 0d		 jl	 SHORT $LN60@stbi__jpeg
$LN61@stbi__jpeg:

; 2137 :        return -1;

  0044e	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR $T13[rsp], -1
  00456	e9 17 01 00 00	 jmp	 $LN50@stbi__jpeg
$LN60@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  0045b	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR c$33[rsp]
  00463	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  0046b	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00473	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00478	2b c8		 sub	 ecx, eax
  0047a	8b c1		 mov	 eax, ecx
  0047c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00484	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv756[rsp], rcx
  0048c	0f b6 c8	 movzx	 ecx, al
  0048f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv756[rsp]
  00497	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0049d	d3 e8		 shr	 eax, cl
  0049f	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR c$33[rsp]
  004a7	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  004af	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  004b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  004be	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  004c1	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR c$33[rsp]
  004c9	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  004d1	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  004d9	3b c1		 cmp	 eax, ecx
  004db	74 1c		 je	 SHORT $LN63@stbi__jpeg
  004dd	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  004e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  004ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004f7	33 c0		 xor	 eax, eax
$LN63@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  004f9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00501	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR k$34[rsp]
  00508	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0050e	2b c1		 sub	 eax, ecx
  00510	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00518	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  0051e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR k$34[rsp]
  00525	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0052d	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv767[rsp], rcx
  00535	0f b6 c8	 movzx	 ecx, al
  00538	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv767[rsp]
  00540	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00546	d3 e0		 shl	 eax, cl
  00548	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00550	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  00556	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR c$33[rsp]
  0055e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00566	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  0056e	89 44 24 60	 mov	 DWORD PTR $T13[rsp], eax
$LN50@stbi__jpeg:

; 2322 :             int rs = stbi__jpeg_huff_decode(j, hac);

  00572	8b 44 24 60	 mov	 eax, DWORD PTR $T13[rsp]
  00576	89 44 24 38	 mov	 DWORD PTR rs$6[rsp], eax

; 2323 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  0057a	83 7c 24 38 00	 cmp	 DWORD PTR rs$6[rsp], 0
  0057f	7d 11		 jge	 SHORT $LN21@stbi__jpeg
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00588	e8 00 00 00 00	 call	 stbi__err
  0058d	e9 77 0c 00 00	 jmp	 $LN1@stbi__jpeg
$LN21@stbi__jpeg:

; 2324 :             s = rs & 15;

  00592	8b 44 24 38	 mov	 eax, DWORD PTR rs$6[rsp]
  00596	83 e0 0f	 and	 eax, 15
  00599	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax

; 2325 :             r = rs >> 4;

  0059d	8b 44 24 38	 mov	 eax, DWORD PTR rs$6[rsp]
  005a1	c1 f8 04	 sar	 eax, 4
  005a4	89 44 24 30	 mov	 DWORD PTR r$4[rsp], eax

; 2326 :             if (s == 0) {

  005a8	83 7c 24 34 00	 cmp	 DWORD PTR s$5[rsp], 0
  005ad	0f 85 80 01 00
	00		 jne	 $LN22@stbi__jpeg

; 2327 :                if (r < 15) {

  005b3	83 7c 24 30 0f	 cmp	 DWORD PTR r$4[rsp], 15
  005b8	0f 8d 65 01 00
	00		 jge	 $LN24@stbi__jpeg

; 2328 :                   j->eob_run = (1 << r);

  005be	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  005c2	b9 01 00 00 00	 mov	 ecx, 1
  005c7	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv774[rsp], ecx
  005ce	0f b6 c8	 movzx	 ecx, al
  005d1	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv774[rsp]
  005d8	d3 e0		 shl	 eax, cl
  005da	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  005e2	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2329 :                   if (r)

  005e8	83 7c 24 30 00	 cmp	 DWORD PTR r$4[rsp], 0
  005ed	0f 84 0d 01 00
	00		 je	 $LN25@stbi__jpeg

; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  005f3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005fb	8b 4c 24 30	 mov	 ecx, DWORD PTR r$4[rsp]
  005ff	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00605	7d 0e		 jge	 SHORT $LN65@stbi__jpeg
  00607	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0060f	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00614	90		 npad	 1
$LN65@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00615	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0061d	8b 4c 24 30	 mov	 ecx, DWORD PTR r$4[rsp]
  00621	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00627	7d 0d		 jge	 SHORT $LN66@stbi__jpeg
  00629	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR $T14[rsp], 0
  00631	e9 a6 00 00 00	 jmp	 $LN64@stbi__jpeg
$LN66@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

  00636	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  0063a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00642	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv782[rsp], rcx
  0064a	0f b6 c8	 movzx	 ecx, al
  0064d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv782[rsp]
  00655	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0065b	d3 c0		 rol	 eax, cl
  0065d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR k$31[rsp], eax

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];

  00664	48 63 44 24 30	 movsxd	 rax, DWORD PTR r$4[rsp]
  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00670	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00673	f7 d0		 not	 eax
  00675	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR k$31[rsp]
  0067c	23 c8		 and	 ecx, eax
  0067e	8b c1		 mov	 eax, ecx
  00680	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00688	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2174 :    k &= stbi__bmask[n];

  0068e	48 63 44 24 30	 movsxd	 rax, DWORD PTR r$4[rsp]
  00693	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  0069a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0069d	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR k$31[rsp]
  006a4	23 c8		 and	 ecx, eax
  006a6	8b c1		 mov	 eax, ecx
  006a8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR k$31[rsp], eax

; 2175 :    j->code_bits -= n;

  006af	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  006b7	8b 4c 24 30	 mov	 ecx, DWORD PTR r$4[rsp]
  006bb	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  006c1	2b c1		 sub	 eax, ecx
  006c3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  006cb	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2176 :    return k;

  006d1	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR k$31[rsp]
  006d8	89 44 24 64	 mov	 DWORD PTR $T14[rsp], eax
$LN64@stbi__jpeg:

; 2330 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

  006dc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  006e4	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  006ea	8b 4c 24 64	 mov	 ecx, DWORD PTR $T14[rsp]
  006ee	03 c8		 add	 ecx, eax
  006f0	8b c1		 mov	 eax, ecx
  006f2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  006fa	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN25@stbi__jpeg:

; 2331 :                   --j->eob_run;

  00700	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00708	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  0070e	ff c8		 dec	 eax
  00710	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00718	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2332 :                   break;

  0071e	e9 99 01 00 00	 jmp	 $LN3@stbi__jpeg
$LN24@stbi__jpeg:

; 2333 :                }
; 2334 :                k += 16;

  00723	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00727	83 c0 10	 add	 eax, 16
  0072a	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2335 :             } else {

  0072e	e9 71 01 00 00	 jmp	 $LN23@stbi__jpeg
$LN22@stbi__jpeg:

; 2336 :                k += r;

  00733	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  00737	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0073b	03 c8		 add	 ecx, eax
  0073d	8b c1		 mov	 eax, ecx
  0073f	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2337 :                zig = stbi__jpeg_dezigzag[k++];

  00743	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  0074f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00753	89 44 24 28	 mov	 DWORD PTR zig$2[rsp], eax
  00757	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0075b	ff c0		 inc	 eax
  0075d	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2155 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  00761	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00769	8b 4c 24 34	 mov	 ecx, DWORD PTR s$5[rsp]
  0076d	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00773	7d 0e		 jge	 SHORT $LN69@stbi__jpeg
  00775	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0077d	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00782	90		 npad	 1
$LN69@stbi__jpeg:

; 2156 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00783	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0078b	8b 4c 24 34	 mov	 ecx, DWORD PTR s$5[rsp]
  0078f	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00795	7d 0d		 jge	 SHORT $LN70@stbi__jpeg
  00797	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR $T15[rsp], 0
  0079f	e9 dc 00 00 00	 jmp	 $LN68@stbi__jpeg
$LN70@stbi__jpeg:

; 2157 : 
; 2158 :    sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  007a4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  007ac	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  007b2	c1 e8 1f	 shr	 eax, 31
  007b5	89 84 24 a4 00
	00 00		 mov	 DWORD PTR sgn$30[rsp], eax

; 2159 :    k = stbi_lrot(j->code_buffer, n);

  007bc	8b 44 24 34	 mov	 eax, DWORD PTR s$5[rsp]
  007c0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  007c8	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv812[rsp], rcx
  007d0	0f b6 c8	 movzx	 ecx, al
  007d3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv812[rsp]
  007db	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  007e1	d3 c0		 rol	 eax, cl
  007e3	89 84 24 a0 00
	00 00		 mov	 DWORD PTR k$29[rsp], eax

; 2160 :    j->code_buffer = k & ~stbi__bmask[n];

  007ea	48 63 44 24 34	 movsxd	 rax, DWORD PTR s$5[rsp]
  007ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  007f6	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  007f9	f7 d0		 not	 eax
  007fb	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR k$29[rsp]
  00802	23 c8		 and	 ecx, eax
  00804	8b c1		 mov	 eax, ecx
  00806	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0080e	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2161 :    k &= stbi__bmask[n];

  00814	48 63 44 24 34	 movsxd	 rax, DWORD PTR s$5[rsp]
  00819	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00820	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00823	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR k$29[rsp]
  0082a	23 c8		 and	 ecx, eax
  0082c	8b c1		 mov	 eax, ecx
  0082e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR k$29[rsp], eax

; 2162 :    j->code_bits -= n;

  00835	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0083d	8b 4c 24 34	 mov	 ecx, DWORD PTR s$5[rsp]
  00841	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00847	2b c1		 sub	 eax, ecx
  00849	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00851	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2163 :    return k + (stbi__jbias[n] & (sgn - 1));

  00857	48 63 44 24 34	 movsxd	 rax, DWORD PTR s$5[rsp]
  0085c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jbias
  00863	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR sgn$30[rsp]
  0086a	ff ca		 dec	 edx
  0086c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0086f	23 c2		 and	 eax, edx
  00871	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR k$29[rsp]
  00878	03 c8		 add	 ecx, eax
  0087a	8b c1		 mov	 eax, ecx
  0087c	89 44 24 68	 mov	 DWORD PTR $T15[rsp], eax
$LN68@stbi__jpeg:

; 2338 :                data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));

  00880	8b 44 24 68	 mov	 eax, DWORD PTR $T15[rsp]
  00884	8b 4c 24 24	 mov	 ecx, DWORD PTR shift$1[rsp]
  00888	ba 01 00 00 00	 mov	 edx, 1
  0088d	d3 e2		 shl	 edx, cl
  0088f	8b ca		 mov	 ecx, edx
  00891	0f af c1	 imul	 eax, ecx
  00894	8b 4c 24 28	 mov	 ecx, DWORD PTR zig$2[rsp]
  00898	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  008a0	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN23@stbi__jpeg:
$LN19@stbi__jpeg:

; 2339 :             }
; 2340 :          }
; 2341 :       } while (k <= j->spec_end);

  008a4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  008ac	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  008b2	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  008b6	0f 8e 00 f8 ff
	ff		 jle	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2342 :    } else {

  008bc	e9 43 09 00 00	 jmp	 $LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 2343 :       // refinement scan for these AC coefficients
; 2344 : 
; 2345 :       short bit = (short) (1 << j->succ_low);

  008c1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  008c9	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  008cf	b9 01 00 00 00	 mov	 ecx, 1
  008d4	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv835[rsp], ecx
  008db	0f b6 c8	 movzx	 ecx, al
  008de	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv835[rsp]
  008e5	d3 e0		 shl	 eax, cl
  008e7	66 89 44 24 3c	 mov	 WORD PTR bit$7[rsp], ax

; 2346 : 
; 2347 :       if (j->eob_run) {

  008ec	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  008f4	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  008fb	0f 84 85 01 00
	00		 je	 $LN26@stbi__jpeg

; 2348 :          --j->eob_run;

  00901	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00909	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  0090f	ff c8		 dec	 eax
  00911	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00919	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2349 :          for (k = j->spec_start; k <= j->spec_end; ++k) {

  0091f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00927	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  0092d	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  00931	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  00933	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00937	ff c0		 inc	 eax
  00939	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__jpeg:
  0093d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00945	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  0094b	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0094f	0f 8f 2c 01 00
	00		 jg	 $LN6@stbi__jpeg

; 2350 :             short *p = &data[stbi__jpeg_dezigzag[k]];

  00955	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0095a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  00961	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00965	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0096d	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00971	48 89 44 24 40	 mov	 QWORD PTR p$8[rsp], rax

; 2351 :             if (*p != 0)

  00976	48 8b 44 24 40	 mov	 rax, QWORD PTR p$8[rsp]
  0097b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0097e	85 c0		 test	 eax, eax
  00980	0f 84 f6 00 00
	00		 je	 $LN28@stbi__jpeg

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  00986	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0098e	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00995	7d 0e		 jge	 SHORT $LN73@stbi__jpeg
  00997	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0099f	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  009a4	90		 npad	 1
$LN73@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  009a5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  009ad	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  009b4	7d 0a		 jge	 SHORT $LN74@stbi__jpeg
  009b6	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR $T16[rsp], 0
  009be	eb 61		 jmp	 SHORT $LN72@stbi__jpeg
$LN74@stbi__jpeg:

; 2184 :    k = j->code_buffer;

  009c0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  009c8	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  009ce	89 84 24 9c 00
	00 00		 mov	 DWORD PTR k$28[rsp], eax

; 2185 :    j->code_buffer <<= 1;

  009d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  009dd	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  009e3	d1 e0		 shl	 eax, 1
  009e5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  009ed	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2186 :    --j->code_bits;

  009f3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  009fb	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00a01	ff c8		 dec	 eax
  00a03	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00a0b	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2187 :    return k & 0x80000000;

  00a11	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR k$28[rsp]
  00a18	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00a1d	89 44 24 6c	 mov	 DWORD PTR $T16[rsp], eax
$LN72@stbi__jpeg:

; 2352 :                if (stbi__jpeg_get_bit(j))

  00a21	8b 44 24 6c	 mov	 eax, DWORD PTR $T16[rsp]
  00a25	85 c0		 test	 eax, eax
  00a27	74 53		 je	 SHORT $LN29@stbi__jpeg

; 2353 :                   if ((*p & bit)==0) {

  00a29	48 8b 44 24 40	 mov	 rax, QWORD PTR p$8[rsp]
  00a2e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00a31	0f bf 4c 24 3c	 movsx	 ecx, WORD PTR bit$7[rsp]
  00a36	23 c1		 and	 eax, ecx
  00a38	85 c0		 test	 eax, eax
  00a3a	75 40		 jne	 SHORT $LN30@stbi__jpeg

; 2354 :                      if (*p > 0)

  00a3c	48 8b 44 24 40	 mov	 rax, QWORD PTR p$8[rsp]
  00a41	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00a44	85 c0		 test	 eax, eax
  00a46	7e 1b		 jle	 SHORT $LN31@stbi__jpeg

; 2355 :                         *p += bit;

  00a48	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  00a4d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$8[rsp]
  00a52	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00a55	03 c8		 add	 ecx, eax
  00a57	8b c1		 mov	 eax, ecx
  00a59	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$8[rsp]
  00a5e	66 89 01	 mov	 WORD PTR [rcx], ax
  00a61	eb 19		 jmp	 SHORT $LN32@stbi__jpeg
$LN31@stbi__jpeg:

; 2356 :                      else
; 2357 :                         *p -= bit;

  00a63	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  00a68	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$8[rsp]
  00a6d	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00a70	2b c8		 sub	 ecx, eax
  00a72	8b c1		 mov	 eax, ecx
  00a74	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p$8[rsp]
  00a79	66 89 01	 mov	 WORD PTR [rcx], ax
$LN32@stbi__jpeg:
$LN30@stbi__jpeg:
$LN29@stbi__jpeg:
$LN28@stbi__jpeg:

; 2358 :                   }
; 2359 :          }

  00a7c	e9 b2 fe ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2360 :       } else {

  00a81	e9 7e 07 00 00	 jmp	 $LN27@stbi__jpeg
$LN26@stbi__jpeg:

; 2361 :          k = j->spec_start;

  00a86	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00a8e	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  00a94	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN10@stbi__jpeg:

; 2100 :    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00a98	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00aa0	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00aa7	7d 0e		 jge	 SHORT $LN80@stbi__jpeg
  00aa9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00ab1	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00ab6	90		 npad	 1
$LN80@stbi__jpeg:

; 2101 : 
; 2102 :    // look at the top FAST_BITS and determine what symbol ID it is,
; 2103 :    // if the code is <= FAST_BITS
; 2104 :    c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00ab7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00abf	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00ac5	c1 e8 17	 shr	 eax, 23
  00ac8	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00acd	89 84 24 90 00
	00 00		 mov	 DWORD PTR c$25[rsp], eax

; 2105 :    k = h->fast[c];

  00ad4	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR c$25[rsp]
  00adc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00ae4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ae8	89 84 24 94 00
	00 00		 mov	 DWORD PTR k$26[rsp], eax

; 2106 :    if (k < 255) {

  00aef	81 bc 24 94 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR k$26[rsp], 255 ; 000000ffH
  00afa	0f 8d c1 00 00
	00		 jge	 $LN81@stbi__jpeg

; 2107 :       int s = h->size[k];

  00b00	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR k$26[rsp]
  00b08	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00b10	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00b18	89 84 24 98 00
	00 00		 mov	 DWORD PTR s$27[rsp], eax

; 2108 :       if (s > j->code_bits)

  00b1f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00b27	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00b2d	39 84 24 98 00
	00 00		 cmp	 DWORD PTR s$27[rsp], eax
  00b34	7e 0d		 jle	 SHORT $LN82@stbi__jpeg

; 2109 :          return -1;

  00b36	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR $T17[rsp], -1
  00b3e	e9 cb 02 00 00	 jmp	 $LN76@stbi__jpeg
$LN82@stbi__jpeg:

; 2110 :       j->code_buffer <<= s;

  00b43	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR s$27[rsp]
  00b4a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b52	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv879[rsp], rcx
  00b5a	0f b6 c8	 movzx	 ecx, al
  00b5d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv879[rsp]
  00b65	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00b6b	d3 e0		 shl	 eax, cl
  00b6d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b75	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2111 :       j->code_bits -= s;

  00b7b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00b83	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR s$27[rsp]
  00b8a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00b90	2b c1		 sub	 eax, ecx
  00b92	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00b9a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2112 :       return h->values[k];

  00ba0	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR k$26[rsp]
  00ba8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00bb0	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00bb8	89 44 24 70	 mov	 DWORD PTR $T17[rsp], eax
  00bbc	e9 4d 02 00 00	 jmp	 $LN76@stbi__jpeg
$LN81@stbi__jpeg:

; 2113 :    }
; 2114 : 
; 2115 :    // naive test is to shift the code_buffer down so k bits are
; 2116 :    // valid, then test against maxcode. To speed this up, we've
; 2117 :    // preshifted maxcode left so that it has (16-k) 0s at the
; 2118 :    // end; in other words, regardless of the number of bits, it
; 2119 :    // wants to be compared against something shifted to have 16;
; 2120 :    // that way we don't need to shift inside the loop.
; 2121 :    temp = j->code_buffer >> 16;

  00bc1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00bc9	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00bcf	c1 e8 10	 shr	 eax, 16
  00bd2	89 84 24 8c 00
	00 00		 mov	 DWORD PTR temp$24[rsp], eax

; 2122 :    for (k=FAST_BITS+1 ; ; ++k)

  00bd9	c7 84 24 94 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR k$26[rsp], 10
  00be4	eb 10		 jmp	 SHORT $LN79@stbi__jpeg
$LN77@stbi__jpeg:
  00be6	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR k$26[rsp]
  00bed	ff c0		 inc	 eax
  00bef	89 84 24 94 00
	00 00		 mov	 DWORD PTR k$26[rsp], eax
$LN79@stbi__jpeg:

; 2123 :       if (temp < h->maxcode[k])

  00bf6	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR k$26[rsp]
  00bfe	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00c06	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00c0d	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR temp$24[rsp], eax
  00c14	73 02		 jae	 SHORT $LN83@stbi__jpeg

; 2124 :          break;

  00c16	eb 02		 jmp	 SHORT $LN78@stbi__jpeg
$LN83@stbi__jpeg:
  00c18	eb cc		 jmp	 SHORT $LN77@stbi__jpeg
$LN78@stbi__jpeg:

; 2125 :    if (k == 17) {

  00c1a	83 bc 24 94 00
	00 00 11	 cmp	 DWORD PTR k$26[rsp], 17
  00c22	75 2c		 jne	 SHORT $LN84@stbi__jpeg

; 2126 :       // error! code not found
; 2127 :       j->code_bits -= 16;

  00c24	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00c2c	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00c32	83 e8 10	 sub	 eax, 16
  00c35	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00c3d	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2128 :       return -1;

  00c43	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR $T17[rsp], -1
  00c4b	e9 be 01 00 00	 jmp	 $LN76@stbi__jpeg
$LN84@stbi__jpeg:

; 2129 :    }
; 2130 : 
; 2131 :    if (k > j->code_bits)

  00c50	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00c58	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00c5e	39 84 24 94 00
	00 00		 cmp	 DWORD PTR k$26[rsp], eax
  00c65	7e 0d		 jle	 SHORT $LN85@stbi__jpeg

; 2132 :       return -1;

  00c67	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR $T17[rsp], -1
  00c6f	e9 9a 01 00 00	 jmp	 $LN76@stbi__jpeg
$LN85@stbi__jpeg:

; 2133 : 
; 2134 :    // convert the huffman code to the symbol id
; 2135 :    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  00c74	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00c79	2b 84 24 94 00
	00 00		 sub	 eax, DWORD PTR k$26[rsp]
  00c80	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00c88	48 89 8c 24 10
	01 00 00	 mov	 QWORD PTR tv900[rsp], rcx
  00c90	0f b6 c8	 movzx	 ecx, al
  00c93	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv900[rsp]
  00c9b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00ca1	d3 e8		 shr	 eax, cl
  00ca3	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR k$26[rsp]
  00cab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00cb2	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00cb5	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR k$26[rsp]
  00cbd	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00cc5	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  00ccc	89 84 24 90 00
	00 00		 mov	 DWORD PTR c$25[rsp], eax

; 2136 :    if(c < 0 || c >= 256) // symbol id out of bounds!

  00cd3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR c$25[rsp], 0
  00cdb	7c 0d		 jl	 SHORT $LN87@stbi__jpeg
  00cdd	81 bc 24 90 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR c$25[rsp], 256 ; 00000100H
  00ce8	7c 0d		 jl	 SHORT $LN86@stbi__jpeg
$LN87@stbi__jpeg:

; 2137 :        return -1;

  00cea	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR $T17[rsp], -1
  00cf2	e9 17 01 00 00	 jmp	 $LN76@stbi__jpeg
$LN86@stbi__jpeg:

; 2138 :    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  00cf7	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR c$25[rsp]
  00cff	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00d07	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00d0f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d14	2b c8		 sub	 ecx, eax
  00d16	8b c1		 mov	 eax, ecx
  00d18	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00d20	48 89 8c 24 18
	01 00 00	 mov	 QWORD PTR tv909[rsp], rcx
  00d28	0f b6 c8	 movzx	 ecx, al
  00d2b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv909[rsp]
  00d33	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00d39	d3 e8		 shr	 eax, cl
  00d3b	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR c$25[rsp]
  00d43	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00d4b	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  00d53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmask
  00d5a	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00d5d	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR c$25[rsp]
  00d65	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00d6d	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00d75	3b c1		 cmp	 eax, ecx
  00d77	74 1c		 je	 SHORT $LN89@stbi__jpeg
  00d79	41 b8 5a 08 00
	00		 mov	 r8d, 2138		; 0000085aH
  00d7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00d86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@JGKPJEBO@?$AA?$CI?$AA?$CI?$AA?$CI?$AAj?$AA?9?$AA?$DO?$AAc?$AAo?$AAd?$AAe?$AA_?$AAb?$AAu?$AAf?$AAf@
  00d8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00d93	33 c0		 xor	 eax, eax
$LN89@stbi__jpeg:

; 2139 : 
; 2140 :    // convert the id to a symbol
; 2141 :    j->code_bits -= k;

  00d95	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00d9d	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR k$26[rsp]
  00da4	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00daa	2b c1		 sub	 eax, ecx
  00dac	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00db4	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2142 :    j->code_buffer <<= k;

  00dba	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR k$26[rsp]
  00dc1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00dc9	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR tv920[rsp], rcx
  00dd1	0f b6 c8	 movzx	 ecx, al
  00dd4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv920[rsp]
  00ddc	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00de2	d3 e0		 shl	 eax, cl
  00de4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00dec	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2143 :    return h->values[c];

  00df2	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR c$25[rsp]
  00dfa	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR hac$[rsp]
  00e02	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00e0a	89 44 24 70	 mov	 DWORD PTR $T17[rsp], eax
$LN76@stbi__jpeg:

; 2362 :          do {
; 2363 :             int r,s;
; 2364 :             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

  00e0e	8b 44 24 70	 mov	 eax, DWORD PTR $T17[rsp]
  00e12	89 44 24 50	 mov	 DWORD PTR rs$11[rsp], eax

; 2365 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00e16	83 7c 24 50 00	 cmp	 DWORD PTR rs$11[rsp], 0
  00e1b	7d 11		 jge	 SHORT $LN33@stbi__jpeg
  00e1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00e24	e8 00 00 00 00	 call	 stbi__err
  00e29	e9 db 03 00 00	 jmp	 $LN1@stbi__jpeg
$LN33@stbi__jpeg:

; 2366 :             s = rs & 15;

  00e2e	8b 44 24 50	 mov	 eax, DWORD PTR rs$11[rsp]
  00e32	83 e0 0f	 and	 eax, 15
  00e35	89 44 24 4c	 mov	 DWORD PTR s$10[rsp], eax

; 2367 :             r = rs >> 4;

  00e39	8b 44 24 50	 mov	 eax, DWORD PTR rs$11[rsp]
  00e3d	c1 f8 04	 sar	 eax, 4
  00e40	89 44 24 48	 mov	 DWORD PTR r$9[rsp], eax

; 2368 :             if (s == 0) {

  00e44	83 7c 24 4c 00	 cmp	 DWORD PTR s$10[rsp], 0
  00e49	0f 85 5c 01 00
	00		 jne	 $LN34@stbi__jpeg

; 2369 :                if (r < 15) {

  00e4f	83 7c 24 48 0f	 cmp	 DWORD PTR r$9[rsp], 15
  00e54	0f 8d 4c 01 00
	00		 jge	 $LN36@stbi__jpeg

; 2370 :                   j->eob_run = (1 << r) - 1;

  00e5a	8b 44 24 48	 mov	 eax, DWORD PTR r$9[rsp]
  00e5e	b9 01 00 00 00	 mov	 ecx, 1
  00e63	89 8c 24 28 01
	00 00		 mov	 DWORD PTR tv927[rsp], ecx
  00e6a	0f b6 c8	 movzx	 ecx, al
  00e6d	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv927[rsp]
  00e74	d3 e0		 shl	 eax, cl
  00e76	ff c8		 dec	 eax
  00e78	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00e80	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2371 :                   if (r)

  00e86	83 7c 24 48 00	 cmp	 DWORD PTR r$9[rsp], 0
  00e8b	0f 84 0d 01 00
	00		 je	 $LN38@stbi__jpeg

; 2170 :    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  00e91	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00e99	8b 4c 24 48	 mov	 ecx, DWORD PTR r$9[rsp]
  00e9d	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00ea3	7d 0e		 jge	 SHORT $LN91@stbi__jpeg
  00ea5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00ead	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00eb2	90		 npad	 1
$LN91@stbi__jpeg:

; 2171 :    if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00eb3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00ebb	8b 4c 24 48	 mov	 ecx, DWORD PTR r$9[rsp]
  00ebf	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00ec5	7d 0d		 jge	 SHORT $LN92@stbi__jpeg
  00ec7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR $T18[rsp], 0
  00ecf	e9 a6 00 00 00	 jmp	 $LN90@stbi__jpeg
$LN92@stbi__jpeg:

; 2172 :    k = stbi_lrot(j->code_buffer, n);

  00ed4	8b 44 24 48	 mov	 eax, DWORD PTR r$9[rsp]
  00ed8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00ee0	48 89 8c 24 30
	01 00 00	 mov	 QWORD PTR tv936[rsp], rcx
  00ee8	0f b6 c8	 movzx	 ecx, al
  00eeb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv936[rsp]
  00ef3	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00ef9	d3 c0		 rol	 eax, cl
  00efb	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$23[rsp], eax

; 2173 :    j->code_buffer = k & ~stbi__bmask[n];

  00f02	48 63 44 24 48	 movsxd	 rax, DWORD PTR r$9[rsp]
  00f07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00f0e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00f11	f7 d0		 not	 eax
  00f13	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR k$23[rsp]
  00f1a	23 c8		 and	 ecx, eax
  00f1c	8b c1		 mov	 eax, ecx
  00f1e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00f26	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2174 :    k &= stbi__bmask[n];

  00f2c	48 63 44 24 48	 movsxd	 rax, DWORD PTR r$9[rsp]
  00f31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__bmask
  00f38	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00f3b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR k$23[rsp]
  00f42	23 c8		 and	 ecx, eax
  00f44	8b c1		 mov	 eax, ecx
  00f46	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$23[rsp], eax

; 2175 :    j->code_bits -= n;

  00f4d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00f55	8b 4c 24 48	 mov	 ecx, DWORD PTR r$9[rsp]
  00f59	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00f5f	2b c1		 sub	 eax, ecx
  00f61	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00f69	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2176 :    return k;

  00f6f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$23[rsp]
  00f76	89 44 24 74	 mov	 DWORD PTR $T18[rsp], eax
$LN90@stbi__jpeg:

; 2372 :                      j->eob_run += stbi__jpeg_get_bits(j, r);

  00f7a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00f82	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00f88	8b 4c 24 74	 mov	 ecx, DWORD PTR $T18[rsp]
  00f8c	03 c8		 add	 ecx, eax
  00f8e	8b c1		 mov	 eax, ecx
  00f90	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00f98	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN38@stbi__jpeg:

; 2373 :                   r = 64; // force end of block

  00f9e	c7 44 24 48 40
	00 00 00	 mov	 DWORD PTR r$9[rsp], 64	; 00000040H
$LN36@stbi__jpeg:

; 2374 :                } else {
; 2375 :                   // r=15 s=0 should write 16 0s, so we just do
; 2376 :                   // a run of 15 0s and then write s (which is 0),
; 2377 :                   // so we don't have to do anything special here
; 2378 :                }
; 2379 :             } else {

  00fa6	e9 d1 00 00 00	 jmp	 $LN35@stbi__jpeg
$LN34@stbi__jpeg:

; 2380 :                if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

  00fab	83 7c 24 4c 01	 cmp	 DWORD PTR s$10[rsp], 1
  00fb0	74 11		 je	 SHORT $LN39@stbi__jpeg
  00fb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00fb9	e8 00 00 00 00	 call	 stbi__err
  00fbe	e9 46 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN39@stbi__jpeg:

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  00fc3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00fcb	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00fd2	7d 0e		 jge	 SHORT $LN95@stbi__jpeg
  00fd4	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00fdc	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00fe1	90		 npad	 1
$LN95@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  00fe2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00fea	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00ff1	7d 0a		 jge	 SHORT $LN96@stbi__jpeg
  00ff3	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR $T19[rsp], 0
  00ffb	eb 61		 jmp	 SHORT $LN94@stbi__jpeg
$LN96@stbi__jpeg:

; 2184 :    k = j->code_buffer;

  00ffd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01005	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0100b	89 84 24 84 00
	00 00		 mov	 DWORD PTR k$22[rsp], eax

; 2185 :    j->code_buffer <<= 1;

  01012	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0101a	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  01020	d1 e0		 shl	 eax, 1
  01022	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0102a	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2186 :    --j->code_bits;

  01030	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01038	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0103e	ff c8		 dec	 eax
  01040	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  01048	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2187 :    return k & 0x80000000;

  0104e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR k$22[rsp]
  01055	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0105a	89 44 24 78	 mov	 DWORD PTR $T19[rsp], eax
$LN94@stbi__jpeg:

; 2381 :                // sign bit
; 2382 :                if (stbi__jpeg_get_bit(j))

  0105e	8b 44 24 78	 mov	 eax, DWORD PTR $T19[rsp]
  01062	85 c0		 test	 eax, eax
  01064	74 0b		 je	 SHORT $LN40@stbi__jpeg

; 2383 :                   s = bit;

  01066	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  0106b	89 44 24 4c	 mov	 DWORD PTR s$10[rsp], eax
  0106f	eb 0b		 jmp	 SHORT $LN41@stbi__jpeg
$LN40@stbi__jpeg:

; 2384 :                else
; 2385 :                   s = -bit;

  01071	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  01076	f7 d8		 neg	 eax
  01078	89 44 24 4c	 mov	 DWORD PTR s$10[rsp], eax
$LN41@stbi__jpeg:
$LN35@stbi__jpeg:
$LN11@stbi__jpeg:

; 2386 :             }
; 2387 : 
; 2388 :             // advance by r
; 2389 :             while (k <= j->spec_end) {

  0107c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01084	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  0108a	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0108e	0f 8f 58 01 00
	00		 jg	 $LN12@stbi__jpeg

; 2390 :                short *p = &data[stbi__jpeg_dezigzag[k++]];

  01094	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  01099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__jpeg_dezigzag
  010a0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010a4	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  010ac	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  010b0	48 89 44 24 58	 mov	 QWORD PTR p$12[rsp], rax
  010b5	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  010b9	ff c0		 inc	 eax
  010bb	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2391 :                if (*p != 0) {

  010bf	48 8b 44 24 58	 mov	 rax, QWORD PTR p$12[rsp]
  010c4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  010c7	85 c0		 test	 eax, eax
  010c9	0f 84 f8 00 00
	00		 je	 $LN42@stbi__jpeg

; 2182 :    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  010cf	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  010d7	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  010de	7d 0e		 jge	 SHORT $LN99@stbi__jpeg
  010e0	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  010e8	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  010ed	90		 npad	 1
$LN99@stbi__jpeg:

; 2183 :    if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  010ee	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  010f6	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  010fd	7d 0a		 jge	 SHORT $LN100@stbi__jpeg
  010ff	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR $T20[rsp], 0
  01107	eb 61		 jmp	 SHORT $LN98@stbi__jpeg
$LN100@stbi__jpeg:

; 2184 :    k = j->code_buffer;

  01109	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01111	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  01117	89 84 24 80 00
	00 00		 mov	 DWORD PTR k$21[rsp], eax

; 2185 :    j->code_buffer <<= 1;

  0111e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01126	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0112c	d1 e0		 shl	 eax, 1
  0112e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  01136	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2186 :    --j->code_bits;

  0113c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  01144	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0114a	ff c8		 dec	 eax
  0114c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  01154	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2187 :    return k & 0x80000000;

  0115a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR k$21[rsp]
  01161	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  01166	89 44 24 7c	 mov	 DWORD PTR $T20[rsp], eax
$LN98@stbi__jpeg:

; 2392 :                   if (stbi__jpeg_get_bit(j))

  0116a	8b 44 24 7c	 mov	 eax, DWORD PTR $T20[rsp]
  0116e	85 c0		 test	 eax, eax
  01170	74 53		 je	 SHORT $LN44@stbi__jpeg

; 2393 :                      if ((*p & bit)==0) {

  01172	48 8b 44 24 58	 mov	 rax, QWORD PTR p$12[rsp]
  01177	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0117a	0f bf 4c 24 3c	 movsx	 ecx, WORD PTR bit$7[rsp]
  0117f	23 c1		 and	 eax, ecx
  01181	85 c0		 test	 eax, eax
  01183	75 40		 jne	 SHORT $LN45@stbi__jpeg

; 2394 :                         if (*p > 0)

  01185	48 8b 44 24 58	 mov	 rax, QWORD PTR p$12[rsp]
  0118a	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0118d	85 c0		 test	 eax, eax
  0118f	7e 1b		 jle	 SHORT $LN46@stbi__jpeg

; 2395 :                            *p += bit;

  01191	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  01196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$12[rsp]
  0119b	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  0119e	03 c8		 add	 ecx, eax
  011a0	8b c1		 mov	 eax, ecx
  011a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$12[rsp]
  011a7	66 89 01	 mov	 WORD PTR [rcx], ax
  011aa	eb 19		 jmp	 SHORT $LN47@stbi__jpeg
$LN46@stbi__jpeg:

; 2396 :                         else
; 2397 :                            *p -= bit;

  011ac	0f bf 44 24 3c	 movsx	 eax, WORD PTR bit$7[rsp]
  011b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$12[rsp]
  011b6	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  011b9	2b c8		 sub	 ecx, eax
  011bb	8b c1		 mov	 eax, ecx
  011bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$12[rsp]
  011c2	66 89 01	 mov	 WORD PTR [rcx], ax
$LN47@stbi__jpeg:
$LN45@stbi__jpeg:
$LN44@stbi__jpeg:

; 2398 :                      }
; 2399 :                } else {

  011c5	eb 20		 jmp	 SHORT $LN43@stbi__jpeg
$LN42@stbi__jpeg:

; 2400 :                   if (r == 0) {

  011c7	83 7c 24 48 00	 cmp	 DWORD PTR r$9[rsp], 0
  011cc	75 0f		 jne	 SHORT $LN48@stbi__jpeg

; 2401 :                      *p = (short) s;

  011ce	48 8b 44 24 58	 mov	 rax, QWORD PTR p$12[rsp]
  011d3	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR s$10[rsp]
  011d8	66 89 08	 mov	 WORD PTR [rax], cx

; 2402 :                      break;

  011db	eb 0f		 jmp	 SHORT $LN12@stbi__jpeg
$LN48@stbi__jpeg:

; 2403 :                   }
; 2404 :                   --r;

  011dd	8b 44 24 48	 mov	 eax, DWORD PTR r$9[rsp]
  011e1	ff c8		 dec	 eax
  011e3	89 44 24 48	 mov	 DWORD PTR r$9[rsp], eax
$LN43@stbi__jpeg:

; 2405 :                }
; 2406 :             }

  011e7	e9 90 fe ff ff	 jmp	 $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 2407 :          } while (k <= j->spec_end);

  011ec	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  011f4	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  011fa	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  011fe	0f 8e 94 f8 ff
	ff		 jle	 $LN10@stbi__jpeg
$LN27@stbi__jpeg:
$LN15@stbi__jpeg:

; 2408 :       }
; 2409 :    }
; 2410 :    return 1;

  01204	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2411 : }

  01209	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  01210	5f		 pop	 rdi
  01211	c3		 ret	 0
stbi__jpeg_decode_block_prog_ac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
x$ = 48
stbi__clamp PROC

; 2415 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2416 :    // trick to use a single test to catch both cases
; 2417 :    if ((unsigned int) x > 255) {

  00015	81 7c 24 30 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  0001d	76 19		 jbe	 SHORT $LN2@stbi__clam

; 2418 :       if (x < 0) return 0;

  0001f	83 7c 24 30 00	 cmp	 DWORD PTR x$[rsp], 0
  00024	7d 04		 jge	 SHORT $LN3@stbi__clam
  00026	32 c0		 xor	 al, al
  00028	eb 13		 jmp	 SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 2419 :       if (x > 255) return 255;

  0002a	81 7c 24 30 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00032	7e 04		 jle	 SHORT $LN4@stbi__clam
  00034	b0 ff		 mov	 al, 255			; 000000ffH
  00036	eb 05		 jmp	 SHORT $LN1@stbi__clam
$LN4@stbi__clam:
$LN2@stbi__clam:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00038	0f b6 44 24 30	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__clam:

; 2422 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
stbi__clamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
val$ = 64
v$ = 328
o$ = 336
d$ = 344
dcterm$4 = 352
t0$5 = 356
t1$6 = 360
t2$7 = 364
t3$8 = 368
p1$9 = 372
p2$10 = 376
p3$11 = 380
p4$12 = 384
p5$13 = 388
x0$14 = 392
x1$15 = 396
x2$16 = 400
x3$17 = 404
t0$18 = 408
t1$19 = 412
t2$20 = 416
t3$21 = 420
p1$22 = 424
p2$23 = 428
p3$24 = 432
p4$25 = 436
p5$26 = 440
x0$27 = 444
x1$28 = 448
x2$29 = 452
x3$30 = 456
$T31 = 472
$T32 = 473
$T33 = 474
$T34 = 475
$T35 = 476
$T36 = 477
$T37 = 478
$T38 = 479
x$ = 480
x$ = 488
x$ = 496
x$ = 504
x$ = 512
x$ = 520
x$ = 528
x$ = 536
__$ArrayPad$ = 544
out$ = 576
out_stride$ = 584
data$ = 592
stbi__idct_block PROC

; 2466 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  00016	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001b	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR [rsp+576]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00036	48 33 c4	 xor	 rax, rsp
  00039	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2467 :    int i,val[64],*v=val;

  0004d	48 8d 44 24 40	 lea	 rax, QWORD PTR val$[rsp]
  00052	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR v$[rsp], rax

; 2468 :    stbi_uc *o;
; 2469 :    short *d = data;

  0005a	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00062	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR d$[rsp], rax

; 2470 : 
; 2471 :    // columns
; 2472 :    for (i=0; i < 8; ++i,++d, ++v) {

  0006a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00072	eb 32		 jmp	 SHORT $LN4@stbi__idct
$LN2@stbi__idct:
  00074	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00078	ff c0		 inc	 eax
  0007a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0007e	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR d$[rsp]
  00086	48 83 c0 02	 add	 rax, 2
  0008a	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR d$[rsp], rax
  00092	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0009a	48 83 c0 04	 add	 rax, 4
  0009e	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR v$[rsp], rax
$LN4@stbi__idct:
  000a6	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  000ab	0f 8d f4 06 00
	00		 jge	 $LN3@stbi__idct

; 2473 :       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2474 :       if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2475 :            && d[40]==0 && d[48]==0 && d[56]==0) {

  000b1	b8 02 00 00 00	 mov	 eax, 2
  000b6	48 6b c0 08	 imul	 rax, rax, 8
  000ba	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  000c2	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000c6	85 c0		 test	 eax, eax
  000c8	0f 85 aa 01 00
	00		 jne	 $LN8@stbi__idct
  000ce	b8 02 00 00 00	 mov	 eax, 2
  000d3	48 6b c0 10	 imul	 rax, rax, 16
  000d7	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  000df	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000e3	85 c0		 test	 eax, eax
  000e5	0f 85 8d 01 00
	00		 jne	 $LN8@stbi__idct
  000eb	b8 02 00 00 00	 mov	 eax, 2
  000f0	48 6b c0 18	 imul	 rax, rax, 24
  000f4	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  000fc	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00100	85 c0		 test	 eax, eax
  00102	0f 85 70 01 00
	00		 jne	 $LN8@stbi__idct
  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00111	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00119	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0011d	85 c0		 test	 eax, eax
  0011f	0f 85 53 01 00
	00		 jne	 $LN8@stbi__idct
  00125	b8 02 00 00 00	 mov	 eax, 2
  0012a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0012e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00136	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 36 01 00
	00		 jne	 $LN8@stbi__idct
  00142	b8 02 00 00 00	 mov	 eax, 2
  00147	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0014b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00153	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00157	85 c0		 test	 eax, eax
  00159	0f 85 19 01 00
	00		 jne	 $LN8@stbi__idct
  0015f	b8 02 00 00 00	 mov	 eax, 2
  00164	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00168	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00170	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00174	85 c0		 test	 eax, eax
  00176	0f 85 fc 00 00
	00		 jne	 $LN8@stbi__idct

; 2476 :          //    no shortcut                 0     seconds
; 2477 :          //    (1|2|3|4|5|6|7)==0          0     seconds
; 2478 :          //    all separate               -0.047 seconds
; 2479 :          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2480 :          int dcterm = d[0]*4;

  0017c	b8 02 00 00 00	 mov	 eax, 2
  00181	48 6b c0 00	 imul	 rax, rax, 0
  00185	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  0018d	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00191	c1 e0 02	 shl	 eax, 2
  00194	89 84 24 60 01
	00 00		 mov	 DWORD PTR dcterm$4[rsp], eax

; 2481 :          v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

  0019b	b8 04 00 00 00	 mov	 eax, 4
  001a0	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  001a4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001ac	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  001b3	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001b6	b8 04 00 00 00	 mov	 eax, 4
  001bb	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  001bf	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001c7	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  001ce	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001d1	b8 04 00 00 00	 mov	 eax, 4
  001d6	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  001da	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001e2	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  001e9	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001ec	b8 04 00 00 00	 mov	 eax, 4
  001f1	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001f5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001fd	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  00204	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00207	b8 04 00 00 00	 mov	 eax, 4
  0020c	48 6b c0 18	 imul	 rax, rax, 24
  00210	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00218	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  0021f	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00222	b8 04 00 00 00	 mov	 eax, 4
  00227	48 6b c0 10	 imul	 rax, rax, 16
  0022b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00233	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  0023a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0023d	b8 04 00 00 00	 mov	 eax, 4
  00242	48 6b c0 08	 imul	 rax, rax, 8
  00246	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0024e	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  00255	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00258	b8 04 00 00 00	 mov	 eax, 4
  0025d	48 6b c0 00	 imul	 rax, rax, 0
  00261	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00269	8b 94 24 60 01
	00 00		 mov	 edx, DWORD PTR dcterm$4[rsp]
  00270	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 2482 :       } else {

  00273	e9 28 05 00 00	 jmp	 $LN9@stbi__idct
$LN8@stbi__idct:

; 2483 :          STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

  00278	b8 02 00 00 00	 mov	 eax, 2
  0027d	48 6b c0 10	 imul	 rax, rax, 16
  00281	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00289	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0028d	89 84 24 78 01
	00 00		 mov	 DWORD PTR p2$10[rsp], eax
  00294	b8 02 00 00 00	 mov	 eax, 2
  00299	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0029d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  002a5	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  002a9	89 84 24 7c 01
	00 00		 mov	 DWORD PTR p3$11[rsp], eax
  002b0	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR p3$11[rsp]
  002b7	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR p2$10[rsp]
  002be	03 c8		 add	 ecx, eax
  002c0	8b c1		 mov	 eax, ecx
  002c2	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  002c8	89 84 24 74 01
	00 00		 mov	 DWORD PTR p1$9[rsp], eax
  002cf	69 84 24 7c 01
	00 00 71 e2 ff
	ff		 imul	 eax, DWORD PTR p3$11[rsp], -7567 ; ffffffffffffe271H
  002da	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR p1$9[rsp]
  002e1	03 c8		 add	 ecx, eax
  002e3	8b c1		 mov	 eax, ecx
  002e5	89 84 24 6c 01
	00 00		 mov	 DWORD PTR t2$7[rsp], eax
  002ec	69 84 24 78 01
	00 00 3f 0c 00
	00		 imul	 eax, DWORD PTR p2$10[rsp], 3135 ; 00000c3fH
  002f7	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR p1$9[rsp]
  002fe	03 c8		 add	 ecx, eax
  00300	8b c1		 mov	 eax, ecx
  00302	89 84 24 70 01
	00 00		 mov	 DWORD PTR t3$8[rsp], eax
  00309	b8 02 00 00 00	 mov	 eax, 2
  0030e	48 6b c0 00	 imul	 rax, rax, 0
  00312	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  0031a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0031e	89 84 24 78 01
	00 00		 mov	 DWORD PTR p2$10[rsp], eax
  00325	b8 02 00 00 00	 mov	 eax, 2
  0032a	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0032e	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00336	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0033a	89 84 24 7c 01
	00 00		 mov	 DWORD PTR p3$11[rsp], eax
  00341	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR p3$11[rsp]
  00348	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR p2$10[rsp]
  0034f	03 c8		 add	 ecx, eax
  00351	8b c1		 mov	 eax, ecx
  00353	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00359	89 84 24 64 01
	00 00		 mov	 DWORD PTR t0$5[rsp], eax
  00360	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR p3$11[rsp]
  00367	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR p2$10[rsp]
  0036e	2b c8		 sub	 ecx, eax
  00370	8b c1		 mov	 eax, ecx
  00372	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00378	89 84 24 68 01
	00 00		 mov	 DWORD PTR t1$6[rsp], eax
  0037f	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  00386	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR t0$5[rsp]
  0038d	03 c8		 add	 ecx, eax
  0038f	8b c1		 mov	 eax, ecx
  00391	89 84 24 88 01
	00 00		 mov	 DWORD PTR x0$14[rsp], eax
  00398	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  0039f	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR t0$5[rsp]
  003a6	2b c8		 sub	 ecx, eax
  003a8	8b c1		 mov	 eax, ecx
  003aa	89 84 24 94 01
	00 00		 mov	 DWORD PTR x3$17[rsp], eax
  003b1	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  003b8	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR t1$6[rsp]
  003bf	03 c8		 add	 ecx, eax
  003c1	8b c1		 mov	 eax, ecx
  003c3	89 84 24 8c 01
	00 00		 mov	 DWORD PTR x1$15[rsp], eax
  003ca	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  003d1	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR t1$6[rsp]
  003d8	2b c8		 sub	 ecx, eax
  003da	8b c1		 mov	 eax, ecx
  003dc	89 84 24 90 01
	00 00		 mov	 DWORD PTR x2$16[rsp], eax
  003e3	b8 02 00 00 00	 mov	 eax, 2
  003e8	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  003ec	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  003f4	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  003f8	89 84 24 64 01
	00 00		 mov	 DWORD PTR t0$5[rsp], eax
  003ff	b8 02 00 00 00	 mov	 eax, 2
  00404	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00408	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00410	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00414	89 84 24 68 01
	00 00		 mov	 DWORD PTR t1$6[rsp], eax
  0041b	b8 02 00 00 00	 mov	 eax, 2
  00420	48 6b c0 18	 imul	 rax, rax, 24
  00424	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  0042c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00430	89 84 24 6c 01
	00 00		 mov	 DWORD PTR t2$7[rsp], eax
  00437	b8 02 00 00 00	 mov	 eax, 2
  0043c	48 6b c0 08	 imul	 rax, rax, 8
  00440	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR d$[rsp]
  00448	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0044c	89 84 24 70 01
	00 00		 mov	 DWORD PTR t3$8[rsp], eax
  00453	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  0045a	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR t0$5[rsp]
  00461	03 c8		 add	 ecx, eax
  00463	8b c1		 mov	 eax, ecx
  00465	89 84 24 7c 01
	00 00		 mov	 DWORD PTR p3$11[rsp], eax
  0046c	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  00473	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR t1$6[rsp]
  0047a	03 c8		 add	 ecx, eax
  0047c	8b c1		 mov	 eax, ecx
  0047e	89 84 24 80 01
	00 00		 mov	 DWORD PTR p4$12[rsp], eax
  00485	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  0048c	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR t0$5[rsp]
  00493	03 c8		 add	 ecx, eax
  00495	8b c1		 mov	 eax, ecx
  00497	89 84 24 74 01
	00 00		 mov	 DWORD PTR p1$9[rsp], eax
  0049e	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  004a5	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR t1$6[rsp]
  004ac	03 c8		 add	 ecx, eax
  004ae	8b c1		 mov	 eax, ecx
  004b0	89 84 24 78 01
	00 00		 mov	 DWORD PTR p2$10[rsp], eax
  004b7	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR p4$12[rsp]
  004be	8b 8c 24 7c 01
	00 00		 mov	 ecx, DWORD PTR p3$11[rsp]
  004c5	03 c8		 add	 ecx, eax
  004c7	8b c1		 mov	 eax, ecx
  004c9	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  004cf	89 84 24 84 01
	00 00		 mov	 DWORD PTR p5$13[rsp], eax
  004d6	69 84 24 64 01
	00 00 c7 04 00
	00		 imul	 eax, DWORD PTR t0$5[rsp], 1223 ; 000004c7H
  004e1	89 84 24 64 01
	00 00		 mov	 DWORD PTR t0$5[rsp], eax
  004e8	69 84 24 68 01
	00 00 da 20 00
	00		 imul	 eax, DWORD PTR t1$6[rsp], 8410 ; 000020daH
  004f3	89 84 24 68 01
	00 00		 mov	 DWORD PTR t1$6[rsp], eax
  004fa	69 84 24 6c 01
	00 00 2a 31 00
	00		 imul	 eax, DWORD PTR t2$7[rsp], 12586 ; 0000312aH
  00505	89 84 24 6c 01
	00 00		 mov	 DWORD PTR t2$7[rsp], eax
  0050c	69 84 24 70 01
	00 00 05 18 00
	00		 imul	 eax, DWORD PTR t3$8[rsp], 6149 ; 00001805H
  00517	89 84 24 70 01
	00 00		 mov	 DWORD PTR t3$8[rsp], eax
  0051e	69 84 24 74 01
	00 00 9b f1 ff
	ff		 imul	 eax, DWORD PTR p1$9[rsp], -3685 ; fffffffffffff19bH
  00529	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR p5$13[rsp]
  00530	03 c8		 add	 ecx, eax
  00532	8b c1		 mov	 eax, ecx
  00534	89 84 24 74 01
	00 00		 mov	 DWORD PTR p1$9[rsp], eax
  0053b	69 84 24 78 01
	00 00 ff d6 ff
	ff		 imul	 eax, DWORD PTR p2$10[rsp], -10497 ; ffffffffffffd6ffH
  00546	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR p5$13[rsp]
  0054d	03 c8		 add	 ecx, eax
  0054f	8b c1		 mov	 eax, ecx
  00551	89 84 24 78 01
	00 00		 mov	 DWORD PTR p2$10[rsp], eax
  00558	69 84 24 7c 01
	00 00 9e e0 ff
	ff		 imul	 eax, DWORD PTR p3$11[rsp], -8034 ; ffffffffffffe09eH
  00563	89 84 24 7c 01
	00 00		 mov	 DWORD PTR p3$11[rsp], eax
  0056a	69 84 24 80 01
	00 00 c3 f9 ff
	ff		 imul	 eax, DWORD PTR p4$12[rsp], -1597 ; fffffffffffff9c3H
  00575	89 84 24 80 01
	00 00		 mov	 DWORD PTR p4$12[rsp], eax
  0057c	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR p4$12[rsp]
  00583	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR p1$9[rsp]
  0058a	03 c8		 add	 ecx, eax
  0058c	8b c1		 mov	 eax, ecx
  0058e	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR t3$8[rsp]
  00595	03 c8		 add	 ecx, eax
  00597	8b c1		 mov	 eax, ecx
  00599	89 84 24 70 01
	00 00		 mov	 DWORD PTR t3$8[rsp], eax
  005a0	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR p3$11[rsp]
  005a7	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR p2$10[rsp]
  005ae	03 c8		 add	 ecx, eax
  005b0	8b c1		 mov	 eax, ecx
  005b2	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR t2$7[rsp]
  005b9	03 c8		 add	 ecx, eax
  005bb	8b c1		 mov	 eax, ecx
  005bd	89 84 24 6c 01
	00 00		 mov	 DWORD PTR t2$7[rsp], eax
  005c4	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR p4$12[rsp]
  005cb	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR p2$10[rsp]
  005d2	03 c8		 add	 ecx, eax
  005d4	8b c1		 mov	 eax, ecx
  005d6	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR t1$6[rsp]
  005dd	03 c8		 add	 ecx, eax
  005df	8b c1		 mov	 eax, ecx
  005e1	89 84 24 68 01
	00 00		 mov	 DWORD PTR t1$6[rsp], eax
  005e8	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR p3$11[rsp]
  005ef	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR p1$9[rsp]
  005f6	03 c8		 add	 ecx, eax
  005f8	8b c1		 mov	 eax, ecx
  005fa	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR t0$5[rsp]
  00601	03 c8		 add	 ecx, eax
  00603	8b c1		 mov	 eax, ecx
  00605	89 84 24 64 01
	00 00		 mov	 DWORD PTR t0$5[rsp], eax

; 2484 :          // constants scaled things up by 1<<12; let's bring them back
; 2485 :          // down, but keep 2 extra bits of precision
; 2486 :          x0 += 512; x1 += 512; x2 += 512; x3 += 512;

  0060c	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR x0$14[rsp]
  00613	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00618	89 84 24 88 01
	00 00		 mov	 DWORD PTR x0$14[rsp], eax
  0061f	8b 84 24 8c 01
	00 00		 mov	 eax, DWORD PTR x1$15[rsp]
  00626	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0062b	89 84 24 8c 01
	00 00		 mov	 DWORD PTR x1$15[rsp], eax
  00632	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR x2$16[rsp]
  00639	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0063e	89 84 24 90 01
	00 00		 mov	 DWORD PTR x2$16[rsp], eax
  00645	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR x3$17[rsp]
  0064c	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00651	89 84 24 94 01
	00 00		 mov	 DWORD PTR x3$17[rsp], eax

; 2487 :          v[ 0] = (x0+t3) >> 10;

  00658	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  0065f	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR x0$14[rsp]
  00666	03 c8		 add	 ecx, eax
  00668	8b c1		 mov	 eax, ecx
  0066a	c1 f8 0a	 sar	 eax, 10
  0066d	b9 04 00 00 00	 mov	 ecx, 4
  00672	48 6b c9 00	 imul	 rcx, rcx, 0
  00676	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  0067e	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2488 :          v[56] = (x0-t3) >> 10;

  00681	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR t3$8[rsp]
  00688	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR x0$14[rsp]
  0068f	2b c8		 sub	 ecx, eax
  00691	8b c1		 mov	 eax, ecx
  00693	c1 f8 0a	 sar	 eax, 10
  00696	b9 04 00 00 00	 mov	 ecx, 4
  0069b	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0069f	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  006a7	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2489 :          v[ 8] = (x1+t2) >> 10;

  006aa	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  006b1	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR x1$15[rsp]
  006b8	03 c8		 add	 ecx, eax
  006ba	8b c1		 mov	 eax, ecx
  006bc	c1 f8 0a	 sar	 eax, 10
  006bf	b9 04 00 00 00	 mov	 ecx, 4
  006c4	48 6b c9 08	 imul	 rcx, rcx, 8
  006c8	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  006d0	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2490 :          v[48] = (x1-t2) >> 10;

  006d3	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR t2$7[rsp]
  006da	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR x1$15[rsp]
  006e1	2b c8		 sub	 ecx, eax
  006e3	8b c1		 mov	 eax, ecx
  006e5	c1 f8 0a	 sar	 eax, 10
  006e8	b9 04 00 00 00	 mov	 ecx, 4
  006ed	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  006f1	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  006f9	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2491 :          v[16] = (x2+t1) >> 10;

  006fc	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR t1$6[rsp]
  00703	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR x2$16[rsp]
  0070a	03 c8		 add	 ecx, eax
  0070c	8b c1		 mov	 eax, ecx
  0070e	c1 f8 0a	 sar	 eax, 10
  00711	b9 04 00 00 00	 mov	 ecx, 4
  00716	48 6b c9 10	 imul	 rcx, rcx, 16
  0071a	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  00722	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2492 :          v[40] = (x2-t1) >> 10;

  00725	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR t1$6[rsp]
  0072c	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR x2$16[rsp]
  00733	2b c8		 sub	 ecx, eax
  00735	8b c1		 mov	 eax, ecx
  00737	c1 f8 0a	 sar	 eax, 10
  0073a	b9 04 00 00 00	 mov	 ecx, 4
  0073f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  00743	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  0074b	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2493 :          v[24] = (x3+t0) >> 10;

  0074e	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR t0$5[rsp]
  00755	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR x3$17[rsp]
  0075c	03 c8		 add	 ecx, eax
  0075e	8b c1		 mov	 eax, ecx
  00760	c1 f8 0a	 sar	 eax, 10
  00763	b9 04 00 00 00	 mov	 ecx, 4
  00768	48 6b c9 18	 imul	 rcx, rcx, 24
  0076c	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  00774	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2494 :          v[32] = (x3-t0) >> 10;

  00777	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR t0$5[rsp]
  0077e	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR x3$17[rsp]
  00785	2b c8		 sub	 ecx, eax
  00787	8b c1		 mov	 eax, ecx
  00789	c1 f8 0a	 sar	 eax, 10
  0078c	b9 04 00 00 00	 mov	 ecx, 4
  00791	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00795	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  0079d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN9@stbi__idct:

; 2495 :       }
; 2496 :    }

  007a0	e9 cf f8 ff ff	 jmp	 $LN2@stbi__idct
$LN3@stbi__idct:

; 2497 : 
; 2498 :    for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

  007a5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007ad	48 8d 44 24 40	 lea	 rax, QWORD PTR val$[rsp]
  007b2	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR v$[rsp], rax
  007ba	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR out$[rsp]
  007c2	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR o$[rsp], rax
  007ca	eb 3c		 jmp	 SHORT $LN7@stbi__idct
$LN5@stbi__idct:
  007cc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  007d0	ff c0		 inc	 eax
  007d2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007d6	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR v$[rsp]
  007de	48 83 c0 20	 add	 rax, 32			; 00000020H
  007e2	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR v$[rsp], rax
  007ea	48 63 84 24 48
	02 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  007f2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  007fa	48 03 c8	 add	 rcx, rax
  007fd	48 8b c1	 mov	 rax, rcx
  00800	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR o$[rsp], rax
$LN7@stbi__idct:
  00808	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  0080d	0f 8d d5 07 00
	00		 jge	 $LN6@stbi__idct

; 2499 :       // no fast case since the first 1D IDCT spread components out
; 2500 :       STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

  00813	b8 04 00 00 00	 mov	 eax, 4
  00818	48 6b c0 02	 imul	 rax, rax, 2
  0081c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00824	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00827	89 84 24 ac 01
	00 00		 mov	 DWORD PTR p2$23[rsp], eax
  0082e	b8 04 00 00 00	 mov	 eax, 4
  00833	48 6b c0 06	 imul	 rax, rax, 6
  00837	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0083f	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00842	89 84 24 b0 01
	00 00		 mov	 DWORD PTR p3$24[rsp], eax
  00849	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR p3$24[rsp]
  00850	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR p2$23[rsp]
  00857	03 c8		 add	 ecx, eax
  00859	8b c1		 mov	 eax, ecx
  0085b	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  00861	89 84 24 a8 01
	00 00		 mov	 DWORD PTR p1$22[rsp], eax
  00868	69 84 24 b0 01
	00 00 71 e2 ff
	ff		 imul	 eax, DWORD PTR p3$24[rsp], -7567 ; ffffffffffffe271H
  00873	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR p1$22[rsp]
  0087a	03 c8		 add	 ecx, eax
  0087c	8b c1		 mov	 eax, ecx
  0087e	89 84 24 a0 01
	00 00		 mov	 DWORD PTR t2$20[rsp], eax
  00885	69 84 24 ac 01
	00 00 3f 0c 00
	00		 imul	 eax, DWORD PTR p2$23[rsp], 3135 ; 00000c3fH
  00890	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR p1$22[rsp]
  00897	03 c8		 add	 ecx, eax
  00899	8b c1		 mov	 eax, ecx
  0089b	89 84 24 a4 01
	00 00		 mov	 DWORD PTR t3$21[rsp], eax
  008a2	b8 04 00 00 00	 mov	 eax, 4
  008a7	48 6b c0 00	 imul	 rax, rax, 0
  008ab	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  008b3	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  008b6	89 84 24 ac 01
	00 00		 mov	 DWORD PTR p2$23[rsp], eax
  008bd	b8 04 00 00 00	 mov	 eax, 4
  008c2	48 6b c0 04	 imul	 rax, rax, 4
  008c6	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  008ce	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  008d1	89 84 24 b0 01
	00 00		 mov	 DWORD PTR p3$24[rsp], eax
  008d8	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR p3$24[rsp]
  008df	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR p2$23[rsp]
  008e6	03 c8		 add	 ecx, eax
  008e8	8b c1		 mov	 eax, ecx
  008ea	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  008f0	89 84 24 98 01
	00 00		 mov	 DWORD PTR t0$18[rsp], eax
  008f7	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR p3$24[rsp]
  008fe	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR p2$23[rsp]
  00905	2b c8		 sub	 ecx, eax
  00907	8b c1		 mov	 eax, ecx
  00909	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  0090f	89 84 24 9c 01
	00 00		 mov	 DWORD PTR t1$19[rsp], eax
  00916	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  0091d	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR t0$18[rsp]
  00924	03 c8		 add	 ecx, eax
  00926	8b c1		 mov	 eax, ecx
  00928	89 84 24 bc 01
	00 00		 mov	 DWORD PTR x0$27[rsp], eax
  0092f	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  00936	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR t0$18[rsp]
  0093d	2b c8		 sub	 ecx, eax
  0093f	8b c1		 mov	 eax, ecx
  00941	89 84 24 c8 01
	00 00		 mov	 DWORD PTR x3$30[rsp], eax
  00948	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  0094f	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR t1$19[rsp]
  00956	03 c8		 add	 ecx, eax
  00958	8b c1		 mov	 eax, ecx
  0095a	89 84 24 c0 01
	00 00		 mov	 DWORD PTR x1$28[rsp], eax
  00961	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  00968	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR t1$19[rsp]
  0096f	2b c8		 sub	 ecx, eax
  00971	8b c1		 mov	 eax, ecx
  00973	89 84 24 c4 01
	00 00		 mov	 DWORD PTR x2$29[rsp], eax
  0097a	b8 04 00 00 00	 mov	 eax, 4
  0097f	48 6b c0 07	 imul	 rax, rax, 7
  00983	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0098b	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0098e	89 84 24 98 01
	00 00		 mov	 DWORD PTR t0$18[rsp], eax
  00995	b8 04 00 00 00	 mov	 eax, 4
  0099a	48 6b c0 05	 imul	 rax, rax, 5
  0099e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  009a6	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  009a9	89 84 24 9c 01
	00 00		 mov	 DWORD PTR t1$19[rsp], eax
  009b0	b8 04 00 00 00	 mov	 eax, 4
  009b5	48 6b c0 03	 imul	 rax, rax, 3
  009b9	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  009c1	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  009c4	89 84 24 a0 01
	00 00		 mov	 DWORD PTR t2$20[rsp], eax
  009cb	b8 04 00 00 00	 mov	 eax, 4
  009d0	48 6b c0 01	 imul	 rax, rax, 1
  009d4	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  009dc	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  009df	89 84 24 a4 01
	00 00		 mov	 DWORD PTR t3$21[rsp], eax
  009e6	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  009ed	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR t0$18[rsp]
  009f4	03 c8		 add	 ecx, eax
  009f6	8b c1		 mov	 eax, ecx
  009f8	89 84 24 b0 01
	00 00		 mov	 DWORD PTR p3$24[rsp], eax
  009ff	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  00a06	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR t1$19[rsp]
  00a0d	03 c8		 add	 ecx, eax
  00a0f	8b c1		 mov	 eax, ecx
  00a11	89 84 24 b4 01
	00 00		 mov	 DWORD PTR p4$25[rsp], eax
  00a18	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  00a1f	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR t0$18[rsp]
  00a26	03 c8		 add	 ecx, eax
  00a28	8b c1		 mov	 eax, ecx
  00a2a	89 84 24 a8 01
	00 00		 mov	 DWORD PTR p1$22[rsp], eax
  00a31	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  00a38	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR t1$19[rsp]
  00a3f	03 c8		 add	 ecx, eax
  00a41	8b c1		 mov	 eax, ecx
  00a43	89 84 24 ac 01
	00 00		 mov	 DWORD PTR p2$23[rsp], eax
  00a4a	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR p4$25[rsp]
  00a51	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR p3$24[rsp]
  00a58	03 c8		 add	 ecx, eax
  00a5a	8b c1		 mov	 eax, ecx
  00a5c	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  00a62	89 84 24 b8 01
	00 00		 mov	 DWORD PTR p5$26[rsp], eax
  00a69	69 84 24 98 01
	00 00 c7 04 00
	00		 imul	 eax, DWORD PTR t0$18[rsp], 1223 ; 000004c7H
  00a74	89 84 24 98 01
	00 00		 mov	 DWORD PTR t0$18[rsp], eax
  00a7b	69 84 24 9c 01
	00 00 da 20 00
	00		 imul	 eax, DWORD PTR t1$19[rsp], 8410 ; 000020daH
  00a86	89 84 24 9c 01
	00 00		 mov	 DWORD PTR t1$19[rsp], eax
  00a8d	69 84 24 a0 01
	00 00 2a 31 00
	00		 imul	 eax, DWORD PTR t2$20[rsp], 12586 ; 0000312aH
  00a98	89 84 24 a0 01
	00 00		 mov	 DWORD PTR t2$20[rsp], eax
  00a9f	69 84 24 a4 01
	00 00 05 18 00
	00		 imul	 eax, DWORD PTR t3$21[rsp], 6149 ; 00001805H
  00aaa	89 84 24 a4 01
	00 00		 mov	 DWORD PTR t3$21[rsp], eax
  00ab1	69 84 24 a8 01
	00 00 9b f1 ff
	ff		 imul	 eax, DWORD PTR p1$22[rsp], -3685 ; fffffffffffff19bH
  00abc	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  00ac3	03 c8		 add	 ecx, eax
  00ac5	8b c1		 mov	 eax, ecx
  00ac7	89 84 24 a8 01
	00 00		 mov	 DWORD PTR p1$22[rsp], eax
  00ace	69 84 24 ac 01
	00 00 ff d6 ff
	ff		 imul	 eax, DWORD PTR p2$23[rsp], -10497 ; ffffffffffffd6ffH
  00ad9	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  00ae0	03 c8		 add	 ecx, eax
  00ae2	8b c1		 mov	 eax, ecx
  00ae4	89 84 24 ac 01
	00 00		 mov	 DWORD PTR p2$23[rsp], eax
  00aeb	69 84 24 b0 01
	00 00 9e e0 ff
	ff		 imul	 eax, DWORD PTR p3$24[rsp], -8034 ; ffffffffffffe09eH
  00af6	89 84 24 b0 01
	00 00		 mov	 DWORD PTR p3$24[rsp], eax
  00afd	69 84 24 b4 01
	00 00 c3 f9 ff
	ff		 imul	 eax, DWORD PTR p4$25[rsp], -1597 ; fffffffffffff9c3H
  00b08	89 84 24 b4 01
	00 00		 mov	 DWORD PTR p4$25[rsp], eax
  00b0f	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR p4$25[rsp]
  00b16	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR p1$22[rsp]
  00b1d	03 c8		 add	 ecx, eax
  00b1f	8b c1		 mov	 eax, ecx
  00b21	8b 8c 24 a4 01
	00 00		 mov	 ecx, DWORD PTR t3$21[rsp]
  00b28	03 c8		 add	 ecx, eax
  00b2a	8b c1		 mov	 eax, ecx
  00b2c	89 84 24 a4 01
	00 00		 mov	 DWORD PTR t3$21[rsp], eax
  00b33	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR p3$24[rsp]
  00b3a	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR p2$23[rsp]
  00b41	03 c8		 add	 ecx, eax
  00b43	8b c1		 mov	 eax, ecx
  00b45	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR t2$20[rsp]
  00b4c	03 c8		 add	 ecx, eax
  00b4e	8b c1		 mov	 eax, ecx
  00b50	89 84 24 a0 01
	00 00		 mov	 DWORD PTR t2$20[rsp], eax
  00b57	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR p4$25[rsp]
  00b5e	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR p2$23[rsp]
  00b65	03 c8		 add	 ecx, eax
  00b67	8b c1		 mov	 eax, ecx
  00b69	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR t1$19[rsp]
  00b70	03 c8		 add	 ecx, eax
  00b72	8b c1		 mov	 eax, ecx
  00b74	89 84 24 9c 01
	00 00		 mov	 DWORD PTR t1$19[rsp], eax
  00b7b	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR p3$24[rsp]
  00b82	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR p1$22[rsp]
  00b89	03 c8		 add	 ecx, eax
  00b8b	8b c1		 mov	 eax, ecx
  00b8d	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR t0$18[rsp]
  00b94	03 c8		 add	 ecx, eax
  00b96	8b c1		 mov	 eax, ecx
  00b98	89 84 24 98 01
	00 00		 mov	 DWORD PTR t0$18[rsp], eax

; 2501 :       // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2502 :       // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2503 :       // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2504 :       // so we want to round that, which means adding 0.5 * 1<<17,
; 2505 :       // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2506 :       // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2507 :       x0 += 65536 + (128<<17);

  00b9f	8b 84 24 bc 01
	00 00		 mov	 eax, DWORD PTR x0$27[rsp]
  00ba6	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00bab	89 84 24 bc 01
	00 00		 mov	 DWORD PTR x0$27[rsp], eax

; 2508 :       x1 += 65536 + (128<<17);

  00bb2	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR x1$28[rsp]
  00bb9	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00bbe	89 84 24 c0 01
	00 00		 mov	 DWORD PTR x1$28[rsp], eax

; 2509 :       x2 += 65536 + (128<<17);

  00bc5	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR x2$29[rsp]
  00bcc	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00bd1	89 84 24 c4 01
	00 00		 mov	 DWORD PTR x2$29[rsp], eax

; 2510 :       x3 += 65536 + (128<<17);

  00bd8	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR x3$30[rsp]
  00bdf	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00be4	89 84 24 c8 01
	00 00		 mov	 DWORD PTR x3$30[rsp], eax

; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);

  00beb	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  00bf2	8b 8c 24 bc 01
	00 00		 mov	 ecx, DWORD PTR x0$27[rsp]
  00bf9	03 c8		 add	 ecx, eax
  00bfb	8b c1		 mov	 eax, ecx
  00bfd	c1 f8 11	 sar	 eax, 17
  00c00	89 84 24 18 02
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00c07	81 bc 24 18 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00c12	76 2b		 jbe	 SHORT $LN12@stbi__idct

; 2418 :       if (x < 0) return 0;

  00c14	83 bc 24 18 02
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00c1c	7d 0a		 jge	 SHORT $LN13@stbi__idct
  00c1e	c6 84 24 d8 01
	00 00 00	 mov	 BYTE PTR $T31[rsp], 0
  00c26	eb 26		 jmp	 SHORT $LN11@stbi__idct
$LN13@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00c28	81 bc 24 18 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00c33	7e 0a		 jle	 SHORT $LN14@stbi__idct
  00c35	c6 84 24 d8 01
	00 00 ff	 mov	 BYTE PTR $T31[rsp], 255	; 000000ffH
  00c3d	eb 0f		 jmp	 SHORT $LN11@stbi__idct
$LN14@stbi__idct:
$LN12@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00c3f	0f b6 84 24 18
	02 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00c47	88 84 24 d8 01
	00 00		 mov	 BYTE PTR $T31[rsp], al
$LN11@stbi__idct:

; 2511 :       // tried computing the shifts into temps, or'ing the temps to see
; 2512 :       // if any were out of range, but that was slower
; 2513 :       o[0] = stbi__clamp((x0+t3) >> 17);

  00c4e	0f b6 84 24 d8
	01 00 00	 movzx	 eax, BYTE PTR $T31[rsp]
  00c56	b9 01 00 00 00	 mov	 ecx, 1
  00c5b	48 6b c9 00	 imul	 rcx, rcx, 0
  00c5f	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00c67	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);

  00c6a	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR t3$21[rsp]
  00c71	8b 8c 24 bc 01
	00 00		 mov	 ecx, DWORD PTR x0$27[rsp]
  00c78	2b c8		 sub	 ecx, eax
  00c7a	8b c1		 mov	 eax, ecx
  00c7c	c1 f8 11	 sar	 eax, 17
  00c7f	89 84 24 10 02
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00c86	81 bc 24 10 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00c91	76 2b		 jbe	 SHORT $LN17@stbi__idct

; 2418 :       if (x < 0) return 0;

  00c93	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00c9b	7d 0a		 jge	 SHORT $LN18@stbi__idct
  00c9d	c6 84 24 d9 01
	00 00 00	 mov	 BYTE PTR $T32[rsp], 0
  00ca5	eb 26		 jmp	 SHORT $LN16@stbi__idct
$LN18@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00ca7	81 bc 24 10 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00cb2	7e 0a		 jle	 SHORT $LN19@stbi__idct
  00cb4	c6 84 24 d9 01
	00 00 ff	 mov	 BYTE PTR $T32[rsp], 255	; 000000ffH
  00cbc	eb 0f		 jmp	 SHORT $LN16@stbi__idct
$LN19@stbi__idct:
$LN17@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00cbe	0f b6 84 24 10
	02 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00cc6	88 84 24 d9 01
	00 00		 mov	 BYTE PTR $T32[rsp], al
$LN16@stbi__idct:

; 2514 :       o[7] = stbi__clamp((x0-t3) >> 17);

  00ccd	0f b6 84 24 d9
	01 00 00	 movzx	 eax, BYTE PTR $T32[rsp]
  00cd5	b9 01 00 00 00	 mov	 ecx, 1
  00cda	48 6b c9 07	 imul	 rcx, rcx, 7
  00cde	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00ce6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);

  00ce9	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  00cf0	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR x1$28[rsp]
  00cf7	03 c8		 add	 ecx, eax
  00cf9	8b c1		 mov	 eax, ecx
  00cfb	c1 f8 11	 sar	 eax, 17
  00cfe	89 84 24 08 02
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00d05	81 bc 24 08 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00d10	76 2b		 jbe	 SHORT $LN22@stbi__idct

; 2418 :       if (x < 0) return 0;

  00d12	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00d1a	7d 0a		 jge	 SHORT $LN23@stbi__idct
  00d1c	c6 84 24 da 01
	00 00 00	 mov	 BYTE PTR $T33[rsp], 0
  00d24	eb 26		 jmp	 SHORT $LN21@stbi__idct
$LN23@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00d26	81 bc 24 08 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00d31	7e 0a		 jle	 SHORT $LN24@stbi__idct
  00d33	c6 84 24 da 01
	00 00 ff	 mov	 BYTE PTR $T33[rsp], 255	; 000000ffH
  00d3b	eb 0f		 jmp	 SHORT $LN21@stbi__idct
$LN24@stbi__idct:
$LN22@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00d3d	0f b6 84 24 08
	02 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00d45	88 84 24 da 01
	00 00		 mov	 BYTE PTR $T33[rsp], al
$LN21@stbi__idct:

; 2515 :       o[1] = stbi__clamp((x1+t2) >> 17);

  00d4c	0f b6 84 24 da
	01 00 00	 movzx	 eax, BYTE PTR $T33[rsp]
  00d54	b9 01 00 00 00	 mov	 ecx, 1
  00d59	48 6b c9 01	 imul	 rcx, rcx, 1
  00d5d	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00d65	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);

  00d68	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR t2$20[rsp]
  00d6f	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR x1$28[rsp]
  00d76	2b c8		 sub	 ecx, eax
  00d78	8b c1		 mov	 eax, ecx
  00d7a	c1 f8 11	 sar	 eax, 17
  00d7d	89 84 24 00 02
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00d84	81 bc 24 00 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00d8f	76 2b		 jbe	 SHORT $LN27@stbi__idct

; 2418 :       if (x < 0) return 0;

  00d91	83 bc 24 00 02
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00d99	7d 0a		 jge	 SHORT $LN28@stbi__idct
  00d9b	c6 84 24 db 01
	00 00 00	 mov	 BYTE PTR $T34[rsp], 0
  00da3	eb 26		 jmp	 SHORT $LN26@stbi__idct
$LN28@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00da5	81 bc 24 00 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00db0	7e 0a		 jle	 SHORT $LN29@stbi__idct
  00db2	c6 84 24 db 01
	00 00 ff	 mov	 BYTE PTR $T34[rsp], 255	; 000000ffH
  00dba	eb 0f		 jmp	 SHORT $LN26@stbi__idct
$LN29@stbi__idct:
$LN27@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00dbc	0f b6 84 24 00
	02 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00dc4	88 84 24 db 01
	00 00		 mov	 BYTE PTR $T34[rsp], al
$LN26@stbi__idct:

; 2516 :       o[6] = stbi__clamp((x1-t2) >> 17);

  00dcb	0f b6 84 24 db
	01 00 00	 movzx	 eax, BYTE PTR $T34[rsp]
  00dd3	b9 01 00 00 00	 mov	 ecx, 1
  00dd8	48 6b c9 06	 imul	 rcx, rcx, 6
  00ddc	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00de4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);

  00de7	8b 84 24 9c 01
	00 00		 mov	 eax, DWORD PTR t1$19[rsp]
  00dee	8b 8c 24 c4 01
	00 00		 mov	 ecx, DWORD PTR x2$29[rsp]
  00df5	03 c8		 add	 ecx, eax
  00df7	8b c1		 mov	 eax, ecx
  00df9	c1 f8 11	 sar	 eax, 17
  00dfc	89 84 24 f8 01
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00e03	81 bc 24 f8 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00e0e	76 2b		 jbe	 SHORT $LN32@stbi__idct

; 2418 :       if (x < 0) return 0;

  00e10	83 bc 24 f8 01
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00e18	7d 0a		 jge	 SHORT $LN33@stbi__idct
  00e1a	c6 84 24 dc 01
	00 00 00	 mov	 BYTE PTR $T35[rsp], 0
  00e22	eb 26		 jmp	 SHORT $LN31@stbi__idct
$LN33@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00e24	81 bc 24 f8 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00e2f	7e 0a		 jle	 SHORT $LN34@stbi__idct
  00e31	c6 84 24 dc 01
	00 00 ff	 mov	 BYTE PTR $T35[rsp], 255	; 000000ffH
  00e39	eb 0f		 jmp	 SHORT $LN31@stbi__idct
$LN34@stbi__idct:
$LN32@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00e3b	0f b6 84 24 f8
	01 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00e43	88 84 24 dc 01
	00 00		 mov	 BYTE PTR $T35[rsp], al
$LN31@stbi__idct:

; 2517 :       o[2] = stbi__clamp((x2+t1) >> 17);

  00e4a	0f b6 84 24 dc
	01 00 00	 movzx	 eax, BYTE PTR $T35[rsp]
  00e52	b9 01 00 00 00	 mov	 ecx, 1
  00e57	48 6b c9 02	 imul	 rcx, rcx, 2
  00e5b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00e63	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);

  00e66	8b 84 24 9c 01
	00 00		 mov	 eax, DWORD PTR t1$19[rsp]
  00e6d	8b 8c 24 c4 01
	00 00		 mov	 ecx, DWORD PTR x2$29[rsp]
  00e74	2b c8		 sub	 ecx, eax
  00e76	8b c1		 mov	 eax, ecx
  00e78	c1 f8 11	 sar	 eax, 17
  00e7b	89 84 24 f0 01
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00e82	81 bc 24 f0 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00e8d	76 2b		 jbe	 SHORT $LN37@stbi__idct

; 2418 :       if (x < 0) return 0;

  00e8f	83 bc 24 f0 01
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00e97	7d 0a		 jge	 SHORT $LN38@stbi__idct
  00e99	c6 84 24 dd 01
	00 00 00	 mov	 BYTE PTR $T36[rsp], 0
  00ea1	eb 26		 jmp	 SHORT $LN36@stbi__idct
$LN38@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00ea3	81 bc 24 f0 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00eae	7e 0a		 jle	 SHORT $LN39@stbi__idct
  00eb0	c6 84 24 dd 01
	00 00 ff	 mov	 BYTE PTR $T36[rsp], 255	; 000000ffH
  00eb8	eb 0f		 jmp	 SHORT $LN36@stbi__idct
$LN39@stbi__idct:
$LN37@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00eba	0f b6 84 24 f0
	01 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00ec2	88 84 24 dd 01
	00 00		 mov	 BYTE PTR $T36[rsp], al
$LN36@stbi__idct:

; 2518 :       o[5] = stbi__clamp((x2-t1) >> 17);

  00ec9	0f b6 84 24 dd
	01 00 00	 movzx	 eax, BYTE PTR $T36[rsp]
  00ed1	b9 01 00 00 00	 mov	 ecx, 1
  00ed6	48 6b c9 05	 imul	 rcx, rcx, 5
  00eda	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00ee2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);

  00ee5	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR t0$18[rsp]
  00eec	8b 8c 24 c8 01
	00 00		 mov	 ecx, DWORD PTR x3$30[rsp]
  00ef3	03 c8		 add	 ecx, eax
  00ef5	8b c1		 mov	 eax, ecx
  00ef7	c1 f8 11	 sar	 eax, 17
  00efa	89 84 24 e8 01
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00f01	81 bc 24 e8 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00f0c	76 2b		 jbe	 SHORT $LN42@stbi__idct

; 2418 :       if (x < 0) return 0;

  00f0e	83 bc 24 e8 01
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00f16	7d 0a		 jge	 SHORT $LN43@stbi__idct
  00f18	c6 84 24 de 01
	00 00 00	 mov	 BYTE PTR $T37[rsp], 0
  00f20	eb 26		 jmp	 SHORT $LN41@stbi__idct
$LN43@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00f22	81 bc 24 e8 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00f2d	7e 0a		 jle	 SHORT $LN44@stbi__idct
  00f2f	c6 84 24 de 01
	00 00 ff	 mov	 BYTE PTR $T37[rsp], 255	; 000000ffH
  00f37	eb 0f		 jmp	 SHORT $LN41@stbi__idct
$LN44@stbi__idct:
$LN42@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00f39	0f b6 84 24 e8
	01 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00f41	88 84 24 de 01
	00 00		 mov	 BYTE PTR $T37[rsp], al
$LN41@stbi__idct:

; 2519 :       o[3] = stbi__clamp((x3+t0) >> 17);

  00f48	0f b6 84 24 de
	01 00 00	 movzx	 eax, BYTE PTR $T37[rsp]
  00f50	b9 01 00 00 00	 mov	 ecx, 1
  00f55	48 6b c9 03	 imul	 rcx, rcx, 3
  00f59	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00f61	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);

  00f64	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR t0$18[rsp]
  00f6b	8b 8c 24 c8 01
	00 00		 mov	 ecx, DWORD PTR x3$30[rsp]
  00f72	2b c8		 sub	 ecx, eax
  00f74	8b c1		 mov	 eax, ecx
  00f76	c1 f8 11	 sar	 eax, 17
  00f79	89 84 24 e0 01
	00 00		 mov	 DWORD PTR x$[rsp], eax

; 2417 :    if ((unsigned int) x > 255) {

  00f80	81 bc 24 e0 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00f8b	76 2b		 jbe	 SHORT $LN47@stbi__idct

; 2418 :       if (x < 0) return 0;

  00f8d	83 bc 24 e0 01
	00 00 00	 cmp	 DWORD PTR x$[rsp], 0
  00f95	7d 0a		 jge	 SHORT $LN48@stbi__idct
  00f97	c6 84 24 df 01
	00 00 00	 mov	 BYTE PTR $T38[rsp], 0
  00f9f	eb 26		 jmp	 SHORT $LN46@stbi__idct
$LN48@stbi__idct:

; 2419 :       if (x > 255) return 255;

  00fa1	81 bc 24 e0 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00fac	7e 0a		 jle	 SHORT $LN49@stbi__idct
  00fae	c6 84 24 df 01
	00 00 ff	 mov	 BYTE PTR $T38[rsp], 255	; 000000ffH
  00fb6	eb 0f		 jmp	 SHORT $LN46@stbi__idct
$LN49@stbi__idct:
$LN47@stbi__idct:

; 2420 :    }
; 2421 :    return (stbi_uc) x;

  00fb8	0f b6 84 24 e0
	01 00 00	 movzx	 eax, BYTE PTR x$[rsp]
  00fc0	88 84 24 df 01
	00 00		 mov	 BYTE PTR $T38[rsp], al
$LN46@stbi__idct:

; 2520 :       o[4] = stbi__clamp((x3-t0) >> 17);

  00fc7	0f b6 84 24 df
	01 00 00	 movzx	 eax, BYTE PTR $T38[rsp]
  00fcf	b9 01 00 00 00	 mov	 ecx, 1
  00fd4	48 6b c9 04	 imul	 rcx, rcx, 4
  00fd8	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR o$[rsp]
  00fe0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2521 :    }

  00fe3	e9 e4 f7 ff ff	 jmp	 $LN5@stbi__idct
$LN6@stbi__idct:

; 2522 : }

  00fe8	48 8b cc	 mov	 rcx, rsp
  00feb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__idct_block$rtcFrameData
  00ff2	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00ff7	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00fff	48 33 cc	 xor	 rcx, rsp
  01002	e8 00 00 00 00	 call	 __security_check_cookie
  01007	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  0100e	5f		 pop	 rdi
  0100f	c3		 ret	 0
stbi__idct_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
row0$ = 32
row1$ = 48
row2$ = 64
row3$ = 80
row4$ = 96
row5$ = 112
row6$ = 128
row7$ = 144
tmp$ = 160
rot0_0$ = 176
rot0_1$ = 192
rot1_0$ = 208
rot1_1$ = 224
rot2_0$ = 240
rot2_1$ = 256
rot3_0$ = 272
rot3_1$ = 288
bias_0$ = 304
bias_1$ = 320
rot0_0lo$1 = 336
rot0_0hi$2 = 352
t2e_l$3 = 368
t2e_h$4 = 384
t3e_l$5 = 400
t3e_h$6 = 416
sum04$7 = 432
dif04$8 = 448
t0e_l$9 = 464
t0e_h$10 = 480
t1e_l$11 = 496
t1e_h$12 = 512
x0_l$13 = 528
x0_h$14 = 544
x3_l$15 = 560
x3_h$16 = 576
x1_l$17 = 592
x1_h$18 = 608
x2_l$19 = 624
x2_h$20 = 640
rot2_0lo$21 = 656
rot2_0hi$22 = 672
y0o_l$23 = 688
y0o_h$24 = 704
y2o_l$25 = 720
y2o_h$26 = 736
rot3_0lo$27 = 752
rot3_0hi$28 = 768
y1o_l$29 = 784
y1o_h$30 = 800
y3o_l$31 = 816
y3o_h$32 = 832
sum17$33 = 848
sum35$34 = 864
rot1_0lo$35 = 880
rot1_0hi$36 = 896
y4o_l$37 = 912
y4o_h$38 = 928
y5o_l$39 = 944
y5o_h$40 = 960
x4_l$41 = 976
x4_h$42 = 992
x5_l$43 = 1008
x5_h$44 = 1024
x6_l$45 = 1040
x6_h$46 = 1056
x7_l$47 = 1072
x7_h$48 = 1088
abiased_l$49 = 1104
abiased_h$50 = 1120
sum_l$51 = 1136
sum_h$52 = 1152
dif_l$53 = 1168
dif_h$54 = 1184
abiased_l$55 = 1200
abiased_h$56 = 1216
sum_l$57 = 1232
sum_h$58 = 1248
dif_l$59 = 1264
dif_h$60 = 1280
abiased_l$61 = 1296
abiased_h$62 = 1312
sum_l$63 = 1328
sum_h$64 = 1344
dif_l$65 = 1360
dif_h$66 = 1376
abiased_l$67 = 1392
abiased_h$68 = 1408
sum_l$69 = 1424
sum_h$70 = 1440
dif_l$71 = 1456
dif_h$72 = 1472
rot0_0lo$73 = 1488
rot0_0hi$74 = 1504
t2e_l$75 = 1520
t2e_h$76 = 1536
t3e_l$77 = 1552
t3e_h$78 = 1568
sum04$79 = 1584
dif04$80 = 1600
t0e_l$81 = 1616
t0e_h$82 = 1632
t1e_l$83 = 1648
t1e_h$84 = 1664
x0_l$85 = 1680
x0_h$86 = 1696
x3_l$87 = 1712
x3_h$88 = 1728
x1_l$89 = 1744
x1_h$90 = 1760
x2_l$91 = 1776
x2_h$92 = 1792
rot2_0lo$93 = 1808
rot2_0hi$94 = 1824
y0o_l$95 = 1840
y0o_h$96 = 1856
y2o_l$97 = 1872
y2o_h$98 = 1888
rot3_0lo$99 = 1904
rot3_0hi$100 = 1920
y1o_l$101 = 1936
y1o_h$102 = 1952
y3o_l$103 = 1968
y3o_h$104 = 1984
sum17$105 = 2000
sum35$106 = 2016
rot1_0lo$107 = 2032
rot1_0hi$108 = 2048
y4o_l$109 = 2064
y4o_h$110 = 2080
y5o_l$111 = 2096
y5o_h$112 = 2112
x4_l$113 = 2128
x4_h$114 = 2144
x5_l$115 = 2160
x5_h$116 = 2176
x6_l$117 = 2192
x6_h$118 = 2208
x7_l$119 = 2224
x7_h$120 = 2240
abiased_l$121 = 2256
abiased_h$122 = 2272
sum_l$123 = 2288
sum_h$124 = 2304
dif_l$125 = 2320
dif_h$126 = 2336
abiased_l$127 = 2352
abiased_h$128 = 2368
sum_l$129 = 2384
sum_h$130 = 2400
dif_l$131 = 2416
dif_h$132 = 2432
abiased_l$133 = 2448
abiased_h$134 = 2464
sum_l$135 = 2480
sum_h$136 = 2496
dif_l$137 = 2512
dif_h$138 = 2528
abiased_l$139 = 2544
abiased_h$140 = 2560
sum_l$141 = 2576
sum_h$142 = 2592
dif_l$143 = 2608
dif_h$144 = 2624
p0$145 = 2640
p1$146 = 2656
p2$147 = 2672
p3$148 = 2688
out$ = 2720
out_stride$ = 2728
data$ = 2736
stbi__idct_simd PROC

; 2529 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 90 0a
	00 00		 sub	 rsp, 2704		; 00000a90H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2530 :    // This is constructed to match our regular (generic) integer IDCT exactly.
; 2531 :    __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2532 :    __m128i tmp;
; 2533 : 
; 2534 :    // dot product constant: even elems=x, odd elems=y
; 2535 :    #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2536 : 
; 2537 :    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2538 :    // out(1) = c1[even]*x + c1[odd]*y
; 2539 :    #define dct_rot(out0,out1, x,y,c0,c1) \
; 2540 :       __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2541 :       __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2542 :       __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2543 :       __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2544 :       __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2545 :       __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2546 : 
; 2547 :    // out = in << 12  (in 16-bit, out 32-bit)
; 2548 :    #define dct_widen(out, in) \
; 2549 :       __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2550 :       __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2551 : 
; 2552 :    // wide add
; 2553 :    #define dct_wadd(out, a, b) \
; 2554 :       __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2555 :       __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2556 : 
; 2557 :    // wide sub
; 2558 :    #define dct_wsub(out, a, b) \
; 2559 :       __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2560 :       __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2561 : 
; 2562 :    // butterfly a/b, add bias, then shift by "s" and pack
; 2563 :    #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2564 :       { \
; 2565 :          __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2566 :          __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2567 :          dct_wadd(sum, abiased, b); \
; 2568 :          dct_wsub(dif, abiased, b); \
; 2569 :          out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2570 :          out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2571 :       }
; 2572 : 
; 2573 :    // 8-bit interleave step (for transposes)
; 2574 :    #define dct_interleave8(a, b) \
; 2575 :       tmp = a; \
; 2576 :       a = _mm_unpacklo_epi8(a, b); \
; 2577 :       b = _mm_unpackhi_epi8(tmp, b)
; 2578 : 
; 2579 :    // 16-bit interleave step (for transposes)
; 2580 :    #define dct_interleave16(a, b) \
; 2581 :       tmp = a; \
; 2582 :       a = _mm_unpacklo_epi16(a, b); \
; 2583 :       b = _mm_unpackhi_epi16(tmp, b)
; 2584 : 
; 2585 :    #define dct_pass(bias,shift) \
; 2586 :       { \
; 2587 :          /* even part */ \
; 2588 :          dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2589 :          __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2590 :          __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2591 :          dct_widen(t0e, sum04); \
; 2592 :          dct_widen(t1e, dif04); \
; 2593 :          dct_wadd(x0, t0e, t3e); \
; 2594 :          dct_wsub(x3, t0e, t3e); \
; 2595 :          dct_wadd(x1, t1e, t2e); \
; 2596 :          dct_wsub(x2, t1e, t2e); \
; 2597 :          /* odd part */ \
; 2598 :          dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2599 :          dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2600 :          __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2601 :          __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2602 :          dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2603 :          dct_wadd(x4, y0o, y4o); \
; 2604 :          dct_wadd(x5, y1o, y5o); \
; 2605 :          dct_wadd(x6, y2o, y5o); \
; 2606 :          dct_wadd(x7, y3o, y4o); \
; 2607 :          dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2608 :          dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2609 :          dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2610 :          dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2611 :       }
; 2612 : 
; 2613 :    __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

  00022	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
  0002a	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR rot0_0$[rsp], xmm0

; 2614 :    __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));

  00033	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
  0003b	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR rot0_1$[rsp], xmm0

; 2615 :    __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

  00044	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
  0004c	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR rot1_0$[rsp], xmm0

; 2616 :    __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

  00055	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
  0005d	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR rot1_1$[rsp], xmm0

; 2617 :    __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));

  00066	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
  0006e	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR rot2_0$[rsp], xmm0

; 2618 :    __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));

  00077	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
  0007f	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR rot2_1$[rsp], xmm0

; 2619 :    __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));

  00088	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
  00090	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR rot3_0$[rsp], xmm0

; 2620 :    __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

  00099	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
  000a1	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR rot3_1$[rsp], xmm0

; 2621 : 
; 2622 :    // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2623 :    __m128i bias_0 = _mm_set1_epi32(512);

  000aa	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
  000b2	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR bias_0$[rsp], xmm0

; 2624 :    __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

  000bb	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
  000c3	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR bias_1$[rsp], xmm0

; 2625 : 
; 2626 :    // load
; 2627 :    row0 = _mm_load_si128((const __m128i *) (data + 0*8));

  000cc	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  000d4	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  000d8	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0

; 2628 :    row1 = _mm_load_si128((const __m128i *) (data + 1*8));

  000de	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  000e6	48 83 c0 10	 add	 rax, 16
  000ea	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  000ee	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2629 :    row2 = _mm_load_si128((const __m128i *) (data + 2*8));

  000f4	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  000fc	48 83 c0 20	 add	 rax, 32			; 00000020H
  00100	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00104	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2630 :    row3 = _mm_load_si128((const __m128i *) (data + 3*8));

  0010a	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00112	48 83 c0 30	 add	 rax, 48			; 00000030H
  00116	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0011a	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2631 :    row4 = _mm_load_si128((const __m128i *) (data + 4*8));

  00120	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00128	48 83 c0 40	 add	 rax, 64			; 00000040H
  0012c	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00130	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2632 :    row5 = _mm_load_si128((const __m128i *) (data + 5*8));

  00136	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0013e	48 83 c0 50	 add	 rax, 80			; 00000050H
  00142	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00146	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2633 :    row6 = _mm_load_si128((const __m128i *) (data + 6*8));

  0014c	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00154	48 83 c0 60	 add	 rax, 96			; 00000060H
  00158	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0015c	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2634 :    row7 = _mm_load_si128((const __m128i *) (data + 7*8));

  00165	48 8b 84 24 b0
	0a 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0016d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00171	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00175	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2635 : 
; 2636 :    // column pass
; 2637 :    dct_pass(bias_0, 10);

  0017e	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00184	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0018d	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR rot0_0lo$1[rsp], xmm0
  00196	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  0019c	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  001a5	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR rot0_0hi$2[rsp], xmm0
  001ae	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$1[rsp]
  001b7	66 0f f5 84 24
	b0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  001c0	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR t2e_l$3[rsp], xmm0
  001c9	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$2[rsp]
  001d2	66 0f f5 84 24
	b0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  001db	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR t2e_h$4[rsp], xmm0
  001e4	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$1[rsp]
  001ed	66 0f f5 84 24
	c0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  001f6	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR t3e_l$5[rsp], xmm0
  001ff	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$2[rsp]
  00208	66 0f f5 84 24
	c0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  00211	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR t3e_h$6[rsp], xmm0
  0021a	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00220	66 0f fd 44 24
	60		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  00226	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR sum04$7[rsp], xmm0
  0022f	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00235	66 0f f9 44 24
	60		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  0023b	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR dif04$8[rsp], xmm0
  00244	66 0f ef c0	 pxor	 xmm0, xmm0
  00248	66 0f 61 84 24
	b0 01 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$7[rsp]
  00251	66 0f 72 e0 04	 psrad	 xmm0, 4
  00256	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR t0e_l$9[rsp], xmm0
  0025f	66 0f ef c0	 pxor	 xmm0, xmm0
  00263	66 0f 69 84 24
	b0 01 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$7[rsp]
  0026c	66 0f 72 e0 04	 psrad	 xmm0, 4
  00271	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR t0e_h$10[rsp], xmm0
  0027a	66 0f ef c0	 pxor	 xmm0, xmm0
  0027e	66 0f 61 84 24
	c0 01 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$8[rsp]
  00287	66 0f 72 e0 04	 psrad	 xmm0, 4
  0028c	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR t1e_l$11[rsp], xmm0
  00295	66 0f ef c0	 pxor	 xmm0, xmm0
  00299	66 0f 69 84 24
	c0 01 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$8[rsp]
  002a2	66 0f 72 e0 04	 psrad	 xmm0, 4
  002a7	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR t1e_h$12[rsp], xmm0
  002b0	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  002b9	66 0f fe 84 24
	90 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$5[rsp]
  002c2	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR x0_l$13[rsp], xmm0
  002cb	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$10[rsp]
  002d4	66 0f fe 84 24
	a0 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$6[rsp]
  002dd	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR x0_h$14[rsp], xmm0
  002e6	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  002ef	66 0f fa 84 24
	90 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$5[rsp]
  002f8	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR x3_l$15[rsp], xmm0
  00301	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$10[rsp]
  0030a	66 0f fa 84 24
	a0 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$6[rsp]
  00313	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR x3_h$16[rsp], xmm0
  0031c	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$11[rsp]
  00325	66 0f fe 84 24
	70 01 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$3[rsp]
  0032e	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR x1_l$17[rsp], xmm0
  00337	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$12[rsp]
  00340	66 0f fe 84 24
	80 01 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$4[rsp]
  00349	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR x1_h$18[rsp], xmm0
  00352	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$11[rsp]
  0035b	66 0f fa 84 24
	70 01 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$3[rsp]
  00364	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR x2_l$19[rsp], xmm0
  0036d	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$12[rsp]
  00376	66 0f fa 84 24
	80 01 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$4[rsp]
  0037f	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR x2_h$20[rsp], xmm0
  00388	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  00391	66 0f 61 44 24
	50		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  00397	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR rot2_0lo$21[rsp], xmm0
  003a0	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  003a9	66 0f 69 44 24
	50		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  003af	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR rot2_0hi$22[rsp], xmm0
  003b8	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$21[rsp]
  003c1	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  003ca	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR y0o_l$23[rsp], xmm0
  003d3	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$22[rsp]
  003dc	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  003e5	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR y0o_h$24[rsp], xmm0
  003ee	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$21[rsp]
  003f7	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  00400	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR y2o_l$25[rsp], xmm0
  00409	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$22[rsp]
  00412	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  0041b	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR y2o_h$26[rsp], xmm0
  00424	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  0042a	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  00430	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR rot3_0lo$27[rsp], xmm0
  00439	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  0043f	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  00445	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR rot3_0hi$28[rsp], xmm0
  0044e	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$27[rsp]
  00457	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  00460	66 0f 7f 84 24
	10 03 00 00	 movdqa	 XMMWORD PTR y1o_l$29[rsp], xmm0
  00469	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$28[rsp]
  00472	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  0047b	66 0f 7f 84 24
	20 03 00 00	 movdqa	 XMMWORD PTR y1o_h$30[rsp], xmm0
  00484	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$27[rsp]
  0048d	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  00496	66 0f 7f 84 24
	30 03 00 00	 movdqa	 XMMWORD PTR y3o_l$31[rsp], xmm0
  0049f	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$28[rsp]
  004a8	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  004b1	66 0f 7f 84 24
	40 03 00 00	 movdqa	 XMMWORD PTR y3o_h$32[rsp], xmm0
  004ba	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  004c0	66 0f fd 84 24
	90 00 00 00	 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  004c9	66 0f 7f 84 24
	50 03 00 00	 movdqa	 XMMWORD PTR sum17$33[rsp], xmm0
  004d2	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  004d8	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  004de	66 0f 7f 84 24
	60 03 00 00	 movdqa	 XMMWORD PTR sum35$34[rsp], xmm0
  004e7	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$33[rsp]
  004f0	66 0f 61 84 24
	60 03 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$34[rsp]
  004f9	66 0f 7f 84 24
	70 03 00 00	 movdqa	 XMMWORD PTR rot1_0lo$35[rsp], xmm0
  00502	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$33[rsp]
  0050b	66 0f 69 84 24
	60 03 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$34[rsp]
  00514	66 0f 7f 84 24
	80 03 00 00	 movdqa	 XMMWORD PTR rot1_0hi$36[rsp], xmm0
  0051d	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$35[rsp]
  00526	66 0f f5 84 24
	d0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  0052f	66 0f 7f 84 24
	90 03 00 00	 movdqa	 XMMWORD PTR y4o_l$37[rsp], xmm0
  00538	66 0f 6f 84 24
	80 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$36[rsp]
  00541	66 0f f5 84 24
	d0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  0054a	66 0f 7f 84 24
	a0 03 00 00	 movdqa	 XMMWORD PTR y4o_h$38[rsp], xmm0
  00553	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$35[rsp]
  0055c	66 0f f5 84 24
	e0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  00565	66 0f 7f 84 24
	b0 03 00 00	 movdqa	 XMMWORD PTR y5o_l$39[rsp], xmm0
  0056e	66 0f 6f 84 24
	80 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$36[rsp]
  00577	66 0f f5 84 24
	e0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  00580	66 0f 7f 84 24
	c0 03 00 00	 movdqa	 XMMWORD PTR y5o_h$40[rsp], xmm0
  00589	66 0f 6f 84 24
	b0 02 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$23[rsp]
  00592	66 0f fe 84 24
	90 03 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$37[rsp]
  0059b	66 0f 7f 84 24
	d0 03 00 00	 movdqa	 XMMWORD PTR x4_l$41[rsp], xmm0
  005a4	66 0f 6f 84 24
	c0 02 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$24[rsp]
  005ad	66 0f fe 84 24
	a0 03 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$38[rsp]
  005b6	66 0f 7f 84 24
	e0 03 00 00	 movdqa	 XMMWORD PTR x4_h$42[rsp], xmm0
  005bf	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$29[rsp]
  005c8	66 0f fe 84 24
	b0 03 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$39[rsp]
  005d1	66 0f 7f 84 24
	f0 03 00 00	 movdqa	 XMMWORD PTR x5_l$43[rsp], xmm0
  005da	66 0f 6f 84 24
	20 03 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$30[rsp]
  005e3	66 0f fe 84 24
	c0 03 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$40[rsp]
  005ec	66 0f 7f 84 24
	00 04 00 00	 movdqa	 XMMWORD PTR x5_h$44[rsp], xmm0
  005f5	66 0f 6f 84 24
	d0 02 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$25[rsp]
  005fe	66 0f fe 84 24
	b0 03 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$39[rsp]
  00607	66 0f 7f 84 24
	10 04 00 00	 movdqa	 XMMWORD PTR x6_l$45[rsp], xmm0
  00610	66 0f 6f 84 24
	e0 02 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$26[rsp]
  00619	66 0f fe 84 24
	c0 03 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$40[rsp]
  00622	66 0f 7f 84 24
	20 04 00 00	 movdqa	 XMMWORD PTR x6_h$46[rsp], xmm0
  0062b	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$31[rsp]
  00634	66 0f fe 84 24
	90 03 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$37[rsp]
  0063d	66 0f 7f 84 24
	30 04 00 00	 movdqa	 XMMWORD PTR x7_l$47[rsp], xmm0
  00646	66 0f 6f 84 24
	40 03 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$32[rsp]
  0064f	66 0f fe 84 24
	a0 03 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$38[rsp]
  00658	66 0f 7f 84 24
	40 04 00 00	 movdqa	 XMMWORD PTR x7_h$48[rsp], xmm0
  00661	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$13[rsp]
  0066a	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00673	66 0f 7f 84 24
	50 04 00 00	 movdqa	 XMMWORD PTR abiased_l$49[rsp], xmm0
  0067c	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$14[rsp]
  00685	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  0068e	66 0f 7f 84 24
	60 04 00 00	 movdqa	 XMMWORD PTR abiased_h$50[rsp], xmm0
  00697	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$49[rsp]
  006a0	66 0f fe 84 24
	30 04 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$47[rsp]
  006a9	66 0f 7f 84 24
	70 04 00 00	 movdqa	 XMMWORD PTR sum_l$51[rsp], xmm0
  006b2	66 0f 6f 84 24
	60 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$50[rsp]
  006bb	66 0f fe 84 24
	40 04 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$48[rsp]
  006c4	66 0f 7f 84 24
	80 04 00 00	 movdqa	 XMMWORD PTR sum_h$52[rsp], xmm0
  006cd	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$49[rsp]
  006d6	66 0f fa 84 24
	30 04 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$47[rsp]
  006df	66 0f 7f 84 24
	90 04 00 00	 movdqa	 XMMWORD PTR dif_l$53[rsp], xmm0
  006e8	66 0f 6f 84 24
	60 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$50[rsp]
  006f1	66 0f fa 84 24
	40 04 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$48[rsp]
  006fa	66 0f 7f 84 24
	a0 04 00 00	 movdqa	 XMMWORD PTR dif_h$54[rsp], xmm0
  00703	66 0f 6f 84 24
	80 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$52[rsp]
  0070c	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00711	66 0f 6f 8c 24
	70 04 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$51[rsp]
  0071a	66 0f 72 e1 0a	 psrad	 xmm1, 10
  0071f	66 0f 6b c8	 packssdw xmm1, xmm0
  00723	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00727	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  0072d	66 0f 6f 84 24
	a0 04 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$54[rsp]
  00736	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0073b	66 0f 6f 8c 24
	90 04 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$53[rsp]
  00744	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00749	66 0f 6b c8	 packssdw xmm1, xmm0
  0074d	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00751	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  0075a	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$17[rsp]
  00763	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  0076c	66 0f 7f 84 24
	b0 04 00 00	 movdqa	 XMMWORD PTR abiased_l$55[rsp], xmm0
  00775	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$18[rsp]
  0077e	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00787	66 0f 7f 84 24
	c0 04 00 00	 movdqa	 XMMWORD PTR abiased_h$56[rsp], xmm0
  00790	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$55[rsp]
  00799	66 0f fe 84 24
	10 04 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$45[rsp]
  007a2	66 0f 7f 84 24
	d0 04 00 00	 movdqa	 XMMWORD PTR sum_l$57[rsp], xmm0
  007ab	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$56[rsp]
  007b4	66 0f fe 84 24
	20 04 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$46[rsp]
  007bd	66 0f 7f 84 24
	e0 04 00 00	 movdqa	 XMMWORD PTR sum_h$58[rsp], xmm0
  007c6	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$55[rsp]
  007cf	66 0f fa 84 24
	10 04 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$45[rsp]
  007d8	66 0f 7f 84 24
	f0 04 00 00	 movdqa	 XMMWORD PTR dif_l$59[rsp], xmm0
  007e1	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$56[rsp]
  007ea	66 0f fa 84 24
	20 04 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$46[rsp]
  007f3	66 0f 7f 84 24
	00 05 00 00	 movdqa	 XMMWORD PTR dif_h$60[rsp], xmm0
  007fc	66 0f 6f 84 24
	e0 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$58[rsp]
  00805	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0080a	66 0f 6f 8c 24
	d0 04 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$57[rsp]
  00813	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00818	66 0f 6b c8	 packssdw xmm1, xmm0
  0081c	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00820	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  00826	66 0f 6f 84 24
	00 05 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$60[rsp]
  0082f	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00834	66 0f 6f 8c 24
	f0 04 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$59[rsp]
  0083d	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00842	66 0f 6b c8	 packssdw xmm1, xmm0
  00846	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0084a	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  00853	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$19[rsp]
  0085c	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00865	66 0f 7f 84 24
	10 05 00 00	 movdqa	 XMMWORD PTR abiased_l$61[rsp], xmm0
  0086e	66 0f 6f 84 24
	80 02 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$20[rsp]
  00877	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00880	66 0f 7f 84 24
	20 05 00 00	 movdqa	 XMMWORD PTR abiased_h$62[rsp], xmm0
  00889	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$61[rsp]
  00892	66 0f fe 84 24
	f0 03 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$43[rsp]
  0089b	66 0f 7f 84 24
	30 05 00 00	 movdqa	 XMMWORD PTR sum_l$63[rsp], xmm0
  008a4	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$62[rsp]
  008ad	66 0f fe 84 24
	00 04 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$44[rsp]
  008b6	66 0f 7f 84 24
	40 05 00 00	 movdqa	 XMMWORD PTR sum_h$64[rsp], xmm0
  008bf	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$61[rsp]
  008c8	66 0f fa 84 24
	f0 03 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$43[rsp]
  008d1	66 0f 7f 84 24
	50 05 00 00	 movdqa	 XMMWORD PTR dif_l$65[rsp], xmm0
  008da	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$62[rsp]
  008e3	66 0f fa 84 24
	00 04 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$44[rsp]
  008ec	66 0f 7f 84 24
	60 05 00 00	 movdqa	 XMMWORD PTR dif_h$66[rsp], xmm0
  008f5	66 0f 6f 84 24
	40 05 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$64[rsp]
  008fe	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00903	66 0f 6f 8c 24
	30 05 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$63[rsp]
  0090c	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00911	66 0f 6b c8	 packssdw xmm1, xmm0
  00915	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00919	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  0091f	66 0f 6f 84 24
	60 05 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$66[rsp]
  00928	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0092d	66 0f 6f 8c 24
	50 05 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$65[rsp]
  00936	66 0f 72 e1 0a	 psrad	 xmm1, 10
  0093b	66 0f 6b c8	 packssdw xmm1, xmm0
  0093f	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00943	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  00949	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$15[rsp]
  00952	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  0095b	66 0f 7f 84 24
	70 05 00 00	 movdqa	 XMMWORD PTR abiased_l$67[rsp], xmm0
  00964	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$16[rsp]
  0096d	66 0f fe 84 24
	30 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00976	66 0f 7f 84 24
	80 05 00 00	 movdqa	 XMMWORD PTR abiased_h$68[rsp], xmm0
  0097f	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$67[rsp]
  00988	66 0f fe 84 24
	d0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$41[rsp]
  00991	66 0f 7f 84 24
	90 05 00 00	 movdqa	 XMMWORD PTR sum_l$69[rsp], xmm0
  0099a	66 0f 6f 84 24
	80 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$68[rsp]
  009a3	66 0f fe 84 24
	e0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$42[rsp]
  009ac	66 0f 7f 84 24
	a0 05 00 00	 movdqa	 XMMWORD PTR sum_h$70[rsp], xmm0
  009b5	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$67[rsp]
  009be	66 0f fa 84 24
	d0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$41[rsp]
  009c7	66 0f 7f 84 24
	b0 05 00 00	 movdqa	 XMMWORD PTR dif_l$71[rsp], xmm0
  009d0	66 0f 6f 84 24
	80 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$68[rsp]
  009d9	66 0f fa 84 24
	e0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$42[rsp]
  009e2	66 0f 7f 84 24
	c0 05 00 00	 movdqa	 XMMWORD PTR dif_h$72[rsp], xmm0
  009eb	66 0f 6f 84 24
	a0 05 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$70[rsp]
  009f4	66 0f 72 e0 0a	 psrad	 xmm0, 10
  009f9	66 0f 6f 8c 24
	90 05 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$69[rsp]
  00a02	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00a07	66 0f 6b c8	 packssdw xmm1, xmm0
  00a0b	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00a0f	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  00a15	66 0f 6f 84 24
	c0 05 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$72[rsp]
  00a1e	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00a23	66 0f 6f 8c 24
	b0 05 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$71[rsp]
  00a2c	66 0f 72 e1 0a	 psrad	 xmm1, 10
  00a31	66 0f 6b c8	 packssdw xmm1, xmm0
  00a35	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00a39	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2638 : 
; 2639 :    {
; 2640 :       // 16bit 8x8 transpose pass 1
; 2641 :       dct_interleave16(row0, row4);

  00a3f	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00a45	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00a4e	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00a54	66 0f 61 44 24
	60		 punpcklwd xmm0, XMMWORD PTR row4$[rsp]
  00a5a	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  00a60	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00a69	66 0f 69 44 24
	60		 punpckhwd xmm0, XMMWORD PTR row4$[rsp]
  00a6f	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2642 :       dct_interleave16(row1, row5);

  00a75	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  00a7b	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00a84	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  00a8a	66 0f 61 44 24
	70		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  00a90	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  00a96	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00a9f	66 0f 69 44 24
	70		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  00aa5	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2643 :       dct_interleave16(row2, row6);

  00aab	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00ab1	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00aba	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00ac0	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  00ac9	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  00acf	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00ad8	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  00ae1	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2644 :       dct_interleave16(row3, row7);

  00aea	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  00af0	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00af9	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  00aff	66 0f 61 84 24
	90 00 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  00b08	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  00b0e	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00b17	66 0f 69 84 24
	90 00 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  00b20	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2645 : 
; 2646 :       // transpose pass 2
; 2647 :       dct_interleave16(row0, row2);

  00b29	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00b2f	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00b38	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00b3e	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row2$[rsp]
  00b44	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  00b4a	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00b53	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row2$[rsp]
  00b59	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2648 :       dct_interleave16(row1, row3);

  00b5f	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  00b65	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00b6e	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  00b74	66 0f 61 44 24
	50		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  00b7a	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  00b80	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00b89	66 0f 69 44 24
	50		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  00b8f	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2649 :       dct_interleave16(row4, row6);

  00b95	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  00b9b	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00ba4	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  00baa	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  00bb3	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  00bb9	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00bc2	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  00bcb	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2650 :       dct_interleave16(row5, row7);

  00bd4	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  00bda	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00be3	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  00be9	66 0f 61 84 24
	90 00 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  00bf2	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  00bf8	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00c01	66 0f 69 84 24
	90 00 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  00c0a	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2651 : 
; 2652 :       // transpose pass 3
; 2653 :       dct_interleave16(row0, row1);

  00c13	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00c19	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00c22	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00c28	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  00c2e	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  00c34	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00c3d	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  00c43	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2654 :       dct_interleave16(row2, row3);

  00c49	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00c4f	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00c58	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00c5e	66 0f 61 44 24
	50		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  00c64	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  00c6a	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00c73	66 0f 69 44 24
	50		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  00c79	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2655 :       dct_interleave16(row4, row5);

  00c7f	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  00c85	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00c8e	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  00c94	66 0f 61 44 24
	70		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  00c9a	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  00ca0	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00ca9	66 0f 69 44 24
	70		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  00caf	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2656 :       dct_interleave16(row6, row7);

  00cb5	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  00cbe	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  00cc7	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  00cd0	66 0f 61 84 24
	90 00 00 00	 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  00cd9	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  00ce2	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  00ceb	66 0f 69 84 24
	90 00 00 00	 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  00cf4	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2657 :    }
; 2658 : 
; 2659 :    // row pass
; 2660 :    dct_pass(bias_1, 17);

  00cfd	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00d03	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  00d0c	66 0f 7f 84 24
	d0 05 00 00	 movdqa	 XMMWORD PTR rot0_0lo$73[rsp], xmm0
  00d15	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  00d1b	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  00d24	66 0f 7f 84 24
	e0 05 00 00	 movdqa	 XMMWORD PTR rot0_0hi$74[rsp], xmm0
  00d2d	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$73[rsp]
  00d36	66 0f f5 84 24
	b0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  00d3f	66 0f 7f 84 24
	f0 05 00 00	 movdqa	 XMMWORD PTR t2e_l$75[rsp], xmm0
  00d48	66 0f 6f 84 24
	e0 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$74[rsp]
  00d51	66 0f f5 84 24
	b0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  00d5a	66 0f 7f 84 24
	00 06 00 00	 movdqa	 XMMWORD PTR t2e_h$76[rsp], xmm0
  00d63	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$73[rsp]
  00d6c	66 0f f5 84 24
	c0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  00d75	66 0f 7f 84 24
	10 06 00 00	 movdqa	 XMMWORD PTR t3e_l$77[rsp], xmm0
  00d7e	66 0f 6f 84 24
	e0 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$74[rsp]
  00d87	66 0f f5 84 24
	c0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  00d90	66 0f 7f 84 24
	20 06 00 00	 movdqa	 XMMWORD PTR t3e_h$78[rsp], xmm0
  00d99	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00d9f	66 0f fd 44 24
	60		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  00da5	66 0f 7f 84 24
	30 06 00 00	 movdqa	 XMMWORD PTR sum04$79[rsp], xmm0
  00dae	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  00db4	66 0f f9 44 24
	60		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  00dba	66 0f 7f 84 24
	40 06 00 00	 movdqa	 XMMWORD PTR dif04$80[rsp], xmm0
  00dc3	66 0f ef c0	 pxor	 xmm0, xmm0
  00dc7	66 0f 61 84 24
	30 06 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$79[rsp]
  00dd0	66 0f 72 e0 04	 psrad	 xmm0, 4
  00dd5	66 0f 7f 84 24
	50 06 00 00	 movdqa	 XMMWORD PTR t0e_l$81[rsp], xmm0
  00dde	66 0f ef c0	 pxor	 xmm0, xmm0
  00de2	66 0f 69 84 24
	30 06 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$79[rsp]
  00deb	66 0f 72 e0 04	 psrad	 xmm0, 4
  00df0	66 0f 7f 84 24
	60 06 00 00	 movdqa	 XMMWORD PTR t0e_h$82[rsp], xmm0
  00df9	66 0f ef c0	 pxor	 xmm0, xmm0
  00dfd	66 0f 61 84 24
	40 06 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$80[rsp]
  00e06	66 0f 72 e0 04	 psrad	 xmm0, 4
  00e0b	66 0f 7f 84 24
	70 06 00 00	 movdqa	 XMMWORD PTR t1e_l$83[rsp], xmm0
  00e14	66 0f ef c0	 pxor	 xmm0, xmm0
  00e18	66 0f 69 84 24
	40 06 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$80[rsp]
  00e21	66 0f 72 e0 04	 psrad	 xmm0, 4
  00e26	66 0f 7f 84 24
	80 06 00 00	 movdqa	 XMMWORD PTR t1e_h$84[rsp], xmm0
  00e2f	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$81[rsp]
  00e38	66 0f fe 84 24
	10 06 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$77[rsp]
  00e41	66 0f 7f 84 24
	90 06 00 00	 movdqa	 XMMWORD PTR x0_l$85[rsp], xmm0
  00e4a	66 0f 6f 84 24
	60 06 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$82[rsp]
  00e53	66 0f fe 84 24
	20 06 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$78[rsp]
  00e5c	66 0f 7f 84 24
	a0 06 00 00	 movdqa	 XMMWORD PTR x0_h$86[rsp], xmm0
  00e65	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$81[rsp]
  00e6e	66 0f fa 84 24
	10 06 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$77[rsp]
  00e77	66 0f 7f 84 24
	b0 06 00 00	 movdqa	 XMMWORD PTR x3_l$87[rsp], xmm0
  00e80	66 0f 6f 84 24
	60 06 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$82[rsp]
  00e89	66 0f fa 84 24
	20 06 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$78[rsp]
  00e92	66 0f 7f 84 24
	c0 06 00 00	 movdqa	 XMMWORD PTR x3_h$88[rsp], xmm0
  00e9b	66 0f 6f 84 24
	70 06 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$83[rsp]
  00ea4	66 0f fe 84 24
	f0 05 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$75[rsp]
  00ead	66 0f 7f 84 24
	d0 06 00 00	 movdqa	 XMMWORD PTR x1_l$89[rsp], xmm0
  00eb6	66 0f 6f 84 24
	80 06 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$84[rsp]
  00ebf	66 0f fe 84 24
	00 06 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$76[rsp]
  00ec8	66 0f 7f 84 24
	e0 06 00 00	 movdqa	 XMMWORD PTR x1_h$90[rsp], xmm0
  00ed1	66 0f 6f 84 24
	70 06 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$83[rsp]
  00eda	66 0f fa 84 24
	f0 05 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$75[rsp]
  00ee3	66 0f 7f 84 24
	f0 06 00 00	 movdqa	 XMMWORD PTR x2_l$91[rsp], xmm0
  00eec	66 0f 6f 84 24
	80 06 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$84[rsp]
  00ef5	66 0f fa 84 24
	00 06 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$76[rsp]
  00efe	66 0f 7f 84 24
	00 07 00 00	 movdqa	 XMMWORD PTR x2_h$92[rsp], xmm0
  00f07	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  00f10	66 0f 61 44 24
	50		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  00f16	66 0f 7f 84 24
	10 07 00 00	 movdqa	 XMMWORD PTR rot2_0lo$93[rsp], xmm0
  00f1f	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  00f28	66 0f 69 44 24
	50		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  00f2e	66 0f 7f 84 24
	20 07 00 00	 movdqa	 XMMWORD PTR rot2_0hi$94[rsp], xmm0
  00f37	66 0f 6f 84 24
	10 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$93[rsp]
  00f40	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  00f49	66 0f 7f 84 24
	30 07 00 00	 movdqa	 XMMWORD PTR y0o_l$95[rsp], xmm0
  00f52	66 0f 6f 84 24
	20 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$94[rsp]
  00f5b	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  00f64	66 0f 7f 84 24
	40 07 00 00	 movdqa	 XMMWORD PTR y0o_h$96[rsp], xmm0
  00f6d	66 0f 6f 84 24
	10 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$93[rsp]
  00f76	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  00f7f	66 0f 7f 84 24
	50 07 00 00	 movdqa	 XMMWORD PTR y2o_l$97[rsp], xmm0
  00f88	66 0f 6f 84 24
	20 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$94[rsp]
  00f91	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  00f9a	66 0f 7f 84 24
	60 07 00 00	 movdqa	 XMMWORD PTR y2o_h$98[rsp], xmm0
  00fa3	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  00fa9	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  00faf	66 0f 7f 84 24
	70 07 00 00	 movdqa	 XMMWORD PTR rot3_0lo$99[rsp], xmm0
  00fb8	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  00fbe	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  00fc4	66 0f 7f 84 24
	80 07 00 00	 movdqa	 XMMWORD PTR rot3_0hi$100[rsp], xmm0
  00fcd	66 0f 6f 84 24
	70 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$99[rsp]
  00fd6	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  00fdf	66 0f 7f 84 24
	90 07 00 00	 movdqa	 XMMWORD PTR y1o_l$101[rsp], xmm0
  00fe8	66 0f 6f 84 24
	80 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$100[rsp]
  00ff1	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  00ffa	66 0f 7f 84 24
	a0 07 00 00	 movdqa	 XMMWORD PTR y1o_h$102[rsp], xmm0
  01003	66 0f 6f 84 24
	70 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$99[rsp]
  0100c	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01015	66 0f 7f 84 24
	b0 07 00 00	 movdqa	 XMMWORD PTR y3o_l$103[rsp], xmm0
  0101e	66 0f 6f 84 24
	80 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$100[rsp]
  01027	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01030	66 0f 7f 84 24
	c0 07 00 00	 movdqa	 XMMWORD PTR y3o_h$104[rsp], xmm0
  01039	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  0103f	66 0f fd 84 24
	90 00 00 00	 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  01048	66 0f 7f 84 24
	d0 07 00 00	 movdqa	 XMMWORD PTR sum17$105[rsp], xmm0
  01051	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  01057	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  0105d	66 0f 7f 84 24
	e0 07 00 00	 movdqa	 XMMWORD PTR sum35$106[rsp], xmm0
  01066	66 0f 6f 84 24
	d0 07 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$105[rsp]
  0106f	66 0f 61 84 24
	e0 07 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$106[rsp]
  01078	66 0f 7f 84 24
	f0 07 00 00	 movdqa	 XMMWORD PTR rot1_0lo$107[rsp], xmm0
  01081	66 0f 6f 84 24
	d0 07 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$105[rsp]
  0108a	66 0f 69 84 24
	e0 07 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$106[rsp]
  01093	66 0f 7f 84 24
	00 08 00 00	 movdqa	 XMMWORD PTR rot1_0hi$108[rsp], xmm0
  0109c	66 0f 6f 84 24
	f0 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$107[rsp]
  010a5	66 0f f5 84 24
	d0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  010ae	66 0f 7f 84 24
	10 08 00 00	 movdqa	 XMMWORD PTR y4o_l$109[rsp], xmm0
  010b7	66 0f 6f 84 24
	00 08 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$108[rsp]
  010c0	66 0f f5 84 24
	d0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  010c9	66 0f 7f 84 24
	20 08 00 00	 movdqa	 XMMWORD PTR y4o_h$110[rsp], xmm0
  010d2	66 0f 6f 84 24
	f0 07 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$107[rsp]
  010db	66 0f f5 84 24
	e0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  010e4	66 0f 7f 84 24
	30 08 00 00	 movdqa	 XMMWORD PTR y5o_l$111[rsp], xmm0
  010ed	66 0f 6f 84 24
	00 08 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$108[rsp]
  010f6	66 0f f5 84 24
	e0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  010ff	66 0f 7f 84 24
	40 08 00 00	 movdqa	 XMMWORD PTR y5o_h$112[rsp], xmm0
  01108	66 0f 6f 84 24
	30 07 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$95[rsp]
  01111	66 0f fe 84 24
	10 08 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$109[rsp]
  0111a	66 0f 7f 84 24
	50 08 00 00	 movdqa	 XMMWORD PTR x4_l$113[rsp], xmm0
  01123	66 0f 6f 84 24
	40 07 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$96[rsp]
  0112c	66 0f fe 84 24
	20 08 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$110[rsp]
  01135	66 0f 7f 84 24
	60 08 00 00	 movdqa	 XMMWORD PTR x4_h$114[rsp], xmm0
  0113e	66 0f 6f 84 24
	90 07 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$101[rsp]
  01147	66 0f fe 84 24
	30 08 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$111[rsp]
  01150	66 0f 7f 84 24
	70 08 00 00	 movdqa	 XMMWORD PTR x5_l$115[rsp], xmm0
  01159	66 0f 6f 84 24
	a0 07 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$102[rsp]
  01162	66 0f fe 84 24
	40 08 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$112[rsp]
  0116b	66 0f 7f 84 24
	80 08 00 00	 movdqa	 XMMWORD PTR x5_h$116[rsp], xmm0
  01174	66 0f 6f 84 24
	50 07 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$97[rsp]
  0117d	66 0f fe 84 24
	30 08 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$111[rsp]
  01186	66 0f 7f 84 24
	90 08 00 00	 movdqa	 XMMWORD PTR x6_l$117[rsp], xmm0
  0118f	66 0f 6f 84 24
	60 07 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$98[rsp]
  01198	66 0f fe 84 24
	40 08 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$112[rsp]
  011a1	66 0f 7f 84 24
	a0 08 00 00	 movdqa	 XMMWORD PTR x6_h$118[rsp], xmm0
  011aa	66 0f 6f 84 24
	b0 07 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$103[rsp]
  011b3	66 0f fe 84 24
	10 08 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$109[rsp]
  011bc	66 0f 7f 84 24
	b0 08 00 00	 movdqa	 XMMWORD PTR x7_l$119[rsp], xmm0
  011c5	66 0f 6f 84 24
	c0 07 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$104[rsp]
  011ce	66 0f fe 84 24
	20 08 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$110[rsp]
  011d7	66 0f 7f 84 24
	c0 08 00 00	 movdqa	 XMMWORD PTR x7_h$120[rsp], xmm0
  011e0	66 0f 6f 84 24
	90 06 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$85[rsp]
  011e9	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  011f2	66 0f 7f 84 24
	d0 08 00 00	 movdqa	 XMMWORD PTR abiased_l$121[rsp], xmm0
  011fb	66 0f 6f 84 24
	a0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$86[rsp]
  01204	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  0120d	66 0f 7f 84 24
	e0 08 00 00	 movdqa	 XMMWORD PTR abiased_h$122[rsp], xmm0
  01216	66 0f 6f 84 24
	d0 08 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$121[rsp]
  0121f	66 0f fe 84 24
	b0 08 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$119[rsp]
  01228	66 0f 7f 84 24
	f0 08 00 00	 movdqa	 XMMWORD PTR sum_l$123[rsp], xmm0
  01231	66 0f 6f 84 24
	e0 08 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$122[rsp]
  0123a	66 0f fe 84 24
	c0 08 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$120[rsp]
  01243	66 0f 7f 84 24
	00 09 00 00	 movdqa	 XMMWORD PTR sum_h$124[rsp], xmm0
  0124c	66 0f 6f 84 24
	d0 08 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$121[rsp]
  01255	66 0f fa 84 24
	b0 08 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$119[rsp]
  0125e	66 0f 7f 84 24
	10 09 00 00	 movdqa	 XMMWORD PTR dif_l$125[rsp], xmm0
  01267	66 0f 6f 84 24
	e0 08 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$122[rsp]
  01270	66 0f fa 84 24
	c0 08 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$120[rsp]
  01279	66 0f 7f 84 24
	20 09 00 00	 movdqa	 XMMWORD PTR dif_h$126[rsp], xmm0
  01282	66 0f 6f 84 24
	00 09 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$124[rsp]
  0128b	66 0f 72 e0 11	 psrad	 xmm0, 17
  01290	66 0f 6f 8c 24
	f0 08 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$123[rsp]
  01299	66 0f 72 e1 11	 psrad	 xmm1, 17
  0129e	66 0f 6b c8	 packssdw xmm1, xmm0
  012a2	66 0f 6f c1	 movdqa	 xmm0, xmm1
  012a6	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  012ac	66 0f 6f 84 24
	20 09 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$126[rsp]
  012b5	66 0f 72 e0 11	 psrad	 xmm0, 17
  012ba	66 0f 6f 8c 24
	10 09 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$125[rsp]
  012c3	66 0f 72 e1 11	 psrad	 xmm1, 17
  012c8	66 0f 6b c8	 packssdw xmm1, xmm0
  012cc	66 0f 6f c1	 movdqa	 xmm0, xmm1
  012d0	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  012d9	66 0f 6f 84 24
	d0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$89[rsp]
  012e2	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  012eb	66 0f 7f 84 24
	30 09 00 00	 movdqa	 XMMWORD PTR abiased_l$127[rsp], xmm0
  012f4	66 0f 6f 84 24
	e0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$90[rsp]
  012fd	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  01306	66 0f 7f 84 24
	40 09 00 00	 movdqa	 XMMWORD PTR abiased_h$128[rsp], xmm0
  0130f	66 0f 6f 84 24
	30 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$127[rsp]
  01318	66 0f fe 84 24
	90 08 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$117[rsp]
  01321	66 0f 7f 84 24
	50 09 00 00	 movdqa	 XMMWORD PTR sum_l$129[rsp], xmm0
  0132a	66 0f 6f 84 24
	40 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$128[rsp]
  01333	66 0f fe 84 24
	a0 08 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$118[rsp]
  0133c	66 0f 7f 84 24
	60 09 00 00	 movdqa	 XMMWORD PTR sum_h$130[rsp], xmm0
  01345	66 0f 6f 84 24
	30 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$127[rsp]
  0134e	66 0f fa 84 24
	90 08 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$117[rsp]
  01357	66 0f 7f 84 24
	70 09 00 00	 movdqa	 XMMWORD PTR dif_l$131[rsp], xmm0
  01360	66 0f 6f 84 24
	40 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$128[rsp]
  01369	66 0f fa 84 24
	a0 08 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$118[rsp]
  01372	66 0f 7f 84 24
	80 09 00 00	 movdqa	 XMMWORD PTR dif_h$132[rsp], xmm0
  0137b	66 0f 6f 84 24
	60 09 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$130[rsp]
  01384	66 0f 72 e0 11	 psrad	 xmm0, 17
  01389	66 0f 6f 8c 24
	50 09 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$129[rsp]
  01392	66 0f 72 e1 11	 psrad	 xmm1, 17
  01397	66 0f 6b c8	 packssdw xmm1, xmm0
  0139b	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0139f	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  013a5	66 0f 6f 84 24
	80 09 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$132[rsp]
  013ae	66 0f 72 e0 11	 psrad	 xmm0, 17
  013b3	66 0f 6f 8c 24
	70 09 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$131[rsp]
  013bc	66 0f 72 e1 11	 psrad	 xmm1, 17
  013c1	66 0f 6b c8	 packssdw xmm1, xmm0
  013c5	66 0f 6f c1	 movdqa	 xmm0, xmm1
  013c9	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  013d2	66 0f 6f 84 24
	f0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$91[rsp]
  013db	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  013e4	66 0f 7f 84 24
	90 09 00 00	 movdqa	 XMMWORD PTR abiased_l$133[rsp], xmm0
  013ed	66 0f 6f 84 24
	00 07 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$92[rsp]
  013f6	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  013ff	66 0f 7f 84 24
	a0 09 00 00	 movdqa	 XMMWORD PTR abiased_h$134[rsp], xmm0
  01408	66 0f 6f 84 24
	90 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$133[rsp]
  01411	66 0f fe 84 24
	70 08 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$115[rsp]
  0141a	66 0f 7f 84 24
	b0 09 00 00	 movdqa	 XMMWORD PTR sum_l$135[rsp], xmm0
  01423	66 0f 6f 84 24
	a0 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$134[rsp]
  0142c	66 0f fe 84 24
	80 08 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$116[rsp]
  01435	66 0f 7f 84 24
	c0 09 00 00	 movdqa	 XMMWORD PTR sum_h$136[rsp], xmm0
  0143e	66 0f 6f 84 24
	90 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$133[rsp]
  01447	66 0f fa 84 24
	70 08 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$115[rsp]
  01450	66 0f 7f 84 24
	d0 09 00 00	 movdqa	 XMMWORD PTR dif_l$137[rsp], xmm0
  01459	66 0f 6f 84 24
	a0 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$134[rsp]
  01462	66 0f fa 84 24
	80 08 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$116[rsp]
  0146b	66 0f 7f 84 24
	e0 09 00 00	 movdqa	 XMMWORD PTR dif_h$138[rsp], xmm0
  01474	66 0f 6f 84 24
	c0 09 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$136[rsp]
  0147d	66 0f 72 e0 11	 psrad	 xmm0, 17
  01482	66 0f 6f 8c 24
	b0 09 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$135[rsp]
  0148b	66 0f 72 e1 11	 psrad	 xmm1, 17
  01490	66 0f 6b c8	 packssdw xmm1, xmm0
  01494	66 0f 6f c1	 movdqa	 xmm0, xmm1
  01498	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  0149e	66 0f 6f 84 24
	e0 09 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$138[rsp]
  014a7	66 0f 72 e0 11	 psrad	 xmm0, 17
  014ac	66 0f 6f 8c 24
	d0 09 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$137[rsp]
  014b5	66 0f 72 e1 11	 psrad	 xmm1, 17
  014ba	66 0f 6b c8	 packssdw xmm1, xmm0
  014be	66 0f 6f c1	 movdqa	 xmm0, xmm1
  014c2	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  014c8	66 0f 6f 84 24
	b0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$87[rsp]
  014d1	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  014da	66 0f 7f 84 24
	f0 09 00 00	 movdqa	 XMMWORD PTR abiased_l$139[rsp], xmm0
  014e3	66 0f 6f 84 24
	c0 06 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$88[rsp]
  014ec	66 0f fe 84 24
	40 01 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  014f5	66 0f 7f 84 24
	00 0a 00 00	 movdqa	 XMMWORD PTR abiased_h$140[rsp], xmm0
  014fe	66 0f 6f 84 24
	f0 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$139[rsp]
  01507	66 0f fe 84 24
	50 08 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$113[rsp]
  01510	66 0f 7f 84 24
	10 0a 00 00	 movdqa	 XMMWORD PTR sum_l$141[rsp], xmm0
  01519	66 0f 6f 84 24
	00 0a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$140[rsp]
  01522	66 0f fe 84 24
	60 08 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$114[rsp]
  0152b	66 0f 7f 84 24
	20 0a 00 00	 movdqa	 XMMWORD PTR sum_h$142[rsp], xmm0
  01534	66 0f 6f 84 24
	f0 09 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$139[rsp]
  0153d	66 0f fa 84 24
	50 08 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$113[rsp]
  01546	66 0f 7f 84 24
	30 0a 00 00	 movdqa	 XMMWORD PTR dif_l$143[rsp], xmm0
  0154f	66 0f 6f 84 24
	00 0a 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$140[rsp]
  01558	66 0f fa 84 24
	60 08 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$114[rsp]
  01561	66 0f 7f 84 24
	40 0a 00 00	 movdqa	 XMMWORD PTR dif_h$144[rsp], xmm0
  0156a	66 0f 6f 84 24
	20 0a 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$142[rsp]
  01573	66 0f 72 e0 11	 psrad	 xmm0, 17
  01578	66 0f 6f 8c 24
	10 0a 00 00	 movdqa	 xmm1, XMMWORD PTR sum_l$141[rsp]
  01581	66 0f 72 e1 11	 psrad	 xmm1, 17
  01586	66 0f 6b c8	 packssdw xmm1, xmm0
  0158a	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0158e	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  01594	66 0f 6f 84 24
	40 0a 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$144[rsp]
  0159d	66 0f 72 e0 11	 psrad	 xmm0, 17
  015a2	66 0f 6f 8c 24
	30 0a 00 00	 movdqa	 xmm1, XMMWORD PTR dif_l$143[rsp]
  015ab	66 0f 72 e1 11	 psrad	 xmm1, 17
  015b0	66 0f 6b c8	 packssdw xmm1, xmm0
  015b4	66 0f 6f c1	 movdqa	 xmm0, xmm1
  015b8	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2661 : 
; 2662 :    {
; 2663 :       // pack
; 2664 :       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

  015be	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  015c4	66 0f 67 44 24
	30		 packuswb xmm0, XMMWORD PTR row1$[rsp]
  015ca	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR p0$145[rsp], xmm0

; 2665 :       __m128i p1 = _mm_packus_epi16(row2, row3);

  015d3	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  015d9	66 0f 67 44 24
	50		 packuswb xmm0, XMMWORD PTR row3$[rsp]
  015df	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR p1$146[rsp], xmm0

; 2666 :       __m128i p2 = _mm_packus_epi16(row4, row5);

  015e8	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  015ee	66 0f 67 44 24
	70		 packuswb xmm0, XMMWORD PTR row5$[rsp]
  015f4	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR p2$147[rsp], xmm0

; 2667 :       __m128i p3 = _mm_packus_epi16(row6, row7);

  015fd	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  01606	66 0f 67 84 24
	90 00 00 00	 packuswb xmm0, XMMWORD PTR row7$[rsp]
  0160f	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR p3$148[rsp], xmm0

; 2668 : 
; 2669 :       // 8bit 8x8 transpose pass 1
; 2670 :       dct_interleave8(p0, p2); // a0e0a1e1...

  01618	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  01621	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0162a	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  01633	66 0f 60 84 24
	70 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p2$147[rsp]
  0163c	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR p0$145[rsp], xmm0
  01645	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  0164e	66 0f 68 84 24
	70 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p2$147[rsp]
  01657	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR p2$147[rsp], xmm0

; 2671 :       dct_interleave8(p1, p3); // c0g0c1g1...

  01660	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  01669	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01672	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  0167b	66 0f 60 84 24
	80 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rsp]
  01684	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR p1$146[rsp], xmm0
  0168d	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01696	66 0f 68 84 24
	80 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rsp]
  0169f	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR p3$148[rsp], xmm0

; 2672 : 
; 2673 :       // transpose pass 2
; 2674 :       dct_interleave8(p0, p1); // a0c0e0g0...

  016a8	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  016b1	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  016ba	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  016c3	66 0f 60 84 24
	60 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p1$146[rsp]
  016cc	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR p0$145[rsp], xmm0
  016d5	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  016de	66 0f 68 84 24
	60 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p1$146[rsp]
  016e7	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR p1$146[rsp], xmm0

; 2675 :       dct_interleave8(p2, p3); // b0d0f0h0...

  016f0	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rsp]
  016f9	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01702	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rsp]
  0170b	66 0f 60 84 24
	80 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rsp]
  01714	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR p2$147[rsp], xmm0
  0171d	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01726	66 0f 68 84 24
	80 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rsp]
  0172f	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR p3$148[rsp], xmm0

; 2676 : 
; 2677 :       // transpose pass 3
; 2678 :       dct_interleave8(p0, p2); // a0b0c0d0...

  01738	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  01741	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0174a	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  01753	66 0f 60 84 24
	70 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p2$147[rsp]
  0175c	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR p0$145[rsp], xmm0
  01765	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  0176e	66 0f 68 84 24
	70 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p2$147[rsp]
  01777	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR p2$147[rsp], xmm0

; 2679 :       dct_interleave8(p1, p3); // a4b4c4d4...

  01780	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  01789	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01792	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  0179b	66 0f 60 84 24
	80 0a 00 00	 punpcklbw xmm0, XMMWORD PTR p3$148[rsp]
  017a4	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR p1$146[rsp], xmm0
  017ad	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  017b6	66 0f 68 84 24
	80 0a 00 00	 punpckhbw xmm0, XMMWORD PTR p3$148[rsp]
  017bf	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR p3$148[rsp], xmm0

; 2680 : 
; 2681 :       // store
; 2682 :       _mm_storel_epi64((__m128i *) out, p0); out += out_stride;

  017c8	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  017d0	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  017d9	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  017dd	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  017e5	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  017ed	48 03 c8	 add	 rcx, rax
  017f0	48 8b c1	 mov	 rax, rcx
  017f3	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2683 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

  017fb	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p0$145[rsp]
  01804	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  01809	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  01811	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01815	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  0181d	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  01825	48 03 c8	 add	 rcx, rax
  01828	48 8b c1	 mov	 rax, rcx
  0182b	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2684 :       _mm_storel_epi64((__m128i *) out, p2); out += out_stride;

  01833	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0183b	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rsp]
  01844	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01848	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  01850	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  01858	48 03 c8	 add	 rcx, rax
  0185b	48 8b c1	 mov	 rax, rcx
  0185e	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2685 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

  01866	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p2$147[rsp]
  0186f	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  01874	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0187c	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  01880	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  01888	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  01890	48 03 c8	 add	 rcx, rax
  01893	48 8b c1	 mov	 rax, rcx
  01896	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2686 :       _mm_storel_epi64((__m128i *) out, p1); out += out_stride;

  0189e	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  018a6	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  018af	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  018b3	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  018bb	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  018c3	48 03 c8	 add	 rcx, rax
  018c6	48 8b c1	 mov	 rax, rcx
  018c9	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2687 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

  018d1	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p1$146[rsp]
  018da	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  018df	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  018e7	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  018eb	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  018f3	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  018fb	48 03 c8	 add	 rcx, rax
  018fe	48 8b c1	 mov	 rax, rcx
  01901	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2688 :       _mm_storel_epi64((__m128i *) out, p3); out += out_stride;

  01909	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  01911	66 0f 6f 84 24
	80 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p3$148[rsp]
  0191a	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  0191e	48 63 84 24 a8
	0a 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  01926	48 8b 8c 24 a0
	0a 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0192e	48 03 c8	 add	 rcx, rax
  01931	48 8b c1	 mov	 rax, rcx
  01934	48 89 84 24 a0
	0a 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2689 :       _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));

  0193c	66 0f 6f 84 24
	80 0a 00 00	 movdqa	 xmm0, XMMWORD PTR p3$148[rsp]
  01945	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  0194a	48 8b 84 24 a0
	0a 00 00	 mov	 rax, QWORD PTR out$[rsp]
  01952	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0

; 2690 :    }
; 2691 : 
; 2692 : #undef dct_const
; 2693 : #undef dct_rot
; 2694 : #undef dct_widen
; 2695 : #undef dct_wadd
; 2696 : #undef dct_wsub
; 2697 : #undef dct_bfly32o
; 2698 : #undef dct_interleave8
; 2699 : #undef dct_interleave16
; 2700 : #undef dct_pass
; 2701 : }

  01956	48 81 c4 90 0a
	00 00		 add	 rsp, 2704		; 00000a90H
  0195d	5f		 pop	 rdi
  0195e	c3		 ret	 0
stbi__idct_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
x$ = 32
$T1 = 33
$T2 = 34
s$ = 40
s$ = 48
tv88 = 56
tv129 = 57
tv137 = 58
tv146 = 59
j$ = 80
stbi__get_marker PROC

; 2918 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2919 :    stbi_uc x;
; 2920 :    if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0001b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00022	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00027	74 26		 je	 SHORT $LN4@stbi__get_
  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0002e	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00035	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0003e	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH
  00045	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  0004a	e9 a5 01 00 00	 jmp	 $LN1@stbi__get_
$LN4@stbi__get_:

; 2921 :    x = stbi__get8(j->s);

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00066	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0006d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00074	73 39		 jae	 SHORT $LN8@stbi__get_

; 1615 :       return *s->img_buffer++;

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0007b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00082	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00085	88 44 24 38	 mov	 BYTE PTR tv88[rsp], al
  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0008e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00095	48 ff c0	 inc	 rax
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0009d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000a4	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv88[rsp]
  000a9	88 44 24 21	 mov	 BYTE PTR $T1[rsp], al
  000ad	eb 53		 jmp	 SHORT $LN7@stbi__get_
$LN8@stbi__get_:

; 1616 :    if (s->read_from_callbacks) {

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000b4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000b8	74 43		 je	 SHORT $LN9@stbi__get_

; 1617 :       stbi__refill_buffer(s);

  000ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000bf	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000c9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d3	88 44 24 39	 mov	 BYTE PTR tv129[rsp], al
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000dc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000e3	48 ff c0	 inc	 rax
  000e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000eb	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000f2	0f b6 44 24 39	 movzx	 eax, BYTE PTR tv129[rsp]
  000f7	88 44 24 21	 mov	 BYTE PTR $T1[rsp], al
  000fb	eb 05		 jmp	 SHORT $LN7@stbi__get_
$LN9@stbi__get_:

; 1619 :    }
; 1620 :    return 0;

  000fd	c6 44 24 21 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__get_:

; 2921 :    x = stbi__get8(j->s);

  00102	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp]
  00107	88 44 24 20	 mov	 BYTE PTR x$[rsp], al

; 2922 :    if (x != 0xff) return STBI__MARKER_none;

  0010b	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00110	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00115	74 07		 je	 SHORT $LN5@stbi__get_
  00117	b0 ff		 mov	 al, 255			; 000000ffH
  00119	e9 d6 00 00 00	 jmp	 $LN1@stbi__get_
$LN5@stbi__get_:
$LN2@stbi__get_:

; 2923 :    while (x == 0xff)

  0011e	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00123	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00128	0f 85 c1 00 00
	00		 jne	 $LN3@stbi__get_

; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes

  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00133	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00136	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0013b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00140	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00145	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0014c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00153	73 39		 jae	 SHORT $LN12@stbi__get_

; 1615 :       return *s->img_buffer++;

  00155	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0015a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00161	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00164	88 44 24 3a	 mov	 BYTE PTR tv137[rsp], al
  00168	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0016d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00174	48 ff c0	 inc	 rax
  00177	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0017c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00183	0f b6 44 24 3a	 movzx	 eax, BYTE PTR tv137[rsp]
  00188	88 44 24 22	 mov	 BYTE PTR $T2[rsp], al
  0018c	eb 53		 jmp	 SHORT $LN11@stbi__get_
$LN12@stbi__get_:

; 1616 :    if (s->read_from_callbacks) {

  0018e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00193	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00197	74 43		 je	 SHORT $LN13@stbi__get_

; 1617 :       stbi__refill_buffer(s);

  00199	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0019e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001a3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001a8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b2	88 44 24 3b	 mov	 BYTE PTR tv146[rsp], al
  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001bb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001c2	48 ff c0	 inc	 rax
  001c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001ca	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001d1	0f b6 44 24 3b	 movzx	 eax, BYTE PTR tv146[rsp]
  001d6	88 44 24 22	 mov	 BYTE PTR $T2[rsp], al
  001da	eb 05		 jmp	 SHORT $LN11@stbi__get_
$LN13@stbi__get_:

; 1619 :    }
; 1620 :    return 0;

  001dc	c6 44 24 22 00	 mov	 BYTE PTR $T2[rsp], 0
$LN11@stbi__get_:

; 2924 :       x = stbi__get8(j->s); // consume repeated 0xff fill bytes

  001e1	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T2[rsp]
  001e6	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  001ea	e9 2f ff ff ff	 jmp	 $LN2@stbi__get_
$LN3@stbi__get_:

; 2925 :    return x;

  001ef	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__get_:

; 2926 : }

  001f4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001f8	5f		 pop	 rdi
  001f9	c3		 ret	 0
stbi__get_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv88 = 32
j$ = 64
stbi__jpeg_reset PROC

; 2935 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2936 :    j->code_bits = 0;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0001b	c7 80 24 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18468], 0

; 2937 :    j->code_buffer = 0;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0002a	c7 80 20 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18464], 0

; 2938 :    j->nomore = 0;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00039	c7 80 2c 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18476], 0

; 2939 :    j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

  00043	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00048	48 6b c0 03	 imul	 rax, rax, 3
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00051	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  0005c	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00061	48 6b c0 02	 imul	 rax, rax, 2
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0006a	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00075	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0007a	48 6b c0 01	 imul	 rax, rax, 1
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00083	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  0008e	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00093	48 6b c0 00	 imul	 rax, rax, 0
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0009c	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0

; 2940 :    j->marker = STBI__MARKER_none;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ac	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 2941 :    j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000b8	83 b8 68 48 00
	00 00		 cmp	 DWORD PTR [rax+18536], 0
  000bf	74 11		 je	 SHORT $LN3@stbi__jpeg
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000c6	8b 80 68 48 00
	00		 mov	 eax, DWORD PTR [rax+18536]
  000cc	89 44 24 20	 mov	 DWORD PTR tv88[rsp], eax
  000d0	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
  000d2	c7 44 24 20 ff
	ff ff 7f	 mov	 DWORD PTR tv88[rsp], 2147483647 ; 7fffffffH
$LN4@stbi__jpeg:
  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000df	8b 4c 24 20	 mov	 ecx, DWORD PTR tv88[rsp]
  000e3	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx

; 2942 :    j->eob_run = 0;

  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ee	c7 80 44 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18500], 0

; 2943 :    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2944 :    // since we don't even allow 1<<30 pixels
; 2945 : }

  000f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
stbi__jpeg_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$5 = 64
j$6 = 68
data$7 = 96
n$8 = 228
w$9 = 232
h$10 = 236
ha$11 = 240
i$12 = 244
j$13 = 248
k$14 = 252
x$15 = 256
y$16 = 260
data$17 = 288
n$18 = 420
x2$19 = 424
y2$20 = 428
ha$21 = 432
i$22 = 436
j$23 = 440
n$24 = 444
w$25 = 448
h$26 = 452
data$27 = 456
ha$28 = 464
i$29 = 468
j$30 = 472
k$31 = 476
x$32 = 480
y$33 = 484
n$34 = 488
x2$35 = 492
y2$36 = 496
data$37 = 504
tv190 = 520
tv311 = 524
tv400 = 528
tv518 = 532
__$ArrayPad$ = 536
z$ = 560
stbi__parse_entropy_coded_data PROC

; 2948 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  0000d	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00012	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR [rsp+560]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 2949 :    stbi__jpeg_reset(z);

  00044	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0004c	e8 00 00 00 00	 call	 stbi__jpeg_reset

; 2950 :    if (!z->progressive) {

  00051	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00059	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00060	0f 85 f4 06 00
	00		 jne	 $LN44@stbi__pars

; 2951 :       if (z->scan_n == 1) {

  00066	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0006e	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00075	0f 85 e4 02 00
	00		 jne	 $LN46@stbi__pars

; 2952 :          int i,j;
; 2953 :          STBI_SIMD_ALIGN(short, data[64]);
; 2954 :          int n = z->order[0];

  0007b	b8 04 00 00 00	 mov	 eax, 4
  00080	48 6b c0 00	 imul	 rax, rax, 0
  00084	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0008c	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  00093	89 84 24 e4 00
	00 00		 mov	 DWORD PTR n$8[rsp], eax

; 2955 :          // non-interleaved data, we just need to process one block at a time,
; 2956 :          // in trivial scanline order
; 2957 :          // number of blocks to do just depends on how many actual "pixels" this
; 2958 :          // component has, independent of interleaved MCU blocking and such
; 2959 :          int w = (z->img_comp[n].x+7) >> 3;

  0009a	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR n$8[rsp]
  000a2	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a6	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000ae	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  000b5	83 c0 07	 add	 eax, 7
  000b8	c1 f8 03	 sar	 eax, 3
  000bb	89 84 24 e8 00
	00 00		 mov	 DWORD PTR w$9[rsp], eax

; 2960 :          int h = (z->img_comp[n].y+7) >> 3;

  000c2	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR n$8[rsp]
  000ca	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000ce	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000d6	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  000dd	83 c0 07	 add	 eax, 7
  000e0	c1 f8 03	 sar	 eax, 3
  000e3	89 84 24 ec 00
	00 00		 mov	 DWORD PTR h$10[rsp], eax

; 2961 :          for (j=0; j < h; ++j) {

  000ea	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$6[rsp], 0
  000f2	eb 0a		 jmp	 SHORT $LN4@stbi__pars
$LN2@stbi__pars:
  000f4	8b 44 24 44	 mov	 eax, DWORD PTR j$6[rsp]
  000f8	ff c0		 inc	 eax
  000fa	89 44 24 44	 mov	 DWORD PTR j$6[rsp], eax
$LN4@stbi__pars:
  000fe	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR h$10[rsp]
  00105	39 44 24 44	 cmp	 DWORD PTR j$6[rsp], eax
  00109	0f 8d 41 02 00
	00		 jge	 $LN3@stbi__pars

; 2962 :             for (i=0; i < w; ++i) {

  0010f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$5[rsp], 0
  00117	eb 0a		 jmp	 SHORT $LN7@stbi__pars
$LN5@stbi__pars:
  00119	8b 44 24 40	 mov	 eax, DWORD PTR i$5[rsp]
  0011d	ff c0		 inc	 eax
  0011f	89 44 24 40	 mov	 DWORD PTR i$5[rsp], eax
$LN7@stbi__pars:
  00123	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR w$9[rsp]
  0012a	39 44 24 40	 cmp	 DWORD PTR i$5[rsp], eax
  0012e	0f 8d 17 02 00
	00		 jge	 $LN6@stbi__pars

; 2963 :                int ha = z->img_comp[n].ha;

  00134	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR n$8[rsp]
  0013c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00140	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00148	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  0014f	89 84 24 f0 00
	00 00		 mov	 DWORD PTR ha$11[rsp], eax

; 2964 :                if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  00156	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR n$8[rsp]
  0015e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00162	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0016a	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  00172	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00179	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00181	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00189	48 63 8c 24 f0
	00 00 00	 movsxd	 rcx, DWORD PTR ha$11[rsp]
  00191	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00198	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  001a0	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  001a8	48 63 94 24 f0
	00 00 00	 movsxd	 rdx, DWORD PTR ha$11[rsp]
  001b0	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  001b7	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  001bf	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  001c7	4c 63 84 24 e4
	00 00 00	 movsxd	 r8, DWORD PTR n$8[rsp]
  001cf	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  001d3	4c 8b 8c 24 30
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001db	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  001e3	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  001ea	4c 8b 8c 24 30
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001f2	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  001f7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001fc	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR n$8[rsp]
  00203	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00207	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0020c	4c 8b ca	 mov	 r9, rdx
  0020f	48 8d 54 24 60	 lea	 rdx, QWORD PTR data$7[rsp]
  00214	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0021c	e8 00 00 00 00	 call	 stbi__jpeg_decode_block
  00221	85 c0		 test	 eax, eax
  00223	75 07		 jne	 SHORT $LN48@stbi__pars
  00225	33 c0		 xor	 eax, eax
  00227	e9 44 0b 00 00	 jmp	 $LN1@stbi__pars
$LN48@stbi__pars:

; 2965 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  0022c	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR n$8[rsp]
  00234	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00238	48 63 8c 24 e4
	00 00 00	 movsxd	 rcx, DWORD PTR n$8[rsp]
  00240	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00244	48 63 94 24 e4
	00 00 00	 movsxd	 rdx, DWORD PTR n$8[rsp]
  0024c	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00250	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00258	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  00260	0f af 54 24 44	 imul	 edx, DWORD PTR j$6[rsp]
  00265	c1 e2 03	 shl	 edx, 3
  00268	48 63 d2	 movsxd	 rdx, edx
  0026b	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00273	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  0027b	48 03 ca	 add	 rcx, rdx
  0027e	8b 54 24 40	 mov	 edx, DWORD PTR i$5[rsp]
  00282	c1 e2 03	 shl	 edx, 3
  00285	48 63 d2	 movsxd	 rdx, edx
  00288	48 03 ca	 add	 rcx, rdx
  0028b	4c 8d 44 24 60	 lea	 r8, QWORD PTR data$7[rsp]
  00290	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00298	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  0029f	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002a7	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2966 :                // every data block is an MCU, so countdown the restart interval
; 2967 :                if (--z->todo <= 0) {

  002ad	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002b5	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  002bb	ff c8		 dec	 eax
  002bd	89 84 24 08 02
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  002c4	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002cc	8b 8c 24 08 02
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  002d3	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  002d9	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR tv190[rsp], 0
  002e1	7f 63		 jg	 SHORT $LN49@stbi__pars

; 2968 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  002e3	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002eb	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  002f2	7d 0e		 jge	 SHORT $LN50@stbi__pars
  002f4	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002fc	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00301	90		 npad	 1
$LN50@stbi__pars:

; 2969 :                   // if it's NOT a restart, then just bail, so we get corrupt data
; 2970 :                   // rather than no data
; 2971 :                   if (!STBI__RESTART(z->marker)) return 1;

  00302	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0030a	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00311	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00316	7c 16		 jl	 SHORT $LN52@stbi__pars
  00318	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00320	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00327	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  0032c	7e 0a		 jle	 SHORT $LN51@stbi__pars
$LN52@stbi__pars:
  0032e	b8 01 00 00 00	 mov	 eax, 1
  00333	e9 38 0a 00 00	 jmp	 $LN1@stbi__pars
$LN51@stbi__pars:

; 2972 :                   stbi__jpeg_reset(z);

  00338	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00340	e8 00 00 00 00	 call	 stbi__jpeg_reset
  00345	90		 npad	 1
$LN49@stbi__pars:

; 2973 :                }
; 2974 :             }

  00346	e9 ce fd ff ff	 jmp	 $LN5@stbi__pars
$LN6@stbi__pars:

; 2975 :          }

  0034b	e9 a4 fd ff ff	 jmp	 $LN2@stbi__pars
$LN3@stbi__pars:

; 2976 :          return 1;

  00350	b8 01 00 00 00	 mov	 eax, 1
  00355	e9 16 0a 00 00	 jmp	 $LN1@stbi__pars

; 2977 :       } else { // interleaved

  0035a	e9 f6 03 00 00	 jmp	 $LN47@stbi__pars
$LN46@stbi__pars:

; 2978 :          int i,j,k,x,y;
; 2979 :          STBI_SIMD_ALIGN(short, data[64]);
; 2980 :          for (j=0; j < z->img_mcu_y; ++j) {

  0035f	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$13[rsp], 0
  0036a	eb 10		 jmp	 SHORT $LN10@stbi__pars
$LN8@stbi__pars:
  0036c	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR j$13[rsp]
  00373	ff c0		 inc	 eax
  00375	89 84 24 f8 00
	00 00		 mov	 DWORD PTR j$13[rsp], eax
$LN10@stbi__pars:
  0037c	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00384	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  0038a	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR j$13[rsp], eax
  00391	0f 8d b4 03 00
	00		 jge	 $LN9@stbi__pars

; 2981 :             for (i=0; i < z->img_mcu_x; ++i) {

  00397	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$12[rsp], 0
  003a2	eb 10		 jmp	 SHORT $LN13@stbi__pars
$LN11@stbi__pars:
  003a4	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR i$12[rsp]
  003ab	ff c0		 inc	 eax
  003ad	89 84 24 f4 00
	00 00		 mov	 DWORD PTR i$12[rsp], eax
$LN13@stbi__pars:
  003b4	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003bc	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  003c2	39 84 24 f4 00
	00 00		 cmp	 DWORD PTR i$12[rsp], eax
  003c9	0f 8d 77 03 00
	00		 jge	 $LN12@stbi__pars

; 2982 :                // scan an interleaved mcu... process scan_n components in order
; 2983 :                for (k=0; k < z->scan_n; ++k) {

  003cf	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$14[rsp], 0
  003da	eb 10		 jmp	 SHORT $LN16@stbi__pars
$LN14@stbi__pars:
  003dc	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR k$14[rsp]
  003e3	ff c0		 inc	 eax
  003e5	89 84 24 fc 00
	00 00		 mov	 DWORD PTR k$14[rsp], eax
$LN16@stbi__pars:
  003ec	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003f4	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  003fa	39 84 24 fc 00
	00 00		 cmp	 DWORD PTR k$14[rsp], eax
  00401	0f 8d a1 02 00
	00		 jge	 $LN15@stbi__pars

; 2984 :                   int n = z->order[k];

  00407	48 63 84 24 fc
	00 00 00	 movsxd	 rax, DWORD PTR k$14[rsp]
  0040f	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00417	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  0041e	89 84 24 a4 01
	00 00		 mov	 DWORD PTR n$18[rsp], eax

; 2985 :                   // scan out an mcu's worth of this component; that's just determined
; 2986 :                   // by the basic H and V specified for the component
; 2987 :                   for (y=0; y < z->img_comp[n].v; ++y) {

  00425	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR y$16[rsp], 0
  00430	eb 10		 jmp	 SHORT $LN19@stbi__pars
$LN17@stbi__pars:
  00432	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR y$16[rsp]
  00439	ff c0		 inc	 eax
  0043b	89 84 24 04 01
	00 00		 mov	 DWORD PTR y$16[rsp], eax
$LN19@stbi__pars:
  00442	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  0044a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0044e	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00456	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  0045d	39 84 24 04 01
	00 00		 cmp	 DWORD PTR y$16[rsp], eax
  00464	0f 8d 39 02 00
	00		 jge	 $LN18@stbi__pars

; 2988 :                      for (x=0; x < z->img_comp[n].h; ++x) {

  0046a	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR x$15[rsp], 0
  00475	eb 10		 jmp	 SHORT $LN22@stbi__pars
$LN20@stbi__pars:
  00477	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$15[rsp]
  0047e	ff c0		 inc	 eax
  00480	89 84 24 00 01
	00 00		 mov	 DWORD PTR x$15[rsp], eax
$LN22@stbi__pars:
  00487	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  0048f	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00493	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0049b	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  004a2	39 84 24 00 01
	00 00		 cmp	 DWORD PTR x$15[rsp], eax
  004a9	0f 8d ef 01 00
	00		 jge	 $LN21@stbi__pars

; 2989 :                         int x2 = (i*z->img_comp[n].h + x)*8;

  004af	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  004b7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004bb	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004c3	8b 94 24 f4 00
	00 00		 mov	 edx, DWORD PTR i$12[rsp]
  004ca	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  004d2	8b c2		 mov	 eax, edx
  004d4	03 84 24 00 01
	00 00		 add	 eax, DWORD PTR x$15[rsp]
  004db	c1 e0 03	 shl	 eax, 3
  004de	89 84 24 a8 01
	00 00		 mov	 DWORD PTR x2$19[rsp], eax

; 2990 :                         int y2 = (j*z->img_comp[n].v + y)*8;

  004e5	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  004ed	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004f1	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004f9	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR j$13[rsp]
  00500	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00508	8b c2		 mov	 eax, edx
  0050a	03 84 24 04 01
	00 00		 add	 eax, DWORD PTR y$16[rsp]
  00511	c1 e0 03	 shl	 eax, 3
  00514	89 84 24 ac 01
	00 00		 mov	 DWORD PTR y2$20[rsp], eax

; 2991 :                         int ha = z->img_comp[n].ha;

  0051b	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  00523	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00527	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0052f	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00536	89 84 24 b0 01
	00 00		 mov	 DWORD PTR ha$21[rsp], eax

; 2992 :                         if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  0053d	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  00545	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00549	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00551	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  00559	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00560	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00568	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00570	48 63 8c 24 b0
	01 00 00	 movsxd	 rcx, DWORD PTR ha$21[rsp]
  00578	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  0057f	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00587	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  0058f	48 63 94 24 b0
	01 00 00	 movsxd	 rdx, DWORD PTR ha$21[rsp]
  00597	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  0059e	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  005a6	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  005ae	4c 63 84 24 a4
	01 00 00	 movsxd	 r8, DWORD PTR n$18[rsp]
  005b6	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  005ba	4c 8b 8c 24 30
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  005c2	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  005ca	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  005d1	4c 8b 8c 24 30
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  005d9	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  005de	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005e3	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR n$18[rsp]
  005ea	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005ee	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005f3	4c 8b ca	 mov	 r9, rdx
  005f6	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR data$17[rsp]
  005fe	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00606	e8 00 00 00 00	 call	 stbi__jpeg_decode_block
  0060b	85 c0		 test	 eax, eax
  0060d	75 07		 jne	 SHORT $LN53@stbi__pars
  0060f	33 c0		 xor	 eax, eax
  00611	e9 5a 07 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 2993 :                         z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);

  00616	48 63 84 24 a4
	01 00 00	 movsxd	 rax, DWORD PTR n$18[rsp]
  0061e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00622	48 63 8c 24 a4
	01 00 00	 movsxd	 rcx, DWORD PTR n$18[rsp]
  0062a	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0062e	48 63 94 24 a4
	01 00 00	 movsxd	 rdx, DWORD PTR n$18[rsp]
  00636	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0063a	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00642	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0064a	0f af 94 24 ac
	01 00 00	 imul	 edx, DWORD PTR y2$20[rsp]
  00652	48 63 d2	 movsxd	 rdx, edx
  00655	4c 8b 84 24 30
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  0065d	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  00665	48 03 ca	 add	 rcx, rdx
  00668	48 63 94 24 a8
	01 00 00	 movsxd	 rdx, DWORD PTR x2$19[rsp]
  00670	48 03 ca	 add	 rcx, rdx
  00673	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR data$17[rsp]
  0067b	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00683	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  0068a	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00692	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]
  00698	90		 npad	 1

; 2994 :                      }

  00699	e9 d9 fd ff ff	 jmp	 $LN20@stbi__pars
$LN21@stbi__pars:

; 2995 :                   }

  0069e	e9 8f fd ff ff	 jmp	 $LN17@stbi__pars
$LN18@stbi__pars:

; 2996 :                }

  006a3	e9 34 fd ff ff	 jmp	 $LN14@stbi__pars
$LN15@stbi__pars:

; 2997 :                // after all interleaved components, that's an interleaved MCU,
; 2998 :                // so now count down the restart interval
; 2999 :                if (--z->todo <= 0) {

  006a8	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006b0	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  006b6	ff c8		 dec	 eax
  006b8	89 84 24 0c 02
	00 00		 mov	 DWORD PTR tv311[rsp], eax
  006bf	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006c7	8b 8c 24 0c 02
	00 00		 mov	 ecx, DWORD PTR tv311[rsp]
  006ce	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  006d4	83 bc 24 0c 02
	00 00 00	 cmp	 DWORD PTR tv311[rsp], 0
  006dc	7f 63		 jg	 SHORT $LN54@stbi__pars

; 3000 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  006de	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006e6	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  006ed	7d 0e		 jge	 SHORT $LN55@stbi__pars
  006ef	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006f7	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  006fc	90		 npad	 1
$LN55@stbi__pars:

; 3001 :                   if (!STBI__RESTART(z->marker)) return 1;

  006fd	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00705	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0070c	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00711	7c 16		 jl	 SHORT $LN57@stbi__pars
  00713	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0071b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00722	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00727	7e 0a		 jle	 SHORT $LN56@stbi__pars
$LN57@stbi__pars:
  00729	b8 01 00 00 00	 mov	 eax, 1
  0072e	e9 3d 06 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 3002 :                   stbi__jpeg_reset(z);

  00733	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0073b	e8 00 00 00 00	 call	 stbi__jpeg_reset
  00740	90		 npad	 1
$LN54@stbi__pars:

; 3003 :                }
; 3004 :             }

  00741	e9 5e fc ff ff	 jmp	 $LN11@stbi__pars
$LN12@stbi__pars:

; 3005 :          }

  00746	e9 21 fc ff ff	 jmp	 $LN8@stbi__pars
$LN9@stbi__pars:

; 3006 :          return 1;

  0074b	b8 01 00 00 00	 mov	 eax, 1
  00750	e9 1b 06 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 3007 :       }
; 3008 :    } else {

  00755	e9 16 06 00 00	 jmp	 $LN45@stbi__pars
$LN44@stbi__pars:

; 3009 :       if (z->scan_n == 1) {

  0075a	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00762	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00769	0f 85 db 02 00
	00		 jne	 $LN58@stbi__pars

; 3010 :          int i,j;
; 3011 :          int n = z->order[0];

  0076f	b8 04 00 00 00	 mov	 eax, 4
  00774	48 6b c0 00	 imul	 rax, rax, 0
  00778	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00780	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  00787	89 84 24 bc 01
	00 00		 mov	 DWORD PTR n$24[rsp], eax

; 3012 :          // non-interleaved data, we just need to process one block at a time,
; 3013 :          // in trivial scanline order
; 3014 :          // number of blocks to do just depends on how many actual "pixels" this
; 3015 :          // component has, independent of interleaved MCU blocking and such
; 3016 :          int w = (z->img_comp[n].x+7) >> 3;

  0078e	48 63 84 24 bc
	01 00 00	 movsxd	 rax, DWORD PTR n$24[rsp]
  00796	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0079a	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007a2	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  007a9	83 c0 07	 add	 eax, 7
  007ac	c1 f8 03	 sar	 eax, 3
  007af	89 84 24 c0 01
	00 00		 mov	 DWORD PTR w$25[rsp], eax

; 3017 :          int h = (z->img_comp[n].y+7) >> 3;

  007b6	48 63 84 24 bc
	01 00 00	 movsxd	 rax, DWORD PTR n$24[rsp]
  007be	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007c2	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007ca	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  007d1	83 c0 07	 add	 eax, 7
  007d4	c1 f8 03	 sar	 eax, 3
  007d7	89 84 24 c4 01
	00 00		 mov	 DWORD PTR h$26[rsp], eax

; 3018 :          for (j=0; j < h; ++j) {

  007de	c7 84 24 b8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR j$23[rsp], 0
  007e9	eb 10		 jmp	 SHORT $LN25@stbi__pars
$LN23@stbi__pars:
  007eb	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR j$23[rsp]
  007f2	ff c0		 inc	 eax
  007f4	89 84 24 b8 01
	00 00		 mov	 DWORD PTR j$23[rsp], eax
$LN25@stbi__pars:
  007fb	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR h$26[rsp]
  00802	39 84 24 b8 01
	00 00		 cmp	 DWORD PTR j$23[rsp], eax
  00809	0f 8d 2c 02 00
	00		 jge	 $LN24@stbi__pars

; 3019 :             for (i=0; i < w; ++i) {

  0080f	c7 84 24 b4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$22[rsp], 0
  0081a	eb 10		 jmp	 SHORT $LN28@stbi__pars
$LN26@stbi__pars:
  0081c	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR i$22[rsp]
  00823	ff c0		 inc	 eax
  00825	89 84 24 b4 01
	00 00		 mov	 DWORD PTR i$22[rsp], eax
$LN28@stbi__pars:
  0082c	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR w$25[rsp]
  00833	39 84 24 b4 01
	00 00		 cmp	 DWORD PTR i$22[rsp], eax
  0083a	0f 8d f6 01 00
	00		 jge	 $LN27@stbi__pars

; 3020 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  00840	48 63 84 24 bc
	01 00 00	 movsxd	 rax, DWORD PTR n$24[rsp]
  00848	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0084c	48 63 8c 24 bc
	01 00 00	 movsxd	 rcx, DWORD PTR n$24[rsp]
  00854	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00858	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00860	44 8b 84 24 b8
	01 00 00	 mov	 r8d, DWORD PTR j$23[rsp]
  00868	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00871	41 8b c8	 mov	 ecx, r8d
  00874	8b 94 24 b4 01
	00 00		 mov	 edx, DWORD PTR i$22[rsp]
  0087b	03 d1		 add	 edx, ecx
  0087d	8b ca		 mov	 ecx, edx
  0087f	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00882	48 63 c9	 movsxd	 rcx, ecx
  00885	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0088d	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00895	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00899	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR data$27[rsp], rax

; 3021 :                if (z->spec_start == 0) {

  008a1	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008a9	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  008b0	75 60		 jne	 SHORT $LN60@stbi__pars

; 3022 :                   if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  008b2	48 63 84 24 bc
	01 00 00	 movsxd	 rax, DWORD PTR n$24[rsp]
  008ba	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  008be	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008c6	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  008ce	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  008d5	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008dd	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  008e2	44 8b 8c 24 bc
	01 00 00	 mov	 r9d, DWORD PTR n$24[rsp]
  008ea	4c 8b c0	 mov	 r8, rax
  008ed	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR data$27[rsp]
  008f5	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008fd	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_dc
  00902	85 c0		 test	 eax, eax
  00904	75 07		 jne	 SHORT $LN62@stbi__pars

; 3023 :                      return 0;

  00906	33 c0		 xor	 eax, eax
  00908	e9 63 04 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 3024 :                } else {

  0090d	e9 86 00 00 00	 jmp	 $LN61@stbi__pars
$LN60@stbi__pars:

; 3025 :                   int ha = z->img_comp[n].ha;

  00912	48 63 84 24 bc
	01 00 00	 movsxd	 rax, DWORD PTR n$24[rsp]
  0091a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0091e	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00926	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  0092d	89 84 24 d0 01
	00 00		 mov	 DWORD PTR ha$28[rsp], eax

; 3026 :                   if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

  00934	48 63 84 24 d0
	01 00 00	 movsxd	 rax, DWORD PTR ha$28[rsp]
  0093c	48 69 c0 00 04
	00 00		 imul	 rax, rax, 1024		; 00000400H
  00943	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0094b	48 8d 84 01 88
	36 00 00	 lea	 rax, QWORD PTR [rcx+rax+13960]
  00953	48 63 8c 24 d0
	01 00 00	 movsxd	 rcx, DWORD PTR ha$28[rsp]
  0095b	48 69 c9 90 06
	00 00		 imul	 rcx, rcx, 1680		; 00000690H
  00962	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0096a	48 8d 8c 0a 48
	1a 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+6728]
  00972	4c 8b c8	 mov	 r9, rax
  00975	4c 8b c1	 mov	 r8, rcx
  00978	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR data$27[rsp]
  00980	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00988	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_ac
  0098d	85 c0		 test	 eax, eax
  0098f	75 07		 jne	 SHORT $LN63@stbi__pars

; 3027 :                      return 0;

  00991	33 c0		 xor	 eax, eax
  00993	e9 d8 03 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:
$LN61@stbi__pars:

; 3028 :                }
; 3029 :                // every data block is an MCU, so countdown the restart interval
; 3030 :                if (--z->todo <= 0) {

  00998	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009a0	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  009a6	ff c8		 dec	 eax
  009a8	89 84 24 10 02
	00 00		 mov	 DWORD PTR tv400[rsp], eax
  009af	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009b7	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR tv400[rsp]
  009be	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  009c4	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR tv400[rsp], 0
  009cc	7f 63		 jg	 SHORT $LN64@stbi__pars

; 3031 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  009ce	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009d6	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  009dd	7d 0e		 jge	 SHORT $LN65@stbi__pars
  009df	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009e7	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  009ec	90		 npad	 1
$LN65@stbi__pars:

; 3032 :                   if (!STBI__RESTART(z->marker)) return 1;

  009ed	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009f5	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  009fc	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00a01	7c 16		 jl	 SHORT $LN67@stbi__pars
  00a03	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a0b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00a12	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00a17	7e 0a		 jle	 SHORT $LN66@stbi__pars
$LN67@stbi__pars:
  00a19	b8 01 00 00 00	 mov	 eax, 1
  00a1e	e9 4d 03 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 3033 :                   stbi__jpeg_reset(z);

  00a23	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a2b	e8 00 00 00 00	 call	 stbi__jpeg_reset
  00a30	90		 npad	 1
$LN64@stbi__pars:

; 3034 :                }
; 3035 :             }

  00a31	e9 e6 fd ff ff	 jmp	 $LN26@stbi__pars
$LN27@stbi__pars:

; 3036 :          }

  00a36	e9 b0 fd ff ff	 jmp	 $LN23@stbi__pars
$LN24@stbi__pars:

; 3037 :          return 1;

  00a3b	b8 01 00 00 00	 mov	 eax, 1
  00a40	e9 2b 03 00 00	 jmp	 $LN1@stbi__pars

; 3038 :       } else { // interleaved

  00a45	e9 26 03 00 00	 jmp	 $LN59@stbi__pars
$LN58@stbi__pars:

; 3039 :          int i,j,k,x,y;
; 3040 :          for (j=0; j < z->img_mcu_y; ++j) {

  00a4a	c7 84 24 d8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR j$30[rsp], 0
  00a55	eb 10		 jmp	 SHORT $LN31@stbi__pars
$LN29@stbi__pars:
  00a57	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR j$30[rsp]
  00a5e	ff c0		 inc	 eax
  00a60	89 84 24 d8 01
	00 00		 mov	 DWORD PTR j$30[rsp], eax
$LN31@stbi__pars:
  00a67	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a6f	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  00a75	39 84 24 d8 01
	00 00		 cmp	 DWORD PTR j$30[rsp], eax
  00a7c	0f 8d e9 02 00
	00		 jge	 $LN30@stbi__pars

; 3041 :             for (i=0; i < z->img_mcu_x; ++i) {

  00a82	c7 84 24 d4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$29[rsp], 0
  00a8d	eb 10		 jmp	 SHORT $LN34@stbi__pars
$LN32@stbi__pars:
  00a8f	8b 84 24 d4 01
	00 00		 mov	 eax, DWORD PTR i$29[rsp]
  00a96	ff c0		 inc	 eax
  00a98	89 84 24 d4 01
	00 00		 mov	 DWORD PTR i$29[rsp], eax
$LN34@stbi__pars:
  00a9f	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00aa7	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  00aad	39 84 24 d4 01
	00 00		 cmp	 DWORD PTR i$29[rsp], eax
  00ab4	0f 8d ac 02 00
	00		 jge	 $LN33@stbi__pars

; 3042 :                // scan an interleaved mcu... process scan_n components in order
; 3043 :                for (k=0; k < z->scan_n; ++k) {

  00aba	c7 84 24 dc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR k$31[rsp], 0
  00ac5	eb 10		 jmp	 SHORT $LN37@stbi__pars
$LN35@stbi__pars:
  00ac7	8b 84 24 dc 01
	00 00		 mov	 eax, DWORD PTR k$31[rsp]
  00ace	ff c0		 inc	 eax
  00ad0	89 84 24 dc 01
	00 00		 mov	 DWORD PTR k$31[rsp], eax
$LN37@stbi__pars:
  00ad7	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00adf	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00ae5	39 84 24 dc 01
	00 00		 cmp	 DWORD PTR k$31[rsp], eax
  00aec	0f 8d d9 01 00
	00		 jge	 $LN36@stbi__pars

; 3044 :                   int n = z->order[k];

  00af2	48 63 84 24 dc
	01 00 00	 movsxd	 rax, DWORD PTR k$31[rsp]
  00afa	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b02	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  00b09	89 84 24 e8 01
	00 00		 mov	 DWORD PTR n$34[rsp], eax

; 3045 :                   // scan out an mcu's worth of this component; that's just determined
; 3046 :                   // by the basic H and V specified for the component
; 3047 :                   for (y=0; y < z->img_comp[n].v; ++y) {

  00b10	c7 84 24 e4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR y$33[rsp], 0
  00b1b	eb 10		 jmp	 SHORT $LN40@stbi__pars
$LN38@stbi__pars:
  00b1d	8b 84 24 e4 01
	00 00		 mov	 eax, DWORD PTR y$33[rsp]
  00b24	ff c0		 inc	 eax
  00b26	89 84 24 e4 01
	00 00		 mov	 DWORD PTR y$33[rsp], eax
$LN40@stbi__pars:
  00b2d	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00b35	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b39	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b41	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00b48	39 84 24 e4 01
	00 00		 cmp	 DWORD PTR y$33[rsp], eax
  00b4f	0f 8d 71 01 00
	00		 jge	 $LN39@stbi__pars

; 3048 :                      for (x=0; x < z->img_comp[n].h; ++x) {

  00b55	c7 84 24 e0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR x$32[rsp], 0
  00b60	eb 10		 jmp	 SHORT $LN43@stbi__pars
$LN41@stbi__pars:
  00b62	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR x$32[rsp]
  00b69	ff c0		 inc	 eax
  00b6b	89 84 24 e0 01
	00 00		 mov	 DWORD PTR x$32[rsp], eax
$LN43@stbi__pars:
  00b72	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00b7a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b7e	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b86	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  00b8d	39 84 24 e0 01
	00 00		 cmp	 DWORD PTR x$32[rsp], eax
  00b94	0f 8d 27 01 00
	00		 jge	 $LN42@stbi__pars

; 3049 :                         int x2 = (i*z->img_comp[n].h + x);

  00b9a	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00ba2	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ba6	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00bae	8b 94 24 d4 01
	00 00		 mov	 edx, DWORD PTR i$29[rsp]
  00bb5	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00bbd	8b c2		 mov	 eax, edx
  00bbf	03 84 24 e0 01
	00 00		 add	 eax, DWORD PTR x$32[rsp]
  00bc6	89 84 24 ec 01
	00 00		 mov	 DWORD PTR x2$35[rsp], eax

; 3050 :                         int y2 = (j*z->img_comp[n].v + y);

  00bcd	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00bd5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00bd9	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00be1	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR j$30[rsp]
  00be8	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00bf0	8b c2		 mov	 eax, edx
  00bf2	03 84 24 e4 01
	00 00		 add	 eax, DWORD PTR y$33[rsp]
  00bf9	89 84 24 f0 01
	00 00		 mov	 DWORD PTR y2$36[rsp], eax

; 3051 :                         short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

  00c00	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00c08	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00c0c	48 63 8c 24 e8
	01 00 00	 movsxd	 rcx, DWORD PTR n$34[rsp]
  00c14	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00c18	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00c20	44 8b 84 24 f0
	01 00 00	 mov	 r8d, DWORD PTR y2$36[rsp]
  00c28	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00c31	41 8b c8	 mov	 ecx, r8d
  00c34	8b 94 24 ec 01
	00 00		 mov	 edx, DWORD PTR x2$35[rsp]
  00c3b	03 d1		 add	 edx, ecx
  00c3d	8b ca		 mov	 ecx, edx
  00c3f	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00c42	48 63 c9	 movsxd	 rcx, ecx
  00c45	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00c4d	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00c55	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00c59	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR data$37[rsp], rax

; 3052 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  00c61	48 63 84 24 e8
	01 00 00	 movsxd	 rax, DWORD PTR n$34[rsp]
  00c69	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00c6d	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c75	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  00c7d	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00c84	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c8c	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00c91	44 8b 8c 24 e8
	01 00 00	 mov	 r9d, DWORD PTR n$34[rsp]
  00c99	4c 8b c0	 mov	 r8, rax
  00c9c	48 8b 94 24 f8
	01 00 00	 mov	 rdx, QWORD PTR data$37[rsp]
  00ca4	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00cac	e8 00 00 00 00	 call	 stbi__jpeg_decode_block_prog_dc
  00cb1	85 c0		 test	 eax, eax
  00cb3	75 07		 jne	 SHORT $LN68@stbi__pars

; 3053 :                            return 0;

  00cb5	33 c0		 xor	 eax, eax
  00cb7	e9 b4 00 00 00	 jmp	 $LN1@stbi__pars
$LN68@stbi__pars:

; 3054 :                      }

  00cbc	e9 a1 fe ff ff	 jmp	 $LN41@stbi__pars
$LN42@stbi__pars:

; 3055 :                   }

  00cc1	e9 57 fe ff ff	 jmp	 $LN38@stbi__pars
$LN39@stbi__pars:

; 3056 :                }

  00cc6	e9 fc fd ff ff	 jmp	 $LN35@stbi__pars
$LN36@stbi__pars:

; 3057 :                // after all interleaved components, that's an interleaved MCU,
; 3058 :                // so now count down the restart interval
; 3059 :                if (--z->todo <= 0) {

  00ccb	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00cd3	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00cd9	ff c8		 dec	 eax
  00cdb	89 84 24 14 02
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00ce2	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00cea	8b 8c 24 14 02
	00 00		 mov	 ecx, DWORD PTR tv518[rsp]
  00cf1	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00cf7	83 bc 24 14 02
	00 00 00	 cmp	 DWORD PTR tv518[rsp], 0
  00cff	7f 60		 jg	 SHORT $LN69@stbi__pars

; 3060 :                   if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00d01	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d09	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00d10	7d 0e		 jge	 SHORT $LN70@stbi__pars
  00d12	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00d1a	e8 00 00 00 00	 call	 stbi__grow_buffer_unsafe
  00d1f	90		 npad	 1
$LN70@stbi__pars:

; 3061 :                   if (!STBI__RESTART(z->marker)) return 1;

  00d20	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d28	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00d2f	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00d34	7c 16		 jl	 SHORT $LN72@stbi__pars
  00d36	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d3e	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00d45	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00d4a	7e 07		 jle	 SHORT $LN71@stbi__pars
$LN72@stbi__pars:
  00d4c	b8 01 00 00 00	 mov	 eax, 1
  00d51	eb 1d		 jmp	 SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 3062 :                   stbi__jpeg_reset(z);

  00d53	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00d5b	e8 00 00 00 00	 call	 stbi__jpeg_reset
  00d60	90		 npad	 1
$LN69@stbi__pars:

; 3063 :                }
; 3064 :             }

  00d61	e9 29 fd ff ff	 jmp	 $LN32@stbi__pars
$LN33@stbi__pars:

; 3065 :          }

  00d66	e9 ec fc ff ff	 jmp	 $LN29@stbi__pars
$LN30@stbi__pars:

; 3066 :          return 1;

  00d6b	b8 01 00 00 00	 mov	 eax, 1
$LN59@stbi__pars:
$LN45@stbi__pars:
$LN1@stbi__pars:

; 3067 :       }
; 3068 :    }
; 3069 : }

  00d70	48 8b f8	 mov	 rdi, rax
  00d73	48 8b cc	 mov	 rcx, rsp
  00d76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_entropy_coded_data$rtcFrameData
  00d7d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00d82	48 8b c7	 mov	 rax, rdi
  00d85	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d8d	48 33 cc	 xor	 rcx, rsp
  00d90	e8 00 00 00 00	 call	 __security_check_cookie
  00d95	48 81 c4 20 02
	00 00		 add	 rsp, 544		; 00000220H
  00d9c	5f		 pop	 rdi
  00d9d	c3		 ret	 0
stbi__parse_entropy_coded_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
data$ = 64
dequant$ = 72
stbi__jpeg_dequantize PROC

; 3072 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	90		 npad	 1

; 3073 :    int i;
; 3074 :    for (i=0; i < 64; ++i)

  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00024	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00026	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__jpeg:
  00030	83 7c 24 20 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00035	7d 2f		 jge	 SHORT $LN3@stbi__jpeg

; 3075 :       data[i] *= dequant[i];

  00037	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00041	48 8b 54 24 48	 mov	 rdx, QWORD PTR dequant$[rsp]
  00046	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0004a	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  0004f	0f bf 04 42	 movsx	 eax, WORD PTR [rdx+rax*2]
  00053	0f af c1	 imul	 eax, ecx
  00056	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005b	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  00060	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  00064	eb c0		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 3076 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5f		 pop	 rdi
  0006b	c3		 ret	 0
stbi__jpeg_dequantize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
n$3 = 40
w$4 = 44
h$5 = 48
data$6 = 56
z$ = 80
stbi__jpeg_finish PROC

; 3079 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3080 :    if (z->progressive) {

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0001b	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00022	0f 84 aa 01 00
	00		 je	 $LN11@stbi__jpeg

; 3081 :       // dequantize and idct the data
; 3082 :       int i,j,n;
; 3083 :       for (n=0; n < z->s->img_n; ++n) {

  00028	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR n$3[rsp], 0
  00030	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00032	8b 44 24 28	 mov	 eax, DWORD PTR n$3[rsp]
  00036	ff c0		 inc	 eax
  00038	89 44 24 28	 mov	 DWORD PTR n$3[rsp], eax
$LN4@stbi__jpeg:
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00047	39 44 24 28	 cmp	 DWORD PTR n$3[rsp], eax
  0004b	0f 8d 81 01 00
	00		 jge	 $LN3@stbi__jpeg

; 3084 :          int w = (z->img_comp[n].x+7) >> 3;

  00051	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$3[rsp]
  00056	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0005f	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00066	83 c0 07	 add	 eax, 7
  00069	c1 f8 03	 sar	 eax, 3
  0006c	89 44 24 2c	 mov	 DWORD PTR w$4[rsp], eax

; 3085 :          int h = (z->img_comp[n].y+7) >> 3;

  00070	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$3[rsp]
  00075	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0007e	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00085	83 c0 07	 add	 eax, 7
  00088	c1 f8 03	 sar	 eax, 3
  0008b	89 44 24 30	 mov	 DWORD PTR h$5[rsp], eax

; 3086 :          for (j=0; j < h; ++j) {

  0008f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$2[rsp], 0
  00097	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  00099	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax
$LN7@stbi__jpeg:
  000a3	8b 44 24 30	 mov	 eax, DWORD PTR h$5[rsp]
  000a7	39 44 24 24	 cmp	 DWORD PTR j$2[rsp], eax
  000ab	0f 8d 1c 01 00
	00		 jge	 $LN6@stbi__jpeg

; 3087 :             for (i=0; i < w; ++i) {

  000b1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000b9	eb 0a		 jmp	 SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
  000bb	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000bf	ff c0		 inc	 eax
  000c1	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN10@stbi__jpeg:
  000c5	8b 44 24 2c	 mov	 eax, DWORD PTR w$4[rsp]
  000c9	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  000cd	0f 8d f5 00 00
	00		 jge	 $LN9@stbi__jpeg

; 3088 :                short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  000d3	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$3[rsp]
  000d8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000dc	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR n$3[rsp]
  000e1	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  000e5	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  000ea	44 8b 44 24 24	 mov	 r8d, DWORD PTR j$2[rsp]
  000ef	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  000f8	41 8b c8	 mov	 ecx, r8d
  000fb	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  000ff	03 d1		 add	 edx, ecx
  00101	8b ca		 mov	 ecx, edx
  00103	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00106	48 63 c9	 movsxd	 rcx, ecx
  00109	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  0010e	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00116	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0011a	48 89 44 24 38	 mov	 QWORD PTR data$6[rsp], rax

; 3089 :                stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

  0011f	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$3[rsp]
  00124	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00128	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0012d	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  00135	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  0013c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00141	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00149	48 8b d0	 mov	 rdx, rax
  0014c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$6[rsp]
  00151	e8 00 00 00 00	 call	 stbi__jpeg_dequantize

; 3090 :                z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  00156	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$3[rsp]
  0015b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0015f	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR n$3[rsp]
  00164	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00168	48 63 54 24 28	 movsxd	 rdx, DWORD PTR n$3[rsp]
  0016d	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00171	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00176	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0017e	0f af 54 24 24	 imul	 edx, DWORD PTR j$2[rsp]
  00183	c1 e2 03	 shl	 edx, 3
  00186	48 63 d2	 movsxd	 rdx, edx
  00189	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  0018e	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  00196	48 03 ca	 add	 rcx, rdx
  00199	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  0019d	c1 e2 03	 shl	 edx, 3
  001a0	48 63 d2	 movsxd	 rdx, edx
  001a3	48 03 ca	 add	 rcx, rdx
  001a6	4c 8b 44 24 38	 mov	 r8, QWORD PTR data$6[rsp]
  001ab	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  001b0	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  001b7	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001bc	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]
  001c2	90		 npad	 1

; 3091 :             }

  001c3	e9 f3 fe ff ff	 jmp	 $LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 3092 :          }

  001c8	e9 cc fe ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 3093 :       }

  001cd	e9 60 fe ff ff	 jmp	 $LN2@stbi__jpeg
$LN3@stbi__jpeg:
$LN11@stbi__jpeg:

; 3094 :    }
; 3095 : }

  001d2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001d6	5f		 pop	 rdi
  001d7	c3		 ret	 0
stbi__jpeg_finish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
L$ = 32
q$4 = 36
p$5 = 40
sixteen$6 = 44
t$7 = 48
i$8 = 52
v$9 = 56
sizes$10 = 80
i$11 = 148
n$12 = 152
q$13 = 156
tc$14 = 160
th$15 = 164
ok$16 = 168
i$17 = 172
ok$18 = 176
i$19 = 180
$T20 = 192
$T21 = 193
$T22 = 194
$T23 = 195
$T24 = 196
$T25 = 197
$T26 = 198
$T27 = 199
s$ = 200
s$ = 208
s$ = 216
s$ = 224
s$ = 232
s$ = 240
s$ = 248
s$ = 256
s$ = 264
tv64 = 272
tv311 = 276
tv320 = 277
tv88 = 280
tv149 = 284
tv328 = 288
tv337 = 289
tv152 = 292
tv155 = 296
tv345 = 300
tv354 = 301
tv362 = 302
tv371 = 303
tv379 = 304
tv388 = 305
tv236 = 308
tv396 = 312
tv405 = 313
tv413 = 314
tv454 = 315
tv462 = 316
tv471 = 317
tv479 = 318
tv488 = 319
__$ArrayPad$ = 320
z$ = 352
m$ = 360
stbi__process_marker PROC

; 3098 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR [rsp+352]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00043	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3099 :    int L;
; 3100 :    switch (m) {

  00048	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR m$[rsp]
  0004f	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv64[rsp], eax
  00056	81 bc 24 10 01
	00 00 c4 00 00
	00		 cmp	 DWORD PTR tv64[rsp], 196 ; 000000c4H
  00061	0f 84 fe 03 00
	00		 je	 $LN29@stbi__proc
  00067	81 bc 24 10 01
	00 00 db 00 00
	00		 cmp	 DWORD PTR tv64[rsp], 219 ; 000000dbH
  00072	74 7e		 je	 SHORT $LN26@stbi__proc
  00074	81 bc 24 10 01
	00 00 dd 00 00
	00		 cmp	 DWORD PTR tv64[rsp], 221 ; 000000ddH
  0007f	74 23		 je	 SHORT $LN24@stbi__proc
  00081	81 bc 24 10 01
	00 00 ff 00 00
	00		 cmp	 DWORD PTR tv64[rsp], 255 ; 000000ffH
  0008c	74 05		 je	 SHORT $LN23@stbi__proc
  0008e	e9 4b 09 00 00	 jmp	 $LN2@stbi__proc
$LN23@stbi__proc:

; 3101 :       case STBI__MARKER_none: // no marker found
; 3102 :          return stbi__err("expected marker","Corrupt JPEG");

  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KLNDOKJD@expected?5marker@
  0009a	e8 00 00 00 00	 call	 stbi__err
  0009f	e9 fc 0e 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3103 : 
; 3104 :       case 0xDD: // DRI - specify restart interval
; 3105 :          if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

  000a4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000ac	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000af	e8 00 00 00 00	 call	 stbi__get16be
  000b4	83 f8 04	 cmp	 eax, 4
  000b7	74 11		 je	 SHORT $LN25@stbi__proc
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@LPHNODCG@bad?5DRI?5len@
  000c0	e8 00 00 00 00	 call	 stbi__err
  000c5	e9 d6 0e 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:

; 3106 :          z->restart_interval = stbi__get16be(z->s);

  000ca	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000d2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d5	e8 00 00 00 00	 call	 stbi__get16be
  000da	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000e2	89 81 68 48 00
	00		 mov	 DWORD PTR [rcx+18536], eax

; 3107 :          return 1;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	e9 ae 0e 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3108 : 
; 3109 :       case 0xDB: // DQT - define quantization table
; 3110 :          L = stbi__get16be(z->s)-2;

  000f2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000fa	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000fd	e8 00 00 00 00	 call	 stbi__get16be
  00102	83 e8 02	 sub	 eax, 2
  00105	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN4@stbi__proc:

; 3111 :          while (L > 0) {

  00109	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  0010e	0f 8e 26 03 00
	00		 jle	 $LN5@stbi__proc

; 3112 :             int q = stbi__get8(z->s);

  00114	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0011c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00127	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0012f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00137	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0013e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00145	73 4b		 jae	 SHORT $LN63@stbi__proc

; 1615 :       return *s->img_buffer++;

  00147	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00156	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00159	88 84 24 14 01
	00 00		 mov	 BYTE PTR tv311[rsp], al
  00160	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00168	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0016f	48 ff c0	 inc	 rax
  00172	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0017a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00181	0f b6 84 24 14
	01 00 00	 movzx	 eax, BYTE PTR tv311[rsp]
  00189	88 84 24 c0 00
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00190	eb 6e		 jmp	 SHORT $LN62@stbi__proc
$LN63@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00192	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0019a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0019e	74 58		 je	 SHORT $LN64@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  001a0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a8	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001ad	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bf	88 84 24 15 01
	00 00		 mov	 BYTE PTR tv320[rsp], al
  001c6	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ce	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001d5	48 ff c0	 inc	 rax
  001d8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001e7	0f b6 84 24 15
	01 00 00	 movzx	 eax, BYTE PTR tv320[rsp]
  001ef	88 84 24 c0 00
	00 00		 mov	 BYTE PTR $T20[rsp], al
  001f6	eb 08		 jmp	 SHORT $LN62@stbi__proc
$LN64@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  001f8	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR $T20[rsp], 0
$LN62@stbi__proc:

; 3112 :             int q = stbi__get8(z->s);

  00200	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR $T20[rsp]
  00208	0f b6 c0	 movzx	 eax, al
  0020b	89 44 24 24	 mov	 DWORD PTR q$4[rsp], eax

; 3113 :             int p = q >> 4, sixteen = (p != 0);

  0020f	8b 44 24 24	 mov	 eax, DWORD PTR q$4[rsp]
  00213	c1 f8 04	 sar	 eax, 4
  00216	89 44 24 28	 mov	 DWORD PTR p$5[rsp], eax
  0021a	83 7c 24 28 00	 cmp	 DWORD PTR p$5[rsp], 0
  0021f	74 0d		 je	 SHORT $LN52@stbi__proc
  00221	c7 84 24 18 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv88[rsp], 1
  0022c	eb 0b		 jmp	 SHORT $LN53@stbi__proc
$LN52@stbi__proc:
  0022e	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv88[rsp], 0
$LN53@stbi__proc:
  00239	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv88[rsp]
  00240	89 44 24 2c	 mov	 DWORD PTR sixteen$6[rsp], eax

; 3114 :             int t = q & 15,i;

  00244	8b 44 24 24	 mov	 eax, DWORD PTR q$4[rsp]
  00248	83 e0 0f	 and	 eax, 15
  0024b	89 44 24 30	 mov	 DWORD PTR t$7[rsp], eax

; 3115 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

  0024f	83 7c 24 28 00	 cmp	 DWORD PTR p$5[rsp], 0
  00254	74 18		 je	 SHORT $LN27@stbi__proc
  00256	83 7c 24 28 01	 cmp	 DWORD PTR p$5[rsp], 1
  0025b	74 11		 je	 SHORT $LN27@stbi__proc
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@BOFJCHAP@bad?5DQT?5type@
  00264	e8 00 00 00 00	 call	 stbi__err
  00269	e9 32 0d 00 00	 jmp	 $LN1@stbi__proc
$LN27@stbi__proc:

; 3116 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

  0026e	83 7c 24 30 03	 cmp	 DWORD PTR t$7[rsp], 3
  00273	7e 11		 jle	 SHORT $LN28@stbi__proc
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CNHKKDIM@bad?5DQT?5table@
  0027c	e8 00 00 00 00	 call	 stbi__err
  00281	e9 1a 0d 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 3117 : 
; 3118 :             for (i=0; i < 64; ++i)

  00286	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  0028e	eb 0a		 jmp	 SHORT $LN8@stbi__proc
$LN6@stbi__proc:
  00290	8b 44 24 34	 mov	 eax, DWORD PTR i$8[rsp]
  00294	ff c0		 inc	 eax
  00296	89 44 24 34	 mov	 DWORD PTR i$8[rsp], eax
$LN8@stbi__proc:
  0029a	83 7c 24 34 40	 cmp	 DWORD PTR i$8[rsp], 64	; 00000040H
  0029f	0f 8d 5e 01 00
	00		 jge	 $LN7@stbi__proc

; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

  002a5	83 7c 24 2c 00	 cmp	 DWORD PTR sixteen$6[rsp], 0
  002aa	74 1c		 je	 SHORT $LN54@stbi__proc
  002ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002b4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002b7	e8 00 00 00 00	 call	 stbi__get16be
  002bc	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  002c3	e9 fe 00 00 00	 jmp	 $LN55@stbi__proc
$LN54@stbi__proc:
  002c8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d3	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  002db	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002e3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002eb	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002f2	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002f9	73 4b		 jae	 SHORT $LN67@stbi__proc

; 1615 :       return *s->img_buffer++;

  002fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00303	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0030a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030d	88 84 24 20 01
	00 00		 mov	 BYTE PTR tv328[rsp], al
  00314	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0031c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00323	48 ff c0	 inc	 rax
  00326	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0032e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00335	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR tv328[rsp]
  0033d	88 84 24 c1 00
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00344	eb 6e		 jmp	 SHORT $LN66@stbi__proc
$LN67@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00346	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0034e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00352	74 58		 je	 SHORT $LN68@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00354	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035c	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00361	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00369	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00370	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00373	88 84 24 21 01
	00 00		 mov	 BYTE PTR tv337[rsp], al
  0037a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00382	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00389	48 ff c0	 inc	 rax
  0038c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00394	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0039b	0f b6 84 24 21
	01 00 00	 movzx	 eax, BYTE PTR tv337[rsp]
  003a3	88 84 24 c1 00
	00 00		 mov	 BYTE PTR $T21[rsp], al
  003aa	eb 08		 jmp	 SHORT $LN66@stbi__proc
$LN68@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  003ac	c6 84 24 c1 00
	00 00 00	 mov	 BYTE PTR $T21[rsp], 0
$LN66@stbi__proc:

; 3119 :                z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

  003b4	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR $T21[rsp]
  003bc	0f b6 c0	 movzx	 eax, al
  003bf	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv149[rsp], eax
$LN55@stbi__proc:
  003c6	48 63 44 24 30	 movsxd	 rax, DWORD PTR t$7[rsp]
  003cb	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  003d2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003da	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  003e2	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$8[rsp]
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__jpeg_dezigzag
  003ee	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003f2	0f b7 94 24 1c
	01 00 00	 movzx	 edx, WORD PTR tv149[rsp]
  003fa	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  003fe	e9 8d fe ff ff	 jmp	 $LN6@stbi__proc
$LN7@stbi__proc:

; 3120 :             L -= (sixteen ? 129 : 65);

  00403	83 7c 24 2c 00	 cmp	 DWORD PTR sixteen$6[rsp], 0
  00408	74 0d		 je	 SHORT $LN56@stbi__proc
  0040a	c7 84 24 24 01
	00 00 81 00 00
	00		 mov	 DWORD PTR tv152[rsp], 129 ; 00000081H
  00415	eb 0b		 jmp	 SHORT $LN57@stbi__proc
$LN56@stbi__proc:
  00417	c7 84 24 24 01
	00 00 41 00 00
	00		 mov	 DWORD PTR tv152[rsp], 65 ; 00000041H
$LN57@stbi__proc:
  00422	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv152[rsp]
  00429	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  0042d	2b c8		 sub	 ecx, eax
  0042f	8b c1		 mov	 eax, ecx
  00431	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3121 :          }

  00435	e9 cf fc ff ff	 jmp	 $LN4@stbi__proc
$LN5@stbi__proc:

; 3122 :          return L==0;

  0043a	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  0043f	75 0d		 jne	 SHORT $LN58@stbi__proc
  00441	c7 84 24 28 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv155[rsp], 1
  0044c	eb 0b		 jmp	 SHORT $LN59@stbi__proc
$LN58@stbi__proc:
  0044e	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN59@stbi__proc:
  00459	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv155[rsp]
  00460	e9 3b 0b 00 00	 jmp	 $LN1@stbi__proc
$LN29@stbi__proc:

; 3123 : 
; 3124 :       case 0xC4: // DHT - define huffman table
; 3125 :          L = stbi__get16be(z->s)-2;

  00465	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0046d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00470	e8 00 00 00 00	 call	 stbi__get16be
  00475	83 e8 02	 sub	 eax, 2
  00478	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN9@stbi__proc:

; 3126 :          while (L > 0) {

  0047c	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  00481	0f 8e 2c 05 00
	00		 jle	 $LN10@stbi__proc

; 3127 :             stbi_uc *v;
; 3128 :             int sizes[16],i,n=0;

  00487	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR n$12[rsp], 0

; 3129 :             int q = stbi__get8(z->s);

  00492	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0049a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049d	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  004a5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ad	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b5	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  004bc	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  004c3	73 4b		 jae	 SHORT $LN71@stbi__proc

; 1615 :       return *s->img_buffer++;

  004c5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004cd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004d7	88 84 24 2c 01
	00 00		 mov	 BYTE PTR tv345[rsp], al
  004de	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004e6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004ed	48 ff c0	 inc	 rax
  004f0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004f8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004ff	0f b6 84 24 2c
	01 00 00	 movzx	 eax, BYTE PTR tv345[rsp]
  00507	88 84 24 c2 00
	00 00		 mov	 BYTE PTR $T22[rsp], al
  0050e	eb 6e		 jmp	 SHORT $LN70@stbi__proc
$LN71@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00510	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00518	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0051c	74 58		 je	 SHORT $LN72@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0051e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00526	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0052b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00533	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0053a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0053d	88 84 24 2d 01
	00 00		 mov	 BYTE PTR tv354[rsp], al
  00544	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0054c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00553	48 ff c0	 inc	 rax
  00556	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00565	0f b6 84 24 2d
	01 00 00	 movzx	 eax, BYTE PTR tv354[rsp]
  0056d	88 84 24 c2 00
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00574	eb 08		 jmp	 SHORT $LN70@stbi__proc
$LN72@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00576	c6 84 24 c2 00
	00 00 00	 mov	 BYTE PTR $T22[rsp], 0
$LN70@stbi__proc:

; 3129 :             int q = stbi__get8(z->s);

  0057e	0f b6 84 24 c2
	00 00 00	 movzx	 eax, BYTE PTR $T22[rsp]
  00586	0f b6 c0	 movzx	 eax, al
  00589	89 84 24 9c 00
	00 00		 mov	 DWORD PTR q$13[rsp], eax

; 3130 :             int tc = q >> 4;

  00590	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR q$13[rsp]
  00597	c1 f8 04	 sar	 eax, 4
  0059a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tc$14[rsp], eax

; 3131 :             int th = q & 15;

  005a1	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR q$13[rsp]
  005a8	83 e0 0f	 and	 eax, 15
  005ab	89 84 24 a4 00
	00 00		 mov	 DWORD PTR th$15[rsp], eax

; 3132 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");

  005b2	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR tc$14[rsp], 1
  005ba	7f 0a		 jg	 SHORT $LN31@stbi__proc
  005bc	83 bc 24 a4 00
	00 00 03	 cmp	 DWORD PTR th$15[rsp], 3
  005c4	7e 11		 jle	 SHORT $LN30@stbi__proc
$LN31@stbi__proc:
  005c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JLGKOCGN@bad?5DHT?5header@
  005cd	e8 00 00 00 00	 call	 stbi__err
  005d2	e9 c9 09 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3133 :             for (i=0; i < 16; ++i) {

  005d7	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$11[rsp], 0
  005e2	eb 10		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  005e4	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR i$11[rsp]
  005eb	ff c0		 inc	 eax
  005ed	89 84 24 94 00
	00 00		 mov	 DWORD PTR i$11[rsp], eax
$LN13@stbi__proc:
  005f4	83 bc 24 94 00
	00 00 10	 cmp	 DWORD PTR i$11[rsp], 16
  005fc	0f 8d 26 01 00
	00		 jge	 $LN12@stbi__proc

; 3134 :                sizes[i] = stbi__get8(z->s);

  00602	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0060a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0060d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00615	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00625	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0062c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00633	73 4b		 jae	 SHORT $LN75@stbi__proc

; 1615 :       return *s->img_buffer++;

  00635	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0063d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00644	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00647	88 84 24 2e 01
	00 00		 mov	 BYTE PTR tv362[rsp], al
  0064e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00656	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0065d	48 ff c0	 inc	 rax
  00660	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00668	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0066f	0f b6 84 24 2e
	01 00 00	 movzx	 eax, BYTE PTR tv362[rsp]
  00677	88 84 24 c3 00
	00 00		 mov	 BYTE PTR $T23[rsp], al
  0067e	eb 6e		 jmp	 SHORT $LN74@stbi__proc
$LN75@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00680	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00688	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0068c	74 58		 je	 SHORT $LN76@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0068e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00696	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0069b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006ad	88 84 24 2f 01
	00 00		 mov	 BYTE PTR tv371[rsp], al
  006b4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006bc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006c3	48 ff c0	 inc	 rax
  006c6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006ce	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006d5	0f b6 84 24 2f
	01 00 00	 movzx	 eax, BYTE PTR tv371[rsp]
  006dd	88 84 24 c3 00
	00 00		 mov	 BYTE PTR $T23[rsp], al
  006e4	eb 08		 jmp	 SHORT $LN74@stbi__proc
$LN76@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  006e6	c6 84 24 c3 00
	00 00 00	 mov	 BYTE PTR $T23[rsp], 0
$LN74@stbi__proc:

; 3134 :                sizes[i] = stbi__get8(z->s);

  006ee	0f b6 84 24 c3
	00 00 00	 movzx	 eax, BYTE PTR $T23[rsp]
  006f6	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR i$11[rsp]
  006fe	0f b6 c0	 movzx	 eax, al
  00701	89 44 8c 50	 mov	 DWORD PTR sizes$10[rsp+rcx*4], eax

; 3135 :                n += sizes[i];

  00705	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR i$11[rsp]
  0070d	8b 44 84 50	 mov	 eax, DWORD PTR sizes$10[rsp+rax*4]
  00711	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR n$12[rsp]
  00718	03 c8		 add	 ecx, eax
  0071a	8b c1		 mov	 eax, ecx
  0071c	89 84 24 98 00
	00 00		 mov	 DWORD PTR n$12[rsp], eax

; 3136 :             }

  00723	e9 bc fe ff ff	 jmp	 $LN11@stbi__proc
$LN12@stbi__proc:

; 3137 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!

  00728	81 bc 24 98 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR n$12[rsp], 256 ; 00000100H
  00733	7e 11		 jle	 SHORT $LN32@stbi__proc
  00735	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JLGKOCGN@bad?5DHT?5header@
  0073c	e8 00 00 00 00	 call	 stbi__err
  00741	e9 5a 08 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 3138 :             L -= 17;

  00746	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  0074a	83 e8 11	 sub	 eax, 17
  0074d	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3139 :             if (tc == 0) {

  00751	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tc$14[rsp], 0
  00759	75 5a		 jne	 SHORT $LN33@stbi__proc

; 3140 :                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;

  0075b	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR th$15[rsp]
  00763	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  0076a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00772	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00777	48 8d 54 24 50	 lea	 rdx, QWORD PTR sizes$10[rsp]
  0077c	48 8b c8	 mov	 rcx, rax
  0077f	e8 00 00 00 00	 call	 stbi__build_huffman
  00784	85 c0		 test	 eax, eax
  00786	75 07		 jne	 SHORT $LN35@stbi__proc
  00788	33 c0		 xor	 eax, eax
  0078a	e9 11 08 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3141 :                v = z->huff_dc[th].values;

  0078f	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR th$15[rsp]
  00797	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  0079e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007a6	48 8d 84 01 08
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1032]
  007ae	48 89 44 24 38	 mov	 QWORD PTR v$9[rsp], rax

; 3142 :             } else {

  007b3	eb 5b		 jmp	 SHORT $LN34@stbi__proc
$LN33@stbi__proc:

; 3143 :                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;

  007b5	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR th$15[rsp]
  007bd	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  007c4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007cc	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  007d4	48 8d 54 24 50	 lea	 rdx, QWORD PTR sizes$10[rsp]
  007d9	48 8b c8	 mov	 rcx, rax
  007dc	e8 00 00 00 00	 call	 stbi__build_huffman
  007e1	85 c0		 test	 eax, eax
  007e3	75 07		 jne	 SHORT $LN36@stbi__proc
  007e5	33 c0		 xor	 eax, eax
  007e7	e9 b4 07 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 3144 :                v = z->huff_ac[th].values;

  007ec	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR th$15[rsp]
  007f4	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  007fb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00803	48 8d 84 01 48
	1e 00 00	 lea	 rax, QWORD PTR [rcx+rax+7752]
  0080b	48 89 44 24 38	 mov	 QWORD PTR v$9[rsp], rax
$LN34@stbi__proc:

; 3145 :             }
; 3146 :             for (i=0; i < n; ++i)

  00810	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$11[rsp], 0
  0081b	eb 10		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  0081d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR i$11[rsp]
  00824	ff c0		 inc	 eax
  00826	89 84 24 94 00
	00 00		 mov	 DWORD PTR i$11[rsp], eax
$LN16@stbi__proc:
  0082d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR n$12[rsp]
  00834	39 84 24 94 00
	00 00		 cmp	 DWORD PTR i$11[rsp], eax
  0083b	0f 8d 09 01 00
	00		 jge	 $LN15@stbi__proc

; 3147 :                v[i] = stbi__get8(z->s);

  00841	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00849	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0084c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00854	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00864	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0086b	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00872	73 4b		 jae	 SHORT $LN79@stbi__proc

; 1615 :       return *s->img_buffer++;

  00874	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0087c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00883	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00886	88 84 24 30 01
	00 00		 mov	 BYTE PTR tv379[rsp], al
  0088d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00895	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0089c	48 ff c0	 inc	 rax
  0089f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008a7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  008ae	0f b6 84 24 30
	01 00 00	 movzx	 eax, BYTE PTR tv379[rsp]
  008b6	88 84 24 c4 00
	00 00		 mov	 BYTE PTR $T24[rsp], al
  008bd	eb 6e		 jmp	 SHORT $LN78@stbi__proc
$LN79@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  008bf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008c7	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  008cb	74 58		 je	 SHORT $LN80@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  008cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008d5	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  008da	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008e2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  008e9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008ec	88 84 24 31 01
	00 00		 mov	 BYTE PTR tv388[rsp], al
  008f3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008fb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00902	48 ff c0	 inc	 rax
  00905	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0090d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00914	0f b6 84 24 31
	01 00 00	 movzx	 eax, BYTE PTR tv388[rsp]
  0091c	88 84 24 c4 00
	00 00		 mov	 BYTE PTR $T24[rsp], al
  00923	eb 08		 jmp	 SHORT $LN78@stbi__proc
$LN80@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00925	c6 84 24 c4 00
	00 00 00	 mov	 BYTE PTR $T24[rsp], 0
$LN78@stbi__proc:

; 3147 :                v[i] = stbi__get8(z->s);

  0092d	0f b6 84 24 c4
	00 00 00	 movzx	 eax, BYTE PTR $T24[rsp]
  00935	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR i$11[rsp]
  0093d	48 8b 54 24 38	 mov	 rdx, QWORD PTR v$9[rsp]
  00942	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00945	e9 d3 fe ff ff	 jmp	 $LN14@stbi__proc
$LN15@stbi__proc:

; 3148 :             if (tc != 0)

  0094a	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tc$14[rsp], 0
  00952	74 47		 je	 SHORT $LN37@stbi__proc

; 3149 :                stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

  00954	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR th$15[rsp]
  0095c	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00963	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0096b	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  00973	48 63 8c 24 a4
	00 00 00	 movsxd	 rcx, DWORD PTR th$15[rsp]
  0097b	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00982	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0098a	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00992	48 8b d0	 mov	 rdx, rax
  00995	e8 00 00 00 00	 call	 stbi__build_fast_ac
  0099a	90		 npad	 1
$LN37@stbi__proc:

; 3150 :             L -= n;

  0099b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR n$12[rsp]
  009a2	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  009a6	2b c8		 sub	 ecx, eax
  009a8	8b c1		 mov	 eax, ecx
  009aa	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3151 :          }

  009ae	e9 c9 fa ff ff	 jmp	 $LN9@stbi__proc
$LN10@stbi__proc:

; 3152 :          return L==0;

  009b3	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  009b8	75 0d		 jne	 SHORT $LN60@stbi__proc
  009ba	c7 84 24 34 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv236[rsp], 1
  009c5	eb 0b		 jmp	 SHORT $LN61@stbi__proc
$LN60@stbi__proc:
  009c7	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv236[rsp], 0
$LN61@stbi__proc:
  009d2	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv236[rsp]
  009d9	e9 c2 05 00 00	 jmp	 $LN1@stbi__proc
$LN2@stbi__proc:

; 3153 :    }
; 3154 : 
; 3155 :    // check for comment block or APP blocks
; 3156 :    if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

  009de	81 bc 24 68 01
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  009e9	7c 0d		 jl	 SHORT $LN40@stbi__proc
  009eb	81 bc 24 68 01
	00 00 ef 00 00
	00		 cmp	 DWORD PTR m$[rsp], 239	; 000000efH
  009f6	7e 11		 jle	 SHORT $LN39@stbi__proc
$LN40@stbi__proc:
  009f8	81 bc 24 68 01
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  00a03	0f 85 8b 05 00
	00		 jne	 $LN38@stbi__proc
$LN39@stbi__proc:

; 3157 :       L = stbi__get16be(z->s);

  00a09	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a11	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a14	e8 00 00 00 00	 call	 stbi__get16be
  00a19	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3158 :       if (L < 2) {

  00a1d	83 7c 24 20 02	 cmp	 DWORD PTR L$[rsp], 2
  00a22	7d 31		 jge	 SHORT $LN41@stbi__proc

; 3159 :          if (m == 0xFE)

  00a24	81 bc 24 68 01
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  00a2f	75 13		 jne	 SHORT $LN42@stbi__proc

; 3160 :             return stbi__err("bad COM len","Corrupt JPEG");

  00a31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CICAFFCH@bad?5COM?5len@
  00a38	e8 00 00 00 00	 call	 stbi__err
  00a3d	e9 5e 05 00 00	 jmp	 $LN1@stbi__proc
  00a42	eb 11		 jmp	 SHORT $LN43@stbi__proc
$LN42@stbi__proc:

; 3161 :          else
; 3162 :             return stbi__err("bad APP len","Corrupt JPEG");

  00a44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@EENLKPDI@bad?5APP?5len@
  00a4b	e8 00 00 00 00	 call	 stbi__err
  00a50	e9 4b 05 00 00	 jmp	 $LN1@stbi__proc
$LN43@stbi__proc:
$LN41@stbi__proc:

; 3163 :       }
; 3164 :       L -= 2;

  00a55	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00a59	83 e8 02	 sub	 eax, 2
  00a5c	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3165 : 
; 3166 :       if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

  00a60	81 bc 24 68 01
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  00a6b	0f 85 8b 01 00
	00		 jne	 $LN44@stbi__proc
  00a71	83 7c 24 20 05	 cmp	 DWORD PTR L$[rsp], 5
  00a76	0f 8c 80 01 00
	00		 jl	 $LN44@stbi__proc

; 3167 :          static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3168 :          int ok = 1;

  00a7c	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ok$16[rsp], 1

; 3169 :          int i;
; 3170 :          for (i=0; i < 5; ++i)

  00a87	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$17[rsp], 0
  00a92	eb 10		 jmp	 SHORT $LN19@stbi__proc
$LN17@stbi__proc:
  00a94	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR i$17[rsp]
  00a9b	ff c0		 inc	 eax
  00a9d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR i$17[rsp], eax
$LN19@stbi__proc:
  00aa4	83 bc 24 ac 00
	00 00 05	 cmp	 DWORD PTR i$17[rsp], 5
  00aac	0f 8d 1e 01 00
	00		 jge	 $LN18@stbi__proc

; 3171 :             if (stbi__get8(z->s) != tag[i])

  00ab2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00aba	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00abd	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00ac5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00acd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ad5	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00adc	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00ae3	73 4b		 jae	 SHORT $LN83@stbi__proc

; 1615 :       return *s->img_buffer++;

  00ae5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aed	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00af4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00af7	88 84 24 38 01
	00 00		 mov	 BYTE PTR tv396[rsp], al
  00afe	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b06	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b0d	48 ff c0	 inc	 rax
  00b10	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b18	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b1f	0f b6 84 24 38
	01 00 00	 movzx	 eax, BYTE PTR tv396[rsp]
  00b27	88 84 24 c5 00
	00 00		 mov	 BYTE PTR $T25[rsp], al
  00b2e	eb 6e		 jmp	 SHORT $LN82@stbi__proc
$LN83@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00b30	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b38	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00b3c	74 58		 je	 SHORT $LN84@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00b3e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b46	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00b4b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b53	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b5a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b5d	88 84 24 39 01
	00 00		 mov	 BYTE PTR tv405[rsp], al
  00b64	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b6c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b73	48 ff c0	 inc	 rax
  00b76	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b7e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b85	0f b6 84 24 39
	01 00 00	 movzx	 eax, BYTE PTR tv405[rsp]
  00b8d	88 84 24 c5 00
	00 00		 mov	 BYTE PTR $T25[rsp], al
  00b94	eb 08		 jmp	 SHORT $LN82@stbi__proc
$LN84@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00b96	c6 84 24 c5 00
	00 00 00	 mov	 BYTE PTR $T25[rsp], 0
$LN82@stbi__proc:

; 3171 :             if (stbi__get8(z->s) != tag[i])

  00b9e	0f b6 84 24 c5
	00 00 00	 movzx	 eax, BYTE PTR $T25[rsp]
  00ba6	0f b6 c0	 movzx	 eax, al
  00ba9	48 63 8c 24 ac
	00 00 00	 movsxd	 rcx, DWORD PTR i$17[rsp]
  00bb1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?O@??stbi__process_marker@@9@9
  00bb8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00bbc	3b c1		 cmp	 eax, ecx
  00bbe	74 0b		 je	 SHORT $LN46@stbi__proc

; 3172 :                ok = 0;

  00bc0	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ok$16[rsp], 0
$LN46@stbi__proc:
  00bcb	e9 c4 fe ff ff	 jmp	 $LN17@stbi__proc
$LN18@stbi__proc:

; 3173 :          L -= 5;

  00bd0	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00bd4	83 e8 05	 sub	 eax, 5
  00bd7	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3174 :          if (ok)

  00bdb	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR ok$16[rsp], 0
  00be3	74 12		 je	 SHORT $LN47@stbi__proc

; 3175 :             z->jfif = 1;

  00be5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bed	c7 80 48 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18504], 1
$LN47@stbi__proc:

; 3176 :       } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

  00bf7	e9 7d 03 00 00	 jmp	 $LN45@stbi__proc
$LN44@stbi__proc:
  00bfc	81 bc 24 68 01
	00 00 ee 00 00
	00		 cmp	 DWORD PTR m$[rsp], 238	; 000000eeH
  00c07	0f 85 6c 03 00
	00		 jne	 $LN48@stbi__proc
  00c0d	83 7c 24 20 0c	 cmp	 DWORD PTR L$[rsp], 12
  00c12	0f 8c 61 03 00
	00		 jl	 $LN48@stbi__proc

; 3177 :          static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3178 :          int ok = 1;

  00c18	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ok$18[rsp], 1

; 3179 :          int i;
; 3180 :          for (i=0; i < 6; ++i)

  00c23	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$19[rsp], 0
  00c2e	eb 10		 jmp	 SHORT $LN22@stbi__proc
$LN20@stbi__proc:
  00c30	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR i$19[rsp]
  00c37	ff c0		 inc	 eax
  00c39	89 84 24 b4 00
	00 00		 mov	 DWORD PTR i$19[rsp], eax
$LN22@stbi__proc:
  00c40	83 bc 24 b4 00
	00 00 06	 cmp	 DWORD PTR i$19[rsp], 6
  00c48	0f 8d 1e 01 00
	00		 jge	 $LN21@stbi__proc

; 3181 :             if (stbi__get8(z->s) != tag[i])

  00c4e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c56	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c59	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00c61	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c69	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c71	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00c78	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00c7f	73 4b		 jae	 SHORT $LN87@stbi__proc

; 1615 :       return *s->img_buffer++;

  00c81	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c89	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c90	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c93	88 84 24 3a 01
	00 00		 mov	 BYTE PTR tv413[rsp], al
  00c9a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ca2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ca9	48 ff c0	 inc	 rax
  00cac	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cb4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00cbb	0f b6 84 24 3a
	01 00 00	 movzx	 eax, BYTE PTR tv413[rsp]
  00cc3	88 84 24 c6 00
	00 00		 mov	 BYTE PTR $T26[rsp], al
  00cca	eb 6e		 jmp	 SHORT $LN86@stbi__proc
$LN87@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00ccc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cd4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00cd8	74 58		 je	 SHORT $LN88@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00cda	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ce2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00ce7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cef	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00cf6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00cf9	88 84 24 3b 01
	00 00		 mov	 BYTE PTR tv454[rsp], al
  00d00	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d08	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d0f	48 ff c0	 inc	 rax
  00d12	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d1a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00d21	0f b6 84 24 3b
	01 00 00	 movzx	 eax, BYTE PTR tv454[rsp]
  00d29	88 84 24 c6 00
	00 00		 mov	 BYTE PTR $T26[rsp], al
  00d30	eb 08		 jmp	 SHORT $LN86@stbi__proc
$LN88@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00d32	c6 84 24 c6 00
	00 00 00	 mov	 BYTE PTR $T26[rsp], 0
$LN86@stbi__proc:

; 3181 :             if (stbi__get8(z->s) != tag[i])

  00d3a	0f b6 84 24 c6
	00 00 00	 movzx	 eax, BYTE PTR $T26[rsp]
  00d42	0f b6 c0	 movzx	 eax, al
  00d45	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR i$19[rsp]
  00d4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?BA@??stbi__process_marker@@9@9
  00d54	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d58	3b c1		 cmp	 eax, ecx
  00d5a	74 0b		 je	 SHORT $LN49@stbi__proc

; 3182 :                ok = 0;

  00d5c	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ok$18[rsp], 0
$LN49@stbi__proc:
  00d67	e9 c4 fe ff ff	 jmp	 $LN20@stbi__proc
$LN21@stbi__proc:

; 3183 :          L -= 6;

  00d6c	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00d70	83 e8 06	 sub	 eax, 6
  00d73	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3184 :          if (ok) {

  00d77	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR ok$18[rsp], 0
  00d7f	0f 84 f4 01 00
	00		 je	 $LN50@stbi__proc

; 3185 :             stbi__get8(z->s); // version

  00d85	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d8d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d90	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00d98	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00da0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00da8	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00daf	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00db6	73 3c		 jae	 SHORT $LN91@stbi__proc

; 1615 :       return *s->img_buffer++;

  00db8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dc0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00dc7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00dca	88 84 24 3c 01
	00 00		 mov	 BYTE PTR tv462[rsp], al
  00dd1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dd9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00de0	48 ff c0	 inc	 rax
  00de3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00deb	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00df2	eb 55		 jmp	 SHORT $LN90@stbi__proc
$LN91@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00df4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dfc	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00e00	74 47		 je	 SHORT $LN92@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00e02	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e0a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00e0f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e17	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e1e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e21	88 84 24 3d 01
	00 00		 mov	 BYTE PTR tv471[rsp], al
  00e28	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e30	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e37	48 ff c0	 inc	 rax
  00e3a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e42	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN92@stbi__proc:
$LN90@stbi__proc:

; 3186 :             stbi__get16be(z->s); // flags0

  00e49	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e51	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00e54	e8 00 00 00 00	 call	 stbi__get16be

; 3187 :             stbi__get16be(z->s); // flags1

  00e59	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e61	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00e64	e8 00 00 00 00	 call	 stbi__get16be

; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform

  00e69	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e71	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e74	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00e7c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e84	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e8c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00e93	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00e9a	73 4b		 jae	 SHORT $LN95@stbi__proc

; 1615 :       return *s->img_buffer++;

  00e9c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ea4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00eab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00eae	88 84 24 3e 01
	00 00		 mov	 BYTE PTR tv479[rsp], al
  00eb5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ebd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ec4	48 ff c0	 inc	 rax
  00ec7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ecf	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00ed6	0f b6 84 24 3e
	01 00 00	 movzx	 eax, BYTE PTR tv479[rsp]
  00ede	88 84 24 c7 00
	00 00		 mov	 BYTE PTR $T27[rsp], al
  00ee5	eb 6e		 jmp	 SHORT $LN94@stbi__proc
$LN95@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00ee7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00eef	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00ef3	74 58		 je	 SHORT $LN96@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00ef5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00efd	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00f02	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f0a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00f11	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f14	88 84 24 3f 01
	00 00		 mov	 BYTE PTR tv488[rsp], al
  00f1b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f23	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00f2a	48 ff c0	 inc	 rax
  00f2d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f35	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00f3c	0f b6 84 24 3f
	01 00 00	 movzx	 eax, BYTE PTR tv488[rsp]
  00f44	88 84 24 c7 00
	00 00		 mov	 BYTE PTR $T27[rsp], al
  00f4b	eb 08		 jmp	 SHORT $LN94@stbi__proc
$LN96@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00f4d	c6 84 24 c7 00
	00 00 00	 mov	 BYTE PTR $T27[rsp], 0
$LN94@stbi__proc:

; 3188 :             z->app14_color_transform = stbi__get8(z->s); // color transform

  00f55	0f b6 84 24 c7
	00 00 00	 movzx	 eax, BYTE PTR $T27[rsp]
  00f5d	0f b6 c0	 movzx	 eax, al
  00f60	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00f68	89 81 4c 48 00
	00		 mov	 DWORD PTR [rcx+18508], eax

; 3189 :             L -= 6;

  00f6e	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00f72	83 e8 06	 sub	 eax, 6
  00f75	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN50@stbi__proc:
$LN48@stbi__proc:
$LN45@stbi__proc:

; 3190 :          }
; 3191 :       }
; 3192 : 
; 3193 :       stbi__skip(z->s, L);

  00f79	8b 54 24 20	 mov	 edx, DWORD PTR L$[rsp]
  00f7d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f85	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00f88	e8 00 00 00 00	 call	 stbi__skip

; 3194 :       return 1;

  00f8d	b8 01 00 00 00	 mov	 eax, 1
  00f92	eb 0c		 jmp	 SHORT $LN1@stbi__proc
$LN38@stbi__proc:

; 3195 :    }
; 3196 : 
; 3197 :    return stbi__err("unknown marker","Corrupt JPEG");

  00f94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NNGPHMMK@unknown?5marker@
  00f9b	e8 00 00 00 00	 call	 stbi__err
$LN1@stbi__proc:

; 3198 : }

  00fa0	48 8b f8	 mov	 rdi, rax
  00fa3	48 8b cc	 mov	 rcx, rsp
  00fa6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__process_marker$rtcFrameData
  00fad	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00fb2	48 8b c7	 mov	 rax, rdi
  00fb5	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00fbd	48 33 cc	 xor	 rcx, rsp
  00fc0	e8 00 00 00 00	 call	 __security_check_cookie
  00fc5	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00fcc	5f		 pop	 rdi
  00fcd	c3		 ret	 0
stbi__process_marker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
Ls$ = 36
id$1 = 40
which$2 = 44
q$3 = 48
aa$4 = 52
$T5 = 56
$T6 = 57
$T7 = 58
$T8 = 59
$T9 = 60
$T10 = 61
s$ = 64
s$ = 72
s$ = 80
s$ = 88
s$ = 96
s$ = 104
tv229 = 112
tv238 = 113
tv246 = 114
tv255 = 115
tv263 = 116
tv272 = 117
tv280 = 118
tv289 = 119
tv297 = 120
tv306 = 121
tv314 = 122
tv323 = 123
z$ = 144
stbi__process_scan_header PROC

; 3202 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3203 :    int i;
; 3204 :    int Ls = stbi__get16be(z->s);

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00021	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00024	e8 00 00 00 00	 call	 stbi__get16be
  00029	89 44 24 24	 mov	 DWORD PTR Ls$[rsp], eax

; 3205 :    z->scan_n = stbi__get8(z->s);

  0002d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 68	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00042	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  00047	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0004e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00055	73 39		 jae	 SHORT $LN24@stbi__proc

; 1615 :       return *s->img_buffer++;

  00057	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0005c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00063	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00066	88 44 24 70	 mov	 BYTE PTR tv229[rsp], al
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  0006f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00076	48 ff c0	 inc	 rax
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00085	0f b6 44 24 70	 movzx	 eax, BYTE PTR tv229[rsp]
  0008a	88 44 24 38	 mov	 BYTE PTR $T5[rsp], al
  0008e	eb 53		 jmp	 SHORT $LN23@stbi__proc
$LN24@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00090	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  00095	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00099	74 43		 je	 SHORT $LN25@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0009b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  000a0	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000a5	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000b1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b4	88 44 24 71	 mov	 BYTE PTR tv238[rsp], al
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR s$[rsp]
  000bd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000c4	48 ff c0	 inc	 rax
  000c7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$[rsp]
  000cc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d3	0f b6 44 24 71	 movzx	 eax, BYTE PTR tv238[rsp]
  000d8	88 44 24 38	 mov	 BYTE PTR $T5[rsp], al
  000dc	eb 05		 jmp	 SHORT $LN23@stbi__proc
$LN25@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  000de	c6 44 24 38 00	 mov	 BYTE PTR $T5[rsp], 0
$LN23@stbi__proc:

; 3205 :    z->scan_n = stbi__get8(z->s);

  000e3	0f b6 44 24 38	 movzx	 eax, BYTE PTR $T5[rsp]
  000e8	0f b6 c0	 movzx	 eax, al
  000eb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000f3	89 81 54 48 00
	00		 mov	 DWORD PTR [rcx+18516], eax

; 3206 :    if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

  000f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00101	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00108	7c 2f		 jl	 SHORT $LN9@stbi__proc
  0010a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00112	83 b8 54 48 00
	00 04		 cmp	 DWORD PTR [rax+18516], 4
  00119	7f 1e		 jg	 SHORT $LN9@stbi__proc
  0011b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00123	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00126	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0012e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00131	39 81 54 48 00
	00		 cmp	 DWORD PTR [rcx+18516], eax
  00137	7e 11		 jle	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DHFJCMBA@bad?5SOS?5component?5count@
  00140	e8 00 00 00 00	 call	 stbi__err
  00145	e9 5e 06 00 00	 jmp	 $LN1@stbi__proc
$LN8@stbi__proc:

; 3207 :    if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

  0014a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00152	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00158	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  0015c	39 44 24 24	 cmp	 DWORD PTR Ls$[rsp], eax
  00160	74 11		 je	 SHORT $LN10@stbi__proc
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@GNEHAHOH@bad?5SOS?5len@
  00169	e8 00 00 00 00	 call	 stbi__err
  0016e	e9 35 06 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 3208 :    for (i=0; i < z->scan_n; ++i) {

  00173	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0017b	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  0017d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00181	ff c0		 inc	 eax
  00183	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  00187	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0018f	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00195	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00199	0f 8d 9c 02 00
	00		 jge	 $LN3@stbi__proc

; 3209 :       int id = stbi__get8(z->s), which;

  0019f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001aa	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001b9	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001c0	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001c7	73 39		 jae	 SHORT $LN28@stbi__proc

; 1615 :       return *s->img_buffer++;

  001c9	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001ce	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001d5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d8	88 44 24 72	 mov	 BYTE PTR tv246[rsp], al
  001dc	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001e8	48 ff c0	 inc	 rax
  001eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001f7	0f b6 44 24 72	 movzx	 eax, BYTE PTR tv246[rsp]
  001fc	88 44 24 39	 mov	 BYTE PTR $T6[rsp], al
  00200	eb 53		 jmp	 SHORT $LN27@stbi__proc
$LN28@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00202	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00207	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0020b	74 43		 je	 SHORT $LN29@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0020d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00212	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00217	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0021c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00223	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00226	88 44 24 73	 mov	 BYTE PTR tv255[rsp], al
  0022a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0022f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00236	48 ff c0	 inc	 rax
  00239	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0023e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00245	0f b6 44 24 73	 movzx	 eax, BYTE PTR tv255[rsp]
  0024a	88 44 24 39	 mov	 BYTE PTR $T6[rsp], al
  0024e	eb 05		 jmp	 SHORT $LN27@stbi__proc
$LN29@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00250	c6 44 24 39 00	 mov	 BYTE PTR $T6[rsp], 0
$LN27@stbi__proc:

; 3209 :       int id = stbi__get8(z->s), which;

  00255	0f b6 44 24 39	 movzx	 eax, BYTE PTR $T6[rsp]
  0025a	0f b6 c0	 movzx	 eax, al
  0025d	89 44 24 28	 mov	 DWORD PTR id$1[rsp], eax

; 3210 :       int q = stbi__get8(z->s);

  00261	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00269	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026c	48 89 44 24 58	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00271	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  00276	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  0027b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00282	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00289	73 39		 jae	 SHORT $LN32@stbi__proc

; 1615 :       return *s->img_buffer++;

  0028b	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  00290	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00297	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0029a	88 44 24 74	 mov	 BYTE PTR tv263[rsp], al
  0029e	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  002a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002aa	48 ff c0	 inc	 rax
  002ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  002b2	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002b9	0f b6 44 24 74	 movzx	 eax, BYTE PTR tv263[rsp]
  002be	88 44 24 3a	 mov	 BYTE PTR $T7[rsp], al
  002c2	eb 53		 jmp	 SHORT $LN31@stbi__proc
$LN32@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  002c4	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  002c9	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002cd	74 43		 je	 SHORT $LN33@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  002cf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  002d4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002d9	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  002de	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e8	88 44 24 75	 mov	 BYTE PTR tv272[rsp], al
  002ec	48 8b 44 24 58	 mov	 rax, QWORD PTR s$[rsp]
  002f1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002f8	48 ff c0	 inc	 rax
  002fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  00300	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00307	0f b6 44 24 75	 movzx	 eax, BYTE PTR tv272[rsp]
  0030c	88 44 24 3a	 mov	 BYTE PTR $T7[rsp], al
  00310	eb 05		 jmp	 SHORT $LN31@stbi__proc
$LN33@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00312	c6 44 24 3a 00	 mov	 BYTE PTR $T7[rsp], 0
$LN31@stbi__proc:

; 3210 :       int q = stbi__get8(z->s);

  00317	0f b6 44 24 3a	 movzx	 eax, BYTE PTR $T7[rsp]
  0031c	0f b6 c0	 movzx	 eax, al
  0031f	89 44 24 30	 mov	 DWORD PTR q$3[rsp], eax

; 3211 :       for (which = 0; which < z->s->img_n; ++which)

  00323	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR which$2[rsp], 0
  0032b	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  0032d	8b 44 24 2c	 mov	 eax, DWORD PTR which$2[rsp]
  00331	ff c0		 inc	 eax
  00333	89 44 24 2c	 mov	 DWORD PTR which$2[rsp], eax
$LN7@stbi__proc:
  00337	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0033f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00342	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00345	39 44 24 2c	 cmp	 DWORD PTR which$2[rsp], eax
  00349	7d 22		 jge	 SHORT $LN6@stbi__proc

; 3212 :          if (z->img_comp[which].id == id)

  0034b	48 63 44 24 2c	 movsxd	 rax, DWORD PTR which$2[rsp]
  00350	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00354	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0035c	8b 54 24 28	 mov	 edx, DWORD PTR id$1[rsp]
  00360	39 94 01 a0 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18080], edx
  00367	75 02		 jne	 SHORT $LN11@stbi__proc

; 3213 :             break;

  00369	eb 02		 jmp	 SHORT $LN6@stbi__proc
$LN11@stbi__proc:
  0036b	eb c0		 jmp	 SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 3214 :       if (which == z->s->img_n) return 0; // no match

  0036d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00375	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00378	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0037b	39 44 24 2c	 cmp	 DWORD PTR which$2[rsp], eax
  0037f	75 07		 jne	 SHORT $LN12@stbi__proc
  00381	33 c0		 xor	 eax, eax
  00383	e9 20 04 00 00	 jmp	 $LN1@stbi__proc
$LN12@stbi__proc:

; 3215 :       z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

  00388	8b 44 24 30	 mov	 eax, DWORD PTR q$3[rsp]
  0038c	c1 f8 04	 sar	 eax, 4
  0038f	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR which$2[rsp]
  00394	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00398	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  003a0	89 84 0a b0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18096], eax
  003a7	48 63 44 24 2c	 movsxd	 rax, DWORD PTR which$2[rsp]
  003ac	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003b8	83 bc 01 b0 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18096], 3
  003c0	7e 11		 jle	 SHORT $LN13@stbi__proc
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@NOCCBFAC@bad?5DC?5huff@
  003c9	e8 00 00 00 00	 call	 stbi__err
  003ce	e9 d5 03 00 00	 jmp	 $LN1@stbi__proc
$LN13@stbi__proc:

; 3216 :       z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

  003d3	8b 44 24 30	 mov	 eax, DWORD PTR q$3[rsp]
  003d7	83 e0 0f	 and	 eax, 15
  003da	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR which$2[rsp]
  003df	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  003e3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  003eb	89 84 0a b4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18100], eax
  003f2	48 63 44 24 2c	 movsxd	 rax, DWORD PTR which$2[rsp]
  003f7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003fb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00403	83 bc 01 b4 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18100], 3
  0040b	7e 11		 jle	 SHORT $LN14@stbi__proc
  0040d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JGMCBLGG@bad?5AC?5huff@
  00414	e8 00 00 00 00	 call	 stbi__err
  00419	e9 8a 03 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:

; 3217 :       z->order[i] = which;

  0041e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00423	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0042b	8b 54 24 2c	 mov	 edx, DWORD PTR which$2[rsp]
  0042f	89 94 81 58 48
	00 00		 mov	 DWORD PTR [rcx+rax*4+18520], edx

; 3218 :    }

  00436	e9 42 fd ff ff	 jmp	 $LN2@stbi__proc
$LN3@stbi__proc:

; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);

  0043b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00443	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00446	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0044b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00450	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00455	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0045c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00463	73 39		 jae	 SHORT $LN36@stbi__proc

; 1615 :       return *s->img_buffer++;

  00465	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0046a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00471	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00474	88 44 24 76	 mov	 BYTE PTR tv280[rsp], al
  00478	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0047d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00484	48 ff c0	 inc	 rax
  00487	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0048c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00493	0f b6 44 24 76	 movzx	 eax, BYTE PTR tv280[rsp]
  00498	88 44 24 3b	 mov	 BYTE PTR $T8[rsp], al
  0049c	eb 53		 jmp	 SHORT $LN35@stbi__proc
$LN36@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  0049e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  004a3	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004a7	74 43		 je	 SHORT $LN37@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  004a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  004ae	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  004b3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  004b8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004c2	88 44 24 77	 mov	 BYTE PTR tv289[rsp], al
  004c6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  004cb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004d2	48 ff c0	 inc	 rax
  004d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  004da	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004e1	0f b6 44 24 77	 movzx	 eax, BYTE PTR tv289[rsp]
  004e6	88 44 24 3b	 mov	 BYTE PTR $T8[rsp], al
  004ea	eb 05		 jmp	 SHORT $LN35@stbi__proc
$LN37@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  004ec	c6 44 24 3b 00	 mov	 BYTE PTR $T8[rsp], 0
$LN35@stbi__proc:

; 3219 : 
; 3220 :    {
; 3221 :       int aa;
; 3222 :       z->spec_start = stbi__get8(z->s);

  004f1	0f b6 44 24 3b	 movzx	 eax, BYTE PTR $T8[rsp]
  004f6	0f b6 c0	 movzx	 eax, al
  004f9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00501	89 81 34 48 00
	00		 mov	 DWORD PTR [rcx+18484], eax

; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

  00507	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0050f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00512	48 89 44 24 48	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00517	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0051c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00521	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00528	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0052f	73 39		 jae	 SHORT $LN40@stbi__proc

; 1615 :       return *s->img_buffer++;

  00531	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00536	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0053d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00540	88 44 24 78	 mov	 BYTE PTR tv297[rsp], al
  00544	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00549	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00550	48 ff c0	 inc	 rax
  00553	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00558	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0055f	0f b6 44 24 78	 movzx	 eax, BYTE PTR tv297[rsp]
  00564	88 44 24 3c	 mov	 BYTE PTR $T9[rsp], al
  00568	eb 53		 jmp	 SHORT $LN39@stbi__proc
$LN40@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  0056a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0056f	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00573	74 43		 je	 SHORT $LN41@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00575	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0057a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0057f	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00584	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0058b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0058e	88 44 24 79	 mov	 BYTE PTR tv306[rsp], al
  00592	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00597	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0059e	48 ff c0	 inc	 rax
  005a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  005a6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005ad	0f b6 44 24 79	 movzx	 eax, BYTE PTR tv306[rsp]
  005b2	88 44 24 3c	 mov	 BYTE PTR $T9[rsp], al
  005b6	eb 05		 jmp	 SHORT $LN39@stbi__proc
$LN41@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  005b8	c6 44 24 3c 00	 mov	 BYTE PTR $T9[rsp], 0
$LN39@stbi__proc:

; 3223 :       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

  005bd	0f b6 44 24 3c	 movzx	 eax, BYTE PTR $T9[rsp]
  005c2	0f b6 c0	 movzx	 eax, al
  005c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  005cd	89 81 38 48 00
	00		 mov	 DWORD PTR [rcx+18488], eax

; 3224 :       aa = stbi__get8(z->s);

  005d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005de	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  005e3	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  005e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  005ed	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  005f4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  005fb	73 39		 jae	 SHORT $LN44@stbi__proc

; 1615 :       return *s->img_buffer++;

  005fd	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00602	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00609	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0060c	88 44 24 7a	 mov	 BYTE PTR tv314[rsp], al
  00610	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00615	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0061c	48 ff c0	 inc	 rax
  0061f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00624	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0062b	0f b6 44 24 7a	 movzx	 eax, BYTE PTR tv314[rsp]
  00630	88 44 24 3d	 mov	 BYTE PTR $T10[rsp], al
  00634	eb 53		 jmp	 SHORT $LN43@stbi__proc
$LN44@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00636	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0063b	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0063f	74 43		 je	 SHORT $LN45@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00641	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00646	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0064b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00650	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00657	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0065a	88 44 24 7b	 mov	 BYTE PTR tv323[rsp], al
  0065e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00663	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0066a	48 ff c0	 inc	 rax
  0066d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00672	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00679	0f b6 44 24 7b	 movzx	 eax, BYTE PTR tv323[rsp]
  0067e	88 44 24 3d	 mov	 BYTE PTR $T10[rsp], al
  00682	eb 05		 jmp	 SHORT $LN43@stbi__proc
$LN45@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00684	c6 44 24 3d 00	 mov	 BYTE PTR $T10[rsp], 0
$LN43@stbi__proc:

; 3224 :       aa = stbi__get8(z->s);

  00689	0f b6 44 24 3d	 movzx	 eax, BYTE PTR $T10[rsp]
  0068e	0f b6 c0	 movzx	 eax, al
  00691	89 44 24 34	 mov	 DWORD PTR aa$4[rsp], eax

; 3225 :       z->succ_high = (aa >> 4);

  00695	8b 44 24 34	 mov	 eax, DWORD PTR aa$4[rsp]
  00699	c1 f8 04	 sar	 eax, 4
  0069c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006a4	89 81 3c 48 00
	00		 mov	 DWORD PTR [rcx+18492], eax

; 3226 :       z->succ_low  = (aa & 15);

  006aa	8b 44 24 34	 mov	 eax, DWORD PTR aa$4[rsp]
  006ae	83 e0 0f	 and	 eax, 15
  006b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006b9	89 81 40 48 00
	00		 mov	 DWORD PTR [rcx+18496], eax

; 3227 :       if (z->progressive) {

  006bf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006c7	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  006ce	74 72		 je	 SHORT $LN15@stbi__proc

; 3228 :          if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

  006d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006d8	83 b8 34 48 00
	00 3f		 cmp	 DWORD PTR [rax+18484], 63 ; 0000003fH
  006df	7f 51		 jg	 SHORT $LN18@stbi__proc
  006e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006e9	83 b8 38 48 00
	00 3f		 cmp	 DWORD PTR [rax+18488], 63 ; 0000003fH
  006f0	7f 40		 jg	 SHORT $LN18@stbi__proc
  006f2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006fa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00702	8b 89 38 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18488]
  00708	39 88 34 48 00
	00		 cmp	 DWORD PTR [rax+18484], ecx
  0070e	7f 22		 jg	 SHORT $LN18@stbi__proc
  00710	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00718	83 b8 3c 48 00
	00 0d		 cmp	 DWORD PTR [rax+18492], 13
  0071f	7f 11		 jg	 SHORT $LN18@stbi__proc
  00721	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00729	83 b8 40 48 00
	00 0d		 cmp	 DWORD PTR [rax+18496], 13
  00730	7e 0e		 jle	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3229 :             return stbi__err("bad SOS", "Corrupt JPEG");

  00732	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  00739	e8 00 00 00 00	 call	 stbi__err
  0073e	eb 68		 jmp	 SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 3230 :       } else {

  00740	eb 61		 jmp	 SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 3231 :          if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");

  00742	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0074a	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  00751	74 0e		 je	 SHORT $LN19@stbi__proc
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  0075a	e8 00 00 00 00	 call	 stbi__err
  0075f	eb 47		 jmp	 SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 3232 :          if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");

  00761	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00769	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  00770	75 11		 jne	 SHORT $LN21@stbi__proc
  00772	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0077a	83 b8 40 48 00
	00 00		 cmp	 DWORD PTR [rax+18496], 0
  00781	74 0e		 je	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:
  00783	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EEJOMGGP@bad?5SOS@
  0078a	e8 00 00 00 00	 call	 stbi__err
  0078f	eb 17		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 3233 :          z->spec_end = 63;

  00791	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00799	c7 80 38 48 00
	00 3f 00 00 00	 mov	 DWORD PTR [rax+18488], 63 ; 0000003fH
$LN16@stbi__proc:

; 3234 :       }
; 3235 :    }
; 3236 : 
; 3237 :    return 1;

  007a3	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3238 : }

  007a8	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  007af	5f		 pop	 rdi
  007b0	c3		 ret	 0
stbi__process_scan_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
z$ = 64
ncomp$ = 72
why$ = 80
stbi__free_jpeg_components PROC

; 3241 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	90		 npad	 1

; 3242 :    int i;
; 3243 :    for (i=0; i < ncomp; ++i) {

  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00028	eb 0a		 jmp	 SHORT $LN4@stbi__free
$LN2@stbi__free:
  0002a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__free:
  00034	8b 44 24 48	 mov	 eax, DWORD PTR ncomp$[rsp]
  00038	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0003c	0f 8d 26 01 00
	00		 jge	 $LN3@stbi__free

; 3244 :       if (z->img_comp[i].raw_data) {

  00042	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00047	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00050	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  00059	74 50		 je	 SHORT $LN5@stbi__free

; 3245 :          STBI_FREE(z->img_comp[i].raw_data);

  0005b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00060	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00069	48 8b 8c 01 d8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18136]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3246 :          z->img_comp[i].raw_data = NULL;

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00085	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3247 :          z->img_comp[i].data = NULL;

  00091	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00096	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0009f	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0
$LN5@stbi__free:

; 3248 :       }
; 3249 :       if (z->img_comp[i].raw_coeff) {

  000ab	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000b9	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  000c2	74 50		 je	 SHORT $LN6@stbi__free

; 3250 :          STBI_FREE(z->img_comp[i].raw_coeff);

  000c4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000d2	48 8b 8c 01 e0
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18144]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3251 :          z->img_comp[i].raw_coeff = 0;

  000e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000ee	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3252 :          z->img_comp[i].coeff = 0;

  000fa	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ff	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00103	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00108	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0
$LN6@stbi__free:

; 3253 :       }
; 3254 :       if (z->img_comp[i].linebuf) {

  00114	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00119	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00122	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  0012b	74 36		 je	 SHORT $LN7@stbi__free

; 3255 :          STBI_FREE(z->img_comp[i].linebuf);

  0012d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00132	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0013b	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3256 :          z->img_comp[i].linebuf = NULL;

  00149	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0014e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00157	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0
$LN7@stbi__free:

; 3257 :       }
; 3258 :    }

  00163	e9 c2 fe ff ff	 jmp	 $LN2@stbi__free
$LN3@stbi__free:

; 3259 :    return why;

  00168	8b 44 24 50	 mov	 eax, DWORD PTR why$[rsp]

; 3260 : }

  0016c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00170	5f		 pop	 rdi
  00171	c3		 ret	 0
stbi__free_jpeg_components ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 32
Lf$ = 40
p$ = 44
i$ = 48
q$ = 52
h_max$ = 56
v_max$ = 60
c$ = 64
$T1 = 68
$T2 = 69
$T3 = 70
$T4 = 71
$T5 = 72
tv517 = 73
tv526 = 74
tv534 = 75
tv543 = 76
tv551 = 77
tv560 = 78
tv568 = 79
tv577 = 80
tv585 = 81
tv594 = 82
tv285 = 88
tv294 = 96
z$ = 128
scan$ = 136
stbi__process_frame_header PROC

; 3263 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3264 :    stbi__context *s = z->s;

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 3265 :    int Lf,p,i,q, h_max=1,v_max=1,c;

  0002a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR h_max$[rsp], 1
  00032	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR v_max$[rsp], 1

; 3266 :    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG

  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 stbi__get16be
  00044	89 44 24 28	 mov	 DWORD PTR Lf$[rsp], eax
  00048	83 7c 24 28 0b	 cmp	 DWORD PTR Lf$[rsp], 11
  0004d	7d 11		 jge	 SHORT $LN17@stbi__proc
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DOFMJEMP@bad?5SOF?5len@
  00056	e8 00 00 00 00	 call	 stbi__err
  0005b	e9 a2 0c 00 00	 jmp	 $LN1@stbi__proc
$LN17@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00071	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00078	73 39		 jae	 SHORT $LN42@stbi__proc

; 1615 :       return *s->img_buffer++;

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00086	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00089	88 44 24 49	 mov	 BYTE PTR tv517[rsp], al
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00099	48 ff c0	 inc	 rax
  0009c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000a8	0f b6 44 24 49	 movzx	 eax, BYTE PTR tv517[rsp]
  000ad	88 44 24 44	 mov	 BYTE PTR $T1[rsp], al
  000b1	eb 53		 jmp	 SHORT $LN41@stbi__proc
$LN42@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  000b3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000bc	74 43		 je	 SHORT $LN43@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000c3	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000cd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d7	88 44 24 4a	 mov	 BYTE PTR tv526[rsp], al
  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000e7	48 ff c0	 inc	 rax
  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000f6	0f b6 44 24 4a	 movzx	 eax, BYTE PTR tv526[rsp]
  000fb	88 44 24 44	 mov	 BYTE PTR $T1[rsp], al
  000ff	eb 05		 jmp	 SHORT $LN41@stbi__proc
$LN43@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00101	c6 44 24 44 00	 mov	 BYTE PTR $T1[rsp], 0
$LN41@stbi__proc:

; 3267 :    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

  00106	0f b6 44 24 44	 movzx	 eax, BYTE PTR $T1[rsp]
  0010b	0f b6 c0	 movzx	 eax, al
  0010e	89 44 24 2c	 mov	 DWORD PTR p$[rsp], eax
  00112	83 7c 24 2c 08	 cmp	 DWORD PTR p$[rsp], 8
  00117	74 11		 je	 SHORT $LN18@stbi__proc
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BCINMEBJ@only?58?9bit@
  00120	e8 00 00 00 00	 call	 stbi__err
  00125	e9 d8 0b 00 00	 jmp	 $LN1@stbi__proc
$LN18@stbi__proc:

; 3268 :    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

  0012a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0012f	e8 00 00 00 00	 call	 stbi__get16be
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00139	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0013c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00141	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00145	75 11		 jne	 SHORT $LN19@stbi__proc
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LNEGOMA@no?5header?5height@
  0014e	e8 00 00 00 00	 call	 stbi__err
  00153	e9 aa 0b 00 00	 jmp	 $LN1@stbi__proc
$LN19@stbi__proc:

; 3269 :    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

  00158	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0015d	e8 00 00 00 00	 call	 stbi__get16be
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00167	89 01		 mov	 DWORD PTR [rcx], eax
  00169	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0016e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00171	75 11		 jne	 SHORT $LN20@stbi__proc
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BIDACDEF@0?5width@
  0017a	e8 00 00 00 00	 call	 stbi__err
  0017f	e9 7e 0b 00 00	 jmp	 $LN1@stbi__proc
$LN20@stbi__proc:

; 3270 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00189	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00190	76 11		 jbe	 SHORT $LN21@stbi__proc
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00199	e8 00 00 00 00	 call	 stbi__err
  0019e	e9 5f 0b 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 3271 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  001a3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001a8	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  001ae	76 11		 jbe	 SHORT $LN22@stbi__proc
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  001b7	e8 00 00 00 00	 call	 stbi__err
  001bc	e9 41 0b 00 00	 jmp	 $LN1@stbi__proc
$LN22@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001c1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001cb	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001d2	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001d9	73 39		 jae	 SHORT $LN46@stbi__proc

; 1615 :       return *s->img_buffer++;

  001db	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ea	88 44 24 4b	 mov	 BYTE PTR tv534[rsp], al
  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001fa	48 ff c0	 inc	 rax
  001fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00202	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00209	0f b6 44 24 4b	 movzx	 eax, BYTE PTR tv534[rsp]
  0020e	88 44 24 45	 mov	 BYTE PTR $T2[rsp], al
  00212	eb 53		 jmp	 SHORT $LN45@stbi__proc
$LN46@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00214	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00219	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0021d	74 43		 je	 SHORT $LN47@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0021f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00224	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00229	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00235	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00238	88 44 24 4c	 mov	 BYTE PTR tv543[rsp], al
  0023c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00241	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00248	48 ff c0	 inc	 rax
  0024b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00250	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00257	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv543[rsp]
  0025c	88 44 24 45	 mov	 BYTE PTR $T2[rsp], al
  00260	eb 05		 jmp	 SHORT $LN45@stbi__proc
$LN47@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00262	c6 44 24 45 00	 mov	 BYTE PTR $T2[rsp], 0
$LN45@stbi__proc:

; 3272 :    c = stbi__get8(s);

  00267	0f b6 44 24 45	 movzx	 eax, BYTE PTR $T2[rsp]
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	89 44 24 40	 mov	 DWORD PTR c$[rsp], eax

; 3273 :    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

  00273	83 7c 24 40 03	 cmp	 DWORD PTR c$[rsp], 3
  00278	74 1f		 je	 SHORT $LN23@stbi__proc
  0027a	83 7c 24 40 01	 cmp	 DWORD PTR c$[rsp], 1
  0027f	74 18		 je	 SHORT $LN23@stbi__proc
  00281	83 7c 24 40 04	 cmp	 DWORD PTR c$[rsp], 4
  00286	74 11		 je	 SHORT $LN23@stbi__proc
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@DAPHADHL@bad?5component?5count@
  0028f	e8 00 00 00 00	 call	 stbi__err
  00294	e9 69 0a 00 00	 jmp	 $LN1@stbi__proc
$LN23@stbi__proc:

; 3274 :    s->img_n = c;

  00299	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0029e	8b 4c 24 40	 mov	 ecx, DWORD PTR c$[rsp]
  002a2	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 3275 :    for (i=0; i < c; ++i) {

  002a5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002ad	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  002af	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002b3	ff c0		 inc	 eax
  002b5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  002b9	8b 44 24 40	 mov	 eax, DWORD PTR c$[rsp]
  002bd	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  002c1	7d 3c		 jge	 SHORT $LN3@stbi__proc

; 3276 :       z->img_comp[i].data = NULL;

  002c3	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002c8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002d4	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0

; 3277 :       z->img_comp[i].linebuf = NULL;

  002e0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002e5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002f1	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3278 :    }

  002fd	eb b0		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 3279 : 
; 3280 :    if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

  002ff	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00304	6b 40 08 03	 imul	 eax, DWORD PTR [rax+8], 3
  00308	83 c0 08	 add	 eax, 8
  0030b	39 44 24 28	 cmp	 DWORD PTR Lf$[rsp], eax
  0030f	74 11		 je	 SHORT $LN24@stbi__proc
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DOFMJEMP@bad?5SOF?5len@
  00318	e8 00 00 00 00	 call	 stbi__err
  0031d	e9 e0 09 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3281 : 
; 3282 :    z->rgb = 0;

  00322	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0032a	c7 80 50 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18512], 0

; 3283 :    for (i=0; i < s->img_n; ++i) {

  00334	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0033c	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  0033e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00342	ff c0		 inc	 eax
  00344	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__proc:
  00348	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0034d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00350	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00354	0f 8d 8e 03 00
	00		 jge	 $LN6@stbi__proc

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0035a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0035f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00364	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0036b	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00372	73 39		 jae	 SHORT $LN50@stbi__proc

; 1615 :       return *s->img_buffer++;

  00374	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00379	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00380	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00383	88 44 24 4d	 mov	 BYTE PTR tv551[rsp], al
  00387	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0038c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00393	48 ff c0	 inc	 rax
  00396	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0039b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003a2	0f b6 44 24 4d	 movzx	 eax, BYTE PTR tv551[rsp]
  003a7	88 44 24 46	 mov	 BYTE PTR $T3[rsp], al
  003ab	eb 53		 jmp	 SHORT $LN49@stbi__proc
$LN50@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  003ad	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003b2	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  003b6	74 43		 je	 SHORT $LN51@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  003b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003bd	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  003c2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003c7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003ce	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003d1	88 44 24 4e	 mov	 BYTE PTR tv560[rsp], al
  003d5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003da	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003e1	48 ff c0	 inc	 rax
  003e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003e9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003f0	0f b6 44 24 4e	 movzx	 eax, BYTE PTR tv560[rsp]
  003f5	88 44 24 46	 mov	 BYTE PTR $T3[rsp], al
  003f9	eb 05		 jmp	 SHORT $LN49@stbi__proc
$LN51@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  003fb	c6 44 24 46 00	 mov	 BYTE PTR $T3[rsp], 0
$LN49@stbi__proc:

; 3284 :       static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3285 :       z->img_comp[i].id = stbi__get8(s);

  00400	0f b6 44 24 46	 movzx	 eax, BYTE PTR $T3[rsp]
  00405	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0040a	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0040e	0f b6 c0	 movzx	 eax, al
  00411	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00419	89 84 0a a0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18080], eax

; 3286 :       if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

  00420	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00425	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00429	75 48		 jne	 SHORT $LN25@stbi__proc
  0042b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00430	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00434	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00439	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?rgb@?5??stbi__process_frame_header@@9@9
  00440	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00444	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0044c	39 8c 02 a0 46
	00 00		 cmp	 DWORD PTR [rdx+rax+18080], ecx
  00453	75 1e		 jne	 SHORT $LN25@stbi__proc

; 3287 :          ++z->rgb;

  00455	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0045d	8b 80 50 48 00
	00		 mov	 eax, DWORD PTR [rax+18512]
  00463	ff c0		 inc	 eax
  00465	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0046d	89 81 50 48 00
	00		 mov	 DWORD PTR [rcx+18512], eax
$LN25@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00473	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00478	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0047d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00484	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0048b	73 39		 jae	 SHORT $LN54@stbi__proc

; 1615 :       return *s->img_buffer++;

  0048d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00492	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00499	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0049c	88 44 24 4f	 mov	 BYTE PTR tv568[rsp], al
  004a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004a5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004ac	48 ff c0	 inc	 rax
  004af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  004b4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004bb	0f b6 44 24 4f	 movzx	 eax, BYTE PTR tv568[rsp]
  004c0	88 44 24 47	 mov	 BYTE PTR $T4[rsp], al
  004c4	eb 53		 jmp	 SHORT $LN53@stbi__proc
$LN54@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  004c6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004cb	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004cf	74 43		 je	 SHORT $LN55@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  004d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  004d6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  004db	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004e0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004ea	88 44 24 50	 mov	 BYTE PTR tv577[rsp], al
  004ee	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004f3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004fa	48 ff c0	 inc	 rax
  004fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00502	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00509	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv577[rsp]
  0050e	88 44 24 47	 mov	 BYTE PTR $T4[rsp], al
  00512	eb 05		 jmp	 SHORT $LN53@stbi__proc
$LN55@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00514	c6 44 24 47 00	 mov	 BYTE PTR $T4[rsp], 0
$LN53@stbi__proc:

; 3288 :       q = stbi__get8(s);

  00519	0f b6 44 24 47	 movzx	 eax, BYTE PTR $T4[rsp]
  0051e	0f b6 c0	 movzx	 eax, al
  00521	89 44 24 34	 mov	 DWORD PTR q$[rsp], eax

; 3289 :       z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");

  00525	8b 44 24 34	 mov	 eax, DWORD PTR q$[rsp]
  00529	c1 f8 04	 sar	 eax, 4
  0052c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00531	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00535	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0053d	89 84 0a a4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18084], eax
  00544	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00549	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0054d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00555	83 bc 01 a4 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18084], 0
  0055d	74 1b		 je	 SHORT $LN27@stbi__proc
  0055f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00564	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00568	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00570	83 bc 01 a4 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18084], 4
  00578	7e 11		 jle	 SHORT $LN26@stbi__proc
$LN27@stbi__proc:
  0057a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BLPKENEJ@bad?5H@
  00581	e8 00 00 00 00	 call	 stbi__err
  00586	e9 77 07 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3290 :       z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");

  0058b	8b 44 24 34	 mov	 eax, DWORD PTR q$[rsp]
  0058f	83 e0 0f	 and	 eax, 15
  00592	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00597	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0059b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  005a3	89 84 0a a8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18088], eax
  005aa	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005af	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  005bb	83 bc 01 a8 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18088], 0
  005c3	74 1b		 je	 SHORT $LN29@stbi__proc
  005c5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005ca	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  005d6	83 bc 01 a8 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18088], 4
  005de	7e 11		 jle	 SHORT $LN28@stbi__proc
$LN29@stbi__proc:
  005e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MPLLHCJG@bad?5V@
  005e7	e8 00 00 00 00	 call	 stbi__err
  005ec	e9 11 07 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  005f1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  005fb	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00602	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00609	73 39		 jae	 SHORT $LN58@stbi__proc

; 1615 :       return *s->img_buffer++;

  0060b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00610	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00617	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0061a	88 44 24 51	 mov	 BYTE PTR tv585[rsp], al
  0061e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00623	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0062a	48 ff c0	 inc	 rax
  0062d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00632	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00639	0f b6 44 24 51	 movzx	 eax, BYTE PTR tv585[rsp]
  0063e	88 44 24 48	 mov	 BYTE PTR $T5[rsp], al
  00642	eb 53		 jmp	 SHORT $LN57@stbi__proc
$LN58@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00644	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00649	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0064d	74 43		 je	 SHORT $LN59@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0064f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00654	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00659	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0065e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00665	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00668	88 44 24 52	 mov	 BYTE PTR tv594[rsp], al
  0066c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00671	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00678	48 ff c0	 inc	 rax
  0067b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00680	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00687	0f b6 44 24 52	 movzx	 eax, BYTE PTR tv594[rsp]
  0068c	88 44 24 48	 mov	 BYTE PTR $T5[rsp], al
  00690	eb 05		 jmp	 SHORT $LN57@stbi__proc
$LN59@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00692	c6 44 24 48 00	 mov	 BYTE PTR $T5[rsp], 0
$LN57@stbi__proc:

; 3291 :       z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");

  00697	0f b6 44 24 48	 movzx	 eax, BYTE PTR $T5[rsp]
  0069c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006a1	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  006a5	0f b6 c0	 movzx	 eax, al
  006a8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  006b0	89 84 0a ac 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18092], eax
  006b7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  006bc	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006c8	83 bc 01 ac 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18092], 3
  006d0	7e 11		 jle	 SHORT $LN30@stbi__proc
  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06LJIHDFHI@bad?5TQ@
  006d9	e8 00 00 00 00	 call	 stbi__err
  006de	e9 1f 06 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3292 :    }

  006e3	e9 56 fc ff ff	 jmp	 $LN5@stbi__proc
$LN6@stbi__proc:

; 3293 : 
; 3294 :    if (scan != STBI__SCAN_load) return 1;

  006e8	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR scan$[rsp], 0
  006f0	74 0a		 je	 SHORT $LN31@stbi__proc
  006f2	b8 01 00 00 00	 mov	 eax, 1
  006f7	e9 06 06 00 00	 jmp	 $LN1@stbi__proc
$LN31@stbi__proc:

; 3295 : 
; 3296 :    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

  006fc	45 33 c9	 xor	 r9d, r9d
  006ff	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00704	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  00708	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0070d	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  00710	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00715	8b 08		 mov	 ecx, DWORD PTR [rax]
  00717	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  0071c	85 c0		 test	 eax, eax
  0071e	75 11		 jne	 SHORT $LN32@stbi__proc
  00720	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00727	e8 00 00 00 00	 call	 stbi__err
  0072c	e9 d1 05 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 3297 : 
; 3298 :    for (i=0; i < s->img_n; ++i) {

  00731	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00739	eb 0a		 jmp	 SHORT $LN10@stbi__proc
$LN8@stbi__proc:
  0073b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0073f	ff c0		 inc	 eax
  00741	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__proc:
  00745	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0074a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0074d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00751	7d 79		 jge	 SHORT $LN9@stbi__proc

; 3299 :       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

  00753	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00758	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0075c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00764	8b 54 24 38	 mov	 edx, DWORD PTR h_max$[rsp]
  00768	39 94 01 a4 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18084], edx
  0076f	7e 1c		 jle	 SHORT $LN33@stbi__proc
  00771	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00776	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0077a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00782	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  00789	89 44 24 38	 mov	 DWORD PTR h_max$[rsp], eax
$LN33@stbi__proc:

; 3300 :       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

  0078d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00792	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00796	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0079e	8b 54 24 3c	 mov	 edx, DWORD PTR v_max$[rsp]
  007a2	39 94 01 a8 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18088], edx
  007a9	7e 1c		 jle	 SHORT $LN34@stbi__proc
  007ab	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  007b0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007b4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007bc	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  007c3	89 44 24 3c	 mov	 DWORD PTR v_max$[rsp], eax
$LN34@stbi__proc:

; 3301 :    }

  007c7	e9 6f ff ff ff	 jmp	 $LN8@stbi__proc
$LN9@stbi__proc:

; 3302 : 
; 3303 :    // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3304 :    // and I've never seen a non-corrupted JPEG file actually use them
; 3305 :    for (i=0; i < s->img_n; ++i) {

  007cc	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007d4	eb 0a		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  007d6	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007da	ff c0		 inc	 eax
  007dc	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__proc:
  007e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007e5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  007e8	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007ec	0f 8d 83 00 00
	00		 jge	 $LN12@stbi__proc

; 3306 :       if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

  007f2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  007f7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007fb	48 89 44 24 58	 mov	 QWORD PTR tv285[rsp], rax
  00800	8b 44 24 38	 mov	 eax, DWORD PTR h_max$[rsp]
  00804	99		 cdq
  00805	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0080d	4c 8b 44 24 58	 mov	 r8, QWORD PTR tv285[rsp]
  00812	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  0081a	8b c2		 mov	 eax, edx
  0081c	85 c0		 test	 eax, eax
  0081e	74 11		 je	 SHORT $LN35@stbi__proc
  00820	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BLPKENEJ@bad?5H@
  00827	e8 00 00 00 00	 call	 stbi__err
  0082c	e9 d1 04 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3307 :       if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");

  00831	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00836	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0083a	48 89 44 24 60	 mov	 QWORD PTR tv294[rsp], rax
  0083f	8b 44 24 3c	 mov	 eax, DWORD PTR v_max$[rsp]
  00843	99		 cdq
  00844	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0084c	4c 8b 44 24 60	 mov	 r8, QWORD PTR tv294[rsp]
  00851	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  00859	8b c2		 mov	 eax, edx
  0085b	85 c0		 test	 eax, eax
  0085d	74 11		 je	 SHORT $LN36@stbi__proc
  0085f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MPLLHCJG@bad?5V@
  00866	e8 00 00 00 00	 call	 stbi__err
  0086b	e9 92 04 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 3308 :    }

  00870	e9 61 ff ff ff	 jmp	 $LN11@stbi__proc
$LN12@stbi__proc:

; 3309 : 
; 3310 :    // compute interleaved mcu info
; 3311 :    z->img_h_max = h_max;

  00875	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0087d	8b 4c 24 38	 mov	 ecx, DWORD PTR h_max$[rsp]
  00881	89 88 88 46 00
	00		 mov	 DWORD PTR [rax+18056], ecx

; 3312 :    z->img_v_max = v_max;

  00887	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0088f	8b 4c 24 3c	 mov	 ecx, DWORD PTR v_max$[rsp]
  00893	89 88 8c 46 00
	00		 mov	 DWORD PTR [rax+18060], ecx

; 3313 :    z->img_mcu_w = h_max * 8;

  00899	8b 44 24 38	 mov	 eax, DWORD PTR h_max$[rsp]
  0089d	c1 e0 03	 shl	 eax, 3
  008a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008a8	89 81 98 46 00
	00		 mov	 DWORD PTR [rcx+18072], eax

; 3314 :    z->img_mcu_h = v_max * 8;

  008ae	8b 44 24 3c	 mov	 eax, DWORD PTR v_max$[rsp]
  008b2	c1 e0 03	 shl	 eax, 3
  008b5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008bd	89 81 9c 46 00
	00		 mov	 DWORD PTR [rcx+18076], eax

; 3315 :    // these sizes can't be more than 17 bits
; 3316 :    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

  008c3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008c8	8b 00		 mov	 eax, DWORD PTR [rax]
  008ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008d2	8b 89 98 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18072]
  008d8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  008dc	33 d2		 xor	 edx, edx
  008de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008e6	f7 b1 98 46 00
	00		 div	 DWORD PTR [rcx+18072]
  008ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008f4	89 81 90 46 00
	00		 mov	 DWORD PTR [rcx+18064], eax

; 3317 :    z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

  008fa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008ff	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00902	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0090a	8b 89 9c 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18076]
  00910	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00914	33 d2		 xor	 edx, edx
  00916	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0091e	f7 b1 9c 46 00
	00		 div	 DWORD PTR [rcx+18076]
  00924	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0092c	89 81 94 46 00
	00		 mov	 DWORD PTR [rcx+18068], eax

; 3318 : 
; 3319 :    for (i=0; i < s->img_n; ++i) {

  00932	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0093a	eb 0a		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  0093c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00940	ff c0		 inc	 eax
  00942	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__proc:
  00946	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0094b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0094e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00952	0f 8d a5 03 00
	00		 jge	 $LN15@stbi__proc

; 3320 :       // number of effective pixels (e.g. for non-interleaved MCU)
; 3321 :       z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

  00958	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0095d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00961	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00966	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0096e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00970	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  00978	8b c1		 mov	 eax, ecx
  0097a	8b 4c 24 38	 mov	 ecx, DWORD PTR h_max$[rsp]
  0097e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00982	33 d2		 xor	 edx, edx
  00984	f7 74 24 38	 div	 DWORD PTR h_max$[rsp]
  00988	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0098d	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00991	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00999	89 84 0a bc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18108], eax

; 3322 :       z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

  009a0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  009a5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  009a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  009ae	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  009b6	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  009b9	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  009c1	8b c1		 mov	 eax, ecx
  009c3	8b 4c 24 3c	 mov	 ecx, DWORD PTR v_max$[rsp]
  009c7	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  009cb	33 d2		 xor	 edx, edx
  009cd	f7 74 24 3c	 div	 DWORD PTR v_max$[rsp]
  009d1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  009d6	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  009da	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  009e2	89 84 0a c0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18112], eax

; 3323 :       // to simplify generation, we'll allocate enough memory to decode
; 3324 :       // the bogus oversized data from using interleaved MCUs and their
; 3325 :       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3326 :       // discard the extra data until colorspace conversion
; 3327 :       //
; 3328 :       // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3329 :       // so these muls can't overflow with 32-bit ints (which we require)
; 3330 :       z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

  009e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  009ee	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  009f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009fa	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00a02	8b 89 90 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18064]
  00a08	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  00a10	8b c1		 mov	 eax, ecx
  00a12	c1 e0 03	 shl	 eax, 3
  00a15	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00a1a	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00a1e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00a26	89 84 0a c4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18116], eax

; 3331 :       z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

  00a2d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00a32	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a36	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a3e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00a46	8b 89 94 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18068]
  00a4c	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  00a54	8b c1		 mov	 eax, ecx
  00a56	c1 e0 03	 shl	 eax, 3
  00a59	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00a5e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00a62	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00a6a	89 84 0a c8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18120], eax

; 3332 :       z->img_comp[i].coeff = 0;

  00a71	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00a76	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a7a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a82	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0

; 3333 :       z->img_comp[i].raw_coeff = 0;

  00a8e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00a93	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a97	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a9f	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3334 :       z->img_comp[i].linebuf = NULL;

  00aab	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00ab0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ab4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00abc	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3335 :       z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

  00ac8	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00acd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ad1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00ad6	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00ada	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00ae0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00ae8	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  00aef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00af7	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00afe	e8 00 00 00 00	 call	 stbi__malloc_mad2
  00b03	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00b08	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00b0c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00b14	48 89 84 0a d8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18136], rax

; 3336 :       if (z->img_comp[i].raw_data == NULL)

  00b1c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00b21	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b25	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b2d	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  00b36	75 29		 jne	 SHORT $LN37@stbi__proc

; 3337 :          return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  00b38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00b3f	e8 00 00 00 00	 call	 stbi__err
  00b44	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00b48	ff c1		 inc	 ecx
  00b4a	44 8b c0	 mov	 r8d, eax
  00b4d	8b d1		 mov	 edx, ecx
  00b4f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b57	e8 00 00 00 00	 call	 stbi__free_jpeg_components
  00b5c	e9 a1 01 00 00	 jmp	 $LN1@stbi__proc
$LN37@stbi__proc:

; 3338 :       // align blocks for idct using mmx/sse
; 3339 :       z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

  00b61	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00b66	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b6a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b72	48 8b 84 01 d8
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18136]
  00b7a	48 83 c0 0f	 add	 rax, 15
  00b7e	48 83 e0 f0	 and	 rax, -16
  00b82	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00b87	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00b8b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00b93	48 89 84 0a d0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18128], rax

; 3340 :       if (z->progressive) {

  00b9b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00ba3	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00baa	0f 84 48 01 00
	00		 je	 $LN38@stbi__proc

; 3341 :          // w2, h2 are multiples of 8 (see above)
; 3342 :          z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

  00bb0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00bb5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00bb9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00bc1	8b 84 01 c4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18116]
  00bc8	99		 cdq
  00bc9	83 e2 07	 and	 edx, 7
  00bcc	03 c2		 add	 eax, edx
  00bce	c1 f8 03	 sar	 eax, 3
  00bd1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00bd6	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00bda	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00be2	89 84 0a f8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18168], eax

; 3343 :          z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

  00be9	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00bee	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00bf2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00bfa	8b 84 01 c8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18120]
  00c01	99		 cdq
  00c02	83 e2 07	 and	 edx, 7
  00c05	03 c2		 add	 eax, edx
  00c07	c1 f8 03	 sar	 eax, 3
  00c0a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c0f	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00c13	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00c1b	89 84 0a fc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18172], eax

; 3344 :          z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

  00c22	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00c27	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00c2b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c30	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00c34	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00c3a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00c40	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00c48	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  00c4f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c57	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00c5e	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00c63	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c68	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00c6c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00c74	48 89 84 0a e0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18144], rax

; 3345 :          if (z->img_comp[i].raw_coeff == NULL)

  00c7c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00c81	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00c85	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c8d	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  00c96	75 26		 jne	 SHORT $LN39@stbi__proc

; 3346 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  00c98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00c9f	e8 00 00 00 00	 call	 stbi__err
  00ca4	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00ca8	ff c1		 inc	 ecx
  00caa	44 8b c0	 mov	 r8d, eax
  00cad	8b d1		 mov	 edx, ecx
  00caf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00cb7	e8 00 00 00 00	 call	 stbi__free_jpeg_components
  00cbc	eb 44		 jmp	 SHORT $LN1@stbi__proc
$LN39@stbi__proc:

; 3347 :          z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);

  00cbe	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00cc3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00cc7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00ccf	48 8b 84 01 e0
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18144]
  00cd7	48 83 c0 0f	 add	 rax, 15
  00cdb	48 83 e0 f0	 and	 rax, -16
  00cdf	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00ce4	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00ce8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00cf0	48 89 84 0a f0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18160], rax
$LN38@stbi__proc:

; 3348 :       }
; 3349 :    }

  00cf8	e9 3f fc ff ff	 jmp	 $LN14@stbi__proc
$LN15@stbi__proc:

; 3350 : 
; 3351 :    return 1;

  00cfd	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3352 : }

  00d02	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00d06	5f		 pop	 rdi
  00d07	c3		 ret	 0
stbi__process_frame_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
m$ = 32
$T1 = 36
s$ = 40
tv149 = 48
tv131 = 52
z$ = 80
scan$ = 88
stbi__decode_jpeg_header PROC

; 3364 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3365 :    int m;
; 3366 :    z->jfif = 0;

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0001f	c7 80 48 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18504], 0

; 3367 :    z->app14_color_transform = -1; // valid values are 0,1,2

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0002e	c7 80 4c 48 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+18508], -1

; 3368 :    z->marker = STBI__MARKER_none; // initialize cached marker to empty

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0003d	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 3369 :    m = stbi__get_marker(z);

  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00049	e8 00 00 00 00	 call	 stbi__get_marker
  0004e	0f b6 c0	 movzx	 eax, al
  00051	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3370 :    if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

  00055	81 7c 24 20 d8
	00 00 00	 cmp	 DWORD PTR m$[rsp], 216	; 000000d8H
  0005d	74 11		 je	 SHORT $LN6@stbi__deco
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CLMBLEP@no?5SOI@
  00066	e8 00 00 00 00	 call	 stbi__err
  0006b	e9 7c 01 00 00	 jmp	 $LN1@stbi__deco
$LN6@stbi__deco:

; 3371 :    if (scan == STBI__SCAN_type) return 1;

  00070	83 7c 24 58 01	 cmp	 DWORD PTR scan$[rsp], 1
  00075	75 0a		 jne	 SHORT $LN7@stbi__deco
  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	e9 6b 01 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 3372 :    m = stbi__get_marker(z);

  00081	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00086	e8 00 00 00 00	 call	 stbi__get_marker
  0008b	0f b6 c0	 movzx	 eax, al
  0008e	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN2@stbi__deco:

; 3373 :    while (!stbi__SOF(m)) {

  00092	81 7c 24 20 c0
	00 00 00	 cmp	 DWORD PTR m$[rsp], 192	; 000000c0H
  0009a	0f 84 06 01 00
	00		 je	 $LN3@stbi__deco
  000a0	81 7c 24 20 c1
	00 00 00	 cmp	 DWORD PTR m$[rsp], 193	; 000000c1H
  000a8	0f 84 f8 00 00
	00		 je	 $LN3@stbi__deco
  000ae	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  000b6	0f 84 ea 00 00
	00		 je	 $LN3@stbi__deco

; 3374 :       if (!stbi__process_marker(z,m)) return 0;

  000bc	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000c5	e8 00 00 00 00	 call	 stbi__process_marker
  000ca	85 c0		 test	 eax, eax
  000cc	75 07		 jne	 SHORT $LN8@stbi__deco
  000ce	33 c0		 xor	 eax, eax
  000d0	e9 17 01 00 00	 jmp	 $LN1@stbi__deco
$LN8@stbi__deco:

; 3375 :       m = stbi__get_marker(z);

  000d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000da	e8 00 00 00 00	 call	 stbi__get_marker
  000df	0f b6 c0	 movzx	 eax, al
  000e2	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:

; 3376 :       while (m == STBI__MARKER_none) {

  000e6	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR m$[rsp], 255	; 000000ffH
  000ee	0f 85 ad 00 00
	00		 jne	 $LN5@stbi__deco

; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 1628 :    if (s->io.read) {

  00101	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00106	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0010b	74 34		 je	 SHORT $LN15@stbi__deco

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  0010d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00112	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0011b	ff 50 20	 call	 QWORD PTR [rax+32]
  0011e	85 c0		 test	 eax, eax
  00120	75 0a		 jne	 SHORT $LN16@stbi__deco
  00122	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  0012a	eb 49		 jmp	 SHORT $LN14@stbi__deco
$LN16@stbi__deco:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00131	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00135	75 0a		 jne	 SHORT $LN17@stbi__deco
  00137	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
  0013f	eb 34		 jmp	 SHORT $LN14@stbi__deco
$LN17@stbi__deco:
$LN15@stbi__deco:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00146	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0014b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00152	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00159	72 0a		 jb	 SHORT $LN19@stbi__deco
  0015b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00163	eb 08		 jmp	 SHORT $LN20@stbi__deco
$LN19@stbi__deco:
  00165	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN20@stbi__deco:
  0016d	8b 44 24 30	 mov	 eax, DWORD PTR tv149[rsp]
  00171	89 44 24 24	 mov	 DWORD PTR $T1[rsp], eax
$LN14@stbi__deco:

; 3377 :          // some files have extra padding after their blocks, so ok, we'll scan
; 3378 :          if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

  00175	8b 44 24 24	 mov	 eax, DWORD PTR $T1[rsp]
  00179	85 c0		 test	 eax, eax
  0017b	74 0e		 je	 SHORT $LN9@stbi__deco
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IFCEAHIA@no?5SOF@
  00184	e8 00 00 00 00	 call	 stbi__err
  00189	eb 61		 jmp	 SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 3379 :          m = stbi__get_marker(z);

  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00190	e8 00 00 00 00	 call	 stbi__get_marker
  00195	0f b6 c0	 movzx	 eax, al
  00198	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3380 :       }

  0019c	e9 45 ff ff ff	 jmp	 $LN4@stbi__deco
$LN5@stbi__deco:

; 3381 :    }

  001a1	e9 ec fe ff ff	 jmp	 $LN2@stbi__deco
$LN3@stbi__deco:

; 3382 :    z->progressive = stbi__SOF_progressive(m);

  001a6	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  001ae	75 0a		 jne	 SHORT $LN12@stbi__deco
  001b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  001b8	eb 08		 jmp	 SHORT $LN13@stbi__deco
$LN12@stbi__deco:
  001ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN13@stbi__deco:
  001c2	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001c7	8b 4c 24 34	 mov	 ecx, DWORD PTR tv131[rsp]
  001cb	89 88 30 48 00
	00		 mov	 DWORD PTR [rax+18480], ecx

; 3383 :    if (!stbi__process_frame_header(z, scan)) return 0;

  001d1	8b 54 24 58	 mov	 edx, DWORD PTR scan$[rsp]
  001d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001da	e8 00 00 00 00	 call	 stbi__process_frame_header
  001df	85 c0		 test	 eax, eax
  001e1	75 04		 jne	 SHORT $LN10@stbi__deco
  001e3	33 c0		 xor	 eax, eax
  001e5	eb 05		 jmp	 SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 3384 :    return 1;

  001e7	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3385 : }

  001ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001f0	5f		 pop	 rdi
  001f1	c3		 ret	 0
stbi__decode_jpeg_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
x$1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 48
s$ = 56
s$ = 64
s$ = 72
s$ = 80
tv128 = 88
tv136 = 92
tv145 = 93
tv157 = 96
tv165 = 100
tv174 = 101
j$ = 128
stbi__skip_jpeg_junk_at_end PROC

; 3388 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00016	90		 npad	 1
$LN2@stbi__skip:

; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {

  00017	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00022	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 1628 :    if (s->io.read) {

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00031	74 34		 je	 SHORT $LN10@stbi__skip

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00038	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00041	ff 50 20	 call	 QWORD PTR [rax+32]
  00044	85 c0		 test	 eax, eax
  00046	75 0a		 jne	 SHORT $LN11@stbi__skip
  00048	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0
  00050	eb 49		 jmp	 SHORT $LN9@stbi__skip
$LN11@stbi__skip:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00057	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0005b	75 0a		 jne	 SHORT $LN12@stbi__skip
  0005d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR $T2[rsp], 1
  00065	eb 34		 jmp	 SHORT $LN9@stbi__skip
$LN12@stbi__skip:
$LN10@stbi__skip:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00071	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00078	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0007f	72 0a		 jb	 SHORT $LN14@stbi__skip
  00081	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00089	eb 08		 jmp	 SHORT $LN15@stbi__skip
$LN14@stbi__skip:
  0008b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN15@stbi__skip:
  00093	8b 44 24 58	 mov	 eax, DWORD PTR tv128[rsp]
  00097	89 44 24 24	 mov	 DWORD PTR $T2[rsp], eax
$LN9@stbi__skip:

; 3389 :    // some JPEGs have junk at end, skip over it but if we find what looks
; 3390 :    // like a valid marker, resume there
; 3391 :    while (!stbi__at_eof(j->s)) {

  0009b	8b 44 24 24	 mov	 eax, DWORD PTR $T2[rsp]
  0009f	85 c0		 test	 eax, eax
  000a1	0f 85 49 02 00
	00		 jne	 $LN3@stbi__skip

; 3392 :       int x = stbi__get8(j->s);

  000a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 89 44 24 48	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000c8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000cf	73 39		 jae	 SHORT $LN17@stbi__skip

; 1615 :       return *s->img_buffer++;

  000d1	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000d6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000dd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e0	88 44 24 5c	 mov	 BYTE PTR tv136[rsp], al
  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000e9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000f0	48 ff c0	 inc	 rax
  000f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ff	0f b6 44 24 5c	 movzx	 eax, BYTE PTR tv136[rsp]
  00104	88 44 24 28	 mov	 BYTE PTR $T3[rsp], al
  00108	eb 53		 jmp	 SHORT $LN16@stbi__skip
$LN17@stbi__skip:

; 1616 :    if (s->read_from_callbacks) {

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0010f	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00113	74 43		 je	 SHORT $LN18@stbi__skip

; 1617 :       stbi__refill_buffer(s);

  00115	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0011a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0011f	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00124	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0012b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012e	88 44 24 5d	 mov	 BYTE PTR tv145[rsp], al
  00132	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00137	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0013e	48 ff c0	 inc	 rax
  00141	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00146	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0014d	0f b6 44 24 5d	 movzx	 eax, BYTE PTR tv145[rsp]
  00152	88 44 24 28	 mov	 BYTE PTR $T3[rsp], al
  00156	eb 05		 jmp	 SHORT $LN16@stbi__skip
$LN18@stbi__skip:

; 1619 :    }
; 1620 :    return 0;

  00158	c6 44 24 28 00	 mov	 BYTE PTR $T3[rsp], 0
$LN16@stbi__skip:

; 3392 :       int x = stbi__get8(j->s);

  0015d	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T3[rsp]
  00162	0f b6 c0	 movzx	 eax, al
  00165	89 44 24 20	 mov	 DWORD PTR x$1[rsp], eax
$LN4@stbi__skip:

; 3393 :       while (x == 255) { // might be a marker

  00169	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR x$1[rsp], 255	; 000000ffH
  00171	0f 85 74 01 00
	00		 jne	 $LN5@stbi__skip

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

  00177	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0017f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00182	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 1628 :    if (s->io.read) {

  00187	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0018c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00191	74 34		 je	 SHORT $LN21@stbi__skip

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00193	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00198	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0019c	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  001a1	ff 50 20	 call	 QWORD PTR [rax+32]
  001a4	85 c0		 test	 eax, eax
  001a6	75 0a		 jne	 SHORT $LN22@stbi__skip
  001a8	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T4[rsp], 0
  001b0	eb 49		 jmp	 SHORT $LN20@stbi__skip
$LN22@stbi__skip:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  001b2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  001b7	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001bb	75 0a		 jne	 SHORT $LN23@stbi__skip
  001bd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR $T4[rsp], 1
  001c5	eb 34		 jmp	 SHORT $LN20@stbi__skip
$LN23@stbi__skip:
$LN21@stbi__skip:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  001c7	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  001cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001d1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001d8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001df	72 0a		 jb	 SHORT $LN25@stbi__skip
  001e1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  001e9	eb 08		 jmp	 SHORT $LN26@stbi__skip
$LN25@stbi__skip:
  001eb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN26@stbi__skip:
  001f3	8b 44 24 60	 mov	 eax, DWORD PTR tv157[rsp]
  001f7	89 44 24 2c	 mov	 DWORD PTR $T4[rsp], eax
$LN20@stbi__skip:

; 3394 :          if (stbi__at_eof(j->s)) return STBI__MARKER_none;

  001fb	8b 44 24 2c	 mov	 eax, DWORD PTR $T4[rsp]
  001ff	85 c0		 test	 eax, eax
  00201	74 0a		 je	 SHORT $LN6@stbi__skip
  00203	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00208	e9 e8 00 00 00	 jmp	 $LN1@stbi__skip
$LN6@stbi__skip:

; 3395 :          x = stbi__get8(j->s);

  0020d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00215	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00218	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0021d	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00222	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00227	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0022e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00235	73 39		 jae	 SHORT $LN28@stbi__skip

; 1615 :       return *s->img_buffer++;

  00237	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0023c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00243	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00246	88 44 24 64	 mov	 BYTE PTR tv165[rsp], al
  0024a	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0024f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00256	48 ff c0	 inc	 rax
  00259	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0025e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00265	0f b6 44 24 64	 movzx	 eax, BYTE PTR tv165[rsp]
  0026a	88 44 24 30	 mov	 BYTE PTR $T5[rsp], al
  0026e	eb 53		 jmp	 SHORT $LN27@stbi__skip
$LN28@stbi__skip:

; 1616 :    if (s->read_from_callbacks) {

  00270	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00275	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00279	74 43		 je	 SHORT $LN29@stbi__skip

; 1617 :       stbi__refill_buffer(s);

  0027b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00280	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00285	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0028a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00291	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00294	88 44 24 65	 mov	 BYTE PTR tv174[rsp], al
  00298	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0029d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002a4	48 ff c0	 inc	 rax
  002a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  002ac	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002b3	0f b6 44 24 65	 movzx	 eax, BYTE PTR tv174[rsp]
  002b8	88 44 24 30	 mov	 BYTE PTR $T5[rsp], al
  002bc	eb 05		 jmp	 SHORT $LN27@stbi__skip
$LN29@stbi__skip:

; 1619 :    }
; 1620 :    return 0;

  002be	c6 44 24 30 00	 mov	 BYTE PTR $T5[rsp], 0
$LN27@stbi__skip:

; 3395 :          x = stbi__get8(j->s);

  002c3	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T5[rsp]
  002c8	0f b6 c0	 movzx	 eax, al
  002cb	89 44 24 20	 mov	 DWORD PTR x$1[rsp], eax

; 3396 :          if (x != 0x00 && x != 0xff) {

  002cf	83 7c 24 20 00	 cmp	 DWORD PTR x$1[rsp], 0
  002d4	74 10		 je	 SHORT $LN7@stbi__skip
  002d6	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR x$1[rsp], 255	; 000000ffH
  002de	74 06		 je	 SHORT $LN7@stbi__skip

; 3397 :             // not a stuffed zero or lead-in to another marker, looks
; 3398 :             // like an actual marker, return it
; 3399 :             return x;

  002e0	8b 44 24 20	 mov	 eax, DWORD PTR x$1[rsp]
  002e4	eb 0f		 jmp	 SHORT $LN1@stbi__skip
$LN7@stbi__skip:

; 3400 :          }
; 3401 :          // stuffed zero has x=0 now which ends the loop, meaning we go
; 3402 :          // back to regular scan loop.
; 3403 :          // repeated 0xff keeps trying to read the next byte of the marker.
; 3404 :       }

  002e6	e9 7e fe ff ff	 jmp	 $LN4@stbi__skip
$LN5@stbi__skip:

; 3405 :    }

  002eb	e9 27 fd ff ff	 jmp	 $LN2@stbi__skip
$LN3@stbi__skip:

; 3406 :    return STBI__MARKER_none;

  002f0	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$LN1@stbi__skip:

; 3407 : }

  002f5	48 83 c4 70	 add	 rsp, 112		; 00000070H
  002f9	5f		 pop	 rdi
  002fa	c3		 ret	 0
stbi__skip_jpeg_junk_at_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
m$ = 32
Ld$1 = 36
NL$2 = 40
j$ = 64
stbi__decode_jpeg_image PROC

; 3411 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00016	90		 npad	 1

; 3412 :    int m;
; 3413 :    for (m = 0; m < 4; m++) {

  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR m$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN4@stbi__deco
$LN2@stbi__deco:
  00021	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:
  0002b	83 7c 24 20 04	 cmp	 DWORD PTR m$[rsp], 4
  00030	7d 36		 jge	 SHORT $LN3@stbi__deco

; 3414 :       j->img_comp[m].raw_data = NULL;

  00032	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00037	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00040	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3415 :       j->img_comp[m].raw_coeff = NULL;

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00051	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0005a	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3416 :    }

  00066	eb b9		 jmp	 SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 3417 :    j->restart_interval = 0;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006d	c7 80 68 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18536], 0

; 3418 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

  00077	33 d2		 xor	 edx, edx
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  00083	85 c0		 test	 eax, eax
  00085	75 07		 jne	 SHORT $LN7@stbi__deco
  00087	33 c0		 xor	 eax, eax
  00089	e9 7a 01 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 3419 :    m = stbi__get_marker(j);

  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00093	e8 00 00 00 00	 call	 stbi__get_marker
  00098	0f b6 c0	 movzx	 eax, al
  0009b	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN5@stbi__deco:

; 3420 :    while (!stbi__EOI(m)) {

  0009f	81 7c 24 20 d9
	00 00 00	 cmp	 DWORD PTR m$[rsp], 217	; 000000d9H
  000a7	0f 84 3d 01 00
	00		 je	 $LN6@stbi__deco

; 3421 :       if (stbi__SOS(m)) {

  000ad	81 7c 24 20 da
	00 00 00	 cmp	 DWORD PTR m$[rsp], 218	; 000000daH
  000b5	0f 85 8d 00 00
	00		 jne	 $LN8@stbi__deco

; 3422 :          if (!stbi__process_scan_header(j)) return 0;

  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c0	e8 00 00 00 00	 call	 stbi__process_scan_header
  000c5	85 c0		 test	 eax, eax
  000c7	75 07		 jne	 SHORT $LN10@stbi__deco
  000c9	33 c0		 xor	 eax, eax
  000cb	e9 38 01 00 00	 jmp	 $LN1@stbi__deco
$LN10@stbi__deco:

; 3423 :          if (!stbi__parse_entropy_coded_data(j)) return 0;

  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000d5	e8 00 00 00 00	 call	 stbi__parse_entropy_coded_data
  000da	85 c0		 test	 eax, eax
  000dc	75 07		 jne	 SHORT $LN11@stbi__deco
  000de	33 c0		 xor	 eax, eax
  000e0	e9 23 01 00 00	 jmp	 $LN1@stbi__deco
$LN11@stbi__deco:

; 3424 :          if (j->marker == STBI__MARKER_none ) {

  000e5	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ea	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  000f1	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f6	75 15		 jne	 SHORT $LN12@stbi__deco

; 3425 :          j->marker = stbi__skip_jpeg_junk_at_end(j);

  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000fd	e8 00 00 00 00	 call	 stbi__skip_jpeg_junk_at_end
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00107	88 81 28 48 00
	00		 mov	 BYTE PTR [rcx+18472], al
$LN12@stbi__deco:

; 3426 :             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3427 :          }
; 3428 :          m = stbi__get_marker(j);

  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00112	e8 00 00 00 00	 call	 stbi__get_marker
  00117	0f b6 c0	 movzx	 eax, al
  0011a	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3429 :          if (STBI__RESTART(m))

  0011e	81 7c 24 20 d0
	00 00 00	 cmp	 DWORD PTR m$[rsp], 208	; 000000d0H
  00126	7c 1b		 jl	 SHORT $LN13@stbi__deco
  00128	81 7c 24 20 d7
	00 00 00	 cmp	 DWORD PTR m$[rsp], 215	; 000000d7H
  00130	7f 11		 jg	 SHORT $LN13@stbi__deco

; 3430 :             m = stbi__get_marker(j);

  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00137	e8 00 00 00 00	 call	 stbi__get_marker
  0013c	0f b6 c0	 movzx	 eax, al
  0013f	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN13@stbi__deco:

; 3431 :       } else if (stbi__DNL(m)) {

  00143	e9 9d 00 00 00	 jmp	 $LN9@stbi__deco
$LN8@stbi__deco:
  00148	81 7c 24 20 dc
	00 00 00	 cmp	 DWORD PTR m$[rsp], 220	; 000000dcH
  00150	75 69		 jne	 SHORT $LN14@stbi__deco

; 3432 :          int Ld = stbi__get16be(j->s);

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00157	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015a	e8 00 00 00 00	 call	 stbi__get16be
  0015f	89 44 24 24	 mov	 DWORD PTR Ld$1[rsp], eax

; 3433 :          stbi__uint32 NL = stbi__get16be(j->s);

  00163	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00168	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016b	e8 00 00 00 00	 call	 stbi__get16be
  00170	89 44 24 28	 mov	 DWORD PTR NL$2[rsp], eax

; 3434 :          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

  00174	83 7c 24 24 04	 cmp	 DWORD PTR Ld$1[rsp], 4
  00179	74 0e		 je	 SHORT $LN16@stbi__deco
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@EPMOIECP@bad?5DNL?5len@
  00182	e8 00 00 00 00	 call	 stbi__err
  00187	eb 7f		 jmp	 SHORT $LN1@stbi__deco
$LN16@stbi__deco:

; 3435 :          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

  00189	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0018e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00191	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00194	39 44 24 28	 cmp	 DWORD PTR NL$2[rsp], eax
  00198	74 0e		 je	 SHORT $LN17@stbi__deco
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@PNCLKCLJ@bad?5DNL?5height@
  001a1	e8 00 00 00 00	 call	 stbi__err
  001a6	eb 60		 jmp	 SHORT $LN1@stbi__deco
$LN17@stbi__deco:

; 3436 :          m = stbi__get_marker(j);

  001a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001ad	e8 00 00 00 00	 call	 stbi__get_marker
  001b2	0f b6 c0	 movzx	 eax, al
  001b5	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3437 :       } else {

  001b9	eb 2a		 jmp	 SHORT $LN15@stbi__deco
$LN14@stbi__deco:

; 3438 :          if (!stbi__process_marker(j, m)) return 1;

  001bb	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001c4	e8 00 00 00 00	 call	 stbi__process_marker
  001c9	85 c0		 test	 eax, eax
  001cb	75 07		 jne	 SHORT $LN18@stbi__deco
  001cd	b8 01 00 00 00	 mov	 eax, 1
  001d2	eb 34		 jmp	 SHORT $LN1@stbi__deco
$LN18@stbi__deco:

; 3439 :          m = stbi__get_marker(j);

  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001d9	e8 00 00 00 00	 call	 stbi__get_marker
  001de	0f b6 c0	 movzx	 eax, al
  001e1	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN15@stbi__deco:
$LN9@stbi__deco:

; 3440 :       }
; 3441 :    }

  001e5	e9 b5 fe ff ff	 jmp	 $LN5@stbi__deco
$LN6@stbi__deco:

; 3442 :    if (j->progressive)

  001ea	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  001ef	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  001f6	74 0b		 je	 SHORT $LN19@stbi__deco

; 3443 :       stbi__jpeg_finish(j);

  001f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001fd	e8 00 00 00 00	 call	 stbi__jpeg_finish
  00202	90		 npad	 1
$LN19@stbi__deco:

; 3444 :    return 1;

  00203	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3445 : }

  00208	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020c	5f		 pop	 rdi
  0020d	c3		 ret	 0
stbi__decode_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
out$ = 48
in_near$ = 56
in_far$ = 64
w$ = 72
hs$ = 80
resample_row_1 PROC

; 3455 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3456 :    STBI_NOTUSED(out);
; 3457 :    STBI_NOTUSED(in_far);
; 3458 :    STBI_NOTUSED(w);
; 3459 :    STBI_NOTUSED(hs);
; 3460 :    return in_near;

  00025	48 8b 44 24 38	 mov	 rax, QWORD PTR in_near$[rsp]

; 3461 : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
resample_row_1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
out$ = 64
in_near$ = 72
in_far$ = 80
w$ = 88
hs$ = 96
stbi__resample_row_v_2 PROC

; 3464 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	90		 npad	 1

; 3465 :    // need to generate two samples vertically for every one in input
; 3466 :    int i;
; 3467 :    STBI_NOTUSED(hs);
; 3468 :    for (i=0; i < w; ++i)

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  0003a	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0003e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00042	7d 35		 jge	 SHORT $LN3@stbi__resa

; 3469 :       out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

  00044	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_near$[rsp]
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	6b c0 03	 imul	 eax, eax, 3
  00055	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005a	48 8b 54 24 50	 mov	 rdx, QWORD PTR in_far$[rsp]
  0005f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00063	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00067	c1 f8 02	 sar	 eax, 2
  0006a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006f	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00074	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00077	eb b7		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3470 :    return out;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]

; 3471 : }

  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
stbi__resample_row_v_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
input$ = 40
n$1 = 48
out$ = 80
in_near$ = 88
in_far$ = 96
w$ = 104
hs$ = 112
stbi__resample_row_h_2 PROC

; 3474 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3475 :    // need to generate two samples horizontally for every one in input
; 3476 :    int i;
; 3477 :    stbi_uc *input = in_near;

  00025	48 8b 44 24 58	 mov	 rax, QWORD PTR in_near$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 3478 : 
; 3479 :    if (w == 1) {

  0002f	83 7c 24 68 01	 cmp	 DWORD PTR w$[rsp], 1
  00034	75 52		 jne	 SHORT $LN5@stbi__resa

; 3480 :       // if only one sample, can't do any interpolation
; 3481 :       out[0] = out[1] = input[0];

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	48 6b c0 00	 imul	 rax, rax, 0
  0003f	b9 01 00 00 00	 mov	 ecx, 1
  00044	48 6b c9 01	 imul	 rcx, rcx, 1
  00048	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  0004d	4c 8b 44 24 28	 mov	 r8, QWORD PTR input$[rsp]
  00052	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00057	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	48 6b c0 01	 imul	 rax, rax, 1
  00063	b9 01 00 00 00	 mov	 ecx, 1
  00068	48 6b c9 00	 imul	 rcx, rcx, 0
  0006c	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  00071	4c 8b 44 24 50	 mov	 r8, QWORD PTR out$[rsp]
  00076	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3482 :       return out;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR out$[rsp]
  00083	e9 65 01 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3483 :    }
; 3484 : 
; 3485 :    out[0] = input[0];

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	48 6b c0 00	 imul	 rax, rax, 0
  00091	b9 01 00 00 00	 mov	 ecx, 1
  00096	48 6b c9 00	 imul	 rcx, rcx, 0
  0009a	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR input$[rsp]
  000a4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3486 :    out[1] = stbi__div4(input[0]*3 + input[1] + 2);

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 00	 imul	 rax, rax, 0
  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000be	6b c0 03	 imul	 eax, eax, 3
  000c1	b9 01 00 00 00	 mov	 ecx, 1
  000c6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ca	48 8b 54 24 28	 mov	 rdx, QWORD PTR input$[rsp]
  000cf	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d3	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  000d7	c1 f8 02	 sar	 eax, 2
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	48 6b c9 01	 imul	 rcx, rcx, 1
  000e3	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  000e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3487 :    for (i=1; i < w-1; ++i) {

  000eb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000f3	eb 0a		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000f5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f9	ff c0		 inc	 eax
  000fb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000ff	8b 44 24 68	 mov	 eax, DWORD PTR w$[rsp]
  00103	ff c8		 dec	 eax
  00105	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00109	7d 79		 jge	 SHORT $LN3@stbi__resa

; 3488 :       int n = 3*input[i]+2;

  0010b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00115	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00119	6b c0 03	 imul	 eax, eax, 3
  0011c	83 c0 02	 add	 eax, 2
  0011f	89 44 24 30	 mov	 DWORD PTR n$1[rsp], eax

; 3489 :       out[i*2+0] = stbi__div4(n+input[i-1]);

  00123	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00127	ff c8		 dec	 eax
  00129	48 98		 cdqe
  0012b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00130	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00134	8b 4c 24 30	 mov	 ecx, DWORD PTR n$1[rsp]
  00138	03 c8		 add	 ecx, eax
  0013a	8b c1		 mov	 eax, ecx
  0013c	c1 f8 02	 sar	 eax, 2
  0013f	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00143	03 c9		 add	 ecx, ecx
  00145	48 63 c9	 movsxd	 rcx, ecx
  00148	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  0014d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3490 :       out[i*2+1] = stbi__div4(n+input[i+1]);

  00150	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00154	ff c0		 inc	 eax
  00156	48 98		 cdqe
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0015d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00161	8b 4c 24 30	 mov	 ecx, DWORD PTR n$1[rsp]
  00165	03 c8		 add	 ecx, eax
  00167	8b c1		 mov	 eax, ecx
  00169	c1 f8 02	 sar	 eax, 2
  0016c	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00170	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  00174	48 63 c9	 movsxd	 rcx, ecx
  00177	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  0017c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3491 :    }

  0017f	e9 71 ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3492 :    out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

  00184	8b 44 24 68	 mov	 eax, DWORD PTR w$[rsp]
  00188	83 e8 02	 sub	 eax, 2
  0018b	48 98		 cdqe
  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00192	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00196	6b c0 03	 imul	 eax, eax, 3
  00199	8b 4c 24 68	 mov	 ecx, DWORD PTR w$[rsp]
  0019d	ff c9		 dec	 ecx
  0019f	48 63 c9	 movsxd	 rcx, ecx
  001a2	48 8b 54 24 28	 mov	 rdx, QWORD PTR input$[rsp]
  001a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001ab	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  001af	c1 f8 02	 sar	 eax, 2
  001b2	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001b6	03 c9		 add	 ecx, ecx
  001b8	48 63 c9	 movsxd	 rcx, ecx
  001bb	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  001c0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3493 :    out[i*2+1] = input[w-1];

  001c3	8b 44 24 68	 mov	 eax, DWORD PTR w$[rsp]
  001c7	ff c8		 dec	 eax
  001c9	48 98		 cdqe
  001cb	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001cf	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  001d3	48 63 c9	 movsxd	 rcx, ecx
  001d6	48 8b 54 24 50	 mov	 rdx, QWORD PTR out$[rsp]
  001db	4c 8b 44 24 28	 mov	 r8, QWORD PTR input$[rsp]
  001e0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001e5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3494 : 
; 3495 :    STBI_NOTUSED(in_far);
; 3496 :    STBI_NOTUSED(hs);
; 3497 : 
; 3498 :    return out;

  001e8	48 8b 44 24 50	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3499 : }

  001ed	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001f1	5f		 pop	 rdi
  001f2	c3		 ret	 0
stbi__resample_row_h_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
t0$ = 36
t1$ = 40
tv78 = 44
out$ = 64
in_near$ = 72
in_far$ = 80
w$ = 88
hs$ = 96
stbi__resample_row_hv_2 PROC

; 3504 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3505 :    // need to generate 2x2 samples for every one in input
; 3506 :    int i,t0,t1;
; 3507 :    if (w == 1) {

  00025	83 7c 24 58 01	 cmp	 DWORD PTR w$[rsp], 1
  0002a	75 68		 jne	 SHORT $LN5@stbi__resa

; 3508 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 00	 imul	 rax, rax, 0
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_near$[rsp]
  0003a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003e	6b c0 03	 imul	 eax, eax, 3
  00041	b9 01 00 00 00	 mov	 ecx, 1
  00046	48 6b c9 00	 imul	 rcx, rcx, 0
  0004a	48 8b 54 24 50	 mov	 rdx, QWORD PTR in_far$[rsp]
  0004f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00053	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00057	c1 f8 02	 sar	 eax, 2
  0005a	89 44 24 2c	 mov	 DWORD PTR tv78[rsp], eax
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	48 6b c0 01	 imul	 rax, rax, 1
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0006c	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv78[rsp]
  00071	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	48 6b c0 00	 imul	 rax, rax, 0
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00082	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv78[rsp]
  00087	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3509 :       return out;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  0008f	e9 fe 00 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3510 :    }
; 3511 : 
; 3512 :    t1 = 3*in_near[0] + in_far[0];

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	48 6b c0 00	 imul	 rax, rax, 0
  0009d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_near$[rsp]
  000a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a6	6b c0 03	 imul	 eax, eax, 3
  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	48 6b c9 00	 imul	 rcx, rcx, 0
  000b2	48 8b 54 24 50	 mov	 rdx, QWORD PTR in_far$[rsp]
  000b7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000bb	03 c1		 add	 eax, ecx
  000bd	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3513 :    out[0] = stbi__div4(t1+2);

  000c1	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	c1 f8 02	 sar	 eax, 2
  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	48 6b c9 00	 imul	 rcx, rcx, 0
  000d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  000d9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3514 :    for (i=1; i < w; ++i) {

  000dc	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000e4	eb 0a		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000e6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000f0	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  000f4	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000f8	7d 76		 jge	 SHORT $LN3@stbi__resa

; 3515 :       t0 = t1;

  000fa	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  000fe	89 44 24 24	 mov	 DWORD PTR t0$[rsp], eax

; 3516 :       t1 = 3*in_near[i]+in_far[i];

  00102	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in_near$[rsp]
  0010c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00110	6b c0 03	 imul	 eax, eax, 3
  00113	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00118	48 8b 54 24 50	 mov	 rdx, QWORD PTR in_far$[rsp]
  0011d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00121	03 c1		 add	 eax, ecx
  00123	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3517 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  00127	6b 44 24 24 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  0012c	8b 4c 24 28	 mov	 ecx, DWORD PTR t1$[rsp]
  00130	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00134	c1 f8 04	 sar	 eax, 4
  00137	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0013b	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0013f	48 63 c9	 movsxd	 rcx, ecx
  00142	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00147	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3518 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  0014a	6b 44 24 28 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  0014f	8b 4c 24 24	 mov	 ecx, DWORD PTR t0$[rsp]
  00153	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00157	c1 f8 04	 sar	 eax, 4
  0015a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0015e	d1 e1		 shl	 ecx, 1
  00160	48 63 c9	 movsxd	 rcx, ecx
  00163	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00168	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3519 :    }

  0016b	e9 76 ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3520 :    out[w*2-1] = stbi__div4(t1+2);

  00170	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  00174	83 c0 02	 add	 eax, 2
  00177	c1 f8 02	 sar	 eax, 2
  0017a	8b 4c 24 58	 mov	 ecx, DWORD PTR w$[rsp]
  0017e	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  00182	48 63 c9	 movsxd	 rcx, ecx
  00185	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  0018a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3521 : 
; 3522 :    STBI_NOTUSED(hs);
; 3523 : 
; 3524 :    return out;

  0018d	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3525 : }

  00192	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00196	5f		 pop	 rdi
  00197	c3		 ret	 0
stbi__resample_row_hv_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
t0$ = 36
t1$ = 40
zero$1 = 48
farb$2 = 64
nearb$3 = 80
farw$4 = 96
nearw$5 = 112
diff$6 = 128
nears$7 = 144
curr$8 = 160
prv0$9 = 176
nxt0$10 = 192
prev$11 = 208
next$12 = 224
bias$13 = 240
curs$14 = 256
prvd$15 = 272
nxtd$16 = 288
curb$17 = 304
even$18 = 320
odd$19 = 336
int0$20 = 352
int1$21 = 368
de0$22 = 384
de1$23 = 400
outv$24 = 416
tv78 = 432
out$ = 464
in_near$ = 472
in_far$ = 480
w$ = 488
hs$ = 496
stbi__resample_row_hv_2_simd PROC

; 3529 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec c0 01
	00 00		 sub	 rsp, 448		; 000001c0H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3530 :    // need to generate 2x2 samples for every one in input
; 3531 :    int i=0,t0,t1;

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 3532 : 
; 3533 :    if (w == 1) {

  00030	83 bc 24 e8 01
	00 00 01	 cmp	 DWORD PTR w$[rsp], 1
  00038	0f 85 80 00 00
	00		 jne	 $LN8@stbi__resa

; 3534 :       out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0004f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00053	6b c0 03	 imul	 eax, eax, 3
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	48 6b c9 00	 imul	 rcx, rcx, 0
  0005f	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00067	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0006b	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0006f	c1 f8 02	 sar	 eax, 2
  00072	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv78[rsp], eax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 01	 imul	 rax, rax, 1
  00082	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0008a	0f b6 94 24 b0
	01 00 00	 movzx	 edx, BYTE PTR tv78[rsp]
  00092	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	48 6b c0 00	 imul	 rax, rax, 0
  0009e	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  000a6	0f b6 94 24 b0
	01 00 00	 movzx	 edx, BYTE PTR tv78[rsp]
  000ae	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3535 :       return out;

  000b1	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000b9	e9 45 04 00 00	 jmp	 $LN1@stbi__resa
$LN8@stbi__resa:

; 3536 :    }
; 3537 : 
; 3538 :    t1 = 3*in_near[0] + in_far[0];

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	48 6b c0 00	 imul	 rax, rax, 0
  000c7	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  000cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d3	6b c0 03	 imul	 eax, eax, 3
  000d6	b9 01 00 00 00	 mov	 ecx, 1
  000db	48 6b c9 00	 imul	 rcx, rcx, 0
  000df	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  000e7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000eb	03 c1		 add	 eax, ecx
  000ed	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3539 :    // process groups of 8 pixels for as long as we can.
; 3540 :    // note we can't handle the last pixel in a row in this loop
; 3541 :    // because we need to handle the filter boundary conditions.
; 3542 :    for (; i < ((w-1) & ~7); i += 8) {

  000f1	eb 0b		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000f3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f7	83 c0 08	 add	 eax, 8
  000fa	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000fe	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  00105	ff c8		 dec	 eax
  00107	83 e0 f8	 and	 eax, -8
  0010a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0010e	0f 8d c4 02 00
	00		 jge	 $LN3@stbi__resa

; 3543 : #if defined(STBI_SSE2)
; 3544 :       // load and perform the vertical filtering pass
; 3545 :       // this uses 3*x + y = 4*x + (y - x)
; 3546 :       __m128i zero  = _mm_setzero_si128();

  00114	66 0f ef c0	 pxor	 xmm0, xmm0
  00118	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR zero$1[rsp], xmm0

; 3547 :       __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));

  0011e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00123	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR in_far$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00135	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR farb$2[rsp], xmm0

; 3548 :       __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));

  0013b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00140	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00148	48 03 c8	 add	 rcx, rax
  0014b	48 8b c1	 mov	 rax, rcx
  0014e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00152	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR nearb$3[rsp], xmm0

; 3549 :       __m128i farw  = _mm_unpacklo_epi8(farb, zero);

  00158	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR farb$2[rsp]
  0015e	66 0f 60 44 24
	30		 punpcklbw xmm0, XMMWORD PTR zero$1[rsp]
  00164	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR farw$4[rsp], xmm0

; 3550 :       __m128i nearw = _mm_unpacklo_epi8(nearb, zero);

  0016a	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR nearb$3[rsp]
  00170	66 0f 60 44 24
	30		 punpcklbw xmm0, XMMWORD PTR zero$1[rsp]
  00176	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR nearw$5[rsp], xmm0

; 3551 :       __m128i diff  = _mm_sub_epi16(farw, nearw);

  0017c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR farw$4[rsp]
  00182	66 0f f9 44 24
	70		 psubw	 xmm0, XMMWORD PTR nearw$5[rsp]
  00188	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR diff$6[rsp], xmm0

; 3552 :       __m128i nears = _mm_slli_epi16(nearw, 2);

  00191	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR nearw$5[rsp]
  00197	66 0f 71 f0 02	 psllw	 xmm0, 2
  0019c	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR nears$7[rsp], xmm0

; 3553 :       __m128i curr  = _mm_add_epi16(nears, diff); // current row

  001a5	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR nears$7[rsp]
  001ae	66 0f fd 84 24
	80 00 00 00	 paddw	 xmm0, XMMWORD PTR diff$6[rsp]
  001b7	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR curr$8[rsp], xmm0

; 3554 : 
; 3555 :       // horizontal filter works the same based on shifted vers of current
; 3556 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3557 :       // insert the previous pixel value (from t1).
; 3558 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3559 :       // of next block of 8 pixels added in.
; 3560 :       __m128i prv0 = _mm_slli_si128(curr, 2);

  001c0	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rsp]
  001c9	66 0f 73 f8 02	 pslldq	 xmm0, 2
  001ce	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR prv0$9[rsp], xmm0

; 3561 :       __m128i nxt0 = _mm_srli_si128(curr, 2);

  001d7	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rsp]
  001e0	66 0f 73 d8 02	 psrldq	 xmm0, 2
  001e5	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR nxt0$10[rsp], xmm0

; 3562 :       __m128i prev = _mm_insert_epi16(prv0, t1, 0);

  001ee	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR prv0$9[rsp]
  001f7	66 0f c4 44 24
	28 00		 pinsrw	 xmm0, DWORD PTR t1$[rsp], 0
  001fe	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR prev$11[rsp], xmm0

; 3563 :       __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

  00207	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0020b	83 c0 08	 add	 eax, 8
  0020e	48 98		 cdqe
  00210	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00218	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021c	6b c0 03	 imul	 eax, eax, 3
  0021f	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00223	83 c1 08	 add	 ecx, 8
  00226	48 63 c9	 movsxd	 rcx, ecx
  00229	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00231	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00235	03 c1		 add	 eax, ecx
  00237	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR nxt0$10[rsp]
  00240	66 0f c4 c0 07	 pinsrw	 xmm0, eax, 7
  00245	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR next$12[rsp], xmm0

; 3564 : 
; 3565 :       // horizontal filter, polyphase implementation since it's convenient:
; 3566 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3567 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3568 :       // note the shared term.
; 3569 :       __m128i bias  = _mm_set1_epi16(8);

  0024e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
  00256	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR bias$13[rsp], xmm0

; 3570 :       __m128i curs = _mm_slli_epi16(curr, 2);

  0025f	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR curr$8[rsp]
  00268	66 0f 71 f0 02	 psllw	 xmm0, 2
  0026d	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR curs$14[rsp], xmm0

; 3571 :       __m128i prvd = _mm_sub_epi16(prev, curr);

  00276	66 0f 6f 84 24
	d0 00 00 00	 movdqa	 xmm0, XMMWORD PTR prev$11[rsp]
  0027f	66 0f f9 84 24
	a0 00 00 00	 psubw	 xmm0, XMMWORD PTR curr$8[rsp]
  00288	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR prvd$15[rsp], xmm0

; 3572 :       __m128i nxtd = _mm_sub_epi16(next, curr);

  00291	66 0f 6f 84 24
	e0 00 00 00	 movdqa	 xmm0, XMMWORD PTR next$12[rsp]
  0029a	66 0f f9 84 24
	a0 00 00 00	 psubw	 xmm0, XMMWORD PTR curr$8[rsp]
  002a3	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR nxtd$16[rsp], xmm0

; 3573 :       __m128i curb = _mm_add_epi16(curs, bias);

  002ac	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR curs$14[rsp]
  002b5	66 0f fd 84 24
	f0 00 00 00	 paddw	 xmm0, XMMWORD PTR bias$13[rsp]
  002be	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR curb$17[rsp], xmm0

; 3574 :       __m128i even = _mm_add_epi16(prvd, curb);

  002c7	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR prvd$15[rsp]
  002d0	66 0f fd 84 24
	30 01 00 00	 paddw	 xmm0, XMMWORD PTR curb$17[rsp]
  002d9	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR even$18[rsp], xmm0

; 3575 :       __m128i odd  = _mm_add_epi16(nxtd, curb);

  002e2	66 0f 6f 84 24
	20 01 00 00	 movdqa	 xmm0, XMMWORD PTR nxtd$16[rsp]
  002eb	66 0f fd 84 24
	30 01 00 00	 paddw	 xmm0, XMMWORD PTR curb$17[rsp]
  002f4	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR odd$19[rsp], xmm0

; 3576 : 
; 3577 :       // interleave even and odd pixels, then undo scaling.
; 3578 :       __m128i int0 = _mm_unpacklo_epi16(even, odd);

  002fd	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR even$18[rsp]
  00306	66 0f 61 84 24
	50 01 00 00	 punpcklwd xmm0, XMMWORD PTR odd$19[rsp]
  0030f	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR int0$20[rsp], xmm0

; 3579 :       __m128i int1 = _mm_unpackhi_epi16(even, odd);

  00318	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR even$18[rsp]
  00321	66 0f 69 84 24
	50 01 00 00	 punpckhwd xmm0, XMMWORD PTR odd$19[rsp]
  0032a	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR int1$21[rsp], xmm0

; 3580 :       __m128i de0  = _mm_srli_epi16(int0, 4);

  00333	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR int0$20[rsp]
  0033c	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00341	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR de0$22[rsp], xmm0

; 3581 :       __m128i de1  = _mm_srli_epi16(int1, 4);

  0034a	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR int1$21[rsp]
  00353	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00358	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR de1$23[rsp], xmm0

; 3582 : 
; 3583 :       // pack and write output
; 3584 :       __m128i outv = _mm_packus_epi16(de0, de1);

  00361	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR de0$22[rsp]
  0036a	66 0f 67 84 24
	90 01 00 00	 packuswb xmm0, XMMWORD PTR de1$23[rsp]
  00373	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR outv$24[rsp], xmm0

; 3585 :       _mm_storeu_si128((__m128i *) (out + i*2), outv);

  0037c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00380	03 c0		 add	 eax, eax
  00382	48 98		 cdqe
  00384	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0038c	48 03 c8	 add	 rcx, rax
  0038f	48 8b c1	 mov	 rax, rcx
  00392	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR outv$24[rsp]
  0039b	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3586 : #elif defined(STBI_NEON)
; 3587 :       // load and perform the vertical filtering pass
; 3588 :       // this uses 3*x + y = 4*x + (y - x)
; 3589 :       uint8x8_t farb  = vld1_u8(in_far + i);
; 3590 :       uint8x8_t nearb = vld1_u8(in_near + i);
; 3591 :       int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3592 :       int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3593 :       int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3594 : 
; 3595 :       // horizontal filter works the same based on shifted vers of current
; 3596 :       // row. "prev" is current row shifted right by 1 pixel; we need to
; 3597 :       // insert the previous pixel value (from t1).
; 3598 :       // "next" is current row shifted left by 1 pixel, with first pixel
; 3599 :       // of next block of 8 pixels added in.
; 3600 :       int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3601 :       int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3602 :       int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3603 :       int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3604 : 
; 3605 :       // horizontal filter, polyphase implementation since it's convenient:
; 3606 :       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3607 :       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3608 :       // note the shared term.
; 3609 :       int16x8_t curs = vshlq_n_s16(curr, 2);
; 3610 :       int16x8_t prvd = vsubq_s16(prev, curr);
; 3611 :       int16x8_t nxtd = vsubq_s16(next, curr);
; 3612 :       int16x8_t even = vaddq_s16(curs, prvd);
; 3613 :       int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3614 : 
; 3615 :       // undo scaling and round, then store with even/odd phases interleaved
; 3616 :       uint8x8x2_t o;
; 3617 :       o.val[0] = vqrshrun_n_s16(even, 4);
; 3618 :       o.val[1] = vqrshrun_n_s16(odd,  4);
; 3619 :       vst2_u8(out + i*2, o);
; 3620 : #endif
; 3621 : 
; 3622 :       // "previous" value for next iter
; 3623 :       t1 = 3*in_near[i+7] + in_far[i+7];

  0039f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003a3	83 c0 07	 add	 eax, 7
  003a6	48 98		 cdqe
  003a8	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  003b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003b4	6b c0 03	 imul	 eax, eax, 3
  003b7	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  003bb	83 c1 07	 add	 ecx, 7
  003be	48 63 c9	 movsxd	 rcx, ecx
  003c1	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  003c9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003cd	03 c1		 add	 eax, ecx
  003cf	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3624 :    }

  003d3	e9 1b fd ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3625 : 
; 3626 :    t0 = t1;

  003d8	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  003dc	89 44 24 24	 mov	 DWORD PTR t0$[rsp], eax

; 3627 :    t1 = 3*in_near[i] + in_far[i];

  003e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003e5	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  003ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f1	6b c0 03	 imul	 eax, eax, 3
  003f4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  003f9	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00401	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00405	03 c1		 add	 eax, ecx
  00407	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3628 :    out[i*2] = stbi__div16(3*t1 + t0 + 8);

  0040b	6b 44 24 28 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  00410	8b 4c 24 24	 mov	 ecx, DWORD PTR t0$[rsp]
  00414	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00418	c1 f8 04	 sar	 eax, 4
  0041b	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0041f	03 c9		 add	 ecx, ecx
  00421	48 63 c9	 movsxd	 rcx, ecx
  00424	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0042c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3629 : 
; 3630 :    for (++i; i < w; ++i) {

  0042f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00433	ff c0		 inc	 eax
  00435	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00439	eb 0a		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  0043b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0043f	ff c0		 inc	 eax
  00441	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__resa:
  00445	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  0044c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00450	0f 8d 82 00 00
	00		 jge	 $LN6@stbi__resa

; 3631 :       t0 = t1;

  00456	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  0045a	89 44 24 24	 mov	 DWORD PTR t0$[rsp], eax

; 3632 :       t1 = 3*in_near[i]+in_far[i];

  0045e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00463	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0046b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0046f	6b c0 03	 imul	 eax, eax, 3
  00472	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00477	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  0047f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00483	03 c1		 add	 eax, ecx
  00485	89 44 24 28	 mov	 DWORD PTR t1$[rsp], eax

; 3633 :       out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  00489	6b 44 24 24 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  0048e	8b 4c 24 28	 mov	 ecx, DWORD PTR t1$[rsp]
  00492	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00496	c1 f8 04	 sar	 eax, 4
  00499	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0049d	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  004a1	48 63 c9	 movsxd	 rcx, ecx
  004a4	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  004ac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3634 :       out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  004af	6b 44 24 28 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  004b4	8b 4c 24 24	 mov	 ecx, DWORD PTR t0$[rsp]
  004b8	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  004bc	c1 f8 04	 sar	 eax, 4
  004bf	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  004c3	d1 e1		 shl	 ecx, 1
  004c5	48 63 c9	 movsxd	 rcx, ecx
  004c8	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  004d0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3635 :    }

  004d3	e9 63 ff ff ff	 jmp	 $LN5@stbi__resa
$LN6@stbi__resa:

; 3636 :    out[w*2-1] = stbi__div4(t1+2);

  004d8	8b 44 24 28	 mov	 eax, DWORD PTR t1$[rsp]
  004dc	83 c0 02	 add	 eax, 2
  004df	c1 f8 02	 sar	 eax, 2
  004e2	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR w$[rsp]
  004e9	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  004ed	48 63 c9	 movsxd	 rcx, ecx
  004f0	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  004f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3637 : 
; 3638 :    STBI_NOTUSED(hs);
; 3639 : 
; 3640 :    return out;

  004fb	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3641 : }

  00503	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  0050a	5f		 pop	 rdi
  0050b	c3		 ret	 0
stbi__resample_row_hv_2_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
j$ = 36
out$ = 64
in_near$ = 72
in_far$ = 80
w$ = 88
hs$ = 96
stbi__resample_row_generic PROC

; 3645 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	90		 npad	 1

; 3646 :    // resample with nearest-neighbor
; 3647 :    int i,j;
; 3648 :    STBI_NOTUSED(in_far);
; 3649 :    for (i=0; i < w; ++i)

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  0003a	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0003e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00042	7d 49		 jge	 SHORT $LN3@stbi__resa

; 3650 :       for (j=0; j < hs; ++j)

  00044	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0004c	eb 0a		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  0004e	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00052	ff c0		 inc	 eax
  00054	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__resa:
  00058	8b 44 24 60	 mov	 eax, DWORD PTR hs$[rsp]
  0005c	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00060	7d 29		 jge	 SHORT $LN6@stbi__resa

; 3651 :          out[i*hs+j] = in_near[i];

  00062	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0006b	0f af 4c 24 60	 imul	 ecx, DWORD PTR hs$[rsp]
  00070	03 4c 24 24	 add	 ecx, DWORD PTR j$[rsp]
  00074	48 63 c9	 movsxd	 rcx, ecx
  00077	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  0007c	4c 8b 44 24 48	 mov	 r8, QWORD PTR in_near$[rsp]
  00081	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00086	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00089	eb c3		 jmp	 SHORT $LN5@stbi__resa
$LN6@stbi__resa:
  0008b	eb a3		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3652 :    return out;

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]

; 3653 : }

  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
stbi__resample_row_generic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
y_fixed$1 = 36
r$2 = 40
g$3 = 44
b$4 = 48
cr$5 = 52
cb$6 = 56
out$ = 80
y$ = 88
pcb$ = 96
pcr$ = 104
count$ = 112
step$ = 120
stbi__YCbCr_to_RGB_row PROC

; 3659 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	90		 npad	 1

; 3660 :    int i;
; 3661 :    for (i=0; i < count; ++i) {

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  0003a	8b 44 24 70	 mov	 eax, DWORD PTR count$[rsp]
  0003e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00042	0f 8d 8c 01 00
	00		 jge	 $LN3@stbi__YCbC

; 3662 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding

  00048	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR y$[rsp]
  00052	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00056	c1 e0 14	 shl	 eax, 20
  00059	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  0005e	89 44 24 24	 mov	 DWORD PTR y_fixed$1[rsp], eax

; 3663 :       int r,g,b;
; 3664 :       int cr = pcr[i] - 128;

  00062	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pcr$[rsp]
  0006c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00070	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00075	89 44 24 34	 mov	 DWORD PTR cr$5[rsp], eax

; 3665 :       int cb = pcb[i] - 128;

  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pcb$[rsp]
  00083	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00087	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0008c	89 44 24 38	 mov	 DWORD PTR cb$6[rsp], eax

; 3666 :       r = y_fixed +  cr* stbi__float2fixed(1.40200f);

  00090	69 44 24 34 00
	6f 16 00	 imul	 eax, DWORD PTR cr$5[rsp], 1470208 ; 00166f00H
  00098	8b 4c 24 24	 mov	 ecx, DWORD PTR y_fixed$1[rsp]
  0009c	03 c8		 add	 ecx, eax
  0009e	8b c1		 mov	 eax, ecx
  000a0	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 3667 :       g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  000a4	69 44 24 34 00
	93 f4 ff	 imul	 eax, DWORD PTR cr$5[rsp], -748800 ; fffffffffff49300H
  000ac	8b 4c 24 24	 mov	 ecx, DWORD PTR y_fixed$1[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	69 4c 24 38 00
	7e fa ff	 imul	 ecx, DWORD PTR cb$6[rsp], -360960 ; fffffffffffa7e00H
  000bc	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  000c2	03 c1		 add	 eax, ecx
  000c4	89 44 24 2c	 mov	 DWORD PTR g$3[rsp], eax

; 3668 :       b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);

  000c8	69 44 24 38 00
	5a 1c 00	 imul	 eax, DWORD PTR cb$6[rsp], 1858048 ; 001c5a00H
  000d0	8b 4c 24 24	 mov	 ecx, DWORD PTR y_fixed$1[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 30	 mov	 DWORD PTR b$4[rsp], eax

; 3669 :       r >>= 20;

  000dc	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  000e0	c1 f8 14	 sar	 eax, 20
  000e3	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 3670 :       g >>= 20;

  000e7	8b 44 24 2c	 mov	 eax, DWORD PTR g$3[rsp]
  000eb	c1 f8 14	 sar	 eax, 20
  000ee	89 44 24 2c	 mov	 DWORD PTR g$3[rsp], eax

; 3671 :       b >>= 20;

  000f2	8b 44 24 30	 mov	 eax, DWORD PTR b$4[rsp]
  000f6	c1 f8 14	 sar	 eax, 20
  000f9	89 44 24 30	 mov	 DWORD PTR b$4[rsp], eax

; 3672 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  000fd	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR r$2[rsp], 255	; 000000ffH
  00105	76 19		 jbe	 SHORT $LN5@stbi__YCbC
  00107	83 7c 24 28 00	 cmp	 DWORD PTR r$2[rsp], 0
  0010c	7d 0a		 jge	 SHORT $LN6@stbi__YCbC
  0010e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR r$2[rsp], 0
  00116	eb 08		 jmp	 SHORT $LN7@stbi__YCbC
$LN6@stbi__YCbC:
  00118	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR r$2[rsp], 255	; 000000ffH
$LN7@stbi__YCbC:
$LN5@stbi__YCbC:

; 3673 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  00120	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR g$3[rsp], 255	; 000000ffH
  00128	76 19		 jbe	 SHORT $LN8@stbi__YCbC
  0012a	83 7c 24 2c 00	 cmp	 DWORD PTR g$3[rsp], 0
  0012f	7d 0a		 jge	 SHORT $LN9@stbi__YCbC
  00131	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR g$3[rsp], 0
  00139	eb 08		 jmp	 SHORT $LN10@stbi__YCbC
$LN9@stbi__YCbC:
  0013b	c7 44 24 2c ff
	00 00 00	 mov	 DWORD PTR g$3[rsp], 255	; 000000ffH
$LN10@stbi__YCbC:
$LN8@stbi__YCbC:

; 3674 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  00143	81 7c 24 30 ff
	00 00 00	 cmp	 DWORD PTR b$4[rsp], 255	; 000000ffH
  0014b	76 19		 jbe	 SHORT $LN11@stbi__YCbC
  0014d	83 7c 24 30 00	 cmp	 DWORD PTR b$4[rsp], 0
  00152	7d 0a		 jge	 SHORT $LN12@stbi__YCbC
  00154	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR b$4[rsp], 0
  0015c	eb 08		 jmp	 SHORT $LN13@stbi__YCbC
$LN12@stbi__YCbC:
  0015e	c7 44 24 30 ff
	00 00 00	 mov	 DWORD PTR b$4[rsp], 255	; 000000ffH
$LN13@stbi__YCbC:
$LN11@stbi__YCbC:

; 3675 :       out[0] = (stbi_uc)r;

  00166	b8 01 00 00 00	 mov	 eax, 1
  0016b	48 6b c0 00	 imul	 rax, rax, 0
  0016f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00174	0f b6 54 24 28	 movzx	 edx, BYTE PTR r$2[rsp]
  00179	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3676 :       out[1] = (stbi_uc)g;

  0017c	b8 01 00 00 00	 mov	 eax, 1
  00181	48 6b c0 01	 imul	 rax, rax, 1
  00185	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  0018a	0f b6 54 24 2c	 movzx	 edx, BYTE PTR g$3[rsp]
  0018f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3677 :       out[2] = (stbi_uc)b;

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 02	 imul	 rax, rax, 2
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  001a0	0f b6 54 24 30	 movzx	 edx, BYTE PTR b$4[rsp]
  001a5	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3678 :       out[3] = 255;

  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 03	 imul	 rax, rax, 3
  001b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  001b6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3679 :       out += step;

  001ba	48 63 44 24 78	 movsxd	 rax, DWORD PTR step$[rsp]
  001bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  001c4	48 03 c8	 add	 rcx, rax
  001c7	48 8b c1	 mov	 rax, rcx
  001ca	48 89 44 24 50	 mov	 QWORD PTR out$[rsp], rax

; 3680 :    }

  001cf	e9 5c fe ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:

; 3681 : }

  001d4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001d8	5f		 pop	 rdi
  001d9	c3		 ret	 0
stbi__YCbCr_to_RGB_row ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
signflip$1 = 48
cr_const0$2 = 64
cr_const1$3 = 80
cb_const0$4 = 96
cb_const1$5 = 112
y_bias$6 = 128
xw$7 = 144
y_bytes$8 = 160
cr_bytes$9 = 176
cb_bytes$10 = 192
cr_biased$11 = 208
cb_biased$12 = 224
yw$13 = 240
crw$14 = 256
cbw$15 = 272
yws$16 = 288
cr0$17 = 304
cb0$18 = 320
cb1$19 = 336
cr1$20 = 352
rws$21 = 368
gwt$22 = 384
bws$23 = 400
gws$24 = 416
rw$25 = 432
bw$26 = 448
gw$27 = 464
brb$28 = 480
gxb$29 = 496
t0$30 = 512
t1$31 = 528
o0$32 = 544
o1$33 = 560
y_fixed$34 = 576
r$35 = 580
g$36 = 584
b$37 = 588
cr$38 = 592
cb$39 = 596
out$ = 624
y$ = 632
pcb$ = 640
pcr$ = 648
count$ = 656
step$ = 664
stbi__YCbCr_to_RGB_simd PROC

; 3685 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3686 :    int i = 0;

  00028	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 3687 : 
; 3688 : #ifdef STBI_SSE2
; 3689 :    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3690 :    // it's useful in practice (you wouldn't use it for textures, for example).
; 3691 :    // so just accelerate step == 4 case.
; 3692 :    if (step == 4) {

  00030	83 bc 24 98 02
	00 00 04	 cmp	 DWORD PTR step$[rsp], 4
  00038	0f 85 6f 03 00
	00		 jne	 $LN8@stbi__YCbC

; 3693 :       // this is a fairly straightforward implementation and not super-optimized.
; 3694 :       __m128i signflip  = _mm_set1_epi8(-0x80);

  0003e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  00046	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR signflip$1[rsp], xmm0

; 3695 :       __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

  0004c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
  00054	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR cr_const0$2[rsp], xmm0

; 3696 :       __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));

  0005a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
  00062	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR cr_const1$3[rsp], xmm0

; 3697 :       __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));

  00068	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
  00070	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR cb_const0$4[rsp], xmm0

; 3698 :       __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));

  00076	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
  0007e	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR cb_const1$5[rsp], xmm0

; 3699 :       __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);

  00084	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  0008c	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR y_bias$6[rsp], xmm0

; 3700 :       __m128i xw = _mm_set1_epi16(255); // alpha channel

  00095	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  0009d	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR xw$7[rsp], xmm0

; 3701 : 
; 3702 :       for (; i+7 < count; i += 8) {

  000a6	eb 0b		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  000a8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ac	83 c0 08	 add	 eax, 8
  000af	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b7	83 c0 07	 add	 eax, 7
  000ba	3b 84 24 90 02
	00 00		 cmp	 eax, DWORD PTR count$[rsp]
  000c1	0f 8d e6 02 00
	00		 jge	 $LN3@stbi__YCbC

; 3703 :          // load
; 3704 :          __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));

  000c7	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000cc	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  000de	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR y_bytes$8[rsp], xmm0

; 3705 :          __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

  000e7	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ec	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  000f4	48 03 c8	 add	 rcx, rax
  000f7	48 8b c1	 mov	 rax, rcx
  000fa	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  000fe	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR cr_bytes$9[rsp], xmm0

; 3706 :          __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));

  00107	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0010c	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  00114	48 03 c8	 add	 rcx, rax
  00117	48 8b c1	 mov	 rax, rcx
  0011a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  0011e	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR cb_bytes$10[rsp], xmm0

; 3707 :          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

  00127	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR cr_bytes$9[rsp]
  00130	0f 57 44 24 30	 xorps	 xmm0, XMMWORD PTR signflip$1[rsp]
  00135	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR cr_biased$11[rsp], xmm0

; 3708 :          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

  0013e	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR cb_bytes$10[rsp]
  00147	0f 57 44 24 30	 xorps	 xmm0, XMMWORD PTR signflip$1[rsp]
  0014c	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR cb_biased$12[rsp], xmm0

; 3709 : 
; 3710 :          // unpack to short (and left-shift cr, cb by 8)
; 3711 :          __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);

  00155	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR y_bias$6[rsp]
  0015e	66 0f 60 84 24
	a0 00 00 00	 punpcklbw xmm0, XMMWORD PTR y_bytes$8[rsp]
  00167	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR yw$13[rsp], xmm0

; 3712 :          __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

  00170	66 0f ef c0	 pxor	 xmm0, xmm0
  00174	66 0f 60 84 24
	d0 00 00 00	 punpcklbw xmm0, XMMWORD PTR cr_biased$11[rsp]
  0017d	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR crw$14[rsp], xmm0

; 3713 :          __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

  00186	66 0f ef c0	 pxor	 xmm0, xmm0
  0018a	66 0f 60 84 24
	e0 00 00 00	 punpcklbw xmm0, XMMWORD PTR cb_biased$12[rsp]
  00193	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR cbw$15[rsp], xmm0

; 3714 : 
; 3715 :          // color transform
; 3716 :          __m128i yws = _mm_srli_epi16(yw, 4);

  0019c	66 0f 6f 84 24
	f0 00 00 00	 movdqa	 xmm0, XMMWORD PTR yw$13[rsp]
  001a5	66 0f 71 d0 04	 psrlw	 xmm0, 4
  001aa	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR yws$16[rsp], xmm0

; 3717 :          __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

  001b3	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR cr_const0$2[rsp]
  001b9	66 0f e5 84 24
	00 01 00 00	 pmulhw	 xmm0, XMMWORD PTR crw$14[rsp]
  001c2	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR cr0$17[rsp], xmm0

; 3718 :          __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

  001cb	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR cb_const0$4[rsp]
  001d1	66 0f e5 84 24
	10 01 00 00	 pmulhw	 xmm0, XMMWORD PTR cbw$15[rsp]
  001da	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR cb0$18[rsp], xmm0

; 3719 :          __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

  001e3	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR cbw$15[rsp]
  001ec	66 0f e5 44 24
	70		 pmulhw	 xmm0, XMMWORD PTR cb_const1$5[rsp]
  001f2	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR cb1$19[rsp], xmm0

; 3720 :          __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

  001fb	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR crw$14[rsp]
  00204	66 0f e5 44 24
	50		 pmulhw	 xmm0, XMMWORD PTR cr_const1$3[rsp]
  0020a	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR cr1$20[rsp], xmm0

; 3721 :          __m128i rws = _mm_add_epi16(cr0, yws);

  00213	66 0f 6f 84 24
	30 01 00 00	 movdqa	 xmm0, XMMWORD PTR cr0$17[rsp]
  0021c	66 0f fd 84 24
	20 01 00 00	 paddw	 xmm0, XMMWORD PTR yws$16[rsp]
  00225	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR rws$21[rsp], xmm0

; 3722 :          __m128i gwt = _mm_add_epi16(cb0, yws);

  0022e	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR cb0$18[rsp]
  00237	66 0f fd 84 24
	20 01 00 00	 paddw	 xmm0, XMMWORD PTR yws$16[rsp]
  00240	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR gwt$22[rsp], xmm0

; 3723 :          __m128i bws = _mm_add_epi16(yws, cb1);

  00249	66 0f 6f 84 24
	20 01 00 00	 movdqa	 xmm0, XMMWORD PTR yws$16[rsp]
  00252	66 0f fd 84 24
	50 01 00 00	 paddw	 xmm0, XMMWORD PTR cb1$19[rsp]
  0025b	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR bws$23[rsp], xmm0

; 3724 :          __m128i gws = _mm_add_epi16(gwt, cr1);

  00264	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR gwt$22[rsp]
  0026d	66 0f fd 84 24
	60 01 00 00	 paddw	 xmm0, XMMWORD PTR cr1$20[rsp]
  00276	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR gws$24[rsp], xmm0

; 3725 : 
; 3726 :          // descale
; 3727 :          __m128i rw = _mm_srai_epi16(rws, 4);

  0027f	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR rws$21[rsp]
  00288	66 0f 71 e0 04	 psraw	 xmm0, 4
  0028d	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR rw$25[rsp], xmm0

; 3728 :          __m128i bw = _mm_srai_epi16(bws, 4);

  00296	66 0f 6f 84 24
	90 01 00 00	 movdqa	 xmm0, XMMWORD PTR bws$23[rsp]
  0029f	66 0f 71 e0 04	 psraw	 xmm0, 4
  002a4	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR bw$26[rsp], xmm0

; 3729 :          __m128i gw = _mm_srai_epi16(gws, 4);

  002ad	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR gws$24[rsp]
  002b6	66 0f 71 e0 04	 psraw	 xmm0, 4
  002bb	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR gw$27[rsp], xmm0

; 3730 : 
; 3731 :          // back to byte, set up for transpose
; 3732 :          __m128i brb = _mm_packus_epi16(rw, bw);

  002c4	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR rw$25[rsp]
  002cd	66 0f 67 84 24
	c0 01 00 00	 packuswb xmm0, XMMWORD PTR bw$26[rsp]
  002d6	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR brb$28[rsp], xmm0

; 3733 :          __m128i gxb = _mm_packus_epi16(gw, xw);

  002df	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR gw$27[rsp]
  002e8	66 0f 67 84 24
	90 00 00 00	 packuswb xmm0, XMMWORD PTR xw$7[rsp]
  002f1	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR gxb$29[rsp], xmm0

; 3734 : 
; 3735 :          // transpose to interleave channels
; 3736 :          __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

  002fa	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR brb$28[rsp]
  00303	66 0f 60 84 24
	f0 01 00 00	 punpcklbw xmm0, XMMWORD PTR gxb$29[rsp]
  0030c	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR t0$30[rsp], xmm0

; 3737 :          __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

  00315	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR brb$28[rsp]
  0031e	66 0f 68 84 24
	f0 01 00 00	 punpckhbw xmm0, XMMWORD PTR gxb$29[rsp]
  00327	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR t1$31[rsp], xmm0

; 3738 :          __m128i o0 = _mm_unpacklo_epi16(t0, t1);

  00330	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR t0$30[rsp]
  00339	66 0f 61 84 24
	10 02 00 00	 punpcklwd xmm0, XMMWORD PTR t1$31[rsp]
  00342	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR o0$32[rsp], xmm0

; 3739 :          __m128i o1 = _mm_unpackhi_epi16(t0, t1);

  0034b	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR t0$30[rsp]
  00354	66 0f 69 84 24
	10 02 00 00	 punpckhwd xmm0, XMMWORD PTR t1$31[rsp]
  0035d	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR o1$33[rsp], xmm0

; 3740 : 
; 3741 :          // store
; 3742 :          _mm_storeu_si128((__m128i *) (out + 0), o0);

  00366	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0036e	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR o0$32[rsp]
  00377	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3743 :          _mm_storeu_si128((__m128i *) (out + 16), o1);

  0037b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00383	48 83 c0 10	 add	 rax, 16
  00387	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR o1$33[rsp]
  00390	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3744 :          out += 32;

  00394	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0039c	48 83 c0 20	 add	 rax, 32			; 00000020H
  003a0	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3745 :       }

  003a8	e9 fb fc ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:
$LN8@stbi__YCbC:

; 3746 :    }
; 3747 : #endif
; 3748 : 
; 3749 : #ifdef STBI_NEON
; 3750 :    // in this version, step=3 support would be easy to add. but is there demand?
; 3751 :    if (step == 4) {
; 3752 :       // this is a fairly straightforward implementation and not super-optimized.
; 3753 :       uint8x8_t signflip = vdup_n_u8(0x80);
; 3754 :       int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3755 :       int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3756 :       int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3757 :       int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3758 : 
; 3759 :       for (; i+7 < count; i += 8) {
; 3760 :          // load
; 3761 :          uint8x8_t y_bytes  = vld1_u8(y + i);
; 3762 :          uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3763 :          uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3764 :          int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3765 :          int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3766 : 
; 3767 :          // expand to s16
; 3768 :          int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3769 :          int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3770 :          int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3771 : 
; 3772 :          // color transform
; 3773 :          int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3774 :          int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3775 :          int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3776 :          int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3777 :          int16x8_t rws = vaddq_s16(yws, cr0);
; 3778 :          int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3779 :          int16x8_t bws = vaddq_s16(yws, cb1);
; 3780 : 
; 3781 :          // undo scaling, round, convert to byte
; 3782 :          uint8x8x4_t o;
; 3783 :          o.val[0] = vqrshrun_n_s16(rws, 4);
; 3784 :          o.val[1] = vqrshrun_n_s16(gws, 4);
; 3785 :          o.val[2] = vqrshrun_n_s16(bws, 4);
; 3786 :          o.val[3] = vdup_n_u8(255);
; 3787 : 
; 3788 :          // store, interleaving r/g/b/a
; 3789 :          vst4_u8(out, o);
; 3790 :          out += 8*4;
; 3791 :       }
; 3792 :    }
; 3793 : #endif
; 3794 : 
; 3795 :    for (; i < count; ++i) {

  003ad	eb 0a		 jmp	 SHORT $LN7@stbi__YCbC
$LN5@stbi__YCbC:
  003af	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003b3	ff c0		 inc	 eax
  003b5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__YCbC:
  003b9	8b 84 24 90 02
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  003c0	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  003c4	0f 8d 10 02 00
	00		 jge	 $LN6@stbi__YCbC

; 3796 :       int y_fixed = (y[i] << 20) + (1<<19); // rounding

  003ca	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003cf	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  003d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003db	c1 e0 14	 shl	 eax, 20
  003de	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  003e3	89 84 24 40 02
	00 00		 mov	 DWORD PTR y_fixed$34[rsp], eax

; 3797 :       int r,g,b;
; 3798 :       int cr = pcr[i] - 128;

  003ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003ef	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  003f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003fb	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00400	89 84 24 50 02
	00 00		 mov	 DWORD PTR cr$38[rsp], eax

; 3799 :       int cb = pcb[i] - 128;

  00407	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0040c	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  00414	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00418	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0041d	89 84 24 54 02
	00 00		 mov	 DWORD PTR cb$39[rsp], eax

; 3800 :       r = y_fixed + cr* stbi__float2fixed(1.40200f);

  00424	69 84 24 50 02
	00 00 00 6f 16
	00		 imul	 eax, DWORD PTR cr$38[rsp], 1470208 ; 00166f00H
  0042f	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR y_fixed$34[rsp]
  00436	03 c8		 add	 ecx, eax
  00438	8b c1		 mov	 eax, ecx
  0043a	89 84 24 44 02
	00 00		 mov	 DWORD PTR r$35[rsp], eax

; 3801 :       g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  00441	69 84 24 50 02
	00 00 00 93 f4
	ff		 imul	 eax, DWORD PTR cr$38[rsp], -748800 ; fffffffffff49300H
  0044c	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR y_fixed$34[rsp]
  00453	03 c8		 add	 ecx, eax
  00455	8b c1		 mov	 eax, ecx
  00457	69 8c 24 54 02
	00 00 00 7e fa
	ff		 imul	 ecx, DWORD PTR cb$39[rsp], -360960 ; fffffffffffa7e00H
  00462	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00468	03 c1		 add	 eax, ecx
  0046a	89 84 24 48 02
	00 00		 mov	 DWORD PTR g$36[rsp], eax

; 3802 :       b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);

  00471	69 84 24 54 02
	00 00 00 5a 1c
	00		 imul	 eax, DWORD PTR cb$39[rsp], 1858048 ; 001c5a00H
  0047c	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR y_fixed$34[rsp]
  00483	03 c8		 add	 ecx, eax
  00485	8b c1		 mov	 eax, ecx
  00487	89 84 24 4c 02
	00 00		 mov	 DWORD PTR b$37[rsp], eax

; 3803 :       r >>= 20;

  0048e	8b 84 24 44 02
	00 00		 mov	 eax, DWORD PTR r$35[rsp]
  00495	c1 f8 14	 sar	 eax, 20
  00498	89 84 24 44 02
	00 00		 mov	 DWORD PTR r$35[rsp], eax

; 3804 :       g >>= 20;

  0049f	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR g$36[rsp]
  004a6	c1 f8 14	 sar	 eax, 20
  004a9	89 84 24 48 02
	00 00		 mov	 DWORD PTR g$36[rsp], eax

; 3805 :       b >>= 20;

  004b0	8b 84 24 4c 02
	00 00		 mov	 eax, DWORD PTR b$37[rsp]
  004b7	c1 f8 14	 sar	 eax, 20
  004ba	89 84 24 4c 02
	00 00		 mov	 DWORD PTR b$37[rsp], eax

; 3806 :       if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  004c1	81 bc 24 44 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR r$35[rsp], 255 ; 000000ffH
  004cc	76 22		 jbe	 SHORT $LN9@stbi__YCbC
  004ce	83 bc 24 44 02
	00 00 00	 cmp	 DWORD PTR r$35[rsp], 0
  004d6	7d 0d		 jge	 SHORT $LN10@stbi__YCbC
  004d8	c7 84 24 44 02
	00 00 00 00 00
	00		 mov	 DWORD PTR r$35[rsp], 0
  004e3	eb 0b		 jmp	 SHORT $LN11@stbi__YCbC
$LN10@stbi__YCbC:
  004e5	c7 84 24 44 02
	00 00 ff 00 00
	00		 mov	 DWORD PTR r$35[rsp], 255 ; 000000ffH
$LN11@stbi__YCbC:
$LN9@stbi__YCbC:

; 3807 :       if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  004f0	81 bc 24 48 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR g$36[rsp], 255 ; 000000ffH
  004fb	76 22		 jbe	 SHORT $LN12@stbi__YCbC
  004fd	83 bc 24 48 02
	00 00 00	 cmp	 DWORD PTR g$36[rsp], 0
  00505	7d 0d		 jge	 SHORT $LN13@stbi__YCbC
  00507	c7 84 24 48 02
	00 00 00 00 00
	00		 mov	 DWORD PTR g$36[rsp], 0
  00512	eb 0b		 jmp	 SHORT $LN14@stbi__YCbC
$LN13@stbi__YCbC:
  00514	c7 84 24 48 02
	00 00 ff 00 00
	00		 mov	 DWORD PTR g$36[rsp], 255 ; 000000ffH
$LN14@stbi__YCbC:
$LN12@stbi__YCbC:

; 3808 :       if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  0051f	81 bc 24 4c 02
	00 00 ff 00 00
	00		 cmp	 DWORD PTR b$37[rsp], 255 ; 000000ffH
  0052a	76 22		 jbe	 SHORT $LN15@stbi__YCbC
  0052c	83 bc 24 4c 02
	00 00 00	 cmp	 DWORD PTR b$37[rsp], 0
  00534	7d 0d		 jge	 SHORT $LN16@stbi__YCbC
  00536	c7 84 24 4c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR b$37[rsp], 0
  00541	eb 0b		 jmp	 SHORT $LN17@stbi__YCbC
$LN16@stbi__YCbC:
  00543	c7 84 24 4c 02
	00 00 ff 00 00
	00		 mov	 DWORD PTR b$37[rsp], 255 ; 000000ffH
$LN17@stbi__YCbC:
$LN15@stbi__YCbC:

; 3809 :       out[0] = (stbi_uc)r;

  0054e	b8 01 00 00 00	 mov	 eax, 1
  00553	48 6b c0 00	 imul	 rax, rax, 0
  00557	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0055f	0f b6 94 24 44
	02 00 00	 movzx	 edx, BYTE PTR r$35[rsp]
  00567	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3810 :       out[1] = (stbi_uc)g;

  0056a	b8 01 00 00 00	 mov	 eax, 1
  0056f	48 6b c0 01	 imul	 rax, rax, 1
  00573	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0057b	0f b6 94 24 48
	02 00 00	 movzx	 edx, BYTE PTR g$36[rsp]
  00583	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3811 :       out[2] = (stbi_uc)b;

  00586	b8 01 00 00 00	 mov	 eax, 1
  0058b	48 6b c0 02	 imul	 rax, rax, 2
  0058f	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00597	0f b6 94 24 4c
	02 00 00	 movzx	 edx, BYTE PTR b$37[rsp]
  0059f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3812 :       out[3] = 255;

  005a2	b8 01 00 00 00	 mov	 eax, 1
  005a7	48 6b c0 03	 imul	 rax, rax, 3
  005ab	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  005b3	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3813 :       out += step;

  005b7	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR step$[rsp]
  005bf	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  005c7	48 03 c8	 add	 rcx, rax
  005ca	48 8b c1	 mov	 rax, rcx
  005cd	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3814 :    }

  005d5	e9 d5 fd ff ff	 jmp	 $LN5@stbi__YCbC
$LN6@stbi__YCbC:

; 3815 : }

  005da	48 81 c4 60 02
	00 00		 add	 rsp, 608		; 00000260H
  005e1	5f		 pop	 rdi
  005e2	c3		 ret	 0
stbi__YCbCr_to_RGB_simd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
j$ = 48
stbi__setup_jpeg PROC

; 3820 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3821 :    j->idct_block_kernel = stbi__idct_block;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__idct_block
  00022	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3822 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__YCbCr_to_RGB_row
  00035	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3823 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_hv_2
  00048	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx

; 3824 : 
; 3825 : #ifdef STBI_SSE2
; 3826 :    if (stbi__sse2_available()) {

  0004f	e8 00 00 00 00	 call	 stbi__sse2_available
  00054	85 c0		 test	 eax, eax
  00056	74 39		 je	 SHORT $LN2@stbi__setu

; 3827 :       j->idct_block_kernel = stbi__idct_simd;

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__idct_simd
  00064	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3828 :       j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__YCbCr_to_RGB_simd
  00077	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3829 :       j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_hv_2_simd
  0008a	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx
$LN2@stbi__setu:

; 3830 :    }
; 3831 : #endif
; 3832 : 
; 3833 : #ifdef STBI_NEON
; 3834 :    j->idct_block_kernel = stbi__idct_simd;
; 3835 :    j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3836 :    j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3837 : #endif
; 3838 : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
stbi__setup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
j$ = 48
stbi__cleanup_jpeg PROC

; 3842 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3843 :    stbi__free_jpeg_components(j, j->s->img_n, 0);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR j$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__free_jpeg_components
  0002e	90		 npad	 1

; 3844 : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
stbi__cleanup_jpeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
t$ = 32
x$ = 64
y$ = 72
stbi__blinn_8x8 PROC

; 3858 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3859 :    unsigned int t = x*y + 128;

  00019	0f b6 44 24 40	 movzx	 eax, BYTE PTR x$[rsp]
  0001e	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR y$[rsp]
  00023	0f af c1	 imul	 eax, ecx
  00026	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0002b	89 44 24 20	 mov	 DWORD PTR t$[rsp], eax

; 3860 :    return (stbi_uc) ((t + (t >>8)) >> 8);

  0002f	8b 44 24 20	 mov	 eax, DWORD PTR t$[rsp]
  00033	c1 e8 08	 shr	 eax, 8
  00036	8b 4c 24 20	 mov	 ecx, DWORD PTR t$[rsp]
  0003a	03 c8		 add	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	c1 e8 08	 shr	 eax, 8

; 3861 : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
stbi__blinn_8x8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
n$ = 48
decode_n$ = 52
is_rgb$ = 56
k$5 = 60
i$6 = 64
j$7 = 68
output$8 = 72
coutput$9 = 88
res_comp$10 = 160
r$11 = 360
out$12 = 368
r$13 = 376
y_bot$14 = 384
y$15 = 392
m$16 = 400
m$17 = 401
m$18 = 402
r$19 = 403
g$20 = 404
b$21 = 405
y$22 = 408
tv71 = 424
tv81 = 432
tv79 = 436
tv91 = 440
tv159 = 448
tv164 = 456
tv172 = 464
tv232 = 472
tv252 = 480
tv265 = 488
tv270 = 496
tv280 = 504
tv288 = 508
tv516 = 512
tv545 = 516
tv626 = 520
tv656 = 524
tv694 = 528
__$ArrayPad$ = 536
z$ = 560
out_x$ = 568
out_y$ = 576
comp$ = 584
req_comp$ = 592
load_jpeg_image PROC

; 3864 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 02
	00 00		 sub	 rsp, 544		; 00000220H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR [rsp+560]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 3865 :    int n, decode_n, is_rgb;
; 3866 :    z->s->img_n = 0; // make stbi__cleanup_jpeg safe

  00053	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0005b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3867 : 
; 3868 :    // validate req_comp
; 3869 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  00065	83 bc 24 50 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0006d	7c 0a		 jl	 SHORT $LN42@load_jpeg_
  0006f	83 bc 24 50 02
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00077	7e 37		 jle	 SHORT $LN41@load_jpeg_
$LN42@load_jpeg_:
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KBPNPPBJ@bad?5req_comp@
  00080	e8 00 00 00 00	 call	 stbi__err
  00085	85 c0		 test	 eax, eax
  00087	74 0e		 je	 SHORT $LN83@load_jpeg_
  00089	48 c7 84 24 a8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv71[rsp], 0
  00095	eb 0c		 jmp	 SHORT $LN84@load_jpeg_
$LN83@load_jpeg_:
  00097	48 c7 84 24 a8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv71[rsp], 0
$LN84@load_jpeg_:
  000a3	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR tv71[rsp]
  000ab	e9 20 12 00 00	 jmp	 $LN1@load_jpeg_
$LN41@load_jpeg_:

; 3870 : 
; 3871 :    // load a jpeg image from whichever source, but leave in YCbCr format
; 3872 :    if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

  000b0	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000b8	e8 00 00 00 00	 call	 stbi__decode_jpeg_image
  000bd	85 c0		 test	 eax, eax
  000bf	75 14		 jne	 SHORT $LN43@load_jpeg_
  000c1	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000c9	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  000ce	33 c0		 xor	 eax, eax
  000d0	e9 fb 11 00 00	 jmp	 $LN1@load_jpeg_
$LN43@load_jpeg_:

; 3873 : 
; 3874 :    // determine actual number of components to generate
; 3875 :    n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

  000d5	83 bc 24 50 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000dd	74 10		 je	 SHORT $LN87@load_jpeg_
  000df	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000e6	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  000ed	eb 37		 jmp	 SHORT $LN88@load_jpeg_
$LN87@load_jpeg_:
  000ef	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fa	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  000fe	7c 0d		 jl	 SHORT $LN85@load_jpeg_
  00100	c7 84 24 b4 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv79[rsp], 3
  0010b	eb 0b		 jmp	 SHORT $LN86@load_jpeg_
$LN85@load_jpeg_:
  0010d	c7 84 24 b4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv79[rsp], 1
$LN86@load_jpeg_:
  00118	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  0011f	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv81[rsp], eax
$LN88@load_jpeg_:
  00126	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  0012d	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 3876 : 
; 3877 :    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

  00131	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00139	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013c	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00140	75 40		 jne	 SHORT $LN91@load_jpeg_
  00142	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0014a	83 b8 50 48 00
	00 03		 cmp	 DWORD PTR [rax+18512], 3
  00151	74 22		 je	 SHORT $LN90@load_jpeg_
  00153	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0015b	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00162	75 1e		 jne	 SHORT $LN89@load_jpeg_
  00164	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0016c	83 b8 48 48 00
	00 00		 cmp	 DWORD PTR [rax+18504], 0
  00173	75 0d		 jne	 SHORT $LN91@load_jpeg_
$LN90@load_jpeg_:
  00175	c7 84 24 b8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv91[rsp], 1
  00180	eb 0b		 jmp	 SHORT $LN92@load_jpeg_
$LN91@load_jpeg_:
$LN89@load_jpeg_:
  00182	c7 84 24 b8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN92@load_jpeg_:
  0018d	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR tv91[rsp]
  00194	89 44 24 38	 mov	 DWORD PTR is_rgb$[rsp], eax

; 3878 : 
; 3879 :    if (z->s->img_n == 3 && n < 3 && !is_rgb)

  00198	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a3	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  001a7	75 18		 jne	 SHORT $LN44@load_jpeg_
  001a9	83 7c 24 30 03	 cmp	 DWORD PTR n$[rsp], 3
  001ae	7d 11		 jge	 SHORT $LN44@load_jpeg_
  001b0	83 7c 24 38 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  001b5	75 0a		 jne	 SHORT $LN44@load_jpeg_

; 3880 :       decode_n = 1;

  001b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR decode_n$[rsp], 1
  001bf	eb 12		 jmp	 SHORT $LN45@load_jpeg_
$LN44@load_jpeg_:

; 3881 :    else
; 3882 :       decode_n = z->s->img_n;

  001c1	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001cf	89 44 24 34	 mov	 DWORD PTR decode_n$[rsp], eax
$LN45@load_jpeg_:

; 3883 : 
; 3884 :    // nothing to do if no components requested; check this now to avoid
; 3885 :    // accessing uninitialized coutput[0] later
; 3886 :    if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

  001d3	83 7c 24 34 00	 cmp	 DWORD PTR decode_n$[rsp], 0
  001d8	7f 14		 jg	 SHORT $LN46@load_jpeg_
  001da	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001e2	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  001e7	33 c0		 xor	 eax, eax
  001e9	e9 e2 10 00 00	 jmp	 $LN1@load_jpeg_
$LN46@load_jpeg_:

; 3887 : 
; 3888 :    // resample and color-convert
; 3889 :    {
; 3890 :       int k;
; 3891 :       unsigned int i,j;
; 3892 :       stbi_uc *output;
; 3893 :       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

  001ee	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR coutput$9[rsp], 0
  001f7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR coutput$9[rsp+8], 0
  00200	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR coutput$9[rsp+16], 0
  00209	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR coutput$9[rsp+24], 0

; 3894 : 
; 3895 :       stbi__resample res_comp[4];
; 3896 : 
; 3897 :       for (k=0; k < decode_n; ++k) {

  00212	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR k$5[rsp], 0
  0021a	eb 0a		 jmp	 SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
  0021c	8b 44 24 3c	 mov	 eax, DWORD PTR k$5[rsp]
  00220	ff c0		 inc	 eax
  00222	89 44 24 3c	 mov	 DWORD PTR k$5[rsp], eax
$LN4@load_jpeg_:
  00226	8b 44 24 34	 mov	 eax, DWORD PTR decode_n$[rsp]
  0022a	39 44 24 3c	 cmp	 DWORD PTR k$5[rsp], eax
  0022e	0f 8d ab 02 00
	00		 jge	 $LN3@load_jpeg_

; 3898 :          stbi__resample *r = &res_comp[k];

  00234	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  00239	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0023d	48 8d 84 04 a0
	00 00 00	 lea	 rax, QWORD PTR res_comp$10[rsp+rax]
  00245	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR r$11[rsp], rax

; 3899 : 
; 3900 :          // allocate line buffer big enough for upsampling off the edges
; 3901 :          // with upsample factor of 4
; 3902 :          z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

  0024d	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00255	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00258	8b 00		 mov	 eax, DWORD PTR [rax]
  0025a	83 c0 03	 add	 eax, 3
  0025d	8b c0		 mov	 eax, eax
  0025f	8b c8		 mov	 ecx, eax
  00261	e8 00 00 00 00	 call	 stbi__malloc
  00266	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR k$5[rsp]
  0026b	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0026f	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00277	48 89 84 0a e8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18152], rax

; 3903 :          if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  0027f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  00284	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00288	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00290	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  00299	75 44		 jne	 SHORT $LN47@load_jpeg_
  0029b	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002a3	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  002af	e8 00 00 00 00	 call	 stbi__err
  002b4	85 c0		 test	 eax, eax
  002b6	74 0e		 je	 SHORT $LN93@load_jpeg_
  002b8	48 c7 84 24 c0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv159[rsp], 0
  002c4	eb 0c		 jmp	 SHORT $LN94@load_jpeg_
$LN93@load_jpeg_:
  002c6	48 c7 84 24 c0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv159[rsp], 0
$LN94@load_jpeg_:
  002d2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR tv159[rsp]
  002da	e9 f1 0f 00 00	 jmp	 $LN1@load_jpeg_
$LN47@load_jpeg_:

; 3904 : 
; 3905 :          r->hs      = z->img_h_max / z->img_comp[k].h;

  002df	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  002e4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002e8	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv164[rsp], rax
  002f0	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002f8	8b 81 88 46 00
	00		 mov	 eax, DWORD PTR [rcx+18056]
  002fe	99		 cdq
  002ff	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00307	4c 8b 84 24 c8
	01 00 00	 mov	 r8, QWORD PTR tv164[rsp]
  0030f	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  00317	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  0031f	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 3906 :          r->vs      = z->img_v_max / z->img_comp[k].v;

  00322	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  00327	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0032b	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00333	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0033b	8b 81 8c 46 00
	00		 mov	 eax, DWORD PTR [rcx+18060]
  00341	99		 cdq
  00342	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0034a	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR tv172[rsp]
  00352	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  0035a	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  00362	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 3907 :          r->ystep   = r->vs >> 1;

  00365	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  0036d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00370	d1 f8		 sar	 eax, 1
  00372	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  0037a	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 3908 :          r->w_lores = (z->s->img_x + r->hs-1) / r->hs;

  0037d	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00385	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00388	8b 00		 mov	 eax, DWORD PTR [rax]
  0038a	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  00392	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00395	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00399	33 d2		 xor	 edx, edx
  0039b	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  003a3	f7 71 18	 div	 DWORD PTR [rcx+24]
  003a6	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  003ae	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3909 :          r->ypos    = 0;

  003b1	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  003b9	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 3910 :          r->line0   = r->line1 = z->img_comp[k].data;

  003c0	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  003c5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003c9	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  003d1	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  003d9	48 8b 84 02 d0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18128]
  003e1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  003e5	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  003ed	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR r$11[rsp]
  003f5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3911 : 
; 3912 :          if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

  003fd	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00405	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00409	75 25		 jne	 SHORT $LN48@load_jpeg_
  0040b	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00413	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  00417	75 17		 jne	 SHORT $LN48@load_jpeg_
  00419	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00421	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:resample_row_1
  00428	48 89 08	 mov	 QWORD PTR [rax], rcx
  0042b	e9 aa 00 00 00	 jmp	 $LN49@load_jpeg_
$LN48@load_jpeg_:

; 3913 :          else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

  00430	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00438	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0043c	75 22		 jne	 SHORT $LN50@load_jpeg_
  0043e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00446	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  0044a	75 14		 jne	 SHORT $LN50@load_jpeg_
  0044c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00454	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_v_2
  0045b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0045e	eb 7a		 jmp	 SHORT $LN51@load_jpeg_
$LN50@load_jpeg_:

; 3914 :          else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

  00460	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00468	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0046c	75 22		 jne	 SHORT $LN52@load_jpeg_
  0046e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00476	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  0047a	75 14		 jne	 SHORT $LN52@load_jpeg_
  0047c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_h_2
  0048b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0048e	eb 4a		 jmp	 SHORT $LN53@load_jpeg_
$LN52@load_jpeg_:

; 3915 :          else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

  00490	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  00498	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0049c	75 2a		 jne	 SHORT $LN54@load_jpeg_
  0049e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  004a6	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  004aa	75 1c		 jne	 SHORT $LN54@load_jpeg_
  004ac	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  004b4	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004bc	48 8b 89 80 48
	00 00		 mov	 rcx, QWORD PTR [rcx+18560]
  004c3	48 89 08	 mov	 QWORD PTR [rax], rcx
  004c6	eb 12		 jmp	 SHORT $LN55@load_jpeg_
$LN54@load_jpeg_:

; 3916 :          else                               r->resample = stbi__resample_row_generic;

  004c8	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR r$11[rsp]
  004d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__resample_row_generic
  004d7	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN55@load_jpeg_:
$LN53@load_jpeg_:
$LN51@load_jpeg_:
$LN49@load_jpeg_:

; 3917 :       }

  004da	e9 3d fd ff ff	 jmp	 $LN2@load_jpeg_
$LN3@load_jpeg_:

; 3918 : 
; 3919 :       // can't error after this so, this is safe
; 3920 :       output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

  004df	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ea	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	41 b9 01 00 00
	00		 mov	 r9d, 1
  004fb	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  004ff	8b 11		 mov	 edx, DWORD PTR [rcx]
  00501	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00505	e8 00 00 00 00	 call	 stbi__malloc_mad3
  0050a	48 89 44 24 48	 mov	 QWORD PTR output$8[rsp], rax

; 3921 :       if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  0050f	48 83 7c 24 48
	00		 cmp	 QWORD PTR output$8[rsp], 0
  00515	75 44		 jne	 SHORT $LN56@load_jpeg_
  00517	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0051f	e8 00 00 00 00	 call	 stbi__cleanup_jpeg
  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0052b	e8 00 00 00 00	 call	 stbi__err
  00530	85 c0		 test	 eax, eax
  00532	74 0e		 je	 SHORT $LN95@load_jpeg_
  00534	48 c7 84 24 d8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv232[rsp], 0
  00540	eb 0c		 jmp	 SHORT $LN96@load_jpeg_
$LN95@load_jpeg_:
  00542	48 c7 84 24 d8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv232[rsp], 0
$LN96@load_jpeg_:
  0054e	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR tv232[rsp]
  00556	e9 75 0d 00 00	 jmp	 $LN1@load_jpeg_
$LN56@load_jpeg_:

; 3922 : 
; 3923 :       // now go ahead and resample
; 3924 :       for (j=0; j < z->s->img_y; ++j) {

  0055b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$7[rsp], 0
  00563	eb 0a		 jmp	 SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
  00565	8b 44 24 44	 mov	 eax, DWORD PTR j$7[rsp]
  00569	ff c0		 inc	 eax
  0056b	89 44 24 44	 mov	 DWORD PTR j$7[rsp], eax
$LN7@load_jpeg_:
  0056f	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00577	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0057a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0057d	39 44 24 44	 cmp	 DWORD PTR j$7[rsp], eax
  00581	0f 83 c3 0c 00
	00		 jae	 $LN6@load_jpeg_

; 3925 :          stbi_uc *out = output + n * z->s->img_x * j;

  00587	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0058f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00592	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00596	0f af 08	 imul	 ecx, DWORD PTR [rax]
  00599	8b c1		 mov	 eax, ecx
  0059b	0f af 44 24 44	 imul	 eax, DWORD PTR j$7[rsp]
  005a0	8b c0		 mov	 eax, eax
  005a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR output$8[rsp]
  005a7	48 03 c8	 add	 rcx, rax
  005aa	48 8b c1	 mov	 rax, rcx
  005ad	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 3926 :          for (k=0; k < decode_n; ++k) {

  005b5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR k$5[rsp], 0
  005bd	eb 0a		 jmp	 SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
  005bf	8b 44 24 3c	 mov	 eax, DWORD PTR k$5[rsp]
  005c3	ff c0		 inc	 eax
  005c5	89 44 24 3c	 mov	 DWORD PTR k$5[rsp], eax
$LN10@load_jpeg_:
  005c9	8b 44 24 34	 mov	 eax, DWORD PTR decode_n$[rsp]
  005cd	39 44 24 3c	 cmp	 DWORD PTR k$5[rsp], eax
  005d1	0f 8d fb 01 00
	00		 jge	 $LN9@load_jpeg_

; 3927 :             stbi__resample *r = &res_comp[k];

  005d7	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  005dc	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  005e0	48 8d 84 04 a0
	00 00 00	 lea	 rax, QWORD PTR res_comp$10[rsp+rax]
  005e8	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR r$13[rsp], rax

; 3928 :             int y_bot = r->ystep >= (r->vs >> 1);

  005f0	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  005f8	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  005fb	d1 f8		 sar	 eax, 1
  005fd	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  00605	39 41 24	 cmp	 DWORD PTR [rcx+36], eax
  00608	7c 0d		 jl	 SHORT $LN97@load_jpeg_
  0060a	c7 84 24 e0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv252[rsp], 1
  00615	eb 0b		 jmp	 SHORT $LN98@load_jpeg_
$LN97@load_jpeg_:
  00617	c7 84 24 e0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN98@load_jpeg_:
  00622	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR tv252[rsp]
  00629	89 84 24 80 01
	00 00		 mov	 DWORD PTR y_bot$14[rsp], eax

; 3929 :             coutput[k] = r->resample(z->img_comp[k].linebuf,

  00630	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR y_bot$14[rsp], 0
  00638	74 16		 je	 SHORT $LN99@load_jpeg_
  0063a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00642	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00646	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv265[rsp], rax
  0064e	eb 14		 jmp	 SHORT $LN100@load_jpeg_
$LN99@load_jpeg_:
  00650	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00658	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0065c	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv265[rsp], rax
$LN100@load_jpeg_:
  00664	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR y_bot$14[rsp], 0
  0066c	74 16		 je	 SHORT $LN101@load_jpeg_
  0066e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00676	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0067a	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR tv270[rsp], rax
  00682	eb 14		 jmp	 SHORT $LN102@load_jpeg_
$LN101@load_jpeg_:
  00684	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  0068c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00690	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR tv270[rsp], rax
$LN102@load_jpeg_:
  00698	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  0069d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006a1	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  006a9	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  006ac	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  006b0	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  006b8	44 8b 49 20	 mov	 r9d, DWORD PTR [rcx+32]
  006bc	4c 8b 84 24 e8
	01 00 00	 mov	 r8, QWORD PTR tv265[rsp]
  006c4	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR tv270[rsp]
  006cc	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006d4	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  006dc	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  006e4	ff 10		 call	 QWORD PTR [rax]
  006e6	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR k$5[rsp]
  006eb	48 89 44 cc 58	 mov	 QWORD PTR coutput$9[rsp+rcx*8], rax

; 3930 :                                      y_bot ? r->line1 : r->line0,
; 3931 :                                      y_bot ? r->line0 : r->line1,
; 3932 :                                      r->w_lores, r->hs);
; 3933 :             if (++r->ystep >= r->vs) {

  006f0	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  006f8	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  006fb	ff c0		 inc	 eax
  006fd	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv280[rsp], eax
  00704	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  0070c	8b 8c 24 f8 01
	00 00		 mov	 ecx, DWORD PTR tv280[rsp]
  00713	89 48 24	 mov	 DWORD PTR [rax+36], ecx
  00716	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  0071e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00721	39 84 24 f8 01
	00 00		 cmp	 DWORD PTR tv280[rsp], eax
  00728	0f 8c 9f 00 00
	00		 jl	 $LN57@load_jpeg_

; 3934 :                r->ystep = 0;

  0072e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00736	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 3935 :                r->line0 = r->line1;

  0073d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00745	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  0074d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00751	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3936 :                if (++r->ypos < z->img_comp[k].y)

  00755	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  0075d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00760	ff c0		 inc	 eax
  00762	89 84 24 fc 01
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00769	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR r$13[rsp]
  00771	8b 8c 24 fc 01
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  00778	89 48 28	 mov	 DWORD PTR [rax+40], ecx
  0077b	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  00780	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00784	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0078c	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00793	39 84 24 fc 01
	00 00		 cmp	 DWORD PTR tv288[rsp], eax
  0079a	7d 31		 jge	 SHORT $LN58@load_jpeg_

; 3937 :                   r->line1 += z->img_comp[k].w2;

  0079c	48 63 44 24 3c	 movsxd	 rax, DWORD PTR k$5[rsp]
  007a1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007a5	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007ad	48 63 84 01 c4
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18116]
  007b5	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  007bd	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  007c1	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR r$13[rsp]
  007c9	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN58@load_jpeg_:
$LN57@load_jpeg_:

; 3938 :             }
; 3939 :          }

  007cd	e9 ed fd ff ff	 jmp	 $LN8@load_jpeg_
$LN9@load_jpeg_:

; 3940 :          if (n >= 3) {

  007d2	83 7c 24 30 03	 cmp	 DWORD PTR n$[rsp], 3
  007d7	0f 8c 93 05 00
	00		 jl	 $LN59@load_jpeg_

; 3941 :             stbi_uc *y = coutput[0];

  007dd	b8 08 00 00 00	 mov	 eax, 8
  007e2	48 6b c0 00	 imul	 rax, rax, 0
  007e6	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  007eb	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR y$15[rsp], rax

; 3942 :             if (z->s->img_n == 3) {

  007f3	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  007fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007fe	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00802	0f 85 43 01 00
	00		 jne	 $LN61@load_jpeg_

; 3943 :                if (is_rgb) {

  00808	83 7c 24 38 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  0080d	0f 84 dd 00 00
	00		 je	 $LN63@load_jpeg_

; 3944 :                   for (i=0; i < z->s->img_x; ++i) {

  00813	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  0081b	eb 0a		 jmp	 SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
  0081d	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00821	ff c0		 inc	 eax
  00823	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN13@load_jpeg_:
  00827	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0082f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00832	8b 00		 mov	 eax, DWORD PTR [rax]
  00834	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00838	0f 83 b0 00 00
	00		 jae	 $LN12@load_jpeg_

; 3945 :                      out[0] = y[i];

  0083e	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00842	b9 01 00 00 00	 mov	 ecx, 1
  00847	48 6b c9 00	 imul	 rcx, rcx, 0
  0084b	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00853	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR y$15[rsp]
  0085b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00860	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3946 :                      out[1] = coutput[1][i];

  00863	b8 08 00 00 00	 mov	 eax, 8
  00868	48 6b c0 01	 imul	 rax, rax, 1
  0086c	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00870	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00875	ba 01 00 00 00	 mov	 edx, 1
  0087a	48 6b d2 01	 imul	 rdx, rdx, 1
  0087e	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR out$12[rsp]
  00886	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0088a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3947 :                      out[2] = coutput[2][i];

  0088e	b8 08 00 00 00	 mov	 eax, 8
  00893	48 6b c0 02	 imul	 rax, rax, 2
  00897	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  0089b	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  008a0	ba 01 00 00 00	 mov	 edx, 1
  008a5	48 6b d2 02	 imul	 rdx, rdx, 2
  008a9	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR out$12[rsp]
  008b1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  008b5	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3948 :                      out[3] = 255;

  008b9	b8 01 00 00 00	 mov	 eax, 1
  008be	48 6b c0 03	 imul	 rax, rax, 3
  008c2	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  008ca	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3949 :                      out += n;

  008ce	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  008d3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  008db	48 03 c8	 add	 rcx, rax
  008de	48 8b c1	 mov	 rax, rcx
  008e1	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 3950 :                   }

  008e9	e9 2f ff ff ff	 jmp	 $LN11@load_jpeg_
$LN12@load_jpeg_:

; 3951 :                } else {

  008ee	eb 56		 jmp	 SHORT $LN64@load_jpeg_
$LN63@load_jpeg_:

; 3952 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  008f0	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008fb	b9 08 00 00 00	 mov	 ecx, 8
  00900	48 6b c9 02	 imul	 rcx, rcx, 2
  00904	ba 08 00 00 00	 mov	 edx, 8
  00909	48 6b d2 01	 imul	 rdx, rdx, 1
  0090d	44 8b 44 24 30	 mov	 r8d, DWORD PTR n$[rsp]
  00912	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00917	8b 00		 mov	 eax, DWORD PTR [rax]
  00919	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0091d	4c 8b 4c 0c 58	 mov	 r9, QWORD PTR coutput$9[rsp+rcx]
  00922	4c 8b 44 14 58	 mov	 r8, QWORD PTR coutput$9[rsp+rdx]
  00927	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR y$15[rsp]
  0092f	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00937	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0093f	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
  00945	90		 npad	 1
$LN64@load_jpeg_:

; 3953 :                }

  00946	e9 20 04 00 00	 jmp	 $LN62@load_jpeg_
$LN61@load_jpeg_:

; 3954 :             } else if (z->s->img_n == 4) {

  0094b	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00953	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00956	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  0095a	0f 85 32 03 00
	00		 jne	 $LN65@load_jpeg_

; 3955 :                if (z->app14_color_transform == 0) { // CMYK

  00960	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00968	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  0096f	0f 85 27 01 00
	00		 jne	 $LN67@load_jpeg_

; 3956 :                   for (i=0; i < z->s->img_x; ++i) {

  00975	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  0097d	eb 0a		 jmp	 SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
  0097f	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00983	ff c0		 inc	 eax
  00985	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN16@load_jpeg_:
  00989	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00991	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00994	8b 00		 mov	 eax, DWORD PTR [rax]
  00996	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  0099a	0f 83 f7 00 00
	00		 jae	 $LN15@load_jpeg_

; 3957 :                      stbi_uc m = coutput[3][i];

  009a0	b8 08 00 00 00	 mov	 eax, 8
  009a5	48 6b c0 03	 imul	 rax, rax, 3
  009a9	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  009ad	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  009b2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  009b6	88 84 24 90 01
	00 00		 mov	 BYTE PTR m$16[rsp], al

; 3958 :                      out[0] = stbi__blinn_8x8(coutput[0][i], m);

  009bd	b8 08 00 00 00	 mov	 eax, 8
  009c2	48 6b c0 00	 imul	 rax, rax, 0
  009c6	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  009ca	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  009cf	0f b6 94 24 90
	01 00 00	 movzx	 edx, BYTE PTR m$16[rsp]
  009d7	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  009db	e8 00 00 00 00	 call	 stbi__blinn_8x8
  009e0	b9 01 00 00 00	 mov	 ecx, 1
  009e5	48 6b c9 00	 imul	 rcx, rcx, 0
  009e9	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  009f1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3959 :                      out[1] = stbi__blinn_8x8(coutput[1][i], m);

  009f4	b8 08 00 00 00	 mov	 eax, 8
  009f9	48 6b c0 01	 imul	 rax, rax, 1
  009fd	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00a01	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00a06	0f b6 94 24 90
	01 00 00	 movzx	 edx, BYTE PTR m$16[rsp]
  00a0e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00a12	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00a17	b9 01 00 00 00	 mov	 ecx, 1
  00a1c	48 6b c9 01	 imul	 rcx, rcx, 1
  00a20	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00a28	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3960 :                      out[2] = stbi__blinn_8x8(coutput[2][i], m);

  00a2b	b8 08 00 00 00	 mov	 eax, 8
  00a30	48 6b c0 02	 imul	 rax, rax, 2
  00a34	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00a38	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00a3d	0f b6 94 24 90
	01 00 00	 movzx	 edx, BYTE PTR m$16[rsp]
  00a45	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00a49	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00a4e	b9 01 00 00 00	 mov	 ecx, 1
  00a53	48 6b c9 02	 imul	 rcx, rcx, 2
  00a57	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00a5f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3961 :                      out[3] = 255;

  00a62	b8 01 00 00 00	 mov	 eax, 1
  00a67	48 6b c0 03	 imul	 rax, rax, 3
  00a6b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00a73	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3962 :                      out += n;

  00a77	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  00a7c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00a84	48 03 c8	 add	 rcx, rax
  00a87	48 8b c1	 mov	 rax, rcx
  00a8a	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 3963 :                   }

  00a92	e9 e8 fe ff ff	 jmp	 $LN14@load_jpeg_
$LN15@load_jpeg_:

; 3964 :                } else if (z->app14_color_transform == 2) { // YCCK

  00a97	e9 f1 01 00 00	 jmp	 $LN68@load_jpeg_
$LN67@load_jpeg_:
  00a9c	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00aa4	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  00aab	0f 85 86 01 00
	00		 jne	 $LN69@load_jpeg_

; 3965 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00ab1	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00ab9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00abc	b9 08 00 00 00	 mov	 ecx, 8
  00ac1	48 6b c9 02	 imul	 rcx, rcx, 2
  00ac5	ba 08 00 00 00	 mov	 edx, 8
  00aca	48 6b d2 01	 imul	 rdx, rdx, 1
  00ace	44 8b 44 24 30	 mov	 r8d, DWORD PTR n$[rsp]
  00ad3	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00ad8	8b 00		 mov	 eax, DWORD PTR [rax]
  00ada	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00ade	4c 8b 4c 0c 58	 mov	 r9, QWORD PTR coutput$9[rsp+rcx]
  00ae3	4c 8b 44 14 58	 mov	 r8, QWORD PTR coutput$9[rsp+rdx]
  00ae8	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR y$15[rsp]
  00af0	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00af8	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b00	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
  00b06	90		 npad	 1

; 3966 :                   for (i=0; i < z->s->img_x; ++i) {

  00b07	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00b0f	eb 0a		 jmp	 SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
  00b11	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00b15	ff c0		 inc	 eax
  00b17	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN19@load_jpeg_:
  00b1b	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b23	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b26	8b 00		 mov	 eax, DWORD PTR [rax]
  00b28	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00b2c	0f 83 03 01 00
	00		 jae	 $LN18@load_jpeg_

; 3967 :                      stbi_uc m = coutput[3][i];

  00b32	b8 08 00 00 00	 mov	 eax, 8
  00b37	48 6b c0 03	 imul	 rax, rax, 3
  00b3b	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00b3f	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00b44	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00b48	88 84 24 91 01
	00 00		 mov	 BYTE PTR m$17[rsp], al

; 3968 :                      out[0] = stbi__blinn_8x8(255 - out[0], m);

  00b4f	b8 01 00 00 00	 mov	 eax, 1
  00b54	48 6b c0 00	 imul	 rax, rax, 0
  00b58	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00b60	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b64	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00b69	2b c8		 sub	 ecx, eax
  00b6b	8b c1		 mov	 eax, ecx
  00b6d	0f b6 94 24 91
	01 00 00	 movzx	 edx, BYTE PTR m$17[rsp]
  00b75	0f b6 c8	 movzx	 ecx, al
  00b78	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00b7d	b9 01 00 00 00	 mov	 ecx, 1
  00b82	48 6b c9 00	 imul	 rcx, rcx, 0
  00b86	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00b8e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3969 :                      out[1] = stbi__blinn_8x8(255 - out[1], m);

  00b91	b8 01 00 00 00	 mov	 eax, 1
  00b96	48 6b c0 01	 imul	 rax, rax, 1
  00b9a	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00ba2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ba6	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00bab	2b c8		 sub	 ecx, eax
  00bad	8b c1		 mov	 eax, ecx
  00baf	0f b6 94 24 91
	01 00 00	 movzx	 edx, BYTE PTR m$17[rsp]
  00bb7	0f b6 c8	 movzx	 ecx, al
  00bba	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00bbf	b9 01 00 00 00	 mov	 ecx, 1
  00bc4	48 6b c9 01	 imul	 rcx, rcx, 1
  00bc8	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00bd0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3970 :                      out[2] = stbi__blinn_8x8(255 - out[2], m);

  00bd3	b8 01 00 00 00	 mov	 eax, 1
  00bd8	48 6b c0 02	 imul	 rax, rax, 2
  00bdc	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00be4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00be8	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00bed	2b c8		 sub	 ecx, eax
  00bef	8b c1		 mov	 eax, ecx
  00bf1	0f b6 94 24 91
	01 00 00	 movzx	 edx, BYTE PTR m$17[rsp]
  00bf9	0f b6 c8	 movzx	 ecx, al
  00bfc	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00c01	b9 01 00 00 00	 mov	 ecx, 1
  00c06	48 6b c9 02	 imul	 rcx, rcx, 2
  00c0a	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00c12	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3971 :                      out += n;

  00c15	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  00c1a	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00c22	48 03 c8	 add	 rcx, rax
  00c25	48 8b c1	 mov	 rax, rcx
  00c28	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 3972 :                   }

  00c30	e9 dc fe ff ff	 jmp	 $LN17@load_jpeg_
$LN18@load_jpeg_:

; 3973 :                } else { // YCbCr + alpha?  Ignore the fourth channel for now

  00c35	eb 56		 jmp	 SHORT $LN70@load_jpeg_
$LN69@load_jpeg_:

; 3974 :                   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00c37	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c3f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c42	b9 08 00 00 00	 mov	 ecx, 8
  00c47	48 6b c9 02	 imul	 rcx, rcx, 2
  00c4b	ba 08 00 00 00	 mov	 edx, 8
  00c50	48 6b d2 01	 imul	 rdx, rdx, 1
  00c54	44 8b 44 24 30	 mov	 r8d, DWORD PTR n$[rsp]
  00c59	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00c5e	8b 00		 mov	 eax, DWORD PTR [rax]
  00c60	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c64	4c 8b 4c 0c 58	 mov	 r9, QWORD PTR coutput$9[rsp+rcx]
  00c69	4c 8b 44 14 58	 mov	 r8, QWORD PTR coutput$9[rsp+rdx]
  00c6e	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR y$15[rsp]
  00c76	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00c7e	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c86	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
  00c8c	90		 npad	 1
$LN70@load_jpeg_:
$LN68@load_jpeg_:

; 3975 :                }
; 3976 :             } else

  00c8d	e9 d9 00 00 00	 jmp	 $LN66@load_jpeg_
$LN65@load_jpeg_:

; 3977 :                for (i=0; i < z->s->img_x; ++i) {

  00c92	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00c9a	eb 0a		 jmp	 SHORT $LN22@load_jpeg_
$LN20@load_jpeg_:
  00c9c	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00ca0	ff c0		 inc	 eax
  00ca2	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN22@load_jpeg_:
  00ca6	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00cae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cb1	8b 00		 mov	 eax, DWORD PTR [rax]
  00cb3	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00cb7	0f 83 ae 00 00
	00		 jae	 $LN21@load_jpeg_

; 3978 :                   out[0] = out[1] = out[2] = y[i];

  00cbd	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00cc1	b9 01 00 00 00	 mov	 ecx, 1
  00cc6	48 6b c9 02	 imul	 rcx, rcx, 2
  00cca	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00cd2	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR y$15[rsp]
  00cda	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00cdf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ce2	b8 01 00 00 00	 mov	 eax, 1
  00ce7	48 6b c0 02	 imul	 rax, rax, 2
  00ceb	b9 01 00 00 00	 mov	 ecx, 1
  00cf0	48 6b c9 01	 imul	 rcx, rcx, 1
  00cf4	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00cfc	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR out$12[rsp]
  00d04	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00d09	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00d0c	b8 01 00 00 00	 mov	 eax, 1
  00d11	48 6b c0 01	 imul	 rax, rax, 1
  00d15	b9 01 00 00 00	 mov	 ecx, 1
  00d1a	48 6b c9 00	 imul	 rcx, rcx, 0
  00d1e	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00d26	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR out$12[rsp]
  00d2e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00d33	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3979 :                   out[3] = 255; // not used if n==3

  00d36	b8 01 00 00 00	 mov	 eax, 1
  00d3b	48 6b c0 03	 imul	 rax, rax, 3
  00d3f	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00d47	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3980 :                   out += n;

  00d4b	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  00d50	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00d58	48 03 c8	 add	 rcx, rax
  00d5b	48 8b c1	 mov	 rax, rcx
  00d5e	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 3981 :                }

  00d66	e9 31 ff ff ff	 jmp	 $LN20@load_jpeg_
$LN21@load_jpeg_:
$LN66@load_jpeg_:
$LN62@load_jpeg_:

; 3982 :          } else {

  00d6b	e9 d5 04 00 00	 jmp	 $LN60@load_jpeg_
$LN59@load_jpeg_:

; 3983 :             if (is_rgb) {

  00d70	83 7c 24 38 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  00d75	0f 84 8b 01 00
	00		 je	 $LN71@load_jpeg_

; 3984 :                if (n == 1)

  00d7b	83 7c 24 30 01	 cmp	 DWORD PTR n$[rsp], 1
  00d80	0f 85 b0 00 00
	00		 jne	 $LN73@load_jpeg_

; 3985 :                   for (i=0; i < z->s->img_x; ++i)

  00d86	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00d8e	eb 0a		 jmp	 SHORT $LN25@load_jpeg_
$LN23@load_jpeg_:
  00d90	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00d94	ff c0		 inc	 eax
  00d96	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN25@load_jpeg_:
  00d9a	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00da2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00da5	8b 00		 mov	 eax, DWORD PTR [rax]
  00da7	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00dab	0f 83 80 00 00
	00		 jae	 $LN24@load_jpeg_

; 3986 :                      *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00db1	b8 08 00 00 00	 mov	 eax, 8
  00db6	48 6b c0 02	 imul	 rax, rax, 2
  00dba	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00dbe	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00dc3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00dc7	b9 08 00 00 00	 mov	 ecx, 8
  00dcc	48 6b c9 01	 imul	 rcx, rcx, 1
  00dd0	8b 54 24 40	 mov	 edx, DWORD PTR i$6[rsp]
  00dd4	48 8b 4c 0c 58	 mov	 rcx, QWORD PTR coutput$9[rsp+rcx]
  00dd9	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00ddd	ba 08 00 00 00	 mov	 edx, 8
  00de2	48 6b d2 00	 imul	 rdx, rdx, 0
  00de6	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$6[rsp]
  00deb	48 8b 54 14 58	 mov	 rdx, QWORD PTR coutput$9[rsp+rdx]
  00df0	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00df5	89 94 24 00 02
	00 00		 mov	 DWORD PTR tv516[rsp], edx
  00dfc	44 8b c0	 mov	 r8d, eax
  00dff	8b d1		 mov	 edx, ecx
  00e01	8b 84 24 00 02
	00 00		 mov	 eax, DWORD PTR tv516[rsp]
  00e08	8b c8		 mov	 ecx, eax
  00e0a	e8 00 00 00 00	 call	 stbi__compute_y
  00e0f	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00e17	88 01		 mov	 BYTE PTR [rcx], al
  00e19	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out$12[rsp]
  00e21	48 ff c0	 inc	 rax
  00e24	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax
  00e2c	e9 5f ff ff ff	 jmp	 $LN23@load_jpeg_
$LN24@load_jpeg_:
  00e31	e9 cb 00 00 00	 jmp	 $LN74@load_jpeg_
$LN73@load_jpeg_:

; 3987 :                else {
; 3988 :                   for (i=0; i < z->s->img_x; ++i, out += 2) {

  00e36	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00e3e	eb 1e		 jmp	 SHORT $LN28@load_jpeg_
$LN26@load_jpeg_:
  00e40	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00e44	ff c0		 inc	 eax
  00e46	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
  00e4a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out$12[rsp]
  00e52	48 83 c0 02	 add	 rax, 2
  00e56	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax
$LN28@load_jpeg_:
  00e5e	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e66	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e69	8b 00		 mov	 eax, DWORD PTR [rax]
  00e6b	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00e6f	0f 83 8c 00 00
	00		 jae	 $LN27@load_jpeg_

; 3989 :                      out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00e75	b8 08 00 00 00	 mov	 eax, 8
  00e7a	48 6b c0 02	 imul	 rax, rax, 2
  00e7e	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00e82	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00e87	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00e8b	b9 08 00 00 00	 mov	 ecx, 8
  00e90	48 6b c9 01	 imul	 rcx, rcx, 1
  00e94	8b 54 24 40	 mov	 edx, DWORD PTR i$6[rsp]
  00e98	48 8b 4c 0c 58	 mov	 rcx, QWORD PTR coutput$9[rsp+rcx]
  00e9d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00ea1	ba 08 00 00 00	 mov	 edx, 8
  00ea6	48 6b d2 00	 imul	 rdx, rdx, 0
  00eaa	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$6[rsp]
  00eaf	48 8b 54 14 58	 mov	 rdx, QWORD PTR coutput$9[rsp+rdx]
  00eb4	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00eb9	89 94 24 04 02
	00 00		 mov	 DWORD PTR tv545[rsp], edx
  00ec0	44 8b c0	 mov	 r8d, eax
  00ec3	8b d1		 mov	 edx, ecx
  00ec5	8b 84 24 04 02
	00 00		 mov	 eax, DWORD PTR tv545[rsp]
  00ecc	8b c8		 mov	 ecx, eax
  00ece	e8 00 00 00 00	 call	 stbi__compute_y
  00ed3	b9 01 00 00 00	 mov	 ecx, 1
  00ed8	48 6b c9 00	 imul	 rcx, rcx, 0
  00edc	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  00ee4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3990 :                      out[1] = 255;

  00ee7	b8 01 00 00 00	 mov	 eax, 1
  00eec	48 6b c0 01	 imul	 rax, rax, 1
  00ef0	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  00ef8	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3991 :                   }

  00efc	e9 3f ff ff ff	 jmp	 $LN26@load_jpeg_
$LN27@load_jpeg_:
$LN74@load_jpeg_:

; 3992 :                }

  00f01	e9 3f 03 00 00	 jmp	 $LN72@load_jpeg_
$LN71@load_jpeg_:

; 3993 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

  00f06	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f0e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f11	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00f15	0f 85 5b 01 00
	00		 jne	 $LN75@load_jpeg_
  00f1b	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f23	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00f2a	0f 85 46 01 00
	00		 jne	 $LN75@load_jpeg_

; 3994 :                for (i=0; i < z->s->img_x; ++i) {

  00f30	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  00f38	eb 0a		 jmp	 SHORT $LN31@load_jpeg_
$LN29@load_jpeg_:
  00f3a	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  00f3e	ff c0		 inc	 eax
  00f40	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN31@load_jpeg_:
  00f44	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f4c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f4f	8b 00		 mov	 eax, DWORD PTR [rax]
  00f51	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  00f55	0f 83 16 01 00
	00		 jae	 $LN30@load_jpeg_

; 3995 :                   stbi_uc m = coutput[3][i];

  00f5b	b8 08 00 00 00	 mov	 eax, 8
  00f60	48 6b c0 03	 imul	 rax, rax, 3
  00f64	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00f68	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00f6d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00f71	88 84 24 92 01
	00 00		 mov	 BYTE PTR m$18[rsp], al

; 3996 :                   stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

  00f78	b8 08 00 00 00	 mov	 eax, 8
  00f7d	48 6b c0 00	 imul	 rax, rax, 0
  00f81	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00f85	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00f8a	0f b6 94 24 92
	01 00 00	 movzx	 edx, BYTE PTR m$18[rsp]
  00f92	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00f96	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00f9b	88 84 24 93 01
	00 00		 mov	 BYTE PTR r$19[rsp], al

; 3997 :                   stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

  00fa2	b8 08 00 00 00	 mov	 eax, 8
  00fa7	48 6b c0 01	 imul	 rax, rax, 1
  00fab	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00faf	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00fb4	0f b6 94 24 92
	01 00 00	 movzx	 edx, BYTE PTR m$18[rsp]
  00fbc	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00fc0	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00fc5	88 84 24 94 01
	00 00		 mov	 BYTE PTR g$20[rsp], al

; 3998 :                   stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

  00fcc	b8 08 00 00 00	 mov	 eax, 8
  00fd1	48 6b c0 02	 imul	 rax, rax, 2
  00fd5	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  00fd9	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  00fde	0f b6 94 24 92
	01 00 00	 movzx	 edx, BYTE PTR m$18[rsp]
  00fe6	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00fea	e8 00 00 00 00	 call	 stbi__blinn_8x8
  00fef	88 84 24 95 01
	00 00		 mov	 BYTE PTR b$21[rsp], al

; 3999 :                   out[0] = stbi__compute_y(r, g, b);

  00ff6	0f b6 84 24 95
	01 00 00	 movzx	 eax, BYTE PTR b$21[rsp]
  00ffe	0f b6 8c 24 94
	01 00 00	 movzx	 ecx, BYTE PTR g$20[rsp]
  01006	0f b6 94 24 93
	01 00 00	 movzx	 edx, BYTE PTR r$19[rsp]
  0100e	89 94 24 08 02
	00 00		 mov	 DWORD PTR tv626[rsp], edx
  01015	44 8b c0	 mov	 r8d, eax
  01018	8b d1		 mov	 edx, ecx
  0101a	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR tv626[rsp]
  01021	8b c8		 mov	 ecx, eax
  01023	e8 00 00 00 00	 call	 stbi__compute_y
  01028	b9 01 00 00 00	 mov	 ecx, 1
  0102d	48 6b c9 00	 imul	 rcx, rcx, 0
  01031	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  01039	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4000 :                   out[1] = 255;

  0103c	b8 01 00 00 00	 mov	 eax, 1
  01041	48 6b c0 01	 imul	 rax, rax, 1
  01045	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  0104d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4001 :                   out += n;

  01051	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  01056	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  0105e	48 03 c8	 add	 rcx, rax
  01061	48 8b c1	 mov	 rax, rcx
  01064	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 4002 :                }

  0106c	e9 c9 fe ff ff	 jmp	 $LN29@load_jpeg_
$LN30@load_jpeg_:

; 4003 :             } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

  01071	e9 cf 01 00 00	 jmp	 $LN76@load_jpeg_
$LN75@load_jpeg_:
  01076	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0107e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01081	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  01085	0f 85 de 00 00
	00		 jne	 $LN77@load_jpeg_
  0108b	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01093	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  0109a	0f 85 c9 00 00
	00		 jne	 $LN77@load_jpeg_

; 4004 :                for (i=0; i < z->s->img_x; ++i) {

  010a0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  010a8	eb 0a		 jmp	 SHORT $LN34@load_jpeg_
$LN32@load_jpeg_:
  010aa	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  010ae	ff c0		 inc	 eax
  010b0	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN34@load_jpeg_:
  010b4	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  010bc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010bf	8b 00		 mov	 eax, DWORD PTR [rax]
  010c1	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  010c5	0f 83 99 00 00
	00		 jae	 $LN33@load_jpeg_

; 4005 :                   out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

  010cb	b8 08 00 00 00	 mov	 eax, 8
  010d0	48 6b c0 03	 imul	 rax, rax, 3
  010d4	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  010d8	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  010dd	ba 08 00 00 00	 mov	 edx, 8
  010e2	48 6b d2 00	 imul	 rdx, rdx, 0
  010e6	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$6[rsp]
  010eb	48 8b 54 14 58	 mov	 rdx, QWORD PTR coutput$9[rsp+rdx]
  010f0	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  010f5	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  010fb	44 2b c2	 sub	 r8d, edx
  010fe	41 8b d0	 mov	 edx, r8d
  01101	89 94 24 0c 02
	00 00		 mov	 DWORD PTR tv656[rsp], edx
  01108	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0110c	8b 84 24 0c 02
	00 00		 mov	 eax, DWORD PTR tv656[rsp]
  01113	0f b6 c8	 movzx	 ecx, al
  01116	e8 00 00 00 00	 call	 stbi__blinn_8x8
  0111b	b9 01 00 00 00	 mov	 ecx, 1
  01120	48 6b c9 00	 imul	 rcx, rcx, 0
  01124	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  0112c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4006 :                   out[1] = 255;

  0112f	b8 01 00 00 00	 mov	 eax, 1
  01134	48 6b c0 01	 imul	 rax, rax, 1
  01138	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  01140	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4007 :                   out += n;

  01144	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$[rsp]
  01149	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  01151	48 03 c8	 add	 rcx, rax
  01154	48 8b c1	 mov	 rax, rcx
  01157	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax

; 4008 :                }

  0115f	e9 46 ff ff ff	 jmp	 $LN32@load_jpeg_
$LN33@load_jpeg_:

; 4009 :             } else {

  01164	e9 dc 00 00 00	 jmp	 $LN78@load_jpeg_
$LN77@load_jpeg_:

; 4010 :                stbi_uc *y = coutput[0];

  01169	b8 08 00 00 00	 mov	 eax, 8
  0116e	48 6b c0 00	 imul	 rax, rax, 0
  01172	48 8b 44 04 58	 mov	 rax, QWORD PTR coutput$9[rsp+rax]
  01177	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR y$22[rsp], rax

; 4011 :                if (n == 1)

  0117f	83 7c 24 30 01	 cmp	 DWORD PTR n$[rsp], 1
  01184	75 4b		 jne	 SHORT $LN79@load_jpeg_

; 4012 :                   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];

  01186	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  0118e	eb 0a		 jmp	 SHORT $LN37@load_jpeg_
$LN35@load_jpeg_:
  01190	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  01194	ff c0		 inc	 eax
  01196	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN37@load_jpeg_:
  0119a	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  011a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011a5	8b 00		 mov	 eax, DWORD PTR [rax]
  011a7	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  011ab	73 22		 jae	 SHORT $LN36@load_jpeg_
  011ad	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  011b1	8b 4c 24 40	 mov	 ecx, DWORD PTR i$6[rsp]
  011b5	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR out$12[rsp]
  011bd	4c 8b 84 24 98
	01 00 00	 mov	 r8, QWORD PTR y$22[rsp]
  011c5	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  011ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  011cd	eb c1		 jmp	 SHORT $LN35@load_jpeg_
$LN36@load_jpeg_:
  011cf	eb 74		 jmp	 SHORT $LN80@load_jpeg_
$LN79@load_jpeg_:

; 4013 :                else
; 4014 :                   for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }

  011d1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  011d9	eb 0a		 jmp	 SHORT $LN40@load_jpeg_
$LN38@load_jpeg_:
  011db	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  011df	ff c0		 inc	 eax
  011e1	89 44 24 40	 mov	 DWORD PTR i$6[rsp], eax
$LN40@load_jpeg_:
  011e5	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  011ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011f0	8b 00		 mov	 eax, DWORD PTR [rax]
  011f2	39 44 24 40	 cmp	 DWORD PTR i$6[rsp], eax
  011f6	73 4d		 jae	 SHORT $LN39@load_jpeg_
  011f8	8b 44 24 40	 mov	 eax, DWORD PTR i$6[rsp]
  011fc	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR out$12[rsp]
  01204	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR y$22[rsp]
  0120c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  01210	88 01		 mov	 BYTE PTR [rcx], al
  01212	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out$12[rsp]
  0121a	48 ff c0	 inc	 rax
  0121d	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax
  01225	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out$12[rsp]
  0122d	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  01230	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR out$12[rsp]
  01238	48 ff c0	 inc	 rax
  0123b	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR out$12[rsp], rax
  01243	eb 96		 jmp	 SHORT $LN38@load_jpeg_
$LN39@load_jpeg_:
$LN80@load_jpeg_:
$LN78@load_jpeg_:
$LN76@load_jpeg_:
$LN72@load_jpeg_:
$LN60@load_jpeg_:

; 4015 :             }
; 4016 :          }
; 4017 :       }

  01245	e9 1b f3 ff ff	 jmp	 $LN5@load_jpeg_
$LN6@load_jpeg_:

; 4018 :       stbi__cleanup_jpeg(z);

  0124a	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01252	e8 00 00 00 00	 call	 stbi__cleanup_jpeg

; 4019 :       *out_x = z->s->img_x;

  01257	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0125f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01262	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR out_x$[rsp]
  0126a	8b 00		 mov	 eax, DWORD PTR [rax]
  0126c	89 01		 mov	 DWORD PTR [rcx], eax

; 4020 :       *out_y = z->s->img_y;

  0126e	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01276	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01279	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR out_y$[rsp]
  01281	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01284	89 01		 mov	 DWORD PTR [rcx], eax

; 4021 :       if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

  01286	48 83 bc 24 48
	02 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0128f	74 3a		 je	 SHORT $LN81@load_jpeg_
  01291	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01299	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0129c	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  012a0	7c 0d		 jl	 SHORT $LN103@load_jpeg_
  012a2	c7 84 24 10 02
	00 00 03 00 00
	00		 mov	 DWORD PTR tv694[rsp], 3
  012ad	eb 0b		 jmp	 SHORT $LN104@load_jpeg_
$LN103@load_jpeg_:
  012af	c7 84 24 10 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv694[rsp], 1
$LN104@load_jpeg_:
  012ba	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  012c2	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR tv694[rsp]
  012c9	89 08		 mov	 DWORD PTR [rax], ecx
$LN81@load_jpeg_:

; 4022 :       return output;

  012cb	48 8b 44 24 48	 mov	 rax, QWORD PTR output$8[rsp]
$LN1@load_jpeg_:

; 4023 :    }
; 4024 : }

  012d0	48 8b f8	 mov	 rdi, rax
  012d3	48 8b cc	 mov	 rcx, rsp
  012d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:load_jpeg_image$rtcFrameData
  012dd	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  012e2	48 8b c7	 mov	 rax, rdi
  012e5	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  012ed	48 33 cc	 xor	 rcx, rsp
  012f0	e8 00 00 00 00	 call	 __security_check_cookie
  012f5	48 81 c4 20 02
	00 00		 add	 rsp, 544		; 00000220H
  012fc	5f		 pop	 rdi
  012fd	c3		 ret	 0
load_jpeg_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
j$ = 56
tv70 = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
stbi__jpeg_load PROC

; 4027 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4028 :    unsigned char* result;
; 4029 :    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));

  00025	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0002a	e8 00 00 00 00	 call	 stbi__malloc
  0002f	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 4030 :    if (!j) return stbi__errpuc("outofmem", "Out of memory");

  00034	48 83 7c 24 38
	00		 cmp	 QWORD PTR j$[rsp], 0
  0003a	75 2b		 jne	 SHORT $LN2@stbi__jpeg
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00043	e8 00 00 00 00	 call	 stbi__err
  00048	85 c0		 test	 eax, eax
  0004a	74 0b		 je	 SHORT $LN4@stbi__jpeg
  0004c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv70[rsp], 0
  00055	eb 09		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:
  00057	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv70[rsp], 0
$LN5@stbi__jpeg:
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR tv70[rsp]
  00065	eb 5e		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4031 :    memset(j, 0, sizeof(stbi__jpeg));

  00067	48 8b 7c 24 38	 mov	 rdi, QWORD PTR j$[rsp]
  0006c	33 c0		 xor	 eax, eax
  0006e	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00073	f3 aa		 rep stosb

; 4032 :    STBI_NOTUSED(ri);
; 4033 :    j->s = s;

  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0007f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4034 :    stbi__setup_jpeg(j);

  00082	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  00087	e8 00 00 00 00	 call	 stbi__setup_jpeg

; 4035 :    result = load_jpeg_image(j, x,y,comp,req_comp);

  0008c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00093	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00097	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0009c	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  000a1	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  000a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  000ab	e8 00 00 00 00	 call	 load_jpeg_image
  000b0	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4036 :    STBI_FREE(j);

  000b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4037 :    return result;

  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 4038 : }

  000c5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
stbi__jpeg_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
j$ = 40
s$ = 64
stbi__jpeg_test PROC

; 4041 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4042 :    int r;
; 4043 :    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

  00016	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0001b	e8 00 00 00 00	 call	 stbi__malloc
  00020	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 4044 :    if (!j) return stbi__err("outofmem", "Out of memory");

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0002b	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00034	e8 00 00 00 00	 call	 stbi__err
  00039	eb 51		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4045 :    memset(j, 0, sizeof(stbi__jpeg));

  0003b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR j$[rsp]
  00040	33 c0		 xor	 eax, eax
  00042	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00047	f3 aa		 rep stosb

; 4046 :    j->s = s;

  00049	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4047 :    stbi__setup_jpeg(j);

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0005b	e8 00 00 00 00	 call	 stbi__setup_jpeg

; 4048 :    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0006a	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  0006f	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 4049 :    stbi__rewind(s);

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00078	e8 00 00 00 00	 call	 stbi__rewind

; 4050 :    STBI_FREE(j);

  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4051 :    return r;

  00088	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__jpeg:

; 4052 : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
stbi__jpeg_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv80 = 32
j$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi__jpeg_info_raw PROC

; 4055 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4056 :    if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

  00025	ba 02 00 00 00	 mov	 edx, 2
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0002f	e8 00 00 00 00	 call	 stbi__decode_jpeg_header
  00034	85 c0		 test	 eax, eax
  00036	75 11		 jne	 SHORT $LN2@stbi__jpeg

; 4057 :       stbi__rewind( j->s );

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0003d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00040	e8 00 00 00 00	 call	 stbi__rewind

; 4058 :       return 0;

  00045	33 c0		 xor	 eax, eax
  00047	eb 6b		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4059 :    }
; 4060 :    if (x) *x = j->s->img_x;

  00049	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  0004f	74 11		 je	 SHORT $LN3@stbi__jpeg
  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  0005e	8b 00		 mov	 eax, DWORD PTR [rax]
  00060	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__jpeg:

; 4061 :    if (y) *y = j->s->img_y;

  00062	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  00068	74 12		 je	 SHORT $LN4@stbi__jpeg
  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007a	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__jpeg:

; 4062 :    if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;

  0007c	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00082	74 2b		 je	 SHORT $LN5@stbi__jpeg
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00090	7c 0a		 jl	 SHORT $LN7@stbi__jpeg
  00092	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR tv80[rsp], 3
  0009a	eb 08		 jmp	 SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
  0009c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN8@stbi__jpeg:
  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  000a9	8b 4c 24 20	 mov	 ecx, DWORD PTR tv80[rsp]
  000ad	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__jpeg:

; 4063 :    return 1;

  000af	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 4064 : }

  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
stbi__jpeg_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 32
j$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi__jpeg_info PROC

; 4067 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4068 :    int result;
; 4069 :    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));

  00025	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0002a	e8 00 00 00 00	 call	 stbi__malloc
  0002f	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 4070 :    if (!j) return stbi__err("outofmem", "Out of memory");

  00034	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0003a	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00043	e8 00 00 00 00	 call	 stbi__err
  00048	eb 47		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4071 :    memset(j, 0, sizeof(stbi__jpeg));

  0004a	48 8b 7c 24 28	 mov	 rdi, QWORD PTR j$[rsp]
  0004f	33 c0		 xor	 eax, eax
  00051	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  00056	f3 aa		 rep stosb

; 4072 :    j->s = s;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00062	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4073 :    result = stbi__jpeg_info_raw(j, x, y, comp);

  00065	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  0006a	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  0006f	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__jpeg_info_raw
  0007e	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 4074 :    STBI_FREE(j);

  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4075 :    return result;

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 4076 : }

  00091	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
stbi__jpeg_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
n$ = 48
stbi__bitreverse16 PROC

; 4106 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00015	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  00019	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0001e	d1 f8		 sar	 eax, 1
  00020	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00024	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  0002a	d1 e1		 shl	 ecx, 1
  0002c	0b c1		 or	 eax, ecx
  0002e	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  00032	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  00036	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0003b	c1 f8 02	 sar	 eax, 2
  0003e	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00042	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  00048	c1 e1 02	 shl	 ecx, 2
  0004b	0b c1		 or	 eax, ecx
  0004d	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00051	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  00055	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  0005a	c1 f8 04	 sar	 eax, 4
  0005d	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00061	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  00067	c1 e1 04	 shl	 ecx, 4
  0006a	0b c1		 or	 eax, ecx
  0006c	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  00070	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]
  00074	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00079	c1 f8 08	 sar	 eax, 8
  0007c	8b 4c 24 30	 mov	 ecx, DWORD PTR n$[rsp]
  00080	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00086	c1 e1 08	 shl	 ecx, 8
  00089	0b c1		 or	 eax, ecx
  0008b	89 44 24 30	 mov	 DWORD PTR n$[rsp], eax

; 4111 :   return n;

  0008f	8b 44 24 30	 mov	 eax, DWORD PTR n$[rsp]

; 4112 : }

  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
stbi__bitreverse16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
$T1 = 32
n$ = 40
v$ = 64
bits$ = 72
stbi__bit_reverse PROC

; 4115 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4116 :    STBI_ASSERT(bits <= 16);

  00019	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  0001e	7e 1c		 jle	 SHORT $LN3@stbi__bit_
  00020	41 b8 14 10 00
	00		 mov	 r8d, 4116		; 00001014H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003a	33 c0		 xor	 eax, eax
$LN3@stbi__bit_:

; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  0003c	8b 44 24 40	 mov	 eax, DWORD PTR v$[rsp]
  00040	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00044	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00048	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0004d	d1 f8		 sar	 eax, 1
  0004f	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00053	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  00059	d1 e1		 shl	 ecx, 1
  0005b	0b c1		 or	 eax, ecx
  0005d	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  00061	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00065	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0006a	c1 f8 02	 sar	 eax, 2
  0006d	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00071	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  00077	c1 e1 02	 shl	 ecx, 2
  0007a	0b c1		 or	 eax, ecx
  0007c	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00080	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00084	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  00089	c1 f8 04	 sar	 eax, 4
  0008c	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00090	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  00096	c1 e1 04	 shl	 ecx, 4
  00099	0b c1		 or	 eax, ecx
  0009b	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  0009f	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000a3	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000a8	c1 f8 08	 sar	 eax, 8
  000ab	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  000af	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b5	c1 e1 08	 shl	 ecx, 8
  000b8	0b c1		 or	 eax, ecx
  000ba	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 4111 :   return n;

  000be	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000c2	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  000c6	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  000ca	b9 10 00 00 00	 mov	 ecx, 16
  000cf	2b 4c 24 48	 sub	 ecx, DWORD PTR bits$[rsp]
  000d3	d3 f8		 sar	 eax, cl

; 4120 : }

  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
stbi__bit_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
k$ = 36
code$ = 40
next_code$ = 64
sizes$ = 160
s$5 = 244
c$6 = 248
fastv$7 = 252
j$8 = 256
$T9 = 272
$T10 = 276
v$ = 280
n$ = 288
tv352 = 296
__$ArrayPad$ = 304
z$ = 336
sizelist$ = 344
num$ = 352
stbi__zbuild_huffman PROC

; 4123 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00049	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4124 :    int i,k=0;

  0004e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 4125 :    int code, next_code[16], sizes[17];
; 4126 : 
; 4127 :    // DEFLATE spec for generating codes
; 4128 :    memset(sizes, 0, sizeof(sizes));

  00056	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR sizes$[rsp]
  0005e	48 8b f8	 mov	 rdi, rax
  00061	33 c0		 xor	 eax, eax
  00063	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00068	f3 aa		 rep stosb

; 4129 :    memset(z->fast, 0, sizeof(z->fast));

  0006a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00072	48 8b bc 24 50
	01 00 00	 mov	 rdi, QWORD PTR z$[rsp]
  0007a	33 c0		 xor	 eax, eax
  0007c	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00081	f3 aa		 rep stosb

; 4130 :    for (i=0; i < num; ++i)

  00083	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008b	eb 0a		 jmp	 SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
  0008d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__zbui:
  00097	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  0009e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000a2	7d 34		 jge	 SHORT $LN3@stbi__zbui

; 4131 :       ++sizes[sizelist[i]];

  000a4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a9	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  000b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b5	8b 84 84 a0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  000bc	ff c0		 inc	 eax
  000be	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000c3	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR sizelist$[rsp]
  000cb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000cf	89 84 8c a0 00
	00 00		 mov	 DWORD PTR sizes$[rsp+rcx*4], eax
  000d6	eb b5		 jmp	 SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 4132 :    sizes[0] = 0;

  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	48 6b c0 00	 imul	 rax, rax, 0
  000e1	c7 84 04 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sizes$[rsp+rax], 0

; 4133 :    for (i=1; i < 16; ++i)

  000ec	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000f4	eb 0a		 jmp	 SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
  000f6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000fa	ff c0		 inc	 eax
  000fc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__zbui:
  00100	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00105	7d 2e		 jge	 SHORT $LN6@stbi__zbui

; 4134 :       if (sizes[i] > (1 << i))

  00107	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0010c	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	d3 e2		 shl	 edx, cl
  00117	8b ca		 mov	 ecx, edx
  00119	39 8c 84 a0 00
	00 00		 cmp	 DWORD PTR sizes$[rsp+rax*4], ecx
  00120	7e 11		 jle	 SHORT $LN16@stbi__zbui

; 4135 :          return stbi__err("bad sizes", "Corrupt PNG");

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EOHLEIKL@bad?5sizes@
  00129	e8 00 00 00 00	 call	 stbi__err
  0012e	e9 b1 03 00 00	 jmp	 $LN1@stbi__zbui
$LN16@stbi__zbui:
  00133	eb c1		 jmp	 SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 4136 :    code = 0;

  00135	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 4137 :    for (i=1; i < 16; ++i) {

  0013d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00145	eb 0a		 jmp	 SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
  00147	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0014b	ff c0		 inc	 eax
  0014d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__zbui:
  00151	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00156	0f 8d dd 00 00
	00		 jge	 $LN9@stbi__zbui

; 4138 :       next_code[i] = code;

  0015c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00161	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  00165	89 4c 84 40	 mov	 DWORD PTR next_code$[rsp+rax*4], ecx

; 4139 :       z->firstcode[i] = (stbi__uint16) code;

  00169	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0016e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00176	0f b7 54 24 28	 movzx	 edx, WORD PTR code$[rsp]
  0017b	66 89 94 41 00
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1024], dx

; 4140 :       z->firstsymbol[i] = (stbi__uint16) k;

  00183	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00188	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00190	0f b7 54 24 24	 movzx	 edx, WORD PTR k$[rsp]
  00195	66 89 94 41 64
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1124], dx

; 4141 :       code = (code + sizes[i]);

  0019d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001a2	8b 84 84 a0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  001a9	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  001ad	03 c8		 add	 ecx, eax
  001af	8b c1		 mov	 eax, ecx
  001b1	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4142 :       if (sizes[i])

  001b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001ba	83 bc 84 a0 00
	00 00 00	 cmp	 DWORD PTR sizes$[rsp+rax*4], 0
  001c2	74 28		 je	 SHORT $LN17@stbi__zbui

; 4143 :          if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

  001c4	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001c8	ff c8		 dec	 eax
  001ca	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001ce	ba 01 00 00 00	 mov	 edx, 1
  001d3	d3 e2		 shl	 edx, cl
  001d5	8b ca		 mov	 ecx, edx
  001d7	3b c1		 cmp	 eax, ecx
  001d9	7c 11		 jl	 SHORT $LN18@stbi__zbui
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  001e2	e8 00 00 00 00	 call	 stbi__err
  001e7	e9 f8 02 00 00	 jmp	 $LN1@stbi__zbui
$LN18@stbi__zbui:
$LN17@stbi__zbui:

; 4144 :       z->maxcode[i] = code << (16-i); // preshift for inner loop

  001ec	b8 10 00 00 00	 mov	 eax, 16
  001f1	2b 44 24 20	 sub	 eax, DWORD PTR i$[rsp]
  001f5	0f b6 c8	 movzx	 ecx, al
  001f8	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001fc	d3 e0		 shl	 eax, cl
  001fe	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00203	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0020b	89 84 8a 20 04
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1056], eax

; 4145 :       code <<= 1;

  00212	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  00216	d1 e0		 shl	 eax, 1
  00218	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4146 :       k += sizes[i];

  0021c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00221	8b 84 84 a0 00
	00 00		 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  00228	8b 4c 24 24	 mov	 ecx, DWORD PTR k$[rsp]
  0022c	03 c8		 add	 ecx, eax
  0022e	8b c1		 mov	 eax, ecx
  00230	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 4147 :    }

  00234	e9 0e ff ff ff	 jmp	 $LN8@stbi__zbui
$LN9@stbi__zbui:

; 4148 :    z->maxcode[16] = 0x10000; // sentinel

  00239	b8 04 00 00 00	 mov	 eax, 4
  0023e	48 6b c0 10	 imul	 rax, rax, 16
  00242	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0024a	c7 84 01 20 04
	00 00 00 00 01
	00		 mov	 DWORD PTR [rcx+rax+1056], 65536 ; 00010000H

; 4149 :    for (i=0; i < num; ++i) {

  00255	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0025d	eb 0a		 jmp	 SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
  0025f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00263	ff c0		 inc	 eax
  00265	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__zbui:
  00269	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00270	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00274	0f 8d 65 02 00
	00		 jge	 $LN12@stbi__zbui

; 4150 :       int s = sizelist[i];

  0027a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0027f	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  00287	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0028b	89 84 24 f4 00
	00 00		 mov	 DWORD PTR s$5[rsp], eax

; 4151 :       if (s) {

  00292	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR s$5[rsp], 0
  0029a	0f 84 3a 02 00
	00		 je	 $LN19@stbi__zbui

; 4152 :          int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

  002a0	48 63 84 24 f4
	00 00 00	 movsxd	 rax, DWORD PTR s$5[rsp]
  002a8	48 63 8c 24 f4
	00 00 00	 movsxd	 rcx, DWORD PTR s$5[rsp]
  002b0	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  002b8	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  002c0	8b 44 84 40	 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  002c4	2b c1		 sub	 eax, ecx
  002c6	48 63 8c 24 f4
	00 00 00	 movsxd	 rcx, DWORD PTR s$5[rsp]
  002ce	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  002d6	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  002de	03 c1		 add	 eax, ecx
  002e0	89 84 24 f8 00
	00 00		 mov	 DWORD PTR c$6[rsp], eax

; 4153 :          stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);

  002e7	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR s$5[rsp]
  002ee	c1 e0 09	 shl	 eax, 9
  002f1	0b 44 24 20	 or	 eax, DWORD PTR i$[rsp]
  002f5	66 89 84 24 fc
	00 00 00	 mov	 WORD PTR fastv$7[rsp], ax

; 4154 :          z->size [c] = (stbi_uc     ) s;

  002fd	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR c$6[rsp]
  00305	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0030d	0f b6 94 24 f4
	00 00 00	 movzx	 edx, BYTE PTR s$5[rsp]
  00315	88 94 01 84 04
	00 00		 mov	 BYTE PTR [rcx+rax+1156], dl

; 4155 :          z->value[c] = (stbi__uint16) i;

  0031c	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR c$6[rsp]
  00324	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0032c	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  00331	66 89 94 41 a4
	05 00 00	 mov	 WORD PTR [rcx+rax*2+1444], dx

; 4156 :          if (s <= STBI__ZFAST_BITS) {

  00339	83 bc 24 f4 00
	00 00 09	 cmp	 DWORD PTR s$5[rsp], 9
  00341	0f 8f 79 01 00
	00		 jg	 $LN20@stbi__zbui

; 4157 :             int j = stbi__bit_reverse(next_code[s],s);

  00347	48 63 84 24 f4
	00 00 00	 movsxd	 rax, DWORD PTR s$5[rsp]
  0034f	8b 44 84 40	 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  00353	89 84 24 18 01
	00 00		 mov	 DWORD PTR v$[rsp], eax

; 4116 :    STBI_ASSERT(bits <= 16);

  0035a	83 bc 24 f4 00
	00 00 10	 cmp	 DWORD PTR s$5[rsp], 16
  00362	7e 1c		 jle	 SHORT $LN24@stbi__zbui
  00364	41 b8 14 10 00
	00		 mov	 r8d, 4116		; 00001014H
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00371	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0037e	33 c0		 xor	 eax, eax
$LN24@stbi__zbui:

; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  00380	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR v$[rsp]
  00387	89 84 24 20 01
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  0038e	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00395	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0039a	d1 f8		 sar	 eax, 1
  0039c	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  003a3	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  003a9	d1 e1		 shl	 ecx, 1
  003ab	0b c1		 or	 eax, ecx
  003ad	89 84 24 20 01
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  003b4	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  003bb	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  003c0	c1 f8 02	 sar	 eax, 2
  003c3	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  003ca	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  003d0	c1 e1 02	 shl	 ecx, 2
  003d3	0b c1		 or	 eax, ecx
  003d5	89 84 24 20 01
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  003dc	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  003e3	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  003e8	c1 f8 04	 sar	 eax, 4
  003eb	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  003f2	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  003f8	c1 e1 04	 shl	 ecx, 4
  003fb	0b c1		 or	 eax, ecx
  003fd	89 84 24 20 01
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  00404	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0040b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00410	c1 f8 08	 sar	 eax, 8
  00413	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  0041a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00420	c1 e1 08	 shl	 ecx, 8
  00423	0b c1		 or	 eax, ecx
  00425	89 84 24 20 01
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4111 :   return n;

  0042c	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00433	89 84 24 10 01
	00 00		 mov	 DWORD PTR $T9[rsp], eax

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  0043a	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR $T9[rsp]
  00441	b9 10 00 00 00	 mov	 ecx, 16
  00446	2b 8c 24 f4 00
	00 00		 sub	 ecx, DWORD PTR s$5[rsp]
  0044d	d3 f8		 sar	 eax, cl
  0044f	89 84 24 14 01
	00 00		 mov	 DWORD PTR $T10[rsp], eax

; 4157 :             int j = stbi__bit_reverse(next_code[s],s);

  00456	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR $T10[rsp]
  0045d	89 84 24 00 01
	00 00		 mov	 DWORD PTR j$8[rsp], eax
$LN14@stbi__zbui:

; 4158 :             while (j < (1 << STBI__ZFAST_BITS)) {

  00464	81 bc 24 00 01
	00 00 00 02 00
	00		 cmp	 DWORD PTR j$8[rsp], 512	; 00000200H
  0046f	7d 4f		 jge	 SHORT $LN15@stbi__zbui

; 4159 :                z->fast[j] = fastv;

  00471	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR j$8[rsp]
  00479	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00481	0f b7 94 24 fc
	00 00 00	 movzx	 edx, WORD PTR fastv$7[rsp]
  00489	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 4160 :                j += (1 << s);

  0048d	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR s$5[rsp]
  00494	b9 01 00 00 00	 mov	 ecx, 1
  00499	89 8c 24 28 01
	00 00		 mov	 DWORD PTR tv352[rsp], ecx
  004a0	0f b6 c8	 movzx	 ecx, al
  004a3	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv352[rsp]
  004aa	d3 e0		 shl	 eax, cl
  004ac	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR j$8[rsp]
  004b3	03 c8		 add	 ecx, eax
  004b5	8b c1		 mov	 eax, ecx
  004b7	89 84 24 00 01
	00 00		 mov	 DWORD PTR j$8[rsp], eax

; 4161 :             }

  004be	eb a4		 jmp	 SHORT $LN14@stbi__zbui
$LN15@stbi__zbui:
$LN20@stbi__zbui:

; 4162 :          }
; 4163 :          ++next_code[s];

  004c0	48 63 84 24 f4
	00 00 00	 movsxd	 rax, DWORD PTR s$5[rsp]
  004c8	8b 44 84 40	 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  004cc	ff c0		 inc	 eax
  004ce	48 63 8c 24 f4
	00 00 00	 movsxd	 rcx, DWORD PTR s$5[rsp]
  004d6	89 44 8c 40	 mov	 DWORD PTR next_code$[rsp+rcx*4], eax
$LN19@stbi__zbui:

; 4164 :       }
; 4165 :    }

  004da	e9 80 fd ff ff	 jmp	 $LN11@stbi__zbui
$LN12@stbi__zbui:

; 4166 :    return 1;

  004df	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zbui:

; 4167 : }

  004e4	48 8b f8	 mov	 rdi, rax
  004e7	48 8b cc	 mov	 rcx, rsp
  004ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zbuild_huffman$rtcFrameData
  004f1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  004f6	48 8b c7	 mov	 rax, rdi
  004f9	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00501	48 33 cc	 xor	 rcx, rsp
  00504	e8 00 00 00 00	 call	 __security_check_cookie
  00509	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  00510	5f		 pop	 rdi
  00511	c3		 ret	 0
stbi__zbuild_huffman ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv67 = 32
z$ = 64
stbi__zeof PROC

; 4190 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00024	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00027	72 0a		 jb	 SHORT $LN3@stbi__zeof
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN4@stbi__zeof
$LN3@stbi__zeof:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__zeof:
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]

; 4192 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
stbi__zeof ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
$T1 = 32
tv79 = 36
tv73 = 40
z$ = 64
stbi__zget8 PROC

; 4195 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00024	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00027	72 0a		 jb	 SHORT $LN7@stbi__zget
  00029	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN8@stbi__zget
$LN7@stbi__zget:
  00033	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN8@stbi__zget:
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR tv79[rsp]
  0003f	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

  00043	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00047	85 c0		 test	 eax, eax
  00049	74 0a		 je	 SHORT $LN3@stbi__zget
  0004b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00053	eb 22		 jmp	 SHORT $LN4@stbi__zget
$LN3@stbi__zget:
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00060	89 44 24 28	 mov	 DWORD PTR tv73[rsp], eax
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 ff c0	 inc	 rax
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@stbi__zget:
  00077	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv73[rsp]

; 4197 : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
stbi__zget8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv136 = 40
tv130 = 44
tv93 = 48
z$ = 80
stbi__fill_bits PROC

; 4200 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00016	90		 npad	 1
$LN4@stbi__fill:

; 4201 :    do {
; 4202 :       if (z->code_buffer >= (1U << z->num_bits)) {

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0001c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	89 4c 24 28	 mov	 DWORD PTR tv136[rsp], ecx
  00028	0f b6 c8	 movzx	 ecx, al
  0002b	8b 44 24 28	 mov	 eax, DWORD PTR tv136[rsp]
  0002f	d3 e0		 shl	 eax, cl
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00036	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00039	72 16		 jb	 SHORT $LN5@stbi__fill

; 4203 :         z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */

  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00045	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00049	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4204 :         return;

  0004c	e9 b2 00 00 00	 jmp	 $LN1@stbi__fill
$LN5@stbi__fill:

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0005b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00062	72 0a		 jb	 SHORT $LN13@stbi__fill
  00064	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  0006c	eb 08		 jmp	 SHORT $LN14@stbi__fill
$LN13@stbi__fill:
  0006e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN14@stbi__fill:
  00076	8b 44 24 2c	 mov	 eax, DWORD PTR tv130[rsp]
  0007a	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

  0007e	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00082	85 c0		 test	 eax, eax
  00084	74 0a		 je	 SHORT $LN9@stbi__fill
  00086	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  0008e	eb 22		 jmp	 SHORT $LN10@stbi__fill
$LN9@stbi__fill:
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009b	89 44 24 30	 mov	 DWORD PTR tv93[rsp], eax
  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a7	48 ff c0	 inc	 rax
  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000af	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN10@stbi__fill:
  000b2	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv93[rsp]
  000b7	88 44 24 24	 mov	 BYTE PTR $T2[rsp], al

; 4205 :       }
; 4206 :       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;

  000bb	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T2[rsp]
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000c8	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000cb	d3 e0		 shl	 eax, cl
  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000d2	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  000d5	0b c8		 or	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000de	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4207 :       z->num_bits += 8;

  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000e6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000e9	83 c0 08	 add	 eax, 8
  000ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000f1	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4208 :    } while (z->num_bits <= 24);

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000f9	83 78 10 18	 cmp	 DWORD PTR [rax+16], 24
  000fd	0f 8e 14 ff ff
	ff		 jle	 $LN4@stbi__fill
$LN1@stbi__fill:

; 4209 : }

  00103	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
stbi__fill_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
k$ = 32
tv84 = 36
tv90 = 40
z$ = 64
n$ = 72
stbi__zreceive PROC

; 4212 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4213 :    unsigned int k;
; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0001f	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00023	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00026	7d 0b		 jge	 SHORT $LN2@stbi__zrec
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0002d	e8 00 00 00 00	 call	 stbi__fill_bits
  00032	90		 npad	 1
$LN2@stbi__zrec:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00033	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00037	b9 01 00 00 00	 mov	 ecx, 1
  0003c	89 4c 24 24	 mov	 DWORD PTR tv84[rsp], ecx
  00040	0f b6 c8	 movzx	 ecx, al
  00043	8b 44 24 24	 mov	 eax, DWORD PTR tv84[rsp]
  00047	d3 e0		 shl	 eax, cl
  00049	ff c8		 dec	 eax
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00050	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00053	23 c8		 and	 ecx, eax
  00055	8b c1		 mov	 eax, ecx
  00057	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0005b	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00064	48 89 4c 24 28	 mov	 QWORD PTR tv90[rsp], rcx
  00069	0f b6 c8	 movzx	 ecx, al
  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR tv90[rsp]
  00071	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00074	d3 e8		 shr	 eax, cl
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0007b	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00083	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00087	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008a	2b c1		 sub	 eax, ecx
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00091	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  00094	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]

; 4219 : }

  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
stbi__zreceive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
b$ = 32
s$ = 36
k$ = 40
$T1 = 44
$T2 = 48
v$ = 56
n$ = 64
tv214 = 72
a$ = 96
z$ = 104
stbi__zhuffman_decode_slowpath PROC

; 4222 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00020	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00023	89 44 24 38	 mov	 DWORD PTR v$[rsp], eax

; 4116 :    STBI_ASSERT(bits <= 16);

  00027	b8 10 00 00 00	 mov	 eax, 16
  0002c	83 f8 10	 cmp	 eax, 16
  0002f	7d 1c		 jge	 SHORT $LN12@stbi__zhuf
  00031	41 b8 14 10 00
	00		 mov	 r8d, 4116		; 00001014H
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HKNLHECB@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA6@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004b	33 c0		 xor	 eax, eax
$LN12@stbi__zhuf:

; 4117 :    // to bit reverse n bits, reverse 16 and shift
; 4118 :    // e.g. 11 bits, bit reverse and shift away 5
; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  0004d	8b 44 24 38	 mov	 eax, DWORD PTR v$[rsp]
  00051	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4107 :   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00055	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00059	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0005e	d1 f8		 sar	 eax, 1
  00060	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  00064	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  0006a	d1 e1		 shl	 ecx, 1
  0006c	0b c1		 or	 eax, ecx
  0006e	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4108 :   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  00072	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00076	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0007b	c1 f8 02	 sar	 eax, 2
  0007e	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  00082	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  00088	c1 e1 02	 shl	 ecx, 2
  0008b	0b c1		 or	 eax, ecx
  0008d	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4109 :   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00091	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  00095	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  0009a	c1 f8 04	 sar	 eax, 4
  0009d	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  000a1	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  000a7	c1 e1 04	 shl	 ecx, 4
  000aa	0b c1		 or	 eax, ecx
  000ac	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4110 :   n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  000b0	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  000b4	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000b9	c1 f8 08	 sar	 eax, 8
  000bc	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  000c0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c6	c1 e1 08	 shl	 ecx, 8
  000c9	0b c1		 or	 eax, ecx
  000cb	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 4111 :   return n;

  000cf	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  000d3	89 44 24 2c	 mov	 DWORD PTR $T1[rsp], eax

; 4119 :    return stbi__bitreverse16(v) >> (16-bits);

  000d7	8b 44 24 2c	 mov	 eax, DWORD PTR $T1[rsp]
  000db	b9 10 00 00 00	 mov	 ecx, 16
  000e0	83 e9 10	 sub	 ecx, 16
  000e3	d3 f8		 sar	 eax, cl
  000e5	89 44 24 30	 mov	 DWORD PTR $T2[rsp], eax

; 4223 :    int b,s,k;
; 4224 :    // not resolved by fast table, so compute it the slow way
; 4225 :    // use jpeg approach, which requires MSbits at top
; 4226 :    k = stbi__bit_reverse(a->code_buffer, 16);

  000e9	8b 44 24 30	 mov	 eax, DWORD PTR $T2[rsp]
  000ed	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 4227 :    for (s=STBI__ZFAST_BITS+1; ; ++s)

  000f1	c7 44 24 24 0a
	00 00 00	 mov	 DWORD PTR s$[rsp], 10
  000f9	eb 0a		 jmp	 SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
  000fb	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax
$LN4@stbi__zhuf:

; 4228 :       if (k < z->maxcode[s])

  00105	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$[rsp]
  0010a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  0010f	8b 84 81 20 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1056]
  00116	39 44 24 28	 cmp	 DWORD PTR k$[rsp], eax
  0011a	7d 02		 jge	 SHORT $LN5@stbi__zhuf

; 4229 :          break;

  0011c	eb 02		 jmp	 SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
  0011e	eb db		 jmp	 SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 4230 :    if (s >= 16) return -1; // invalid code!

  00120	83 7c 24 24 10	 cmp	 DWORD PTR s$[rsp], 16
  00125	7c 0a		 jl	 SHORT $LN6@stbi__zhuf
  00127	b8 ff ff ff ff	 mov	 eax, -1
  0012c	e9 b9 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 4231 :    // code size is s, so:
; 4232 :    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

  00131	b8 10 00 00 00	 mov	 eax, 16
  00136	2b 44 24 24	 sub	 eax, DWORD PTR s$[rsp]
  0013a	0f b6 c8	 movzx	 ecx, al
  0013d	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00141	d3 f8		 sar	 eax, cl
  00143	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$[rsp]
  00148	48 8b 54 24 68	 mov	 rdx, QWORD PTR z$[rsp]
  0014d	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  00155	2b c1		 sub	 eax, ecx
  00157	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$[rsp]
  0015c	48 8b 54 24 68	 mov	 rdx, QWORD PTR z$[rsp]
  00161	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  00169	03 c1		 add	 eax, ecx
  0016b	89 44 24 20	 mov	 DWORD PTR b$[rsp], eax

; 4233 :    if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!

  0016f	81 7c 24 20 20
	01 00 00	 cmp	 DWORD PTR b$[rsp], 288	; 00000120H
  00177	7c 07		 jl	 SHORT $LN7@stbi__zhuf
  00179	b8 ff ff ff ff	 mov	 eax, -1
  0017e	eb 6a		 jmp	 SHORT $LN1@stbi__zhuf
$LN7@stbi__zhuf:

; 4234 :    if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

  00180	48 63 44 24 20	 movsxd	 rax, DWORD PTR b$[rsp]
  00185	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  0018a	0f b6 84 01 84
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1156]
  00192	3b 44 24 24	 cmp	 eax, DWORD PTR s$[rsp]
  00196	74 07		 je	 SHORT $LN8@stbi__zhuf
  00198	b8 ff ff ff ff	 mov	 eax, -1
  0019d	eb 4b		 jmp	 SHORT $LN1@stbi__zhuf
$LN8@stbi__zhuf:

; 4235 :    a->code_buffer >>= s;

  0019f	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  001a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001a8	48 89 4c 24 48	 mov	 QWORD PTR tv214[rsp], rcx
  001ad	0f b6 c8	 movzx	 ecx, al
  001b0	48 8b 44 24 48	 mov	 rax, QWORD PTR tv214[rsp]
  001b5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001b8	d3 e8		 shr	 eax, cl
  001ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001bf	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4236 :    a->num_bits -= s;

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  001c7	8b 4c 24 24	 mov	 ecx, DWORD PTR s$[rsp]
  001cb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001ce	2b c1		 sub	 eax, ecx
  001d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  001d5	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4237 :    return z->value[b];

  001d8	48 63 44 24 20	 movsxd	 rax, DWORD PTR b$[rsp]
  001dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  001e2	0f b7 84 41 a4
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+1444]
$LN1@stbi__zhuf:

; 4238 : }

  001ea	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ee	5f		 pop	 rdi
  001ef	c3		 ret	 0
stbi__zhuffman_decode_slowpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
b$ = 32
s$ = 36
$T1 = 40
tv93 = 44
tv138 = 48
a$ = 80
z$ = 88
stbi__zhuffman_decode PROC

; 4241 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4242 :    int b,s;
; 4243 :    if (a->num_bits < 16) {

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00020	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00024	7d 4a		 jge	 SHORT $LN2@stbi__zhuf

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0002b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00030	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00034	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00037	72 0a		 jb	 SHORT $LN8@stbi__zhuf
  00039	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN9@stbi__zhuf
$LN8@stbi__zhuf:
  00043	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN9@stbi__zhuf:
  0004b	8b 44 24 2c	 mov	 eax, DWORD PTR tv93[rsp]
  0004f	89 44 24 28	 mov	 DWORD PTR $T1[rsp], eax

; 4244 :       if (stbi__zeof(a)) {

  00053	8b 44 24 28	 mov	 eax, DWORD PTR $T1[rsp]
  00057	85 c0		 test	 eax, eax
  00059	74 0a		 je	 SHORT $LN3@stbi__zhuf

; 4245 :          return -1;   /* report error for unexpected end of data. */

  0005b	b8 ff ff ff ff	 mov	 eax, -1
  00060	e9 8c 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN3@stbi__zhuf:

; 4246 :       }
; 4247 :       stbi__fill_bits(a);

  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0006a	e8 00 00 00 00	 call	 stbi__fill_bits
  0006f	90		 npad	 1
$LN2@stbi__zhuf:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00075	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00078	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0007d	8b c0		 mov	 eax, eax
  0007f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  00084	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00088	89 44 24 20	 mov	 DWORD PTR b$[rsp], eax

; 4250 :    if (b) {

  0008c	83 7c 24 20 00	 cmp	 DWORD PTR b$[rsp], 0
  00091	74 4f		 je	 SHORT $LN4@stbi__zhuf

; 4251 :       s = b >> 9;

  00093	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  00097	c1 f8 09	 sar	 eax, 9
  0009a	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax

; 4252 :       a->code_buffer >>= s;

  0009e	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  000a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000a7	48 89 4c 24 30	 mov	 QWORD PTR tv138[rsp], rcx
  000ac	0f b6 c8	 movzx	 ecx, al
  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR tv138[rsp]
  000b4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b7	d3 e8		 shr	 eax, cl
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000be	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4253 :       a->num_bits -= s;

  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000c6	8b 4c 24 24	 mov	 ecx, DWORD PTR s$[rsp]
  000ca	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000cd	2b c1		 sub	 eax, ecx
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000d4	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4254 :       return b & 511;

  000d7	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  000db	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000e0	eb 0f		 jmp	 SHORT $LN1@stbi__zhuf
$LN4@stbi__zhuf:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

  000e2	48 8b 54 24 58	 mov	 rdx, QWORD PTR z$[rsp]
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000ec	e8 00 00 00 00	 call	 stbi__zhuffman_decode_slowpath
$LN1@stbi__zhuf:

; 4257 : }

  000f1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f5	5f		 pop	 rdi
  000f6	c3		 ret	 0
stbi__zhuffman_decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
q$ = 32
cur$ = 40
limit$ = 44
old_limit$ = 48
z$ = 80
zout$ = 88
n$ = 96
stbi__zexpand PROC

; 4260 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4261 :    char *q;
; 4262 :    unsigned int cur, limit, old_limit;
; 4263 :    z->zout = zout;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00025	48 8b 4c 24 58	 mov	 rcx, QWORD PTR zout$[rsp]
  0002a	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4264 :    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00033	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00037	75 11		 jne	 SHORT $LN4@stbi__zexp
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@IBFIPFO@output?5buffer?5limit@
  00040	e8 00 00 00 00	 call	 stbi__err
  00045	e9 03 01 00 00	 jmp	 $LN1@stbi__zexp
$LN4@stbi__zexp:

; 4265 :    cur   = (unsigned int) (z->zout - z->zout_start);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00054	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00058	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005c	48 2b c1	 sub	 rax, rcx
  0005f	89 44 24 28	 mov	 DWORD PTR cur$[rsp], eax

; 4266 :    limit = old_limit = (unsigned) (z->zout_end - z->zout_start);

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0006d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00071	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00075	48 2b c1	 sub	 rax, rcx
  00078	89 44 24 30	 mov	 DWORD PTR old_limit$[rsp], eax
  0007c	8b 44 24 30	 mov	 eax, DWORD PTR old_limit$[rsp]
  00080	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 4267 :    if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");

  00084	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00089	2b 44 24 28	 sub	 eax, DWORD PTR cur$[rsp]
  0008d	3b 44 24 60	 cmp	 eax, DWORD PTR n$[rsp]
  00091	73 11		 jae	 SHORT $LN5@stbi__zexp
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0009a	e8 00 00 00 00	 call	 stbi__err
  0009f	e9 a9 00 00 00	 jmp	 $LN1@stbi__zexp
$LN5@stbi__zexp:
$LN2@stbi__zexp:

; 4268 :    while (cur + n > limit) {

  000a4	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  000a8	8b 4c 24 28	 mov	 ecx, DWORD PTR cur$[rsp]
  000ac	03 c8		 add	 ecx, eax
  000ae	8b c1		 mov	 eax, ecx
  000b0	3b 44 24 2c	 cmp	 eax, DWORD PTR limit$[rsp]
  000b4	76 24		 jbe	 SHORT $LN3@stbi__zexp

; 4269 :       if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");

  000b6	81 7c 24 2c ff
	ff ff 7f	 cmp	 DWORD PTR limit$[rsp], 2147483647 ; 7fffffffH
  000be	76 0e		 jbe	 SHORT $LN6@stbi__zexp
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  000c7	e8 00 00 00 00	 call	 stbi__err
  000cc	eb 7f		 jmp	 SHORT $LN1@stbi__zexp
$LN6@stbi__zexp:

; 4270 :       limit *= 2;

  000ce	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  000d2	d1 e0		 shl	 eax, 1
  000d4	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 4271 :    }

  000d8	eb ca		 jmp	 SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 4272 :    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

  000da	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  000de	8b d0		 mov	 edx, eax
  000e0	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000e5	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000ef	48 89 44 24 20	 mov	 QWORD PTR q$[rsp], rax

; 4273 :    STBI_NOTUSED(old_limit);
; 4274 :    if (q == NULL) return stbi__err("outofmem", "Out of memory");

  000f4	48 83 7c 24 20
	00		 cmp	 QWORD PTR q$[rsp], 0
  000fa	75 0e		 jne	 SHORT $LN7@stbi__zexp
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00103	e8 00 00 00 00	 call	 stbi__err
  00108	eb 43		 jmp	 SHORT $LN1@stbi__zexp
$LN7@stbi__zexp:

; 4275 :    z->zout_start = q;

  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0010f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  00114	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4276 :    z->zout       = q + cur;

  00118	8b 44 24 28	 mov	 eax, DWORD PTR cur$[rsp]
  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  00121	48 03 c8	 add	 rcx, rax
  00124	48 8b c1	 mov	 rax, rcx
  00127	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0012c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4277 :    z->zout_end   = q + limit;

  00130	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  00139	48 03 c8	 add	 rcx, rax
  0013c	48 8b c1	 mov	 rax, rcx
  0013f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00144	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4278 :    return 1;

  00148	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zexp:

; 4279 : }

  0014d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00151	5f		 pop	 rdi
  00152	c3		 ret	 0
stbi__zexpand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
zout$ = 32
z$1 = 40
p$2 = 48
len$3 = 56
dist$4 = 60
v$5 = 64
$T6 = 68
$T7 = 72
$T8 = 76
$T9 = 80
$T10 = 84
$T11 = 88
n$ = 96
k$12 = 104
z$ = 112
b$13 = 120
s$14 = 124
n$ = 128
k$15 = 136
z$ = 144
b$16 = 152
s$17 = 156
tv213 = 160
tv305 = 168
tv328 = 176
tv334 = 184
tv250 = 192
tv355 = 200
tv368 = 208
tv374 = 216
a$ = 240
stbi__parse_huffman_block PROC

; 4296 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00014	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4297 :    char *zout = a->zout;

  00019	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00021	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00025	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax
$LN2@stbi__pars:

; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);

  0002a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00032	48 83 c0 34	 add	 rax, 52			; 00000034H
  00036	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR z$[rsp], rax

; 4243 :    if (a->num_bits < 16) {

  0003e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00046	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  0004a	7d 5f		 jge	 SHORT $LN31@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  0004c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00054	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0005c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00060	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00063	72 0d		 jb	 SHORT $LN37@stbi__pars
  00065	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv213[rsp], 1
  00070	eb 0b		 jmp	 SHORT $LN38@stbi__pars
$LN37@stbi__pars:
  00072	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv213[rsp], 0
$LN38@stbi__pars:
  0007d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  00084	89 44 24 44	 mov	 DWORD PTR $T6[rsp], eax

; 4244 :       if (stbi__zeof(a)) {

  00088	8b 44 24 44	 mov	 eax, DWORD PTR $T6[rsp]
  0008c	85 c0		 test	 eax, eax
  0008e	74 0d		 je	 SHORT $LN32@stbi__pars

; 4245 :          return -1;   /* report error for unexpected end of data. */

  00090	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR $T7[rsp], -1
  00098	e9 ca 00 00 00	 jmp	 $LN30@stbi__pars
$LN32@stbi__pars:

; 4246 :       }
; 4247 :       stbi__fill_bits(a);

  0009d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000a5	e8 00 00 00 00	 call	 stbi__fill_bits
  000aa	90		 npad	 1
$LN31@stbi__pars:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  000ab	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000b3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b6	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000bb	8b c0		 mov	 eax, eax
  000bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000c5	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000c9	89 84 24 98 00
	00 00		 mov	 DWORD PTR b$16[rsp], eax

; 4250 :    if (b) {

  000d0	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR b$16[rsp], 0
  000d8	74 74		 je	 SHORT $LN33@stbi__pars

; 4251 :       s = b >> 9;

  000da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR b$16[rsp]
  000e1	c1 f8 09	 sar	 eax, 9
  000e4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR s$17[rsp], eax

; 4252 :       a->code_buffer >>= s;

  000eb	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR s$17[rsp]
  000f2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000fa	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv305[rsp], rcx
  00102	0f b6 c8	 movzx	 ecx, al
  00105	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv305[rsp]
  0010d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00110	d3 e8		 shr	 eax, cl
  00112	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0011a	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4253 :       a->num_bits -= s;

  0011d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00125	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR s$17[rsp]
  0012c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0012f	2b c1		 sub	 eax, ecx
  00131	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00139	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4254 :       return b & 511;

  0013c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR b$16[rsp]
  00143	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00148	89 44 24 48	 mov	 DWORD PTR $T7[rsp], eax
  0014c	eb 19		 jmp	 SHORT $LN30@stbi__pars
$LN33@stbi__pars:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

  0014e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00156	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0015e	e8 00 00 00 00	 call	 stbi__zhuffman_decode_slowpath
  00163	89 44 24 48	 mov	 DWORD PTR $T7[rsp], eax
$LN30@stbi__pars:

; 4298 :    for(;;) {
; 4299 :       int z = stbi__zhuffman_decode(a, &a->z_length);

  00167	8b 44 24 48	 mov	 eax, DWORD PTR $T7[rsp]
  0016b	89 44 24 28	 mov	 DWORD PTR z$1[rsp], eax

; 4300 :       if (z < 256) {

  0016f	81 7c 24 28 00
	01 00 00	 cmp	 DWORD PTR z$1[rsp], 256	; 00000100H
  00177	7d 7d		 jge	 SHORT $LN11@stbi__pars

; 4301 :          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes

  00179	83 7c 24 28 00	 cmp	 DWORD PTR z$1[rsp], 0
  0017e	7d 11		 jge	 SHORT $LN13@stbi__pars
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00187	e8 00 00 00 00	 call	 stbi__err
  0018c	e9 11 05 00 00	 jmp	 $LN1@stbi__pars
$LN13@stbi__pars:

; 4302 :          if (zout >= a->zout_end) {

  00191	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00199	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0019d	48 39 44 24 20	 cmp	 QWORD PTR zout$[rsp], rax
  001a2	72 34		 jb	 SHORT $LN14@stbi__pars

; 4303 :             if (!stbi__zexpand(a, zout, 1)) return 0;

  001a4	41 b8 01 00 00
	00		 mov	 r8d, 1
  001aa	48 8b 54 24 20	 mov	 rdx, QWORD PTR zout$[rsp]
  001af	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001b7	e8 00 00 00 00	 call	 stbi__zexpand
  001bc	85 c0		 test	 eax, eax
  001be	75 07		 jne	 SHORT $LN15@stbi__pars
  001c0	33 c0		 xor	 eax, eax
  001c2	e9 db 04 00 00	 jmp	 $LN1@stbi__pars
$LN15@stbi__pars:

; 4304 :             zout = a->zout;

  001c7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001cf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001d3	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax
$LN14@stbi__pars:

; 4305 :          }
; 4306 :          *zout++ = (char) z;

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  001dd	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR z$1[rsp]
  001e2	88 08		 mov	 BYTE PTR [rax], cl
  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  001e9	48 ff c0	 inc	 rax
  001ec	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax

; 4307 :       } else {

  001f1	e9 a7 04 00 00	 jmp	 $LN12@stbi__pars
$LN11@stbi__pars:

; 4308 :          stbi_uc *p;
; 4309 :          int len,dist;
; 4310 :          if (z == 256) {

  001f6	81 7c 24 28 00
	01 00 00	 cmp	 DWORD PTR z$1[rsp], 256	; 00000100H
  001fe	75 1b		 jne	 SHORT $LN16@stbi__pars

; 4311 :             a->zout = zout;

  00200	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00208	48 8b 4c 24 20	 mov	 rcx, QWORD PTR zout$[rsp]
  0020d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4312 :             return 1;

  00211	b8 01 00 00 00	 mov	 eax, 1
  00216	e9 87 04 00 00	 jmp	 $LN1@stbi__pars
$LN16@stbi__pars:

; 4313 :          }
; 4314 :          if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data

  0021b	81 7c 24 28 1e
	01 00 00	 cmp	 DWORD PTR z$1[rsp], 286	; 0000011eH
  00223	7c 11		 jl	 SHORT $LN17@stbi__pars
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  0022c	e8 00 00 00 00	 call	 stbi__err
  00231	e9 6c 04 00 00	 jmp	 $LN1@stbi__pars
$LN17@stbi__pars:

; 4315 :          z -= 257;

  00236	8b 44 24 28	 mov	 eax, DWORD PTR z$1[rsp]
  0023a	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  0023f	89 44 24 28	 mov	 DWORD PTR z$1[rsp], eax

; 4316 :          len = stbi__zlength_base[z];

  00243	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  00248	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_base
  0024f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00252	89 44 24 38	 mov	 DWORD PTR len$3[rsp], eax

; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

  00256	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_extra
  00262	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00266	0f 84 db 00 00
	00		 je	 $LN18@stbi__pars
  0026c	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zlength_extra
  00278	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0027b	89 84 24 80 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  00282	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0028a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  00291	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00294	7d 0e		 jge	 SHORT $LN40@stbi__pars
  00296	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0029e	e8 00 00 00 00	 call	 stbi__fill_bits
  002a3	90		 npad	 1
$LN40@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  002a4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  002ab	b9 01 00 00 00	 mov	 ecx, 1
  002b0	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv328[rsp], ecx
  002b7	0f b6 c8	 movzx	 ecx, al
  002ba	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv328[rsp]
  002c1	d3 e0		 shl	 eax, cl
  002c3	ff c8		 dec	 eax
  002c5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002cd	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  002d0	23 c8		 and	 ecx, eax
  002d2	8b c1		 mov	 eax, ecx
  002d4	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$15[rsp], eax

; 4216 :    z->code_buffer >>= n;

  002db	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  002e2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002ea	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv334[rsp], rcx
  002f2	0f b6 c8	 movzx	 ecx, al
  002f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv334[rsp]
  002fd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00300	d3 e8		 shr	 eax, cl
  00302	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0030a	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0030d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00315	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  0031c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0031f	2b c1		 sub	 eax, ecx
  00321	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00329	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  0032c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$15[rsp]
  00333	89 44 24 4c	 mov	 DWORD PTR $T8[rsp], eax

; 4317 :          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

  00337	8b 44 24 4c	 mov	 eax, DWORD PTR $T8[rsp]
  0033b	8b 4c 24 38	 mov	 ecx, DWORD PTR len$3[rsp]
  0033f	03 c8		 add	 ecx, eax
  00341	8b c1		 mov	 eax, ecx
  00343	89 44 24 38	 mov	 DWORD PTR len$3[rsp], eax
$LN18@stbi__pars:

; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);

  00347	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0034f	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  00355	48 89 44 24 70	 mov	 QWORD PTR z$[rsp], rax

; 4243 :    if (a->num_bits < 16) {

  0035a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00362	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00366	7d 5f		 jge	 SHORT $LN43@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00368	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00370	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00378	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0037c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0037f	72 0d		 jb	 SHORT $LN49@stbi__pars
  00381	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv250[rsp], 1
  0038c	eb 0b		 jmp	 SHORT $LN50@stbi__pars
$LN49@stbi__pars:
  0038e	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv250[rsp], 0
$LN50@stbi__pars:
  00399	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv250[rsp]
  003a0	89 44 24 50	 mov	 DWORD PTR $T9[rsp], eax

; 4244 :       if (stbi__zeof(a)) {

  003a4	8b 44 24 50	 mov	 eax, DWORD PTR $T9[rsp]
  003a8	85 c0		 test	 eax, eax
  003aa	74 0d		 je	 SHORT $LN44@stbi__pars

; 4245 :          return -1;   /* report error for unexpected end of data. */

  003ac	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR $T10[rsp], -1
  003b4	e9 af 00 00 00	 jmp	 $LN42@stbi__pars
$LN44@stbi__pars:

; 4246 :       }
; 4247 :       stbi__fill_bits(a);

  003b9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  003c1	e8 00 00 00 00	 call	 stbi__fill_bits
  003c6	90		 npad	 1
$LN43@stbi__pars:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  003c7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  003cf	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003d2	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  003d7	8b c0		 mov	 eax, eax
  003d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  003de	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  003e2	89 44 24 78	 mov	 DWORD PTR b$13[rsp], eax

; 4250 :    if (b) {

  003e6	83 7c 24 78 00	 cmp	 DWORD PTR b$13[rsp], 0
  003eb	74 65		 je	 SHORT $LN45@stbi__pars

; 4251 :       s = b >> 9;

  003ed	8b 44 24 78	 mov	 eax, DWORD PTR b$13[rsp]
  003f1	c1 f8 09	 sar	 eax, 9
  003f4	89 44 24 7c	 mov	 DWORD PTR s$14[rsp], eax

; 4252 :       a->code_buffer >>= s;

  003f8	8b 44 24 7c	 mov	 eax, DWORD PTR s$14[rsp]
  003fc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00404	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv355[rsp], rcx
  0040c	0f b6 c8	 movzx	 ecx, al
  0040f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv355[rsp]
  00417	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0041a	d3 e8		 shr	 eax, cl
  0041c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00424	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4253 :       a->num_bits -= s;

  00427	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0042f	8b 4c 24 7c	 mov	 ecx, DWORD PTR s$14[rsp]
  00433	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00436	2b c1		 sub	 eax, ecx
  00438	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00440	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4254 :       return b & 511;

  00443	8b 44 24 78	 mov	 eax, DWORD PTR b$13[rsp]
  00447	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0044c	89 44 24 54	 mov	 DWORD PTR $T10[rsp], eax
  00450	eb 16		 jmp	 SHORT $LN42@stbi__pars
$LN45@stbi__pars:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

  00452	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00457	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0045f	e8 00 00 00 00	 call	 stbi__zhuffman_decode_slowpath
  00464	89 44 24 54	 mov	 DWORD PTR $T10[rsp], eax
$LN42@stbi__pars:

; 4318 :          z = stbi__zhuffman_decode(a, &a->z_distance);

  00468	8b 44 24 54	 mov	 eax, DWORD PTR $T10[rsp]
  0046c	89 44 24 28	 mov	 DWORD PTR z$1[rsp], eax

; 4319 :          if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data

  00470	83 7c 24 28 00	 cmp	 DWORD PTR z$1[rsp], 0
  00475	7c 07		 jl	 SHORT $LN20@stbi__pars
  00477	83 7c 24 28 1e	 cmp	 DWORD PTR z$1[rsp], 30
  0047c	7c 11		 jl	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:
  0047e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IIMLINA@bad?5huffman?5code@
  00485	e8 00 00 00 00	 call	 stbi__err
  0048a	e9 13 02 00 00	 jmp	 $LN1@stbi__pars
$LN19@stbi__pars:

; 4320 :          dist = stbi__zdist_base[z];

  0048f	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  00494	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_base
  0049b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0049e	89 44 24 3c	 mov	 DWORD PTR dist$4[rsp], eax

; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

  004a2	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  004a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_extra
  004ae	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  004b2	0f 84 c6 00 00
	00		 je	 $LN21@stbi__pars
  004b8	48 63 44 24 28	 movsxd	 rax, DWORD PTR z$1[rsp]
  004bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__zdist_extra
  004c4	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  004c7	89 44 24 60	 mov	 DWORD PTR n$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  004cb	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004d3	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  004d7	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  004da	7d 0e		 jge	 SHORT $LN52@stbi__pars
  004dc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  004e4	e8 00 00 00 00	 call	 stbi__fill_bits
  004e9	90		 npad	 1
$LN52@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  004ea	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  004ee	b9 01 00 00 00	 mov	 ecx, 1
  004f3	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv368[rsp], ecx
  004fa	0f b6 c8	 movzx	 ecx, al
  004fd	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv368[rsp]
  00504	d3 e0		 shl	 eax, cl
  00506	ff c8		 dec	 eax
  00508	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00510	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00513	23 c8		 and	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	89 44 24 68	 mov	 DWORD PTR k$12[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0051b	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  0051f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00527	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv374[rsp], rcx
  0052f	0f b6 c8	 movzx	 ecx, al
  00532	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv374[rsp]
  0053a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0053d	d3 e8		 shr	 eax, cl
  0053f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00547	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0054a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00552	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  00556	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00559	2b c1		 sub	 eax, ecx
  0055b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00563	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  00566	8b 44 24 68	 mov	 eax, DWORD PTR k$12[rsp]
  0056a	89 44 24 58	 mov	 DWORD PTR $T11[rsp], eax

; 4321 :          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

  0056e	8b 44 24 58	 mov	 eax, DWORD PTR $T11[rsp]
  00572	8b 4c 24 3c	 mov	 ecx, DWORD PTR dist$4[rsp]
  00576	03 c8		 add	 ecx, eax
  00578	8b c1		 mov	 eax, ecx
  0057a	89 44 24 3c	 mov	 DWORD PTR dist$4[rsp], eax
$LN21@stbi__pars:

; 4322 :          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

  0057e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00586	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0058a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR zout$[rsp]
  0058f	48 2b c8	 sub	 rcx, rax
  00592	48 8b c1	 mov	 rax, rcx
  00595	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR dist$4[rsp]
  0059a	48 3b c1	 cmp	 rax, rcx
  0059d	7d 11		 jge	 SHORT $LN22@stbi__pars
  0059f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DIAPIMGJ@bad?5dist@
  005a6	e8 00 00 00 00	 call	 stbi__err
  005ab	e9 f2 00 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:

; 4323 :          if (zout + len > a->zout_end) {

  005b0	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$3[rsp]
  005b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR zout$[rsp]
  005ba	48 03 c8	 add	 rcx, rax
  005bd	48 8b c1	 mov	 rax, rcx
  005c0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  005c8	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  005cc	76 33		 jbe	 SHORT $LN23@stbi__pars

; 4324 :             if (!stbi__zexpand(a, zout, len)) return 0;

  005ce	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$3[rsp]
  005d3	48 8b 54 24 20	 mov	 rdx, QWORD PTR zout$[rsp]
  005d8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  005e0	e8 00 00 00 00	 call	 stbi__zexpand
  005e5	85 c0		 test	 eax, eax
  005e7	75 07		 jne	 SHORT $LN24@stbi__pars
  005e9	33 c0		 xor	 eax, eax
  005eb	e9 b2 00 00 00	 jmp	 $LN1@stbi__pars
$LN24@stbi__pars:

; 4325 :             zout = a->zout;

  005f0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  005f8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  005fc	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax
$LN23@stbi__pars:

; 4326 :          }
; 4327 :          p = (stbi_uc *) (zout - dist);

  00601	48 63 44 24 3c	 movsxd	 rax, DWORD PTR dist$4[rsp]
  00606	48 8b 4c 24 20	 mov	 rcx, QWORD PTR zout$[rsp]
  0060b	48 2b c8	 sub	 rcx, rax
  0060e	48 8b c1	 mov	 rax, rcx
  00611	48 89 44 24 30	 mov	 QWORD PTR p$2[rsp], rax

; 4328 :          if (dist == 1) { // run of one byte; common in images.

  00616	83 7c 24 3c 01	 cmp	 DWORD PTR dist$4[rsp], 1
  0061b	75 3f		 jne	 SHORT $LN25@stbi__pars

; 4329 :             stbi_uc v = *p;

  0061d	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00622	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00625	88 44 24 40	 mov	 BYTE PTR v$5[rsp], al

; 4330 :             if (len) { do *zout++ = v; while (--len); }

  00629	83 7c 24 38 00	 cmp	 DWORD PTR len$3[rsp], 0
  0062e	74 2a		 je	 SHORT $LN27@stbi__pars
$LN7@stbi__pars:
  00630	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  00635	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR v$5[rsp]
  0063a	88 08		 mov	 BYTE PTR [rax], cl
  0063c	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  00641	48 ff c0	 inc	 rax
  00644	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax
  00649	8b 44 24 38	 mov	 eax, DWORD PTR len$3[rsp]
  0064d	ff c8		 dec	 eax
  0064f	89 44 24 38	 mov	 DWORD PTR len$3[rsp], eax
  00653	83 7c 24 38 00	 cmp	 DWORD PTR len$3[rsp], 0
  00658	75 d6		 jne	 SHORT $LN7@stbi__pars
$LN27@stbi__pars:

; 4331 :          } else {

  0065a	eb 41		 jmp	 SHORT $LN26@stbi__pars
$LN25@stbi__pars:

; 4332 :             if (len) { do *zout++ = *p++; while (--len); }

  0065c	83 7c 24 38 00	 cmp	 DWORD PTR len$3[rsp], 0
  00661	74 3a		 je	 SHORT $LN28@stbi__pars
$LN10@stbi__pars:
  00663	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  00668	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$2[rsp]
  0066d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00670	88 08		 mov	 BYTE PTR [rax], cl
  00672	48 8b 44 24 20	 mov	 rax, QWORD PTR zout$[rsp]
  00677	48 ff c0	 inc	 rax
  0067a	48 89 44 24 20	 mov	 QWORD PTR zout$[rsp], rax
  0067f	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00684	48 ff c0	 inc	 rax
  00687	48 89 44 24 30	 mov	 QWORD PTR p$2[rsp], rax
  0068c	8b 44 24 38	 mov	 eax, DWORD PTR len$3[rsp]
  00690	ff c8		 dec	 eax
  00692	89 44 24 38	 mov	 DWORD PTR len$3[rsp], eax
  00696	83 7c 24 38 00	 cmp	 DWORD PTR len$3[rsp], 0
  0069b	75 c6		 jne	 SHORT $LN10@stbi__pars
$LN28@stbi__pars:
$LN26@stbi__pars:
$LN12@stbi__pars:

; 4333 :          }
; 4334 :       }
; 4335 :    }

  0069d	e9 88 f9 ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 4336 : }

  006a2	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  006a9	5f		 pop	 rdi
  006aa	c3		 ret	 0
stbi__parse_huffman_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
z_codelength$ = 48
lencodes$ = 2112
codelength_sizes$ = 2600
i$ = 2628
n$ = 2632
hlit$ = 2636
hdist$ = 2640
hclen$ = 2644
ntot$ = 2648
s$6 = 2652
c$7 = 2656
fill$8 = 2660
$T9 = 2672
$T10 = 2676
$T11 = 2680
$T12 = 2684
$T13 = 2688
$T14 = 2692
$T15 = 2696
$T16 = 2700
$T17 = 2704
k$18 = 2708
k$19 = 2712
k$20 = 2716
b$21 = 2720
s$22 = 2724
k$23 = 2728
k$24 = 2732
k$25 = 2736
k$26 = 2740
tv269 = 2744
tv434 = 2752
tv172 = 2760
__$ArrayPad$ = 2768
a$ = 2800
stbi__compute_huffman_codes PROC

; 4339 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec e0 0a
	00 00		 sub	 rsp, 2784		; 00000ae0H
  0000d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00012	b9 b0 02 00 00	 mov	 ecx, 688		; 000002b0H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR [rsp+2800]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 d0
	0a 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  00044	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0004c	83 78 10 05	 cmp	 DWORD PTR [rax+16], 5
  00050	7d 0e		 jge	 SHORT $LN25@stbi__comp
  00052	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0005a	e8 00 00 00 00	 call	 stbi__fill_bits
  0005f	90		 npad	 1
$LN25@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	c1 e0 05	 shl	 eax, 5
  00068	ff c8		 dec	 eax
  0006a	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00072	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00075	23 c8		 and	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 84 24 b4 0a
	00 00		 mov	 DWORD PTR k$26[rsp], eax

; 4216 :    z->code_buffer >>= n;

  00080	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00088	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0008b	c1 e8 05	 shr	 eax, 5
  0008e	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00096	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  00099	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000a1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a4	83 e8 05	 sub	 eax, 5
  000a7	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000af	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  000b2	8b 84 24 b4 0a
	00 00		 mov	 eax, DWORD PTR k$26[rsp]
  000b9	89 84 24 70 0a
	00 00		 mov	 DWORD PTR $T9[rsp], eax

; 4340 :    static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4341 :    stbi__zhuffman z_codelength;
; 4342 :    stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4343 :    stbi_uc codelength_sizes[19];
; 4344 :    int i,n;
; 4345 : 
; 4346 :    int hlit  = stbi__zreceive(a,5) + 257;

  000c0	8b 84 24 70 0a
	00 00		 mov	 eax, DWORD PTR $T9[rsp]
  000c7	05 01 01 00 00	 add	 eax, 257		; 00000101H
  000cc	89 84 24 4c 0a
	00 00		 mov	 DWORD PTR hlit$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  000d3	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000db	83 78 10 05	 cmp	 DWORD PTR [rax+16], 5
  000df	7d 0e		 jge	 SHORT $LN28@stbi__comp
  000e1	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e9	e8 00 00 00 00	 call	 stbi__fill_bits
  000ee	90		 npad	 1
$LN28@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	c1 e0 05	 shl	 eax, 5
  000f7	ff c8		 dec	 eax
  000f9	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00101	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00104	23 c8		 and	 ecx, eax
  00106	8b c1		 mov	 eax, ecx
  00108	89 84 24 b0 0a
	00 00		 mov	 DWORD PTR k$25[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0010f	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00117	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011a	c1 e8 05	 shr	 eax, 5
  0011d	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00125	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  00128	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00130	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00133	83 e8 05	 sub	 eax, 5
  00136	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0013e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  00141	8b 84 24 b0 0a
	00 00		 mov	 eax, DWORD PTR k$25[rsp]
  00148	89 84 24 74 0a
	00 00		 mov	 DWORD PTR $T10[rsp], eax

; 4347 :    int hdist = stbi__zreceive(a,5) + 1;

  0014f	8b 84 24 74 0a
	00 00		 mov	 eax, DWORD PTR $T10[rsp]
  00156	ff c0		 inc	 eax
  00158	89 84 24 50 0a
	00 00		 mov	 DWORD PTR hdist$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  0015f	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00167	83 78 10 04	 cmp	 DWORD PTR [rax+16], 4
  0016b	7d 0e		 jge	 SHORT $LN31@stbi__comp
  0016d	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00175	e8 00 00 00 00	 call	 stbi__fill_bits
  0017a	90		 npad	 1
$LN31@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  0017b	b8 01 00 00 00	 mov	 eax, 1
  00180	c1 e0 04	 shl	 eax, 4
  00183	ff c8		 dec	 eax
  00185	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0018d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00190	23 c8		 and	 ecx, eax
  00192	8b c1		 mov	 eax, ecx
  00194	89 84 24 ac 0a
	00 00		 mov	 DWORD PTR k$24[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0019b	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001a3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001a6	c1 e8 04	 shr	 eax, 4
  001a9	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001b1	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  001b4	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001bc	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001bf	83 e8 04	 sub	 eax, 4
  001c2	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001ca	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  001cd	8b 84 24 ac 0a
	00 00		 mov	 eax, DWORD PTR k$24[rsp]
  001d4	89 84 24 78 0a
	00 00		 mov	 DWORD PTR $T11[rsp], eax

; 4348 :    int hclen = stbi__zreceive(a,4) + 4;

  001db	8b 84 24 78 0a
	00 00		 mov	 eax, DWORD PTR $T11[rsp]
  001e2	83 c0 04	 add	 eax, 4
  001e5	89 84 24 54 0a
	00 00		 mov	 DWORD PTR hclen$[rsp], eax

; 4349 :    int ntot  = hlit + hdist;

  001ec	8b 84 24 50 0a
	00 00		 mov	 eax, DWORD PTR hdist$[rsp]
  001f3	8b 8c 24 4c 0a
	00 00		 mov	 ecx, DWORD PTR hlit$[rsp]
  001fa	03 c8		 add	 ecx, eax
  001fc	8b c1		 mov	 eax, ecx
  001fe	89 84 24 58 0a
	00 00		 mov	 DWORD PTR ntot$[rsp], eax

; 4350 : 
; 4351 :    memset(codelength_sizes, 0, sizeof(codelength_sizes));

  00205	48 8d 84 24 28
	0a 00 00	 lea	 rax, QWORD PTR codelength_sizes$[rsp]
  0020d	48 8b f8	 mov	 rdi, rax
  00210	33 c0		 xor	 eax, eax
  00212	b9 13 00 00 00	 mov	 ecx, 19
  00217	f3 aa		 rep stosb

; 4352 :    for (i=0; i < hclen; ++i) {

  00219	c7 84 24 44 0a
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00224	eb 10		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  00226	8b 84 24 44 0a
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0022d	ff c0		 inc	 eax
  0022f	89 84 24 44 0a
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  00236	8b 84 24 54 0a
	00 00		 mov	 eax, DWORD PTR hclen$[rsp]
  0023d	39 84 24 44 0a
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00244	0f 8d b1 00 00
	00		 jge	 $LN3@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  0024a	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00252	83 78 10 03	 cmp	 DWORD PTR [rax+16], 3
  00256	7d 0e		 jge	 SHORT $LN34@stbi__comp
  00258	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00260	e8 00 00 00 00	 call	 stbi__fill_bits
  00265	90		 npad	 1
$LN34@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00266	b8 01 00 00 00	 mov	 eax, 1
  0026b	c1 e0 03	 shl	 eax, 3
  0026e	ff c8		 dec	 eax
  00270	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00278	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0027b	23 c8		 and	 ecx, eax
  0027d	8b c1		 mov	 eax, ecx
  0027f	89 84 24 a8 0a
	00 00		 mov	 DWORD PTR k$23[rsp], eax

; 4216 :    z->code_buffer >>= n;

  00286	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0028e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00291	c1 e8 03	 shr	 eax, 3
  00294	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0029c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0029f	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002a7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  002aa	83 e8 03	 sub	 eax, 3
  002ad	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002b5	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  002b8	8b 84 24 a8 0a
	00 00		 mov	 eax, DWORD PTR k$23[rsp]
  002bf	89 84 24 7c 0a
	00 00		 mov	 DWORD PTR $T12[rsp], eax

; 4353 :       int s = stbi__zreceive(a,3);

  002c6	8b 84 24 7c 0a
	00 00		 mov	 eax, DWORD PTR $T12[rsp]
  002cd	89 84 24 5c 0a
	00 00		 mov	 DWORD PTR s$6[rsp], eax

; 4354 :       codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;

  002d4	48 63 84 24 44
	0a 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  002dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@9@9
  002e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e7	0f b6 8c 24 5c
	0a 00 00	 movzx	 ecx, BYTE PTR s$6[rsp]
  002ef	88 8c 04 28 0a
	00 00		 mov	 BYTE PTR codelength_sizes$[rsp+rax], cl

; 4355 :    }

  002f6	e9 2b ff ff ff	 jmp	 $LN2@stbi__comp
$LN3@stbi__comp:

; 4356 :    if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

  002fb	41 b8 13 00 00
	00		 mov	 r8d, 19
  00301	48 8d 94 24 28
	0a 00 00	 lea	 rdx, QWORD PTR codelength_sizes$[rsp]
  00309	48 8d 4c 24 30	 lea	 rcx, QWORD PTR z_codelength$[rsp]
  0030e	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  00313	85 c0		 test	 eax, eax
  00315	75 07		 jne	 SHORT $LN7@stbi__comp
  00317	33 c0		 xor	 eax, eax
  00319	e9 ec 04 00 00	 jmp	 $LN1@stbi__comp
$LN7@stbi__comp:

; 4357 : 
; 4358 :    n = 0;

  0031e	c7 84 24 48 0a
	00 00 00 00 00
	00		 mov	 DWORD PTR n$[rsp], 0
$LN5@stbi__comp:

; 4359 :    while (n < ntot) {

  00329	8b 84 24 58 0a
	00 00		 mov	 eax, DWORD PTR ntot$[rsp]
  00330	39 84 24 48 0a
	00 00		 cmp	 DWORD PTR n$[rsp], eax
  00337	0f 8d 47 04 00
	00		 jge	 $LN6@stbi__comp

; 4243 :    if (a->num_bits < 16) {

  0033d	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00345	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00349	7d 68		 jge	 SHORT $LN37@stbi__comp

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  0034b	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00353	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0035b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0035f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00362	72 0d		 jb	 SHORT $LN43@stbi__comp
  00364	c7 84 24 b8 0a
	00 00 01 00 00
	00		 mov	 DWORD PTR tv269[rsp], 1
  0036f	eb 0b		 jmp	 SHORT $LN44@stbi__comp
$LN43@stbi__comp:
  00371	c7 84 24 b8 0a
	00 00 00 00 00
	00		 mov	 DWORD PTR tv269[rsp], 0
$LN44@stbi__comp:
  0037c	8b 84 24 b8 0a
	00 00		 mov	 eax, DWORD PTR tv269[rsp]
  00383	89 84 24 80 0a
	00 00		 mov	 DWORD PTR $T13[rsp], eax

; 4244 :       if (stbi__zeof(a)) {

  0038a	8b 84 24 80 0a
	00 00		 mov	 eax, DWORD PTR $T13[rsp]
  00391	85 c0		 test	 eax, eax
  00393	74 10		 je	 SHORT $LN38@stbi__comp

; 4245 :          return -1;   /* report error for unexpected end of data. */

  00395	c7 84 24 84 0a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR $T14[rsp], -1
  003a0	e9 c6 00 00 00	 jmp	 $LN36@stbi__comp
$LN38@stbi__comp:

; 4246 :       }
; 4247 :       stbi__fill_bits(a);

  003a5	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  003ad	e8 00 00 00 00	 call	 stbi__fill_bits
  003b2	90		 npad	 1
$LN37@stbi__comp:

; 4248 :    }
; 4249 :    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  003b3	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  003bb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003be	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  003c3	8b c0		 mov	 eax, eax
  003c5	0f b7 44 44 30	 movzx	 eax, WORD PTR z_codelength$[rsp+rax*2]
  003ca	89 84 24 a0 0a
	00 00		 mov	 DWORD PTR b$21[rsp], eax

; 4250 :    if (b) {

  003d1	83 bc 24 a0 0a
	00 00 00	 cmp	 DWORD PTR b$21[rsp], 0
  003d9	74 77		 je	 SHORT $LN39@stbi__comp

; 4251 :       s = b >> 9;

  003db	8b 84 24 a0 0a
	00 00		 mov	 eax, DWORD PTR b$21[rsp]
  003e2	c1 f8 09	 sar	 eax, 9
  003e5	89 84 24 a4 0a
	00 00		 mov	 DWORD PTR s$22[rsp], eax

; 4252 :       a->code_buffer >>= s;

  003ec	8b 84 24 a4 0a
	00 00		 mov	 eax, DWORD PTR s$22[rsp]
  003f3	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  003fb	48 89 8c 24 c0
	0a 00 00	 mov	 QWORD PTR tv434[rsp], rcx
  00403	0f b6 c8	 movzx	 ecx, al
  00406	48 8b 84 24 c0
	0a 00 00	 mov	 rax, QWORD PTR tv434[rsp]
  0040e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00411	d3 e8		 shr	 eax, cl
  00413	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0041b	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4253 :       a->num_bits -= s;

  0041e	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00426	8b 8c 24 a4 0a
	00 00		 mov	 ecx, DWORD PTR s$22[rsp]
  0042d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00430	2b c1		 sub	 eax, ecx
  00432	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0043a	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4254 :       return b & 511;

  0043d	8b 84 24 a0 0a
	00 00		 mov	 eax, DWORD PTR b$21[rsp]
  00444	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00449	89 84 24 84 0a
	00 00		 mov	 DWORD PTR $T14[rsp], eax
  00450	eb 19		 jmp	 SHORT $LN36@stbi__comp
$LN39@stbi__comp:

; 4255 :    }
; 4256 :    return stbi__zhuffman_decode_slowpath(a, z);

  00452	48 8d 54 24 30	 lea	 rdx, QWORD PTR z_codelength$[rsp]
  00457	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0045f	e8 00 00 00 00	 call	 stbi__zhuffman_decode_slowpath
  00464	89 84 24 84 0a
	00 00		 mov	 DWORD PTR $T14[rsp], eax
$LN36@stbi__comp:

; 4360 :       int c = stbi__zhuffman_decode(a, &z_codelength);

  0046b	8b 84 24 84 0a
	00 00		 mov	 eax, DWORD PTR $T14[rsp]
  00472	89 84 24 60 0a
	00 00		 mov	 DWORD PTR c$7[rsp], eax

; 4361 :       if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

  00479	83 bc 24 60 0a
	00 00 00	 cmp	 DWORD PTR c$7[rsp], 0
  00481	7c 0a		 jl	 SHORT $LN9@stbi__comp
  00483	83 bc 24 60 0a
	00 00 13	 cmp	 DWORD PTR c$7[rsp], 19
  0048b	7c 11		 jl	 SHORT $LN8@stbi__comp
$LN9@stbi__comp:
  0048d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  00494	e8 00 00 00 00	 call	 stbi__err
  00499	e9 6c 03 00 00	 jmp	 $LN1@stbi__comp
$LN8@stbi__comp:

; 4362 :       if (c < 16)

  0049e	83 bc 24 60 0a
	00 00 10	 cmp	 DWORD PTR c$7[rsp], 16
  004a6	7d 2c		 jge	 SHORT $LN10@stbi__comp

; 4363 :          lencodes[n++] = (stbi_uc) c;

  004a8	48 63 84 24 48
	0a 00 00	 movsxd	 rax, DWORD PTR n$[rsp]
  004b0	0f b6 8c 24 60
	0a 00 00	 movzx	 ecx, BYTE PTR c$7[rsp]
  004b8	88 8c 04 40 08
	00 00		 mov	 BYTE PTR lencodes$[rsp+rax], cl
  004bf	8b 84 24 48 0a
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  004c6	ff c0		 inc	 eax
  004c8	89 84 24 48 0a
	00 00		 mov	 DWORD PTR n$[rsp], eax
  004cf	e9 ab 02 00 00	 jmp	 $LN11@stbi__comp
$LN10@stbi__comp:

; 4364 :       else {
; 4365 :          stbi_uc fill = 0;

  004d4	c6 84 24 64 0a
	00 00 00	 mov	 BYTE PTR fill$8[rsp], 0

; 4366 :          if (c == 16) {

  004dc	83 bc 24 60 0a
	00 00 10	 cmp	 DWORD PTR c$7[rsp], 16
  004e4	0f 85 c7 00 00
	00		 jne	 $LN12@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  004ea	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004f2	83 78 10 02	 cmp	 DWORD PTR [rax+16], 2
  004f6	7d 0e		 jge	 SHORT $LN46@stbi__comp
  004f8	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00500	e8 00 00 00 00	 call	 stbi__fill_bits
  00505	90		 npad	 1
$LN46@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00506	b8 01 00 00 00	 mov	 eax, 1
  0050b	c1 e0 02	 shl	 eax, 2
  0050e	ff c8		 dec	 eax
  00510	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00518	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0051b	23 c8		 and	 ecx, eax
  0051d	8b c1		 mov	 eax, ecx
  0051f	89 84 24 9c 0a
	00 00		 mov	 DWORD PTR k$20[rsp], eax

; 4216 :    z->code_buffer >>= n;

  00526	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0052e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00531	c1 e8 02	 shr	 eax, 2
  00534	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0053c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0053f	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00547	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0054a	83 e8 02	 sub	 eax, 2
  0054d	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00555	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  00558	8b 84 24 9c 0a
	00 00		 mov	 eax, DWORD PTR k$20[rsp]
  0055f	89 84 24 88 0a
	00 00		 mov	 DWORD PTR $T15[rsp], eax

; 4367 :             c = stbi__zreceive(a,2)+3;

  00566	8b 84 24 88 0a
	00 00		 mov	 eax, DWORD PTR $T15[rsp]
  0056d	83 c0 03	 add	 eax, 3
  00570	89 84 24 60 0a
	00 00		 mov	 DWORD PTR c$7[rsp], eax

; 4368 :             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

  00577	83 bc 24 48 0a
	00 00 00	 cmp	 DWORD PTR n$[rsp], 0
  0057f	75 11		 jne	 SHORT $LN14@stbi__comp
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  00588	e8 00 00 00 00	 call	 stbi__err
  0058d	e9 78 02 00 00	 jmp	 $LN1@stbi__comp
$LN14@stbi__comp:

; 4369 :             fill = lencodes[n-1];

  00592	8b 84 24 48 0a
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00599	ff c8		 dec	 eax
  0059b	48 98		 cdqe
  0059d	0f b6 84 04 40
	08 00 00	 movzx	 eax, BYTE PTR lencodes$[rsp+rax]
  005a5	88 84 24 64 0a
	00 00		 mov	 BYTE PTR fill$8[rsp], al
  005ac	e9 4e 01 00 00	 jmp	 $LN13@stbi__comp
$LN12@stbi__comp:

; 4370 :          } else if (c == 17) {

  005b1	83 bc 24 60 0a
	00 00 11	 cmp	 DWORD PTR c$7[rsp], 17
  005b9	0f 85 92 00 00
	00		 jne	 $LN15@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  005bf	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  005c7	83 78 10 03	 cmp	 DWORD PTR [rax+16], 3
  005cb	7d 0e		 jge	 SHORT $LN49@stbi__comp
  005cd	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  005d5	e8 00 00 00 00	 call	 stbi__fill_bits
  005da	90		 npad	 1
$LN49@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  005db	b8 01 00 00 00	 mov	 eax, 1
  005e0	c1 e0 03	 shl	 eax, 3
  005e3	ff c8		 dec	 eax
  005e5	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  005ed	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  005f0	23 c8		 and	 ecx, eax
  005f2	8b c1		 mov	 eax, ecx
  005f4	89 84 24 98 0a
	00 00		 mov	 DWORD PTR k$19[rsp], eax

; 4216 :    z->code_buffer >>= n;

  005fb	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00603	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00606	c1 e8 03	 shr	 eax, 3
  00609	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00611	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  00614	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0061c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0061f	83 e8 03	 sub	 eax, 3
  00622	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0062a	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  0062d	8b 84 24 98 0a
	00 00		 mov	 eax, DWORD PTR k$19[rsp]
  00634	89 84 24 8c 0a
	00 00		 mov	 DWORD PTR $T16[rsp], eax

; 4371 :             c = stbi__zreceive(a,3)+3;

  0063b	8b 84 24 8c 0a
	00 00		 mov	 eax, DWORD PTR $T16[rsp]
  00642	83 c0 03	 add	 eax, 3
  00645	89 84 24 60 0a
	00 00		 mov	 DWORD PTR c$7[rsp], eax
  0064c	e9 ae 00 00 00	 jmp	 $LN16@stbi__comp
$LN15@stbi__comp:

; 4372 :          } else if (c == 18) {

  00651	83 bc 24 60 0a
	00 00 12	 cmp	 DWORD PTR c$7[rsp], 18
  00659	0f 85 8f 00 00
	00		 jne	 $LN17@stbi__comp

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  0065f	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00667	83 78 10 07	 cmp	 DWORD PTR [rax+16], 7
  0066b	7d 0e		 jge	 SHORT $LN52@stbi__comp
  0066d	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00675	e8 00 00 00 00	 call	 stbi__fill_bits
  0067a	90		 npad	 1
$LN52@stbi__comp:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  0067b	b8 01 00 00 00	 mov	 eax, 1
  00680	c1 e0 07	 shl	 eax, 7
  00683	ff c8		 dec	 eax
  00685	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0068d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00690	23 c8		 and	 ecx, eax
  00692	8b c1		 mov	 eax, ecx
  00694	89 84 24 94 0a
	00 00		 mov	 DWORD PTR k$18[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0069b	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  006a3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  006a6	c1 e8 07	 shr	 eax, 7
  006a9	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  006b1	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  006b4	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  006bc	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  006bf	83 e8 07	 sub	 eax, 7
  006c2	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  006ca	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  006cd	8b 84 24 94 0a
	00 00		 mov	 eax, DWORD PTR k$18[rsp]
  006d4	89 84 24 90 0a
	00 00		 mov	 DWORD PTR $T17[rsp], eax

; 4373 :             c = stbi__zreceive(a,7)+11;

  006db	8b 84 24 90 0a
	00 00		 mov	 eax, DWORD PTR $T17[rsp]
  006e2	83 c0 0b	 add	 eax, 11
  006e5	89 84 24 60 0a
	00 00		 mov	 DWORD PTR c$7[rsp], eax

; 4374 :          } else {

  006ec	eb 11		 jmp	 SHORT $LN18@stbi__comp
$LN17@stbi__comp:

; 4375 :             return stbi__err("bad codelengths", "Corrupt PNG");

  006ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  006f5	e8 00 00 00 00	 call	 stbi__err
  006fa	e9 0b 01 00 00	 jmp	 $LN1@stbi__comp
$LN18@stbi__comp:
$LN16@stbi__comp:
$LN13@stbi__comp:

; 4376 :          }
; 4377 :          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

  006ff	8b 84 24 48 0a
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00706	8b 8c 24 58 0a
	00 00		 mov	 ecx, DWORD PTR ntot$[rsp]
  0070d	2b c8		 sub	 ecx, eax
  0070f	8b c1		 mov	 eax, ecx
  00711	3b 84 24 60 0a
	00 00		 cmp	 eax, DWORD PTR c$7[rsp]
  00718	7d 11		 jge	 SHORT $LN19@stbi__comp
  0071a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  00721	e8 00 00 00 00	 call	 stbi__err
  00726	e9 df 00 00 00	 jmp	 $LN1@stbi__comp
$LN19@stbi__comp:

; 4378 :          memset(lencodes+n, fill, c);

  0072b	48 63 84 24 60
	0a 00 00	 movsxd	 rax, DWORD PTR c$7[rsp]
  00733	48 89 84 24 c8
	0a 00 00	 mov	 QWORD PTR tv172[rsp], rax
  0073b	0f b6 8c 24 64
	0a 00 00	 movzx	 ecx, BYTE PTR fill$8[rsp]
  00743	48 63 94 24 48
	0a 00 00	 movsxd	 rdx, DWORD PTR n$[rsp]
  0074b	48 8d 94 14 40
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp+rdx]
  00753	48 63 c9	 movsxd	 rcx, ecx
  00756	48 8b fa	 mov	 rdi, rdx
  00759	48 8b c1	 mov	 rax, rcx
  0075c	48 8b 8c 24 c8
	0a 00 00	 mov	 rcx, QWORD PTR tv172[rsp]
  00764	f3 aa		 rep stosb

; 4379 :          n += c;

  00766	8b 84 24 60 0a
	00 00		 mov	 eax, DWORD PTR c$7[rsp]
  0076d	8b 8c 24 48 0a
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  00774	03 c8		 add	 ecx, eax
  00776	8b c1		 mov	 eax, ecx
  00778	89 84 24 48 0a
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__comp:

; 4380 :       }
; 4381 :    }

  0077f	e9 a5 fb ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:

; 4382 :    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");

  00784	8b 84 24 58 0a
	00 00		 mov	 eax, DWORD PTR ntot$[rsp]
  0078b	39 84 24 48 0a
	00 00		 cmp	 DWORD PTR n$[rsp], eax
  00792	74 0e		 je	 SHORT $LN20@stbi__comp
  00794	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDNKOBMC@bad?5codelengths@
  0079b	e8 00 00 00 00	 call	 stbi__err
  007a0	eb 68		 jmp	 SHORT $LN1@stbi__comp
$LN20@stbi__comp:

; 4383 :    if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

  007a2	48 8b 84 24 f0
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  007aa	48 83 c0 34	 add	 rax, 52			; 00000034H
  007ae	44 8b 84 24 4c
	0a 00 00	 mov	 r8d, DWORD PTR hlit$[rsp]
  007b6	48 8d 94 24 40
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp]
  007be	48 8b c8	 mov	 rcx, rax
  007c1	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  007c6	85 c0		 test	 eax, eax
  007c8	75 04		 jne	 SHORT $LN21@stbi__comp
  007ca	33 c0		 xor	 eax, eax
  007cc	eb 3c		 jmp	 SHORT $LN1@stbi__comp
$LN21@stbi__comp:

; 4384 :    if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

  007ce	48 63 84 24 4c
	0a 00 00	 movsxd	 rax, DWORD PTR hlit$[rsp]
  007d6	48 8d 84 04 40
	08 00 00	 lea	 rax, QWORD PTR lencodes$[rsp+rax]
  007de	48 8b 8c 24 f0
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  007e6	48 81 c1 18 08
	00 00		 add	 rcx, 2072		; 00000818H
  007ed	44 8b 84 24 50
	0a 00 00	 mov	 r8d, DWORD PTR hdist$[rsp]
  007f5	48 8b d0	 mov	 rdx, rax
  007f8	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  007fd	85 c0		 test	 eax, eax
  007ff	75 04		 jne	 SHORT $LN22@stbi__comp
  00801	33 c0		 xor	 eax, eax
  00803	eb 05		 jmp	 SHORT $LN1@stbi__comp
$LN22@stbi__comp:

; 4385 :    return 1;

  00805	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__comp:

; 4386 : }

  0080a	48 8b f8	 mov	 rdi, rax
  0080d	48 8b cc	 mov	 rcx, rsp
  00810	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__compute_huffman_codes$rtcFrameData
  00817	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0081c	48 8b c7	 mov	 rax, rdi
  0081f	48 8b 8c 24 d0
	0a 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00827	48 33 cc	 xor	 rcx, rsp
  0082a	e8 00 00 00 00	 call	 __security_check_cookie
  0082f	48 81 c4 e0 0a
	00 00		 add	 rsp, 2784		; 00000ae0H
  00836	5f		 pop	 rdi
  00837	c3		 ret	 0
stbi__compute_huffman_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
header$ = 36
len$ = 52
nlen$ = 56
k$ = 60
$T4 = 64
$T5 = 68
n$ = 72
k$6 = 80
tv232 = 84
tv238 = 88
tv209 = 96
tv204 = 100
a$ = 144
stbi__parse_uncompressed_block PROC

; 4389 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00010	b9 16 00 00 00	 mov	 ecx, 22
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0002b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4390 :    stbi_uc header[4];
; 4391 :    int len,nlen,k;
; 4392 :    if (a->num_bits & 7)

  00030	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00038	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003b	83 e0 07	 and	 eax, 7
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 a1 00 00
	00		 je	 $LN6@stbi__pars

; 4393 :       stbi__zreceive(a, a->num_bits & 7); // discard

  00046	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0004e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00051	83 e0 07	 and	 eax, 7
  00054	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  00058	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00060	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00064	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00067	7d 0e		 jge	 SHORT $LN14@stbi__pars
  00069	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00071	e8 00 00 00 00	 call	 stbi__fill_bits
  00076	90		 npad	 1
$LN14@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00077	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0007b	b9 01 00 00 00	 mov	 ecx, 1
  00080	89 4c 24 54	 mov	 DWORD PTR tv232[rsp], ecx
  00084	0f b6 c8	 movzx	 ecx, al
  00087	8b 44 24 54	 mov	 eax, DWORD PTR tv232[rsp]
  0008b	d3 e0		 shl	 eax, cl
  0008d	ff c8		 dec	 eax
  0008f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00097	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0009a	23 c8		 and	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	89 44 24 50	 mov	 DWORD PTR k$6[rsp], eax

; 4216 :    z->code_buffer >>= n;

  000a2	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  000a6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 89 4c 24 58	 mov	 QWORD PTR tv238[rsp], rcx
  000b3	0f b6 c8	 movzx	 ecx, al
  000b6	48 8b 44 24 58	 mov	 rax, QWORD PTR tv238[rsp]
  000bb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000be	d3 e8		 shr	 eax, cl
  000c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000c8	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  000cb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000d3	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  000d7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000da	2b c1		 sub	 eax, ecx
  000dc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e4	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN6@stbi__pars:

; 4394 :    // drain the bit-packed data into header
; 4395 :    k = 0;

  000e7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN2@stbi__pars:

; 4396 :    while (a->num_bits > 0) {

  000ef	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000f7	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  000fb	7e 57		 jle	 SHORT $LN3@stbi__pars

; 4397 :       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check

  000fd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00105	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00108	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010d	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR k$[rsp]
  00112	88 44 0c 24	 mov	 BYTE PTR header$[rsp+rcx], al
  00116	8b 44 24 3c	 mov	 eax, DWORD PTR k$[rsp]
  0011a	ff c0		 inc	 eax
  0011c	89 44 24 3c	 mov	 DWORD PTR k$[rsp], eax

; 4398 :       a->code_buffer >>= 8;

  00120	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00128	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0012b	c1 e8 08	 shr	 eax, 8
  0012e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00136	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4399 :       a->num_bits -= 8;

  00139	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00141	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00144	83 e8 08	 sub	 eax, 8
  00147	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0014f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4400 :    }

  00152	eb 9b		 jmp	 SHORT $LN2@stbi__pars
$LN3@stbi__pars:

; 4401 :    if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");

  00154	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0015c	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00160	7d 11		 jge	 SHORT $LN7@stbi__pars
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IECDHMDI@zlib?5corrupt@
  00169	e8 00 00 00 00	 call	 stbi__err
  0016e	e9 e3 01 00 00	 jmp	 $LN1@stbi__pars
$LN7@stbi__pars:
$LN4@stbi__pars:

; 4402 :    // now fill header the normal way
; 4403 :    while (k < 4)

  00173	83 7c 24 3c 04	 cmp	 DWORD PTR k$[rsp], 4
  00178	0f 8d 96 00 00
	00		 jge	 $LN5@stbi__pars

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  0017e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00186	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0018e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00192	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00195	72 0a		 jb	 SHORT $LN22@stbi__pars
  00197	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  0019f	eb 08		 jmp	 SHORT $LN23@stbi__pars
$LN22@stbi__pars:
  001a1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN23@stbi__pars:
  001a9	8b 44 24 60	 mov	 eax, DWORD PTR tv209[rsp]
  001ad	89 44 24 40	 mov	 DWORD PTR $T4[rsp], eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

  001b1	8b 44 24 40	 mov	 eax, DWORD PTR $T4[rsp]
  001b5	85 c0		 test	 eax, eax
  001b7	74 0a		 je	 SHORT $LN18@stbi__pars
  001b9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
  001c1	eb 2b		 jmp	 SHORT $LN19@stbi__pars
$LN18@stbi__pars:
  001c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ce	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d1	89 44 24 64	 mov	 DWORD PTR tv204[rsp], eax
  001d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e0	48 ff c0	 inc	 rax
  001e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001eb	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN19@stbi__pars:
  001ee	0f b6 44 24 64	 movzx	 eax, BYTE PTR tv204[rsp]
  001f3	88 44 24 44	 mov	 BYTE PTR $T5[rsp], al

; 4404 :       header[k++] = stbi__zget8(a);

  001f7	0f b6 44 24 44	 movzx	 eax, BYTE PTR $T5[rsp]
  001fc	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR k$[rsp]
  00201	88 44 0c 24	 mov	 BYTE PTR header$[rsp+rcx], al
  00205	8b 44 24 3c	 mov	 eax, DWORD PTR k$[rsp]
  00209	ff c0		 inc	 eax
  0020b	89 44 24 3c	 mov	 DWORD PTR k$[rsp], eax
  0020f	e9 5f ff ff ff	 jmp	 $LN4@stbi__pars
$LN5@stbi__pars:

; 4405 :    len  = header[1] * 256 + header[0];

  00214	b8 01 00 00 00	 mov	 eax, 1
  00219	48 6b c0 01	 imul	 rax, rax, 1
  0021d	0f b6 44 04 24	 movzx	 eax, BYTE PTR header$[rsp+rax]
  00222	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	48 6b c9 00	 imul	 rcx, rcx, 0
  00231	0f b6 4c 0c 24	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  00236	03 c1		 add	 eax, ecx
  00238	89 44 24 34	 mov	 DWORD PTR len$[rsp], eax

; 4406 :    nlen = header[3] * 256 + header[2];

  0023c	b8 01 00 00 00	 mov	 eax, 1
  00241	48 6b c0 03	 imul	 rax, rax, 3
  00245	0f b6 44 04 24	 movzx	 eax, BYTE PTR header$[rsp+rax]
  0024a	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00250	b9 01 00 00 00	 mov	 ecx, 1
  00255	48 6b c9 02	 imul	 rcx, rcx, 2
  00259	0f b6 4c 0c 24	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  0025e	03 c1		 add	 eax, ecx
  00260	89 44 24 38	 mov	 DWORD PTR nlen$[rsp], eax

; 4407 :    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");

  00264	8b 44 24 34	 mov	 eax, DWORD PTR len$[rsp]
  00268	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  0026d	39 44 24 38	 cmp	 DWORD PTR nlen$[rsp], eax
  00271	74 11		 je	 SHORT $LN8@stbi__pars
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IECDHMDI@zlib?5corrupt@
  0027a	e8 00 00 00 00	 call	 stbi__err
  0027f	e9 d2 00 00 00	 jmp	 $LN1@stbi__pars
$LN8@stbi__pars:

; 4408 :    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

  00284	48 63 44 24 34	 movsxd	 rax, DWORD PTR len$[rsp]
  00289	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00291	48 03 01	 add	 rax, QWORD PTR [rcx]
  00294	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0029c	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  002a0	76 11		 jbe	 SHORT $LN9@stbi__pars
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@PIPBCKIA@read?5past?5buffer@
  002a9	e8 00 00 00 00	 call	 stbi__err
  002ae	e9 a3 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 4409 :    if (a->zout + len > a->zout_end)

  002b3	48 63 44 24 34	 movsxd	 rax, DWORD PTR len$[rsp]
  002b8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002c0	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  002c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002cc	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  002d0	76 26		 jbe	 SHORT $LN10@stbi__pars

; 4410 :       if (!stbi__zexpand(a, a->zout, len)) return 0;

  002d2	44 8b 44 24 34	 mov	 r8d, DWORD PTR len$[rsp]
  002d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002df	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  002e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002eb	e8 00 00 00 00	 call	 stbi__zexpand
  002f0	85 c0		 test	 eax, eax
  002f2	75 04		 jne	 SHORT $LN11@stbi__pars
  002f4	33 c0		 xor	 eax, eax
  002f6	eb 5e		 jmp	 SHORT $LN1@stbi__pars
$LN11@stbi__pars:
$LN10@stbi__pars:

; 4411 :    memcpy(a->zout, a->zbuffer, len);

  002f8	48 63 44 24 34	 movsxd	 rax, DWORD PTR len$[rsp]
  002fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00305	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  0030d	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00311	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
  00314	48 8b c8	 mov	 rcx, rax
  00317	f3 a4		 rep movsb

; 4412 :    a->zbuffer += len;

  00319	48 63 44 24 34	 movsxd	 rax, DWORD PTR len$[rsp]
  0031e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00326	48 03 01	 add	 rax, QWORD PTR [rcx]
  00329	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00331	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4413 :    a->zout += len;

  00334	48 63 44 24 34	 movsxd	 rax, DWORD PTR len$[rsp]
  00339	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00341	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00345	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0034d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4414 :    return 1;

  00351	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4415 : }

  00356	48 8b f8	 mov	 rdi, rax
  00359	48 8b cc	 mov	 rcx, rsp
  0035c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_uncompressed_block$rtcFrameData
  00363	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00368	48 8b c7	 mov	 rax, rdi
  0036b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0036f	5f		 pop	 rdi
  00370	5e		 pop	 rsi
  00371	c3		 ret	 0
stbi__parse_uncompressed_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
cmf$ = 32
cm$ = 36
flg$ = 40
$T1 = 44
$T2 = 48
$T3 = 52
$T4 = 56
$T5 = 60
tv136 = 64
tv131 = 68
tv149 = 72
tv144 = 76
tv151 = 80
a$ = 112
stbi__parse_zlib_header PROC

; 4418 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  00020	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00024	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00027	72 0a		 jb	 SHORT $LN13@stbi__pars
  00029	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN14@stbi__pars
$LN13@stbi__pars:
  00033	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN14@stbi__pars:
  0003b	8b 44 24 40	 mov	 eax, DWORD PTR tv136[rsp]
  0003f	89 44 24 2c	 mov	 DWORD PTR $T1[rsp], eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

  00043	8b 44 24 2c	 mov	 eax, DWORD PTR $T1[rsp]
  00047	85 c0		 test	 eax, eax
  00049	74 0a		 je	 SHORT $LN9@stbi__pars
  0004b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
  00053	eb 22		 jmp	 SHORT $LN10@stbi__pars
$LN9@stbi__pars:
  00055	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0005a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00060	89 44 24 44	 mov	 DWORD PTR tv131[rsp], eax
  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 ff c0	 inc	 rax
  0006f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN10@stbi__pars:
  00077	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv131[rsp]
  0007c	88 44 24 30	 mov	 BYTE PTR $T2[rsp], al

; 4419 :    int cmf   = stbi__zget8(a);

  00080	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T2[rsp]
  00085	0f b6 c0	 movzx	 eax, al
  00088	89 44 24 20	 mov	 DWORD PTR cmf$[rsp], eax

; 4420 :    int cm    = cmf & 15;

  0008c	8b 44 24 20	 mov	 eax, DWORD PTR cmf$[rsp]
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 24	 mov	 DWORD PTR cm$[rsp], eax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  0009c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  000a1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a5	48 39 08	 cmp	 QWORD PTR [rax], rcx
  000a8	72 0a		 jb	 SHORT $LN21@stbi__pars
  000aa	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  000b2	eb 08		 jmp	 SHORT $LN22@stbi__pars
$LN21@stbi__pars:
  000b4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN22@stbi__pars:
  000bc	8b 44 24 48	 mov	 eax, DWORD PTR tv149[rsp]
  000c0	89 44 24 34	 mov	 DWORD PTR $T3[rsp], eax

; 4196 :    return stbi__zeof(z) ? 0 : *z->zbuffer++;

  000c4	8b 44 24 34	 mov	 eax, DWORD PTR $T3[rsp]
  000c8	85 c0		 test	 eax, eax
  000ca	74 0a		 je	 SHORT $LN17@stbi__pars
  000cc	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
  000d4	eb 22		 jmp	 SHORT $LN18@stbi__pars
$LN17@stbi__pars:
  000d6	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000de	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e1	89 44 24 4c	 mov	 DWORD PTR tv144[rsp], eax
  000e5	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000ea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ed	48 ff c0	 inc	 rax
  000f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  000f5	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN18@stbi__pars:
  000f8	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv144[rsp]
  000fd	88 44 24 38	 mov	 BYTE PTR $T4[rsp], al

; 4421 :    /* int cinfo = cmf >> 4; */
; 4422 :    int flg   = stbi__zget8(a);

  00101	0f b6 44 24 38	 movzx	 eax, BYTE PTR $T4[rsp]
  00106	0f b6 c0	 movzx	 eax, al
  00109	89 44 24 28	 mov	 DWORD PTR flg$[rsp], eax

; 4191 :    return (z->zbuffer >= z->zbuffer_end);

  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00112	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  00117	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0011b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0011e	72 0a		 jb	 SHORT $LN25@stbi__pars
  00120	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00128	eb 08		 jmp	 SHORT $LN26@stbi__pars
$LN25@stbi__pars:
  0012a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN26@stbi__pars:
  00132	8b 44 24 50	 mov	 eax, DWORD PTR tv151[rsp]
  00136	89 44 24 3c	 mov	 DWORD PTR $T5[rsp], eax

; 4423 :    if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  0013a	8b 44 24 3c	 mov	 eax, DWORD PTR $T5[rsp]
  0013e	85 c0		 test	 eax, eax
  00140	74 0e		 je	 SHORT $LN2@stbi__pars
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
  00149	e8 00 00 00 00	 call	 stbi__err
  0014e	eb 5b		 jmp	 SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 4424 :    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  00150	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR cmf$[rsp], 256 ; 00000100H
  00158	03 44 24 28	 add	 eax, DWORD PTR flg$[rsp]
  0015c	99		 cdq
  0015d	b9 1f 00 00 00	 mov	 ecx, 31
  00162	f7 f9		 idiv	 ecx
  00164	8b c2		 mov	 eax, edx
  00166	85 c0		 test	 eax, eax
  00168	74 0e		 je	 SHORT $LN3@stbi__pars
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@OBKOPAFL@bad?5zlib?5header@
  00171	e8 00 00 00 00	 call	 stbi__err
  00176	eb 33		 jmp	 SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 4425 :    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

  00178	8b 44 24 28	 mov	 eax, DWORD PTR flg$[rsp]
  0017c	83 e0 20	 and	 eax, 32			; 00000020H
  0017f	85 c0		 test	 eax, eax
  00181	74 0e		 je	 SHORT $LN4@stbi__pars
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@DOGMHEBI@no?5preset?5dict@
  0018a	e8 00 00 00 00	 call	 stbi__err
  0018f	eb 1a		 jmp	 SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 4426 :    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

  00191	83 7c 24 24 08	 cmp	 DWORD PTR cm$[rsp], 8
  00196	74 0e		 je	 SHORT $LN5@stbi__pars
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@
  0019f	e8 00 00 00 00	 call	 stbi__err
  001a4	eb 05		 jmp	 SHORT $LN1@stbi__pars
$LN5@stbi__pars:

; 4427 :    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4428 :    return 1;

  001a6	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4429 : }

  001ab	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001af	5f		 pop	 rdi
  001b0	c3		 ret	 0
stbi__parse_zlib_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
final$ = 32
type$ = 36
$T1 = 40
$T2 = 44
k$3 = 48
k$4 = 52
a$ = 80
parse_header$ = 88
stbi__parse_zlib PROC

; 4461 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4462 :    int final, type;
; 4463 :    if (parse_header)

  0001a	83 7c 24 58 00	 cmp	 DWORD PTR parse_header$[rsp], 0
  0001f	74 15		 je	 SHORT $LN5@stbi__pars

; 4464 :       if (!stbi__parse_zlib_header(a)) return 0;

  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00026	e8 00 00 00 00	 call	 stbi__parse_zlib_header
  0002b	85 c0		 test	 eax, eax
  0002d	75 07		 jne	 SHORT $LN6@stbi__pars
  0002f	33 c0		 xor	 eax, eax
  00031	e9 9d 01 00 00	 jmp	 $LN1@stbi__pars
$LN6@stbi__pars:
$LN5@stbi__pars:

; 4465 :    a->num_bits = 0;

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0003b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 4466 :    a->code_buffer = 0;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00047	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN4@stbi__pars:

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00053	83 78 10 01	 cmp	 DWORD PTR [rax+16], 1
  00057	7d 0b		 jge	 SHORT $LN20@stbi__pars
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0005e	e8 00 00 00 00	 call	 stbi__fill_bits
  00063	90		 npad	 1
$LN20@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	d1 e0		 shl	 eax, 1
  0006b	ff c8		 dec	 eax
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00072	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00075	23 c8		 and	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 44 24 34	 mov	 DWORD PTR k$4[rsp], eax

; 4216 :    z->code_buffer >>= n;

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00082	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00085	d1 e8		 shr	 eax, 1
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0008c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00094	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00097	ff c8		 dec	 eax
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0009e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  000a1	8b 44 24 34	 mov	 eax, DWORD PTR k$4[rsp]
  000a5	89 44 24 28	 mov	 DWORD PTR $T1[rsp], eax

; 4467 :    do {
; 4468 :       final = stbi__zreceive(a,1);

  000a9	8b 44 24 28	 mov	 eax, DWORD PTR $T1[rsp]
  000ad	89 44 24 20	 mov	 DWORD PTR final$[rsp], eax

; 4214 :    if (z->num_bits < n) stbi__fill_bits(z);

  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000b6	83 78 10 02	 cmp	 DWORD PTR [rax+16], 2
  000ba	7d 0b		 jge	 SHORT $LN23@stbi__pars
  000bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000c1	e8 00 00 00 00	 call	 stbi__fill_bits
  000c6	90		 npad	 1
$LN23@stbi__pars:

; 4215 :    k = z->code_buffer & ((1 << n) - 1);

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	c1 e0 02	 shl	 eax, 2
  000cf	ff c8		 dec	 eax
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000d6	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  000d9	23 c8		 and	 ecx, eax
  000db	8b c1		 mov	 eax, ecx
  000dd	89 44 24 30	 mov	 DWORD PTR k$3[rsp], eax

; 4216 :    z->code_buffer >>= n;

  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000e6	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000e9	c1 e8 02	 shr	 eax, 2
  000ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000f1	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4217 :    z->num_bits -= n;

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000f9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000fc	83 e8 02	 sub	 eax, 2
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00104	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4218 :    return k;

  00107	8b 44 24 30	 mov	 eax, DWORD PTR k$3[rsp]
  0010b	89 44 24 2c	 mov	 DWORD PTR $T2[rsp], eax

; 4469 :       type = stbi__zreceive(a,2);

  0010f	8b 44 24 2c	 mov	 eax, DWORD PTR $T2[rsp]
  00113	89 44 24 24	 mov	 DWORD PTR type$[rsp], eax

; 4470 :       if (type == 0) {

  00117	83 7c 24 24 00	 cmp	 DWORD PTR type$[rsp], 0
  0011c	75 1a		 jne	 SHORT $LN7@stbi__pars

; 4471 :          if (!stbi__parse_uncompressed_block(a)) return 0;

  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00123	e8 00 00 00 00	 call	 stbi__parse_uncompressed_block
  00128	85 c0		 test	 eax, eax
  0012a	75 07		 jne	 SHORT $LN9@stbi__pars
  0012c	33 c0		 xor	 eax, eax
  0012e	e9 a0 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 4472 :       } else if (type == 3) {

  00133	e9 8b 00 00 00	 jmp	 $LN8@stbi__pars
$LN7@stbi__pars:
  00138	83 7c 24 24 03	 cmp	 DWORD PTR type$[rsp], 3
  0013d	75 09		 jne	 SHORT $LN10@stbi__pars

; 4473 :          return 0;

  0013f	33 c0		 xor	 eax, eax
  00141	e9 8d 00 00 00	 jmp	 $LN1@stbi__pars

; 4474 :       } else {

  00146	eb 7b		 jmp	 SHORT $LN11@stbi__pars
$LN10@stbi__pars:

; 4475 :          if (type == 1) {

  00148	83 7c 24 24 01	 cmp	 DWORD PTR type$[rsp], 1
  0014d	75 50		 jne	 SHORT $LN12@stbi__pars

; 4476 :             // use fixed code lengths
; 4477 :             if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;

  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00154	48 83 c0 34	 add	 rax, 52			; 00000034H
  00158	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zdefault_length
  00165	48 8b c8	 mov	 rcx, rax
  00168	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  0016d	85 c0		 test	 eax, eax
  0016f	75 04		 jne	 SHORT $LN14@stbi__pars
  00171	33 c0		 xor	 eax, eax
  00173	eb 5e		 jmp	 SHORT $LN1@stbi__pars
$LN14@stbi__pars:

; 4478 :             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0017a	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  00180	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__zdefault_distance
  0018d	48 8b c8	 mov	 rcx, rax
  00190	e8 00 00 00 00	 call	 stbi__zbuild_huffman
  00195	85 c0		 test	 eax, eax
  00197	75 04		 jne	 SHORT $LN15@stbi__pars
  00199	33 c0		 xor	 eax, eax
  0019b	eb 36		 jmp	 SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 4479 :          } else {

  0019d	eb 12		 jmp	 SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 4480 :             if (!stbi__compute_huffman_codes(a)) return 0;

  0019f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001a4	e8 00 00 00 00	 call	 stbi__compute_huffman_codes
  001a9	85 c0		 test	 eax, eax
  001ab	75 04		 jne	 SHORT $LN16@stbi__pars
  001ad	33 c0		 xor	 eax, eax
  001af	eb 22		 jmp	 SHORT $LN1@stbi__pars
$LN16@stbi__pars:
$LN13@stbi__pars:

; 4481 :          }
; 4482 :          if (!stbi__parse_huffman_block(a)) return 0;

  001b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001b6	e8 00 00 00 00	 call	 stbi__parse_huffman_block
  001bb	85 c0		 test	 eax, eax
  001bd	75 04		 jne	 SHORT $LN17@stbi__pars
  001bf	33 c0		 xor	 eax, eax
  001c1	eb 10		 jmp	 SHORT $LN1@stbi__pars
$LN17@stbi__pars:
$LN11@stbi__pars:
$LN8@stbi__pars:

; 4483 :       }
; 4484 :    } while (!final);

  001c3	83 7c 24 20 00	 cmp	 DWORD PTR final$[rsp], 0
  001c8	0f 84 80 fe ff
	ff		 je	 $LN4@stbi__pars

; 4485 :    return 1;

  001ce	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4486 : }

  001d3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001d7	5f		 pop	 rdi
  001d8	c3		 ret	 0
stbi__parse_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 48
obuf$ = 56
olen$ = 64
exp$ = 72
parse_header$ = 80
stbi__do_zlib PROC

; 4489 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4490 :    a->zout_start = obuf;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  0002f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4491 :    a->zout       = obuf;

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00038	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  0003d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4492 :    a->zout_end   = obuf + olen;

  00041	48 63 44 24 40	 movsxd	 rax, DWORD PTR olen$[rsp]
  00046	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  0004b	48 03 c8	 add	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00056	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4493 :    a->z_expandable = exp;

  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0005f	8b 4c 24 48	 mov	 ecx, DWORD PTR exp$[rsp]
  00063	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 4494 : 
; 4495 :    return stbi__parse_zlib(a, parse_header);

  00066	8b 54 24 50	 mov	 edx, DWORD PTR parse_header$[rsp]
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0006f	e8 00 00 00 00	 call	 stbi__parse_zlib

; 4496 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
stbi__do_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
p$ = 4168
__$ArrayPad$ = 4184
buffer$ = 4208
len$ = 4216
initial_size$ = 4224
outlen$ = 4232
stbi_zlib_decode_malloc_guesssize PROC

; 4499 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4208]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c4	 xor	 rax, rsp
  00044	48 89 84 24 58
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4500 :    stbi__zbuf a;
; 4501 :    char *p = (char *) stbi__malloc(initial_size);

  00058	48 63 84 24 80
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 stbi__malloc
  00068	48 89 84 24 48
	10 00 00	 mov	 QWORD PTR p$[rsp], rax

; 4502 :    if (p == NULL) return NULL;

  00070	48 83 bc 24 48
	10 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00079	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0007b	33 c0		 xor	 eax, eax
  0007d	e9 8f 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4503 :    a.zbuffer = (stbi_uc *) buffer;

  00082	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0008a	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4504 :    a.zbuffer_end = (stbi_uc *) buffer + len;

  0008f	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00097	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0009f	48 03 c8	 add	 rcx, rax
  000a2	48 8b c1	 mov	 rax, rcx
  000a5	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4505 :    if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

  000aa	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000b2	41 b9 01 00 00
	00		 mov	 r9d, 1
  000b8	44 8b 84 24 80
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  000c0	48 8b 94 24 48
	10 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000c8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000cd	e8 00 00 00 00	 call	 stbi__do_zlib
  000d2	85 c0		 test	 eax, eax
  000d4	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4506 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000d6	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000df	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000e1	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000eb	48 2b c8	 sub	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000f9	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4507 :       return a.zout_start;

  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  00100	eb 0f		 jmp	 SHORT $LN1@stbi_zlib_

; 4508 :    } else {

  00102	eb 0d		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4509 :       STBI_FREE(a.zout_start);

  00104	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4510 :       return NULL;

  0010f	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4511 :    }
; 4512 : }

  00111	48 8b f8	 mov	 rdi, rax
  00114	48 8b cc	 mov	 rcx, rsp
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_malloc_guesssize$rtcFrameData
  0011e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00123	48 8b c7	 mov	 rax, rdi
  00126	48 8b 8c 24 58
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012e	48 33 cc	 xor	 rcx, rsp
  00131	e8 00 00 00 00	 call	 __security_check_cookie
  00136	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  0013d	5f		 pop	 rdi
  0013e	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
buffer$ = 48
len$ = 56
outlen$ = 64
stbi_zlib_decode_malloc PROC

; 4515 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4516 :    return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

  0001f	4c 8b 4c 24 40	 mov	 r9, QWORD PTR outlen$[rsp]
  00024	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  0002a	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  00033	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize

; 4517 : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
p$ = 4168
__$ArrayPad$ = 4184
buffer$ = 4208
len$ = 4216
initial_size$ = 4224
outlen$ = 4232
parse_header$ = 4240
stbi_zlib_decode_malloc_guesssize_headerflag PROC

; 4520 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4208]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c4	 xor	 rax, rsp
  00044	48 89 84 24 58
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4521 :    stbi__zbuf a;
; 4522 :    char *p = (char *) stbi__malloc(initial_size);

  00058	48 63 84 24 80
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  00060	48 8b c8	 mov	 rcx, rax
  00063	e8 00 00 00 00	 call	 stbi__malloc
  00068	48 89 84 24 48
	10 00 00	 mov	 QWORD PTR p$[rsp], rax

; 4523 :    if (p == NULL) return NULL;

  00070	48 83 bc 24 48
	10 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00079	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0007b	33 c0		 xor	 eax, eax
  0007d	e9 92 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4524 :    a.zbuffer = (stbi_uc *) buffer;

  00082	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0008a	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4525 :    a.zbuffer_end = (stbi_uc *) buffer + len;

  0008f	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00097	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0009f	48 03 c8	 add	 rcx, rax
  000a2	48 8b c1	 mov	 rax, rcx
  000a5	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4526 :    if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

  000aa	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR parse_header$[rsp]
  000b1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b5	41 b9 01 00 00
	00		 mov	 r9d, 1
  000bb	44 8b 84 24 80
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  000c3	48 8b 94 24 48
	10 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000d0	e8 00 00 00 00	 call	 stbi__do_zlib
  000d5	85 c0		 test	 eax, eax
  000d7	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4527 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000d9	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000e2	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000ee	48 2b c8	 sub	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000fc	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4528 :       return a.zout_start;

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  00103	eb 0f		 jmp	 SHORT $LN1@stbi_zlib_

; 4529 :    } else {

  00105	eb 0d		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4530 :       STBI_FREE(a.zout_start);

  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4531 :       return NULL;

  00112	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4532 :    }
; 4533 : }

  00114	48 8b f8	 mov	 rdi, rax
  00117	48 8b cc	 mov	 rcx, rsp
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_malloc_guesssize_headerflag$rtcFrameData
  00121	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00126	48 8b c7	 mov	 rax, rdi
  00129	48 8b 8c 24 58
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00131	48 33 cc	 xor	 rcx, rsp
  00134	e8 00 00 00 00	 call	 __security_check_cookie
  00139	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  00140	5f		 pop	 rdi
  00141	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
__$ArrayPad$ = 4176
obuffer$ = 4208
olen$ = 4216
ibuffer$ = 4224
ilen$ = 4232
stbi_zlib_decode_buffer PROC

; 4536 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4208]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c4	 xor	 rax, rsp
  00044	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4537 :    stbi__zbuf a;
; 4538 :    a.zbuffer = (stbi_uc *) ibuffer;

  00058	48 8b 84 24 80
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  00060	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4539 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  00065	48 63 84 24 88
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  0006d	48 8b 8c 24 80
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4540 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

  00080	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	44 8b 84 24 78
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  00093	48 8b 94 24 70
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  0009b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000a0	e8 00 00 00 00	 call	 stbi__do_zlib
  000a5	85 c0		 test	 eax, eax
  000a7	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4541 :       return (int) (a.zout - a.zout_start);

  000a9	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000b3	48 2b c8	 sub	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  000bb	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4542 :    else
; 4543 :       return -1;

  000bd	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4544 : }

  000c2	48 8b f8	 mov	 rdi, rax
  000c5	48 8b cc	 mov	 rcx, rsp
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_buffer$rtcFrameData
  000cf	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d4	48 8b c7	 mov	 rax, rdi
  000d7	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000df	48 33 cc	 xor	 rcx, rsp
  000e2	e8 00 00 00 00	 call	 __security_check_cookie
  000e7	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
p$ = 4168
__$ArrayPad$ = 4184
buffer$ = 4208
len$ = 4216
outlen$ = 4224
stbi_zlib_decode_noheader_malloc PROC

; 4547 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  00014	e8 00 00 00 00	 call	 __chkstk
  00019	48 2b e0	 sub	 rsp, rax
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4208]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 58
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4548 :    stbi__zbuf a;
; 4549 :    char *p = (char *) stbi__malloc(16384);

  00053	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00058	e8 00 00 00 00	 call	 stbi__malloc
  0005d	48 89 84 24 48
	10 00 00	 mov	 QWORD PTR p$[rsp], rax

; 4550 :    if (p == NULL) return NULL;

  00065	48 83 bc 24 48
	10 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN2@stbi_zlib_
  00070	33 c0		 xor	 eax, eax
  00072	e9 8d 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4551 :    a.zbuffer = (stbi_uc *) buffer;

  00077	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0007f	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4552 :    a.zbuffer_end = (stbi_uc *) buffer+len;

  00084	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0008c	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00094	48 03 c8	 add	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4553 :    if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

  0009f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000a7	41 b9 01 00 00
	00		 mov	 r9d, 1
  000ad	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  000b3	48 8b 94 24 48
	10 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000c0	e8 00 00 00 00	 call	 stbi__do_zlib
  000c5	85 c0		 test	 eax, eax
  000c7	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4554 :       if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000c9	48 83 bc 24 80
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000d2	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000d4	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000de	48 2b c8	 sub	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 8b 8c 24 80
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000ec	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4555 :       return a.zout_start;

  000ee	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000f3	eb 0f		 jmp	 SHORT $LN1@stbi_zlib_

; 4556 :    } else {

  000f5	eb 0d		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4557 :       STBI_FREE(a.zout_start);

  000f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4558 :       return NULL;

  00102	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4559 :    }
; 4560 : }

  00104	48 8b f8	 mov	 rdi, rax
  00107	48 8b cc	 mov	 rcx, rsp
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_noheader_malloc$rtcFrameData
  00111	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00116	48 8b c7	 mov	 rax, rdi
  00119	48 8b 8c 24 58
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00121	48 33 cc	 xor	 rcx, rsp
  00124	e8 00 00 00 00	 call	 __security_check_cookie
  00129	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 64
__$ArrayPad$ = 4176
obuffer$ = 4208
olen$ = 4216
ibuffer$ = 4224
ilen$ = 4232
stbi_zlib_decode_noheader_buffer PROC

; 4563 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00026	b9 0c 04 00 00	 mov	 ecx, 1036		; 0000040cH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR [rsp+4208]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00041	48 33 c4	 xor	 rax, rsp
  00044	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00053	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4564 :    stbi__zbuf a;
; 4565 :    a.zbuffer = (stbi_uc *) ibuffer;

  00058	48 8b 84 24 80
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  00060	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4566 :    a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  00065	48 63 84 24 88
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  0006d	48 8b 8c 24 80
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4567 :    if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

  00080	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	44 8b 84 24 78
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  00093	48 8b 94 24 70
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  0009b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000a0	e8 00 00 00 00	 call	 stbi__do_zlib
  000a5	85 c0		 test	 eax, eax
  000a7	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4568 :       return (int) (a.zout - a.zout_start);

  000a9	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000b3	48 2b c8	 sub	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  000bb	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4569 :    else
; 4570 :       return -1;

  000bd	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4571 : }

  000c2	48 8b f8	 mov	 rdi, rax
  000c5	48 8b cc	 mov	 rcx, rsp
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_zlib_decode_noheader_buffer$rtcFrameData
  000cf	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000d4	48 8b c7	 mov	 rax, rdi
  000d7	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000df	48 33 cc	 xor	 rcx, rsp
  000e2	e8 00 00 00 00	 call	 __security_check_cookie
  000e7	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
c$ = 40
s$ = 80
stbi__get_chunk_header PROC

; 4592 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4593 :    stbi__pngchunk c;
; 4594 :    c.length = stbi__get32be(s);

  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00031	e8 00 00 00 00	 call	 stbi__get32be
  00036	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 4595 :    c.type   = stbi__get32be(s);

  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 stbi__get32be
  00044	89 44 24 2c	 mov	 DWORD PTR c$[rsp+4], eax

; 4596 :    return c;

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR c$[rsp]

; 4597 : }

  0004d	48 8b f8	 mov	 rdi, rax
  00050	48 8b cc	 mov	 rcx, rsp
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__get_chunk_header$rtcFrameData
  0005a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0005f	48 8b c7	 mov	 rax, rdi
  00062	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stbi__get_chunk_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
$T1 = 36
tv85 = 37
tv94 = 38
s$ = 64
stbi__check_png_header PROC

; 4600 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00016	90		 npad	 1

; 4601 :    static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4602 :    int i;
; 4603 :    for (i=0; i < 8; ++i)

  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN4@stbi__chec
$LN2@stbi__chec:
  00021	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__chec:
  0002b	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00030	0f 8d d5 00 00
	00		 jge	 $LN3@stbi__chec

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00040	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00047	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0004e	73 39		 jae	 SHORT $LN8@stbi__chec

; 1615 :       return *s->img_buffer++;

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00055	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005f	88 44 24 25	 mov	 BYTE PTR tv85[rsp], al
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00068	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006f	48 ff c0	 inc	 rax
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00077	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0007e	0f b6 44 24 25	 movzx	 eax, BYTE PTR tv85[rsp]
  00083	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00087	eb 53		 jmp	 SHORT $LN7@stbi__chec
$LN8@stbi__chec:

; 1616 :    if (s->read_from_callbacks) {

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0008e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00092	74 43		 je	 SHORT $LN9@stbi__chec

; 1617 :       stbi__refill_buffer(s);

  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00099	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ad	88 44 24 26	 mov	 BYTE PTR tv94[rsp], al
  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000bd	48 ff c0	 inc	 rax
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000cc	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv94[rsp]
  000d1	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000d5	eb 05		 jmp	 SHORT $LN7@stbi__chec
$LN9@stbi__chec:

; 1619 :    }
; 1620 :    return 0;

  000d7	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__chec:

; 4604 :       if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

  000dc	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000e1	0f b6 c0	 movzx	 eax, al
  000e4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@9@9
  000f0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f4	3b c1		 cmp	 eax, ecx
  000f6	74 0e		 je	 SHORT $LN5@stbi__chec
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@DMDNBACF@bad?5png?5sig@
  000ff	e8 00 00 00 00	 call	 stbi__err
  00104	eb 0a		 jmp	 SHORT $LN1@stbi__chec
$LN5@stbi__chec:
  00106	e9 16 ff ff ff	 jmp	 $LN2@stbi__chec
$LN3@stbi__chec:

; 4605 :    return 1;

  0010b	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__chec:

; 4606 : }

  00110	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
stbi__check_png_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 32
pa$ = 36
pb$ = 40
pc$ = 44
a$ = 64
b$ = 72
c$ = 80
stbi__paeth PROC

; 4637 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4638 :    int p = a + b - c;

  0001e	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00026	03 c8		 add	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	2b 44 24 50	 sub	 eax, DWORD PTR c$[rsp]
  0002e	89 44 24 20	 mov	 DWORD PTR p$[rsp], eax

; 4639 :    int pa = abs(p-a);

  00032	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00036	8b 4c 24 20	 mov	 ecx, DWORD PTR p$[rsp]
  0003a	2b c8		 sub	 ecx, eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	8b c8		 mov	 ecx, eax
  00040	f7 d9		 neg	 ecx
  00042	0f 48 c8	 cmovs	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	89 44 24 24	 mov	 DWORD PTR pa$[rsp], eax

; 4640 :    int pb = abs(p-b);

  0004b	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  0004f	8b 4c 24 20	 mov	 ecx, DWORD PTR p$[rsp]
  00053	2b c8		 sub	 ecx, eax
  00055	8b c1		 mov	 eax, ecx
  00057	8b c8		 mov	 ecx, eax
  00059	f7 d9		 neg	 ecx
  0005b	0f 48 c8	 cmovs	 ecx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	89 44 24 28	 mov	 DWORD PTR pb$[rsp], eax

; 4641 :    int pc = abs(p-c);

  00064	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
  00068	8b 4c 24 20	 mov	 ecx, DWORD PTR p$[rsp]
  0006c	2b c8		 sub	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	8b c8		 mov	 ecx, eax
  00072	f7 d9		 neg	 ecx
  00074	0f 48 c8	 cmovs	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 44 24 2c	 mov	 DWORD PTR pc$[rsp], eax

; 4642 :    if (pa <= pb && pa <= pc) return a;

  0007d	8b 44 24 28	 mov	 eax, DWORD PTR pb$[rsp]
  00081	39 44 24 24	 cmp	 DWORD PTR pa$[rsp], eax
  00085	7f 10		 jg	 SHORT $LN2@stbi__paet
  00087	8b 44 24 2c	 mov	 eax, DWORD PTR pc$[rsp]
  0008b	39 44 24 24	 cmp	 DWORD PTR pa$[rsp], eax
  0008f	7f 06		 jg	 SHORT $LN2@stbi__paet
  00091	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00095	eb 14		 jmp	 SHORT $LN1@stbi__paet
$LN2@stbi__paet:

; 4643 :    if (pb <= pc) return b;

  00097	8b 44 24 2c	 mov	 eax, DWORD PTR pc$[rsp]
  0009b	39 44 24 28	 cmp	 DWORD PTR pb$[rsp], eax
  0009f	7f 06		 jg	 SHORT $LN3@stbi__paet
  000a1	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  000a5	eb 04		 jmp	 SHORT $LN1@stbi__paet
$LN3@stbi__paet:

; 4644 :    return c;

  000a7	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
$LN1@stbi__paet:

; 4645 : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
stbi__paeth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
bytes$ = 32
s$ = 40
i$ = 48
j$ = 52
stride$ = 56
img_len$ = 60
img_width_bytes$ = 64
k$ = 68
img_n$ = 72
output_bytes$ = 76
filter_bytes$ = 80
width$ = 84
cur$1 = 88
prior$2 = 96
filter$3 = 104
nk$4 = 108
cur$5 = 112
in$6 = 120
scale$7 = 128
q$8 = 132
cur$9 = 136
cur16$10 = 144
tv65 = 152
tv168 = 156
tv216 = 160
tv274 = 164
tv345 = 168
tv393 = 172
tv415 = 176
tv548 = 180
tv620 = 184
tv668 = 188
a$ = 224
raw$ = 232
raw_len$ = 240
out_n$ = 248
x$ = 256
y$ = 264
depth$ = 272
color$ = 280
stbi__create_png_image_raw PROC

; 4651 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4652 :    int bytes = (depth == 16? 2 : 1);

  00029	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00031	75 0d		 jne	 SHORT $LN159@stbi__crea
  00033	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv65[rsp], 2
  0003e	eb 0b		 jmp	 SHORT $LN160@stbi__crea
$LN159@stbi__crea:
  00040	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv65[rsp], 1
$LN160@stbi__crea:
  0004b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00052	89 44 24 20	 mov	 DWORD PTR bytes$[rsp], eax

; 4653 :    stbi__context *s = a->s;

  00056	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 4654 :    stbi__uint32 i,j,stride = x*out_n*bytes;

  00066	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0006d	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  00075	0f af 44 24 20	 imul	 eax, DWORD PTR bytes$[rsp]
  0007a	89 44 24 38	 mov	 DWORD PTR stride$[rsp], eax

; 4655 :    stbi__uint32 img_len, img_width_bytes;
; 4656 :    int k;
; 4657 :    int img_n = s->img_n; // copy it into a local for later

  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00083	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00086	89 44 24 48	 mov	 DWORD PTR img_n$[rsp], eax

; 4658 : 
; 4659 :    int output_bytes = out_n*bytes;

  0008a	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00091	0f af 44 24 20	 imul	 eax, DWORD PTR bytes$[rsp]
  00096	89 44 24 4c	 mov	 DWORD PTR output_bytes$[rsp], eax

; 4660 :    int filter_bytes = img_n*bytes;

  0009a	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  0009e	0f af 44 24 20	 imul	 eax, DWORD PTR bytes$[rsp]
  000a3	89 44 24 50	 mov	 DWORD PTR filter_bytes$[rsp], eax

; 4661 :    int width = x;

  000a7	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  000ae	89 44 24 54	 mov	 DWORD PTR width$[rsp], eax

; 4662 : 
; 4663 :    STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000b7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ba	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000c1	74 2f		 je	 SHORT $LN161@stbi__crea
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000c8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000cb	ff c0		 inc	 eax
  000cd	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000d4	74 1c		 je	 SHORT $LN161@stbi__crea
  000d6	41 b8 37 12 00
	00		 mov	 r8d, 4663		; 00001237H
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@ICDHLHK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg@
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f0	33 c0		 xor	 eax, eax
$LN161@stbi__crea:

; 4664 :    a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

  000f2	45 33 c9	 xor	 r9d, r9d
  000f5	44 8b 44 24 4c	 mov	 r8d, DWORD PTR output_bytes$[rsp]
  000fa	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR y$[rsp]
  00101	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR x$[rsp]
  00108	e8 00 00 00 00	 call	 stbi__malloc_mad3
  0010d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00115	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4665 :    if (!a->out) return stbi__err("outofmem", "Out of memory");

  00119	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00121	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00126	75 11		 jne	 SHORT $LN98@stbi__crea
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0012f	e8 00 00 00 00	 call	 stbi__err
  00134	e9 57 17 00 00	 jmp	 $LN1@stbi__crea
$LN98@stbi__crea:

; 4666 : 
; 4667 :    if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

  00139	41 b9 07 00 00
	00		 mov	 r9d, 7
  0013f	44 8b 84 24 10
	01 00 00	 mov	 r8d, DWORD PTR depth$[rsp]
  00147	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  0014e	8b 4c 24 48	 mov	 ecx, DWORD PTR img_n$[rsp]
  00152	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00157	85 c0		 test	 eax, eax
  00159	75 11		 jne	 SHORT $LN99@stbi__crea
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00162	e8 00 00 00 00	 call	 stbi__err
  00167	e9 24 17 00 00	 jmp	 $LN1@stbi__crea
$LN99@stbi__crea:

; 4668 :    img_width_bytes = (((img_n * x * depth) + 7) >> 3);

  0016c	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  00170	0f af 84 24 00
	01 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00178	0f af 84 24 10
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  00180	83 c0 07	 add	 eax, 7
  00183	c1 e8 03	 shr	 eax, 3
  00186	89 44 24 40	 mov	 DWORD PTR img_width_bytes$[rsp], eax

; 4669 :    img_len = (img_width_bytes + 1) * y;

  0018a	8b 44 24 40	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  0018e	ff c0		 inc	 eax
  00190	0f af 84 24 08
	01 00 00	 imul	 eax, DWORD PTR y$[rsp]
  00198	89 44 24 3c	 mov	 DWORD PTR img_len$[rsp], eax

; 4670 : 
; 4671 :    // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4672 :    // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4673 :    // so just check for raw_len < img_len always.
; 4674 :    if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

  0019c	8b 44 24 3c	 mov	 eax, DWORD PTR img_len$[rsp]
  001a0	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR raw_len$[rsp], eax
  001a7	73 11		 jae	 SHORT $LN100@stbi__crea
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@BHMPBBMG@not?5enough?5pixels@
  001b0	e8 00 00 00 00	 call	 stbi__err
  001b5	e9 d6 16 00 00	 jmp	 $LN1@stbi__crea
$LN100@stbi__crea:

; 4675 : 
; 4676 :    for (j=0; j < y; ++j) {

  001ba	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001c2	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  001c4	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  001c8	ff c0		 inc	 eax
  001ca	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__crea:
  001ce	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  001d5	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  001d9	0f 83 04 0e 00
	00		 jae	 $LN3@stbi__crea

; 4677 :       stbi_uc *cur = a->out + stride*j;

  001df	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  001e3	0f af 44 24 34	 imul	 eax, DWORD PTR j$[rsp]
  001e8	8b c0		 mov	 eax, eax
  001ea	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001f2	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  001f6	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4678 :       stbi_uc *prior;
; 4679 :       int filter = *raw++;

  001fb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  00203	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00206	89 44 24 68	 mov	 DWORD PTR filter$3[rsp], eax
  0020a	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  00212	48 ff c0	 inc	 rax
  00215	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4680 : 
; 4681 :       if (filter > 4)

  0021d	83 7c 24 68 04	 cmp	 DWORD PTR filter$3[rsp], 4
  00222	7e 11		 jle	 SHORT $LN101@stbi__crea

; 4682 :          return stbi__err("invalid filter","Corrupt PNG");

  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FBBCPGMN@invalid?5filter@
  0022b	e8 00 00 00 00	 call	 stbi__err
  00230	e9 5b 16 00 00	 jmp	 $LN1@stbi__crea
$LN101@stbi__crea:

; 4683 : 
; 4684 :       if (depth < 8) {

  00235	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0023d	7d 53		 jge	 SHORT $LN102@stbi__crea

; 4685 :          if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");

  0023f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00246	39 44 24 40	 cmp	 DWORD PTR img_width_bytes$[rsp], eax
  0024a	76 11		 jbe	 SHORT $LN103@stbi__crea
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  00253	e8 00 00 00 00	 call	 stbi__err
  00258	e9 33 16 00 00	 jmp	 $LN1@stbi__crea
$LN103@stbi__crea:

; 4686 :          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

  0025d	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00264	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  0026c	2b 44 24 40	 sub	 eax, DWORD PTR img_width_bytes$[rsp]
  00270	8b c0		 mov	 eax, eax
  00272	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00277	48 03 c8	 add	 rcx, rax
  0027a	48 8b c1	 mov	 rax, rcx
  0027d	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4687 :          filter_bytes = 1;

  00282	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR filter_bytes$[rsp], 1

; 4688 :          width = img_width_bytes;

  0028a	8b 44 24 40	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  0028e	89 44 24 54	 mov	 DWORD PTR width$[rsp], eax
$LN102@stbi__crea:

; 4689 :       }
; 4690 :       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

  00292	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  00296	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  0029b	48 2b c8	 sub	 rcx, rax
  0029e	48 8b c1	 mov	 rax, rcx
  002a1	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax

; 4691 : 
; 4692 :       // if first row, use special filter that doesn't sample previous row
; 4693 :       if (j == 0) filter = first_row_filter[filter];

  002a6	83 7c 24 34 00	 cmp	 DWORD PTR j$[rsp], 0
  002ab	75 14		 jne	 SHORT $LN104@stbi__crea
  002ad	48 63 44 24 68	 movsxd	 rax, DWORD PTR filter$3[rsp]
  002b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:first_row_filter
  002b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002bd	89 44 24 68	 mov	 DWORD PTR filter$3[rsp], eax
$LN104@stbi__crea:

; 4694 : 
; 4695 :       // handle first byte explicitly
; 4696 :       for (k=0; k < filter_bytes; ++k) {

  002c1	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  002c9	eb 0a		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  002cb	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  002cf	ff c0		 inc	 eax
  002d1	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__crea:
  002d5	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  002d9	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  002dd	0f 8d 84 01 00
	00		 jge	 $LN6@stbi__crea

; 4697 :          switch (filter) {

  002e3	8b 44 24 68	 mov	 eax, DWORD PTR filter$3[rsp]
  002e7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  002ee	83 bc 24 9c 00
	00 00 06	 cmp	 DWORD PTR tv168[rsp], 6
  002f6	0f 87 66 01 00
	00		 ja	 $LN8@stbi__crea
  002fc	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv168[rsp]
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0030b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN168@stbi__crea[rcx+rax*4]
  00312	48 03 c1	 add	 rax, rcx
  00315	ff e0		 jmp	 rax
$LN105@stbi__crea:

; 4698 :             case STBI__F_none       : cur[k] = raw[k]; break;

  00317	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  0031c	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00321	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00326	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  0032e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00333	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00336	e9 27 01 00 00	 jmp	 $LN8@stbi__crea
$LN106@stbi__crea:

; 4699 :             case STBI__F_sub        : cur[k] = raw[k]; break;

  0033b	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00340	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00345	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  0034a	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00352	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00357	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0035a	e9 03 01 00 00	 jmp	 $LN8@stbi__crea
$LN107@stbi__crea:

; 4700 :             case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

  0035f	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00364	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0036c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00370	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00375	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  0037a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0037e	03 c1		 add	 eax, ecx
  00380	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00385	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  0038a	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  0038f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00392	e9 cb 00 00 00	 jmp	 $LN8@stbi__crea
$LN108@stbi__crea:

; 4701 :             case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;

  00397	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  0039c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  003a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a8	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  003ad	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  003b2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003b6	d1 f9		 sar	 ecx, 1
  003b8	03 c1		 add	 eax, ecx
  003ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003bf	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  003c4	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  003c9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003cc	e9 91 00 00 00	 jmp	 $LN8@stbi__crea
$LN109@stbi__crea:

; 4702 :             case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;

  003d1	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  003d6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  003de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  003e9	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  003ee	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  003f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003f7	45 33 c0	 xor	 r8d, r8d
  003fa	8b d1		 mov	 edx, ecx
  003fc	33 c9		 xor	 ecx, ecx
  003fe	e8 00 00 00 00	 call	 stbi__paeth
  00403	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  0040a	03 c8		 add	 ecx, eax
  0040c	8b c1		 mov	 eax, ecx
  0040e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00413	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00418	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  0041d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00420	eb 40		 jmp	 SHORT $LN8@stbi__crea
$LN110@stbi__crea:

; 4703 :             case STBI__F_avg_first  : cur[k] = raw[k]; break;

  00422	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00427	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  0042c	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00431	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00439	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0043e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00441	eb 1f		 jmp	 SHORT $LN8@stbi__crea
$LN111@stbi__crea:

; 4704 :             case STBI__F_paeth_first: cur[k] = raw[k]; break;

  00443	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00448	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  0044d	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00452	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  0045a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0045f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN8@stbi__crea:

; 4705 :          }
; 4706 :       }

  00462	e9 64 fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4707 : 
; 4708 :       if (depth == 8) {

  00467	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0046f	75 6b		 jne	 SHORT $LN112@stbi__crea

; 4709 :          if (img_n != out_n)

  00471	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00478	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  0047c	74 0e		 je	 SHORT $LN114@stbi__crea

; 4710 :             cur[img_n] = 255; // first pixel

  0047e	48 63 44 24 48	 movsxd	 rax, DWORD PTR img_n$[rsp]
  00483	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00488	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN114@stbi__crea:

; 4711 :          raw += img_n;

  0048c	48 63 44 24 48	 movsxd	 rax, DWORD PTR img_n$[rsp]
  00491	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00499	48 03 c8	 add	 rcx, rax
  0049c	48 8b c1	 mov	 rax, rcx
  0049f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4712 :          cur += out_n;

  004a7	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR out_n$[rsp]
  004af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  004b4	48 03 c8	 add	 rcx, rax
  004b7	48 8b c1	 mov	 rax, rcx
  004ba	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4713 :          prior += out_n;

  004bf	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR out_n$[rsp]
  004c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  004cc	48 03 c8	 add	 rcx, rax
  004cf	48 8b c1	 mov	 rax, rcx
  004d2	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
  004d7	e9 aa 00 00 00	 jmp	 $LN113@stbi__crea
$LN112@stbi__crea:

; 4714 :       } else if (depth == 16) {

  004dc	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  004e4	75 73		 jne	 SHORT $LN115@stbi__crea

; 4715 :          if (img_n != out_n) {

  004e6	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  004ed	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  004f1	74 1f		 je	 SHORT $LN117@stbi__crea

; 4716 :             cur[filter_bytes]   = 255; // first pixel top byte

  004f3	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  004f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  004fd	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4717 :             cur[filter_bytes+1] = 255; // first pixel bottom byte

  00501	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00505	ff c0		 inc	 eax
  00507	48 98		 cdqe
  00509	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  0050e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN117@stbi__crea:

; 4718 :          }
; 4719 :          raw += filter_bytes;

  00512	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00517	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0051f	48 03 c8	 add	 rcx, rax
  00522	48 8b c1	 mov	 rax, rcx
  00525	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4720 :          cur += output_bytes;

  0052d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00532	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00537	48 03 c8	 add	 rcx, rax
  0053a	48 8b c1	 mov	 rax, rcx
  0053d	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4721 :          prior += output_bytes;

  00542	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00547	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  0054c	48 03 c8	 add	 rcx, rax
  0054f	48 8b c1	 mov	 rax, rcx
  00552	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax

; 4722 :       } else {

  00557	eb 2d		 jmp	 SHORT $LN116@stbi__crea
$LN115@stbi__crea:

; 4723 :          raw += 1;

  00559	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  00561	48 ff c0	 inc	 rax
  00564	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4724 :          cur += 1;

  0056c	48 8b 44 24 58	 mov	 rax, QWORD PTR cur$1[rsp]
  00571	48 ff c0	 inc	 rax
  00574	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4725 :          prior += 1;

  00579	48 8b 44 24 60	 mov	 rax, QWORD PTR prior$2[rsp]
  0057e	48 ff c0	 inc	 rax
  00581	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN116@stbi__crea:
$LN113@stbi__crea:

; 4726 :       }
; 4727 : 
; 4728 :       // this is a little gross, so that we don't switch per-pixel or per-component
; 4729 :       if (depth < 8 || img_n == out_n) {

  00586	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0058e	7c 11		 jl	 SHORT $LN120@stbi__crea
  00590	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00597	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  0059b	0f 85 2e 03 00
	00		 jne	 $LN118@stbi__crea
$LN120@stbi__crea:

; 4730 :          int nk = (width - 1)*filter_bytes;

  005a1	8b 44 24 54	 mov	 eax, DWORD PTR width$[rsp]
  005a5	ff c8		 dec	 eax
  005a7	0f af 44 24 50	 imul	 eax, DWORD PTR filter_bytes$[rsp]
  005ac	89 44 24 6c	 mov	 DWORD PTR nk$4[rsp], eax

; 4731 :          #define STBI__CASE(f) \
; 4732 :              case f:     \
; 4733 :                 for (k=0; k < nk; ++k)
; 4734 :          switch (filter) {

  005b0	8b 44 24 68	 mov	 eax, DWORD PTR filter$3[rsp]
  005b4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv274[rsp], eax
  005bb	83 bc 24 a4 00
	00 00 06	 cmp	 DWORD PTR tv274[rsp], 6
  005c3	0f 87 e6 02 00
	00		 ja	 $LN10@stbi__crea
  005c9	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv274[rsp]
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  005d8	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN167@stbi__crea[rcx+rax*4]
  005df	48 03 c1	 add	 rax, rcx
  005e2	ff e0		 jmp	 rax
$LN121@stbi__crea:

; 4735 :             // "none" filter turns into a memcpy here; make that explicit.
; 4736 :             case STBI__F_none:         memcpy(cur, raw, nk); break;

  005e4	48 63 44 24 6c	 movsxd	 rax, DWORD PTR nk$4[rsp]
  005e9	48 8b 7c 24 58	 mov	 rdi, QWORD PTR cur$1[rsp]
  005ee	48 8b b4 24 e8
	00 00 00	 mov	 rsi, QWORD PTR raw$[rsp]
  005f6	48 8b c8	 mov	 rcx, rax
  005f9	f3 a4		 rep movsb
  005fb	e9 af 02 00 00	 jmp	 $LN10@stbi__crea
$LN122@stbi__crea:

; 4737 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;

  00600	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00608	eb 0a		 jmp	 SHORT $LN14@stbi__crea
$LN12@stbi__crea:
  0060a	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  0060e	ff c0		 inc	 eax
  00610	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN14@stbi__crea:
  00614	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  00618	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  0061c	7d 3f		 jge	 SHORT $LN13@stbi__crea
  0061e	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00623	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0062b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0062f	8b 4c 24 50	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  00633	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00637	2b d1		 sub	 edx, ecx
  00639	8b ca		 mov	 ecx, edx
  0063b	48 63 c9	 movsxd	 rcx, ecx
  0063e	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00643	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00647	03 c1		 add	 eax, ecx
  00649	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0064e	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00653	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00658	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0065b	eb ad		 jmp	 SHORT $LN12@stbi__crea
$LN13@stbi__crea:
  0065d	e9 4d 02 00 00	 jmp	 $LN10@stbi__crea
$LN123@stbi__crea:

; 4738 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  00662	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  0066a	eb 0a		 jmp	 SHORT $LN17@stbi__crea
$LN15@stbi__crea:
  0066c	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00670	ff c0		 inc	 eax
  00672	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN17@stbi__crea:
  00676	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  0067a	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  0067e	7d 35		 jge	 SHORT $LN16@stbi__crea
  00680	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00685	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0068d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00691	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00696	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  0069b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0069f	03 c1		 add	 eax, ecx
  006a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006a6	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  006ab	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  006b0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006b3	eb b7		 jmp	 SHORT $LN15@stbi__crea
$LN16@stbi__crea:
  006b5	e9 f5 01 00 00	 jmp	 $LN10@stbi__crea
$LN124@stbi__crea:

; 4739 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;

  006ba	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006c2	eb 0a		 jmp	 SHORT $LN20@stbi__crea
$LN18@stbi__crea:
  006c4	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  006c8	ff c0		 inc	 eax
  006ca	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN20@stbi__crea:
  006ce	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  006d2	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  006d6	7d 51		 jge	 SHORT $LN19@stbi__crea
  006d8	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  006dd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  006e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006e9	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  006ee	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  006f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006f7	8b 54 24 50	 mov	 edx, DWORD PTR filter_bytes$[rsp]
  006fb	8b 7c 24 44	 mov	 edi, DWORD PTR k$[rsp]
  006ff	2b fa		 sub	 edi, edx
  00701	8b d7		 mov	 edx, edi
  00703	48 63 d2	 movsxd	 rdx, edx
  00706	48 8b 7c 24 58	 mov	 rdi, QWORD PTR cur$1[rsp]
  0070b	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  0070f	03 ca		 add	 ecx, edx
  00711	d1 f9		 sar	 ecx, 1
  00713	03 c1		 add	 eax, ecx
  00715	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0071a	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  0071f	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00724	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00727	eb 9b		 jmp	 SHORT $LN18@stbi__crea
$LN19@stbi__crea:
  00729	e9 81 01 00 00	 jmp	 $LN10@stbi__crea
$LN125@stbi__crea:

; 4740 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;

  0072e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00736	eb 0a		 jmp	 SHORT $LN23@stbi__crea
$LN21@stbi__crea:
  00738	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  0073c	ff c0		 inc	 eax
  0073e	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN23@stbi__crea:
  00742	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  00746	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  0074a	0f 8d 82 00 00
	00		 jge	 $LN22@stbi__crea
  00750	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00755	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0075d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00761	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv345[rsp], eax
  00768	8b 4c 24 50	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  0076c	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00770	2b d1		 sub	 edx, ecx
  00772	8b ca		 mov	 ecx, edx
  00774	48 63 c9	 movsxd	 rcx, ecx
  00777	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  0077c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00780	48 63 54 24 44	 movsxd	 rdx, DWORD PTR k$[rsp]
  00785	48 8b 7c 24 60	 mov	 rdi, QWORD PTR prior$2[rsp]
  0078a	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  0078e	8b 7c 24 50	 mov	 edi, DWORD PTR filter_bytes$[rsp]
  00792	8b 74 24 44	 mov	 esi, DWORD PTR k$[rsp]
  00796	2b f7		 sub	 esi, edi
  00798	8b fe		 mov	 edi, esi
  0079a	48 63 ff	 movsxd	 rdi, edi
  0079d	48 8b 74 24 58	 mov	 rsi, QWORD PTR cur$1[rsp]
  007a2	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  007a6	44 8b c1	 mov	 r8d, ecx
  007a9	8b cf		 mov	 ecx, edi
  007ab	e8 00 00 00 00	 call	 stbi__paeth
  007b0	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv345[rsp]
  007b7	03 c8		 add	 ecx, eax
  007b9	8b c1		 mov	 eax, ecx
  007bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007c0	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  007c5	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  007ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007cd	e9 66 ff ff ff	 jmp	 $LN21@stbi__crea
$LN22@stbi__crea:
  007d2	e9 d8 00 00 00	 jmp	 $LN10@stbi__crea
$LN126@stbi__crea:

; 4741 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;

  007d7	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  007df	eb 0a		 jmp	 SHORT $LN26@stbi__crea
$LN24@stbi__crea:
  007e1	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  007e5	ff c0		 inc	 eax
  007e7	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN26@stbi__crea:
  007eb	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  007ef	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  007f3	7d 41		 jge	 SHORT $LN25@stbi__crea
  007f5	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  007fa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00802	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00806	8b 4c 24 50	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  0080a	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  0080e	2b d1		 sub	 edx, ecx
  00810	8b ca		 mov	 ecx, edx
  00812	48 63 c9	 movsxd	 rcx, ecx
  00815	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  0081a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0081e	d1 f9		 sar	 ecx, 1
  00820	03 c1		 add	 eax, ecx
  00822	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00827	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  0082c	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00831	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00834	eb ab		 jmp	 SHORT $LN24@stbi__crea
$LN25@stbi__crea:
  00836	eb 77		 jmp	 SHORT $LN10@stbi__crea
$LN127@stbi__crea:

; 4742 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;

  00838	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00840	eb 0a		 jmp	 SHORT $LN29@stbi__crea
$LN27@stbi__crea:
  00842	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00846	ff c0		 inc	 eax
  00848	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN29@stbi__crea:
  0084c	8b 44 24 6c	 mov	 eax, DWORD PTR nk$4[rsp]
  00850	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00854	7d 59		 jge	 SHORT $LN28@stbi__crea
  00856	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  0085b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00863	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00867	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv393[rsp], eax
  0086e	8b 4c 24 50	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  00872	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00876	2b d1		 sub	 edx, ecx
  00878	8b ca		 mov	 ecx, edx
  0087a	48 63 c9	 movsxd	 rcx, ecx
  0087d	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00882	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00886	45 33 c0	 xor	 r8d, r8d
  00889	33 d2		 xor	 edx, edx
  0088b	e8 00 00 00 00	 call	 stbi__paeth
  00890	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv393[rsp]
  00897	03 c8		 add	 ecx, eax
  00899	8b c1		 mov	 eax, ecx
  0089b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008a0	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  008a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  008aa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008ad	eb 93		 jmp	 SHORT $LN27@stbi__crea
$LN28@stbi__crea:
$LN10@stbi__crea:

; 4743 :          }
; 4744 :          #undef STBI__CASE
; 4745 :          raw += nk;

  008af	48 63 44 24 6c	 movsxd	 rax, DWORD PTR nk$4[rsp]
  008b4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  008bc	48 03 c8	 add	 rcx, rax
  008bf	48 8b c1	 mov	 rax, rcx
  008c2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4746 :       } else {

  008ca	e9 0f 07 00 00	 jmp	 $LN119@stbi__crea
$LN118@stbi__crea:

; 4747 :          STBI_ASSERT(img_n+1 == out_n);

  008cf	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  008d3	ff c0		 inc	 eax
  008d5	3b 84 24 f8 00
	00 00		 cmp	 eax, DWORD PTR out_n$[rsp]
  008dc	74 1c		 je	 SHORT $LN162@stbi__crea
  008de	41 b8 8b 12 00
	00		 mov	 r8d, 4747		; 0000128bH
  008e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  008eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CPJBBDGC@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?$CL?$AA1?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu?$AAt?$AA_@
  008f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008f8	33 c0		 xor	 eax, eax
$LN162@stbi__crea:

; 4748 :          #define STBI__CASE(f) \
; 4749 :              case f:     \
; 4750 :                 for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4751 :                    for (k=0; k < filter_bytes; ++k)
; 4752 :          switch (filter) {

  008fa	8b 44 24 68	 mov	 eax, DWORD PTR filter$3[rsp]
  008fe	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv415[rsp], eax
  00905	83 bc 24 b0 00
	00 00 06	 cmp	 DWORD PTR tv415[rsp], 6
  0090d	0f 87 5c 06 00
	00		 ja	 $LN30@stbi__crea
  00913	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv415[rsp]
  0091b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00922	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN166@stbi__crea[rcx+rax*4]
  00929	48 03 c1	 add	 rax, rcx
  0092c	ff e0		 jmp	 rax
$LN128@stbi__crea:

; 4753 :             STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;

  0092e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00935	ff c8		 dec	 eax
  00937	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0093b	eb 5d		 jmp	 SHORT $LN34@stbi__crea
$LN32@stbi__crea:
  0093d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00941	ff c8		 dec	 eax
  00943	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00947	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  0094c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00951	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00955	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  0095a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00962	48 03 c8	 add	 rcx, rax
  00965	48 8b c1	 mov	 rax, rcx
  00968	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00970	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00975	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  0097a	48 03 c8	 add	 rcx, rax
  0097d	48 8b c1	 mov	 rax, rcx
  00980	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00985	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  0098a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  0098f	48 03 c8	 add	 rcx, rax
  00992	48 8b c1	 mov	 rax, rcx
  00995	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN34@stbi__crea:
  0099a	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  0099f	72 43		 jb	 SHORT $LN33@stbi__crea
  009a1	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  009a9	eb 0a		 jmp	 SHORT $LN37@stbi__crea
$LN35@stbi__crea:
  009ab	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  009af	ff c0		 inc	 eax
  009b1	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN37@stbi__crea:
  009b5	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  009b9	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  009bd	7d 20		 jge	 SHORT $LN36@stbi__crea
  009bf	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  009c4	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  009c9	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  009ce	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR raw$[rsp]
  009d6	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  009da	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  009dd	eb cc		 jmp	 SHORT $LN35@stbi__crea
$LN36@stbi__crea:
  009df	e9 59 ff ff ff	 jmp	 $LN32@stbi__crea
$LN33@stbi__crea:
  009e4	e9 86 05 00 00	 jmp	 $LN30@stbi__crea
$LN129@stbi__crea:

; 4754 :             STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;

  009e9	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  009f0	ff c8		 dec	 eax
  009f2	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  009f6	eb 5d		 jmp	 SHORT $LN40@stbi__crea
$LN38@stbi__crea:
  009f8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  009fc	ff c8		 dec	 eax
  009fe	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00a02	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00a07	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00a0c	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00a10	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00a15	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00a1d	48 03 c8	 add	 rcx, rax
  00a20	48 8b c1	 mov	 rax, rcx
  00a23	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00a2b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00a30	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00a35	48 03 c8	 add	 rcx, rax
  00a38	48 8b c1	 mov	 rax, rcx
  00a3b	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00a40	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00a45	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00a4a	48 03 c8	 add	 rcx, rax
  00a4d	48 8b c1	 mov	 rax, rcx
  00a50	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN40@stbi__crea:
  00a55	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00a5a	72 62		 jb	 SHORT $LN39@stbi__crea
  00a5c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00a64	eb 0a		 jmp	 SHORT $LN43@stbi__crea
$LN41@stbi__crea:
  00a66	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00a6a	ff c0		 inc	 eax
  00a6c	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN43@stbi__crea:
  00a70	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00a74	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00a78	7d 3f		 jge	 SHORT $LN42@stbi__crea
  00a7a	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00a7f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00a87	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a8b	8b 4c 24 4c	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00a8f	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00a93	2b d1		 sub	 edx, ecx
  00a95	8b ca		 mov	 ecx, edx
  00a97	48 63 c9	 movsxd	 rcx, ecx
  00a9a	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00a9f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00aa3	03 c1		 add	 eax, ecx
  00aa5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00aaa	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00aaf	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00ab4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ab7	eb ad		 jmp	 SHORT $LN41@stbi__crea
$LN42@stbi__crea:
  00ab9	e9 3a ff ff ff	 jmp	 $LN38@stbi__crea
$LN39@stbi__crea:
  00abe	e9 ac 04 00 00	 jmp	 $LN30@stbi__crea
$LN130@stbi__crea:

; 4755 :             STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  00ac3	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00aca	ff c8		 dec	 eax
  00acc	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00ad0	eb 5d		 jmp	 SHORT $LN46@stbi__crea
$LN44@stbi__crea:
  00ad2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00ad6	ff c8		 dec	 eax
  00ad8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00adc	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00ae1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00ae6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00aea	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00aef	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00af7	48 03 c8	 add	 rcx, rax
  00afa	48 8b c1	 mov	 rax, rcx
  00afd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00b05	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00b0a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00b0f	48 03 c8	 add	 rcx, rax
  00b12	48 8b c1	 mov	 rax, rcx
  00b15	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00b1a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00b1f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00b24	48 03 c8	 add	 rcx, rax
  00b27	48 8b c1	 mov	 rax, rcx
  00b2a	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN46@stbi__crea:
  00b2f	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00b34	72 58		 jb	 SHORT $LN45@stbi__crea
  00b36	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00b3e	eb 0a		 jmp	 SHORT $LN49@stbi__crea
$LN47@stbi__crea:
  00b40	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00b44	ff c0		 inc	 eax
  00b46	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN49@stbi__crea:
  00b4a	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00b4e	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00b52	7d 35		 jge	 SHORT $LN48@stbi__crea
  00b54	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00b59	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00b61	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b65	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00b6a	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  00b6f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b73	03 c1		 add	 eax, ecx
  00b75	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b7a	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00b7f	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00b84	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00b87	eb b7		 jmp	 SHORT $LN47@stbi__crea
$LN48@stbi__crea:
  00b89	e9 44 ff ff ff	 jmp	 $LN44@stbi__crea
$LN45@stbi__crea:
  00b8e	e9 dc 03 00 00	 jmp	 $LN30@stbi__crea
$LN131@stbi__crea:

; 4756 :             STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;

  00b93	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00b9a	ff c8		 dec	 eax
  00b9c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00ba0	eb 5d		 jmp	 SHORT $LN52@stbi__crea
$LN50@stbi__crea:
  00ba2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00ba6	ff c8		 dec	 eax
  00ba8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00bac	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00bb1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00bb6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00bba	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00bbf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00bc7	48 03 c8	 add	 rcx, rax
  00bca	48 8b c1	 mov	 rax, rcx
  00bcd	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00bd5	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00bda	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00bdf	48 03 c8	 add	 rcx, rax
  00be2	48 8b c1	 mov	 rax, rcx
  00be5	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00bea	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00bef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00bf4	48 03 c8	 add	 rcx, rax
  00bf7	48 8b c1	 mov	 rax, rcx
  00bfa	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN52@stbi__crea:
  00bff	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00c04	72 74		 jb	 SHORT $LN51@stbi__crea
  00c06	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00c0e	eb 0a		 jmp	 SHORT $LN55@stbi__crea
$LN53@stbi__crea:
  00c10	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00c14	ff c0		 inc	 eax
  00c16	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN55@stbi__crea:
  00c1a	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00c1e	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00c22	7d 51		 jge	 SHORT $LN54@stbi__crea
  00c24	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00c29	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00c31	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c35	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00c3a	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  00c3f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00c43	8b 54 24 4c	 mov	 edx, DWORD PTR output_bytes$[rsp]
  00c47	8b 7c 24 44	 mov	 edi, DWORD PTR k$[rsp]
  00c4b	2b fa		 sub	 edi, edx
  00c4d	8b d7		 mov	 edx, edi
  00c4f	48 63 d2	 movsxd	 rdx, edx
  00c52	48 8b 7c 24 58	 mov	 rdi, QWORD PTR cur$1[rsp]
  00c57	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00c5b	03 ca		 add	 ecx, edx
  00c5d	d1 f9		 sar	 ecx, 1
  00c5f	03 c1		 add	 eax, ecx
  00c61	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c66	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00c6b	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00c70	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c73	eb 9b		 jmp	 SHORT $LN53@stbi__crea
$LN54@stbi__crea:
  00c75	e9 28 ff ff ff	 jmp	 $LN50@stbi__crea
$LN51@stbi__crea:
  00c7a	e9 f0 02 00 00	 jmp	 $LN30@stbi__crea
$LN132@stbi__crea:

; 4757 :             STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;

  00c7f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00c86	ff c8		 dec	 eax
  00c88	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00c8c	eb 5d		 jmp	 SHORT $LN58@stbi__crea
$LN56@stbi__crea:
  00c8e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00c92	ff c8		 dec	 eax
  00c94	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00c98	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00c9d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00ca2	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00ca6	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00cab	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00cb3	48 03 c8	 add	 rcx, rax
  00cb6	48 8b c1	 mov	 rax, rcx
  00cb9	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00cc1	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00cc6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00ccb	48 03 c8	 add	 rcx, rax
  00cce	48 8b c1	 mov	 rax, rcx
  00cd1	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00cd6	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00cdb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00ce0	48 03 c8	 add	 rcx, rax
  00ce3	48 8b c1	 mov	 rax, rcx
  00ce6	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN58@stbi__crea:
  00ceb	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00cf0	0f 82 a9 00 00
	00		 jb	 $LN57@stbi__crea
  00cf6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00cfe	eb 0a		 jmp	 SHORT $LN61@stbi__crea
$LN59@stbi__crea:
  00d00	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00d04	ff c0		 inc	 eax
  00d06	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN61@stbi__crea:
  00d0a	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00d0e	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00d12	0f 8d 82 00 00
	00		 jge	 $LN60@stbi__crea
  00d18	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00d1d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00d25	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d29	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv548[rsp], eax
  00d30	8b 4c 24 4c	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00d34	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00d38	2b d1		 sub	 edx, ecx
  00d3a	8b ca		 mov	 ecx, edx
  00d3c	48 63 c9	 movsxd	 rcx, ecx
  00d3f	48 8b 54 24 60	 mov	 rdx, QWORD PTR prior$2[rsp]
  00d44	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d48	48 63 54 24 44	 movsxd	 rdx, DWORD PTR k$[rsp]
  00d4d	48 8b 7c 24 60	 mov	 rdi, QWORD PTR prior$2[rsp]
  00d52	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00d56	8b 7c 24 4c	 mov	 edi, DWORD PTR output_bytes$[rsp]
  00d5a	8b 74 24 44	 mov	 esi, DWORD PTR k$[rsp]
  00d5e	2b f7		 sub	 esi, edi
  00d60	8b fe		 mov	 edi, esi
  00d62	48 63 ff	 movsxd	 rdi, edi
  00d65	48 8b 74 24 58	 mov	 rsi, QWORD PTR cur$1[rsp]
  00d6a	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00d6e	44 8b c1	 mov	 r8d, ecx
  00d71	8b cf		 mov	 ecx, edi
  00d73	e8 00 00 00 00	 call	 stbi__paeth
  00d78	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv548[rsp]
  00d7f	03 c8		 add	 ecx, eax
  00d81	8b c1		 mov	 eax, ecx
  00d83	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d88	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00d8d	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00d92	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00d95	e9 66 ff ff ff	 jmp	 $LN59@stbi__crea
$LN60@stbi__crea:
  00d9a	e9 ef fe ff ff	 jmp	 $LN56@stbi__crea
$LN57@stbi__crea:
  00d9f	e9 cb 01 00 00	 jmp	 $LN30@stbi__crea
$LN133@stbi__crea:

; 4758 :             STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;

  00da4	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00dab	ff c8		 dec	 eax
  00dad	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00db1	eb 5d		 jmp	 SHORT $LN64@stbi__crea
$LN62@stbi__crea:
  00db3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00db7	ff c8		 dec	 eax
  00db9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00dbd	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00dc2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00dc7	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00dcb	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00dd0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00dd8	48 03 c8	 add	 rcx, rax
  00ddb	48 8b c1	 mov	 rax, rcx
  00dde	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00de6	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00deb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00df0	48 03 c8	 add	 rcx, rax
  00df3	48 8b c1	 mov	 rax, rcx
  00df6	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00dfb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00e00	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00e05	48 03 c8	 add	 rcx, rax
  00e08	48 8b c1	 mov	 rax, rcx
  00e0b	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN64@stbi__crea:
  00e10	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00e15	72 64		 jb	 SHORT $LN63@stbi__crea
  00e17	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00e1f	eb 0a		 jmp	 SHORT $LN67@stbi__crea
$LN65@stbi__crea:
  00e21	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00e25	ff c0		 inc	 eax
  00e27	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN67@stbi__crea:
  00e2b	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00e2f	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00e33	7d 41		 jge	 SHORT $LN66@stbi__crea
  00e35	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00e3a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00e42	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e46	8b 4c 24 4c	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00e4a	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00e4e	2b d1		 sub	 edx, ecx
  00e50	8b ca		 mov	 ecx, edx
  00e52	48 63 c9	 movsxd	 rcx, ecx
  00e55	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00e5a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e5e	d1 f9		 sar	 ecx, 1
  00e60	03 c1		 add	 eax, ecx
  00e62	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e67	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00e6c	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00e71	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e74	eb ab		 jmp	 SHORT $LN65@stbi__crea
$LN66@stbi__crea:
  00e76	e9 38 ff ff ff	 jmp	 $LN62@stbi__crea
$LN63@stbi__crea:
  00e7b	e9 ef 00 00 00	 jmp	 $LN30@stbi__crea
$LN134@stbi__crea:

; 4759 :             STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;

  00e80	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00e87	ff c8		 dec	 eax
  00e89	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00e8d	eb 5d		 jmp	 SHORT $LN70@stbi__crea
$LN68@stbi__crea:
  00e8f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00e93	ff c8		 dec	 eax
  00e95	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00e99	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00e9e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00ea3	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00ea7	48 63 44 24 50	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00eac	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00eb4	48 03 c8	 add	 rcx, rax
  00eb7	48 8b c1	 mov	 rax, rcx
  00eba	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00ec2	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00ec7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00ecc	48 03 c8	 add	 rcx, rax
  00ecf	48 8b c1	 mov	 rax, rcx
  00ed2	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
  00ed7	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00edc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prior$2[rsp]
  00ee1	48 03 c8	 add	 rcx, rax
  00ee4	48 8b c1	 mov	 rax, rcx
  00ee7	48 89 44 24 60	 mov	 QWORD PTR prior$2[rsp], rax
$LN70@stbi__crea:
  00eec	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00ef1	72 7c		 jb	 SHORT $LN69@stbi__crea
  00ef3	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00efb	eb 0a		 jmp	 SHORT $LN73@stbi__crea
$LN71@stbi__crea:
  00efd	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  00f01	ff c0		 inc	 eax
  00f03	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN73@stbi__crea:
  00f07	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00f0b	39 44 24 44	 cmp	 DWORD PTR k$[rsp], eax
  00f0f	7d 59		 jge	 SHORT $LN72@stbi__crea
  00f11	48 63 44 24 44	 movsxd	 rax, DWORD PTR k$[rsp]
  00f16	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00f1e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f22	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv620[rsp], eax
  00f29	8b 4c 24 4c	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00f2d	8b 54 24 44	 mov	 edx, DWORD PTR k$[rsp]
  00f31	2b d1		 sub	 edx, ecx
  00f33	8b ca		 mov	 ecx, edx
  00f35	48 63 c9	 movsxd	 rcx, ecx
  00f38	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00f3d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00f41	45 33 c0	 xor	 r8d, r8d
  00f44	33 d2		 xor	 edx, edx
  00f46	e8 00 00 00 00	 call	 stbi__paeth
  00f4b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv620[rsp]
  00f52	03 c8		 add	 ecx, eax
  00f54	8b c1		 mov	 eax, ecx
  00f56	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f5b	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR k$[rsp]
  00f60	48 8b 54 24 58	 mov	 rdx, QWORD PTR cur$1[rsp]
  00f65	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f68	eb 93		 jmp	 SHORT $LN71@stbi__crea
$LN72@stbi__crea:
  00f6a	e9 20 ff ff ff	 jmp	 $LN68@stbi__crea
$LN69@stbi__crea:
$LN30@stbi__crea:

; 4760 :          }
; 4761 :          #undef STBI__CASE
; 4762 : 
; 4763 :          // the loop above sets the high byte of the pixels' alpha, but for
; 4764 :          // 16 bit png files we also need the low byte set. we'll do that here.
; 4765 :          if (depth == 16) {

  00f6f	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00f77	75 65		 jne	 SHORT $LN135@stbi__crea

; 4766 :             cur = a->out + stride*j; // start at the beginning of the row again

  00f79	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  00f7d	0f af 44 24 34	 imul	 eax, DWORD PTR j$[rsp]
  00f82	8b c0		 mov	 eax, eax
  00f84	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00f8c	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00f90	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax

; 4767 :             for (i=0; i < x; ++i,cur+=output_bytes) {

  00f95	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00f9d	eb 1f		 jmp	 SHORT $LN76@stbi__crea
$LN74@stbi__crea:
  00f9f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00fa3	ff c0		 inc	 eax
  00fa5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00fa9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00fae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00fb3	48 03 c8	 add	 rcx, rax
  00fb6	48 8b c1	 mov	 rax, rcx
  00fb9	48 89 44 24 58	 mov	 QWORD PTR cur$1[rsp], rax
$LN76@stbi__crea:
  00fbe	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00fc5	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00fc9	73 13		 jae	 SHORT $LN75@stbi__crea

; 4768 :                cur[filter_bytes+1] = 255;

  00fcb	8b 44 24 50	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00fcf	ff c0		 inc	 eax
  00fd1	48 98		 cdqe
  00fd3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cur$1[rsp]
  00fd8	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4769 :             }

  00fdc	eb c1		 jmp	 SHORT $LN74@stbi__crea
$LN75@stbi__crea:
$LN135@stbi__crea:
$LN119@stbi__crea:

; 4770 :          }
; 4771 :       }
; 4772 :    }

  00fde	e9 e1 f1 ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4773 : 
; 4774 :    // we make a separate pass to expand bits to pixels; for performance,
; 4775 :    // this could run two scanlines behind the above code, so it won't
; 4776 :    // intefere with filtering but will still be in the cache.
; 4777 :    if (depth < 8) {

  00fe3	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  00feb	0f 8d d0 07 00
	00		 jge	 $LN136@stbi__crea

; 4778 :       for (j=0; j < y; ++j) {

  00ff1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00ff9	eb 0a		 jmp	 SHORT $LN79@stbi__crea
$LN77@stbi__crea:
  00ffb	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00fff	ff c0		 inc	 eax
  01001	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN79@stbi__crea:
  01005	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  0100c	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  01010	0f 83 a6 07 00
	00		 jae	 $LN78@stbi__crea

; 4779 :          stbi_uc *cur = a->out + stride*j;

  01016	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  0101a	0f af 44 24 34	 imul	 eax, DWORD PTR j$[rsp]
  0101f	8b c0		 mov	 eax, eax
  01021	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  01029	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  0102d	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4780 :          stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;

  01032	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  01036	0f af 44 24 34	 imul	 eax, DWORD PTR j$[rsp]
  0103b	8b c0		 mov	 eax, eax
  0103d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  01045	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01049	48 03 c8	 add	 rcx, rax
  0104c	48 8b c1	 mov	 rax, rcx
  0104f	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR x$[rsp]
  01056	0f af 8c 24 f8
	00 00 00	 imul	 ecx, DWORD PTR out_n$[rsp]
  0105e	8b c9		 mov	 ecx, ecx
  01060	48 03 c1	 add	 rax, rcx
  01063	8b 4c 24 40	 mov	 ecx, DWORD PTR img_width_bytes$[rsp]
  01067	48 2b c1	 sub	 rax, rcx
  0106a	48 89 44 24 78	 mov	 QWORD PTR in$6[rsp], rax

; 4781 :          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4782 :          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4783 :          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

  0106f	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR color$[rsp], 0
  01077	75 1c		 jne	 SHORT $LN163@stbi__crea
  01079	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR depth$[rsp]
  01081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stbi__depth_scale_table
  01088	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0108c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv668[rsp], eax
  01093	eb 0b		 jmp	 SHORT $LN164@stbi__crea
$LN163@stbi__crea:
  01095	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv668[rsp], 1
$LN164@stbi__crea:
  010a0	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR tv668[rsp]
  010a8	88 84 24 80 00
	00 00		 mov	 BYTE PTR scale$7[rsp], al

; 4784 : 
; 4785 :          // note that the final byte might overshoot and write more data than desired.
; 4786 :          // we can allocate enough data that this never writes out of memory, but it
; 4787 :          // could also overwrite the next scanline. can it overwrite non-empty data
; 4788 :          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4789 :          // so we need to explicitly clamp the final ones
; 4790 : 
; 4791 :          if (depth == 4) {

  010af	83 bc 24 10 01
	00 00 04	 cmp	 DWORD PTR depth$[rsp], 4
  010b7	0f 85 bd 00 00
	00		 jne	 $LN138@stbi__crea

; 4792 :             for (k=x*img_n; k >= 2; k-=2, ++in) {

  010bd	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  010c4	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  010c9	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  010cd	eb 18		 jmp	 SHORT $LN82@stbi__crea
$LN80@stbi__crea:
  010cf	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  010d3	83 e8 02	 sub	 eax, 2
  010d6	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  010da	48 8b 44 24 78	 mov	 rax, QWORD PTR in$6[rsp]
  010df	48 ff c0	 inc	 rax
  010e2	48 89 44 24 78	 mov	 QWORD PTR in$6[rsp], rax
$LN82@stbi__crea:
  010e7	83 7c 24 44 02	 cmp	 DWORD PTR k$[rsp], 2
  010ec	7c 56		 jl	 SHORT $LN81@stbi__crea

; 4793 :                *cur++ = scale * ((*in >> 4)       );

  010ee	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  010f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  010fb	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  010fe	c1 f9 04	 sar	 ecx, 4
  01101	0f af c1	 imul	 eax, ecx
  01104	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01109	88 01		 mov	 BYTE PTR [rcx], al
  0110b	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01110	48 ff c0	 inc	 rax
  01113	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4794 :                *cur++ = scale * ((*in     ) & 0x0f);

  01118	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01120	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01125	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01128	83 e1 0f	 and	 ecx, 15
  0112b	0f af c1	 imul	 eax, ecx
  0112e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01133	88 01		 mov	 BYTE PTR [rcx], al
  01135	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  0113a	48 ff c0	 inc	 rax
  0113d	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4795 :             }

  01142	eb 8b		 jmp	 SHORT $LN80@stbi__crea
$LN81@stbi__crea:

; 4796 :             if (k > 0) *cur++ = scale * ((*in >> 4)       );

  01144	83 7c 24 44 00	 cmp	 DWORD PTR k$[rsp], 0
  01149	7e 2a		 jle	 SHORT $LN140@stbi__crea
  0114b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01153	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01158	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0115b	c1 f9 04	 sar	 ecx, 4
  0115e	0f af c1	 imul	 eax, ecx
  01161	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01166	88 01		 mov	 BYTE PTR [rcx], al
  01168	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  0116d	48 ff c0	 inc	 rax
  01170	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN140@stbi__crea:

; 4797 :          } else if (depth == 2) {

  01175	e9 a5 04 00 00	 jmp	 $LN139@stbi__crea
$LN138@stbi__crea:
  0117a	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR depth$[rsp], 2
  01182	0f 85 86 01 00
	00		 jne	 $LN141@stbi__crea

; 4798 :             for (k=x*img_n; k >= 4; k-=4, ++in) {

  01188	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0118f	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  01194	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  01198	eb 18		 jmp	 SHORT $LN85@stbi__crea
$LN83@stbi__crea:
  0119a	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  0119e	83 e8 04	 sub	 eax, 4
  011a1	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  011a5	48 8b 44 24 78	 mov	 rax, QWORD PTR in$6[rsp]
  011aa	48 ff c0	 inc	 rax
  011ad	48 89 44 24 78	 mov	 QWORD PTR in$6[rsp], rax
$LN85@stbi__crea:
  011b2	83 7c 24 44 04	 cmp	 DWORD PTR k$[rsp], 4
  011b7	0f 8c b3 00 00
	00		 jl	 $LN84@stbi__crea

; 4799 :                *cur++ = scale * ((*in >> 6)       );

  011bd	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  011c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  011ca	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  011cd	c1 f9 06	 sar	 ecx, 6
  011d0	0f af c1	 imul	 eax, ecx
  011d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  011d8	88 01		 mov	 BYTE PTR [rcx], al
  011da	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  011df	48 ff c0	 inc	 rax
  011e2	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4800 :                *cur++ = scale * ((*in >> 4) & 0x03);

  011e7	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  011ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  011f4	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  011f7	c1 f9 04	 sar	 ecx, 4
  011fa	83 e1 03	 and	 ecx, 3
  011fd	0f af c1	 imul	 eax, ecx
  01200	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01205	88 01		 mov	 BYTE PTR [rcx], al
  01207	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  0120c	48 ff c0	 inc	 rax
  0120f	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4801 :                *cur++ = scale * ((*in >> 2) & 0x03);

  01214	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  0121c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01221	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01224	c1 f9 02	 sar	 ecx, 2
  01227	83 e1 03	 and	 ecx, 3
  0122a	0f af c1	 imul	 eax, ecx
  0122d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01232	88 01		 mov	 BYTE PTR [rcx], al
  01234	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01239	48 ff c0	 inc	 rax
  0123c	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4802 :                *cur++ = scale * ((*in     ) & 0x03);

  01241	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01249	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  0124e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01251	83 e1 03	 and	 ecx, 3
  01254	0f af c1	 imul	 eax, ecx
  01257	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  0125c	88 01		 mov	 BYTE PTR [rcx], al
  0125e	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01263	48 ff c0	 inc	 rax
  01266	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4803 :             }

  0126b	e9 2a ff ff ff	 jmp	 $LN83@stbi__crea
$LN84@stbi__crea:

; 4804 :             if (k > 0) *cur++ = scale * ((*in >> 6)       );

  01270	83 7c 24 44 00	 cmp	 DWORD PTR k$[rsp], 0
  01275	7e 2a		 jle	 SHORT $LN143@stbi__crea
  01277	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  0127f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01284	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01287	c1 f9 06	 sar	 ecx, 6
  0128a	0f af c1	 imul	 eax, ecx
  0128d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01292	88 01		 mov	 BYTE PTR [rcx], al
  01294	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01299	48 ff c0	 inc	 rax
  0129c	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN143@stbi__crea:

; 4805 :             if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

  012a1	83 7c 24 44 01	 cmp	 DWORD PTR k$[rsp], 1
  012a6	7e 2d		 jle	 SHORT $LN144@stbi__crea
  012a8	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  012b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  012b5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  012b8	c1 f9 04	 sar	 ecx, 4
  012bb	83 e1 03	 and	 ecx, 3
  012be	0f af c1	 imul	 eax, ecx
  012c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  012c6	88 01		 mov	 BYTE PTR [rcx], al
  012c8	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  012cd	48 ff c0	 inc	 rax
  012d0	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN144@stbi__crea:

; 4806 :             if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

  012d5	83 7c 24 44 02	 cmp	 DWORD PTR k$[rsp], 2
  012da	7e 2d		 jle	 SHORT $LN145@stbi__crea
  012dc	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  012e4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  012e9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  012ec	c1 f9 02	 sar	 ecx, 2
  012ef	83 e1 03	 and	 ecx, 3
  012f2	0f af c1	 imul	 eax, ecx
  012f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  012fa	88 01		 mov	 BYTE PTR [rcx], al
  012fc	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01301	48 ff c0	 inc	 rax
  01304	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN145@stbi__crea:

; 4807 :          } else if (depth == 1) {

  01309	e9 11 03 00 00	 jmp	 $LN142@stbi__crea
$LN141@stbi__crea:
  0130e	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR depth$[rsp], 1
  01316	0f 85 03 03 00
	00		 jne	 $LN146@stbi__crea

; 4808 :             for (k=x*img_n; k >= 8; k-=8, ++in) {

  0131c	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  01323	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  01328	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  0132c	eb 18		 jmp	 SHORT $LN88@stbi__crea
$LN86@stbi__crea:
  0132e	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  01332	83 e8 08	 sub	 eax, 8
  01335	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  01339	48 8b 44 24 78	 mov	 rax, QWORD PTR in$6[rsp]
  0133e	48 ff c0	 inc	 rax
  01341	48 89 44 24 78	 mov	 QWORD PTR in$6[rsp], rax
$LN88@stbi__crea:
  01346	83 7c 24 44 08	 cmp	 DWORD PTR k$[rsp], 8
  0134b	0f 8c 66 01 00
	00		 jl	 $LN87@stbi__crea

; 4809 :                *cur++ = scale * ((*in >> 7)       );

  01351	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01359	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  0135e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01361	c1 f9 07	 sar	 ecx, 7
  01364	0f af c1	 imul	 eax, ecx
  01367	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  0136c	88 01		 mov	 BYTE PTR [rcx], al
  0136e	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01373	48 ff c0	 inc	 rax
  01376	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4810 :                *cur++ = scale * ((*in >> 6) & 0x01);

  0137b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01383	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01388	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0138b	c1 f9 06	 sar	 ecx, 6
  0138e	83 e1 01	 and	 ecx, 1
  01391	0f af c1	 imul	 eax, ecx
  01394	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01399	88 01		 mov	 BYTE PTR [rcx], al
  0139b	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  013a0	48 ff c0	 inc	 rax
  013a3	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4811 :                *cur++ = scale * ((*in >> 5) & 0x01);

  013a8	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  013b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  013b5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  013b8	c1 f9 05	 sar	 ecx, 5
  013bb	83 e1 01	 and	 ecx, 1
  013be	0f af c1	 imul	 eax, ecx
  013c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  013c6	88 01		 mov	 BYTE PTR [rcx], al
  013c8	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  013cd	48 ff c0	 inc	 rax
  013d0	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4812 :                *cur++ = scale * ((*in >> 4) & 0x01);

  013d5	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  013dd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  013e2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  013e5	c1 f9 04	 sar	 ecx, 4
  013e8	83 e1 01	 and	 ecx, 1
  013eb	0f af c1	 imul	 eax, ecx
  013ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  013f3	88 01		 mov	 BYTE PTR [rcx], al
  013f5	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  013fa	48 ff c0	 inc	 rax
  013fd	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4813 :                *cur++ = scale * ((*in >> 3) & 0x01);

  01402	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  0140a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  0140f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01412	c1 f9 03	 sar	 ecx, 3
  01415	83 e1 01	 and	 ecx, 1
  01418	0f af c1	 imul	 eax, ecx
  0141b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01420	88 01		 mov	 BYTE PTR [rcx], al
  01422	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01427	48 ff c0	 inc	 rax
  0142a	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4814 :                *cur++ = scale * ((*in >> 2) & 0x01);

  0142f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01437	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  0143c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0143f	c1 f9 02	 sar	 ecx, 2
  01442	83 e1 01	 and	 ecx, 1
  01445	0f af c1	 imul	 eax, ecx
  01448	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  0144d	88 01		 mov	 BYTE PTR [rcx], al
  0144f	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01454	48 ff c0	 inc	 rax
  01457	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4815 :                *cur++ = scale * ((*in >> 1) & 0x01);

  0145c	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01464	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01469	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0146c	d1 f9		 sar	 ecx, 1
  0146e	83 e1 01	 and	 ecx, 1
  01471	0f af c1	 imul	 eax, ecx
  01474	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01479	88 01		 mov	 BYTE PTR [rcx], al
  0147b	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01480	48 ff c0	 inc	 rax
  01483	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4816 :                *cur++ = scale * ((*in     ) & 0x01);

  01488	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01490	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01495	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01498	83 e1 01	 and	 ecx, 1
  0149b	0f af c1	 imul	 eax, ecx
  0149e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  014a3	88 01		 mov	 BYTE PTR [rcx], al
  014a5	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  014aa	48 ff c0	 inc	 rax
  014ad	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4817 :             }

  014b2	e9 77 fe ff ff	 jmp	 $LN86@stbi__crea
$LN87@stbi__crea:

; 4818 :             if (k > 0) *cur++ = scale * ((*in >> 7)       );

  014b7	83 7c 24 44 00	 cmp	 DWORD PTR k$[rsp], 0
  014bc	7e 2a		 jle	 SHORT $LN147@stbi__crea
  014be	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  014c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  014cb	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014ce	c1 f9 07	 sar	 ecx, 7
  014d1	0f af c1	 imul	 eax, ecx
  014d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  014d9	88 01		 mov	 BYTE PTR [rcx], al
  014db	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  014e0	48 ff c0	 inc	 rax
  014e3	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN147@stbi__crea:

; 4819 :             if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

  014e8	83 7c 24 44 01	 cmp	 DWORD PTR k$[rsp], 1
  014ed	7e 2d		 jle	 SHORT $LN148@stbi__crea
  014ef	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  014f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  014fc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014ff	c1 f9 06	 sar	 ecx, 6
  01502	83 e1 01	 and	 ecx, 1
  01505	0f af c1	 imul	 eax, ecx
  01508	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  0150d	88 01		 mov	 BYTE PTR [rcx], al
  0150f	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01514	48 ff c0	 inc	 rax
  01517	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN148@stbi__crea:

; 4820 :             if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

  0151c	83 7c 24 44 02	 cmp	 DWORD PTR k$[rsp], 2
  01521	7e 2d		 jle	 SHORT $LN149@stbi__crea
  01523	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  0152b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01530	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01533	c1 f9 05	 sar	 ecx, 5
  01536	83 e1 01	 and	 ecx, 1
  01539	0f af c1	 imul	 eax, ecx
  0153c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01541	88 01		 mov	 BYTE PTR [rcx], al
  01543	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01548	48 ff c0	 inc	 rax
  0154b	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN149@stbi__crea:

; 4821 :             if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

  01550	83 7c 24 44 03	 cmp	 DWORD PTR k$[rsp], 3
  01555	7e 2d		 jle	 SHORT $LN150@stbi__crea
  01557	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  0155f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01564	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01567	c1 f9 04	 sar	 ecx, 4
  0156a	83 e1 01	 and	 ecx, 1
  0156d	0f af c1	 imul	 eax, ecx
  01570	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01575	88 01		 mov	 BYTE PTR [rcx], al
  01577	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  0157c	48 ff c0	 inc	 rax
  0157f	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN150@stbi__crea:

; 4822 :             if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

  01584	83 7c 24 44 04	 cmp	 DWORD PTR k$[rsp], 4
  01589	7e 2d		 jle	 SHORT $LN151@stbi__crea
  0158b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  01593	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01598	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0159b	c1 f9 03	 sar	 ecx, 3
  0159e	83 e1 01	 and	 ecx, 1
  015a1	0f af c1	 imul	 eax, ecx
  015a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  015a9	88 01		 mov	 BYTE PTR [rcx], al
  015ab	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  015b0	48 ff c0	 inc	 rax
  015b3	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN151@stbi__crea:

; 4823 :             if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

  015b8	83 7c 24 44 05	 cmp	 DWORD PTR k$[rsp], 5
  015bd	7e 2d		 jle	 SHORT $LN152@stbi__crea
  015bf	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  015c7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  015cc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  015cf	c1 f9 02	 sar	 ecx, 2
  015d2	83 e1 01	 and	 ecx, 1
  015d5	0f af c1	 imul	 eax, ecx
  015d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  015dd	88 01		 mov	 BYTE PTR [rcx], al
  015df	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  015e4	48 ff c0	 inc	 rax
  015e7	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN152@stbi__crea:

; 4824 :             if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

  015ec	83 7c 24 44 06	 cmp	 DWORD PTR k$[rsp], 6
  015f1	7e 2c		 jle	 SHORT $LN153@stbi__crea
  015f3	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR scale$7[rsp]
  015fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR in$6[rsp]
  01600	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01603	d1 f9		 sar	 ecx, 1
  01605	83 e1 01	 and	 ecx, 1
  01608	0f af c1	 imul	 eax, ecx
  0160b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01610	88 01		 mov	 BYTE PTR [rcx], al
  01612	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$5[rsp]
  01617	48 ff c0	 inc	 rax
  0161a	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax
$LN153@stbi__crea:
$LN146@stbi__crea:
$LN142@stbi__crea:
$LN139@stbi__crea:

; 4825 :          }
; 4826 :          if (img_n != out_n) {

  0161f	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  01626	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  0162a	0f 84 87 01 00
	00		 je	 $LN154@stbi__crea

; 4827 :             int q;
; 4828 :             // insert alpha = 255
; 4829 :             cur = a->out + stride*j;

  01630	8b 44 24 38	 mov	 eax, DWORD PTR stride$[rsp]
  01634	0f af 44 24 34	 imul	 eax, DWORD PTR j$[rsp]
  01639	8b c0		 mov	 eax, eax
  0163b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  01643	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01647	48 89 44 24 70	 mov	 QWORD PTR cur$5[rsp], rax

; 4830 :             if (img_n == 1) {

  0164c	83 7c 24 48 01	 cmp	 DWORD PTR img_n$[rsp], 1
  01651	75 6e		 jne	 SHORT $LN155@stbi__crea

; 4831 :                for (q=x-1; q >= 0; --q) {

  01653	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0165a	ff c8		 dec	 eax
  0165c	89 84 24 84 00
	00 00		 mov	 DWORD PTR q$8[rsp], eax
  01663	eb 10		 jmp	 SHORT $LN91@stbi__crea
$LN89@stbi__crea:
  01665	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR q$8[rsp]
  0166c	ff c8		 dec	 eax
  0166e	89 84 24 84 00
	00 00		 mov	 DWORD PTR q$8[rsp], eax
$LN91@stbi__crea:
  01675	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR q$8[rsp], 0
  0167d	7c 3d		 jl	 SHORT $LN90@stbi__crea

; 4832 :                   cur[q*2+1] = 255;

  0167f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR q$8[rsp]
  01686	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0168a	48 98		 cdqe
  0168c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01691	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4833 :                   cur[q*2+0] = cur[q];

  01695	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR q$8[rsp]
  0169d	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR q$8[rsp]
  016a4	03 c9		 add	 ecx, ecx
  016a6	48 63 c9	 movsxd	 rcx, ecx
  016a9	48 8b 54 24 70	 mov	 rdx, QWORD PTR cur$5[rsp]
  016ae	48 8b 7c 24 70	 mov	 rdi, QWORD PTR cur$5[rsp]
  016b3	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  016b7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4834 :                }

  016ba	eb a9		 jmp	 SHORT $LN89@stbi__crea
$LN90@stbi__crea:

; 4835 :             } else {

  016bc	e9 f6 00 00 00	 jmp	 $LN156@stbi__crea
$LN155@stbi__crea:

; 4836 :                STBI_ASSERT(img_n == 3);

  016c1	83 7c 24 48 03	 cmp	 DWORD PTR img_n$[rsp], 3
  016c6	74 1c		 je	 SHORT $LN165@stbi__crea
  016c8	41 b8 e4 12 00
	00		 mov	 r8d, 4836		; 000012e4H
  016ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  016d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FLOPDKAN@?$AAi?$AAm?$AAg?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA3@
  016dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  016e2	33 c0		 xor	 eax, eax
$LN165@stbi__crea:

; 4837 :                for (q=x-1; q >= 0; --q) {

  016e4	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  016eb	ff c8		 dec	 eax
  016ed	89 84 24 84 00
	00 00		 mov	 DWORD PTR q$8[rsp], eax
  016f4	eb 10		 jmp	 SHORT $LN94@stbi__crea
$LN92@stbi__crea:
  016f6	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR q$8[rsp]
  016fd	ff c8		 dec	 eax
  016ff	89 84 24 84 00
	00 00		 mov	 DWORD PTR q$8[rsp], eax
$LN94@stbi__crea:
  01706	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR q$8[rsp], 0
  0170e	0f 8c a3 00 00
	00		 jl	 $LN93@stbi__crea

; 4838 :                   cur[q*4+3] = 255;

  01714	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR q$8[rsp]
  0171b	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  01722	48 98		 cdqe
  01724	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cur$5[rsp]
  01729	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4839 :                   cur[q*4+2] = cur[q*3+2];

  0172d	6b 84 24 84 00
	00 00 03	 imul	 eax, DWORD PTR q$8[rsp], 3
  01735	83 c0 02	 add	 eax, 2
  01738	48 98		 cdqe
  0173a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR q$8[rsp]
  01741	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  01748	48 63 c9	 movsxd	 rcx, ecx
  0174b	48 8b 54 24 70	 mov	 rdx, QWORD PTR cur$5[rsp]
  01750	48 8b 7c 24 70	 mov	 rdi, QWORD PTR cur$5[rsp]
  01755	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  01759	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4840 :                   cur[q*4+1] = cur[q*3+1];

  0175c	6b 84 24 84 00
	00 00 03	 imul	 eax, DWORD PTR q$8[rsp], 3
  01764	ff c0		 inc	 eax
  01766	48 98		 cdqe
  01768	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR q$8[rsp]
  0176f	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  01776	48 63 c9	 movsxd	 rcx, ecx
  01779	48 8b 54 24 70	 mov	 rdx, QWORD PTR cur$5[rsp]
  0177e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR cur$5[rsp]
  01783	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  01787	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4841 :                   cur[q*4+0] = cur[q*3+0];

  0178a	6b 84 24 84 00
	00 00 03	 imul	 eax, DWORD PTR q$8[rsp], 3
  01792	48 98		 cdqe
  01794	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR q$8[rsp]
  0179b	c1 e1 02	 shl	 ecx, 2
  0179e	48 63 c9	 movsxd	 rcx, ecx
  017a1	48 8b 54 24 70	 mov	 rdx, QWORD PTR cur$5[rsp]
  017a6	48 8b 7c 24 70	 mov	 rdi, QWORD PTR cur$5[rsp]
  017ab	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  017af	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4842 :                }

  017b2	e9 3f ff ff ff	 jmp	 $LN92@stbi__crea
$LN93@stbi__crea:
$LN156@stbi__crea:
$LN154@stbi__crea:

; 4843 :             }
; 4844 :          }
; 4845 :       }

  017b7	e9 3f f8 ff ff	 jmp	 $LN77@stbi__crea
$LN78@stbi__crea:

; 4846 :    } else if (depth == 16) {

  017bc	e9 ca 00 00 00	 jmp	 $LN137@stbi__crea
$LN136@stbi__crea:
  017c1	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  017c9	0f 85 bc 00 00
	00		 jne	 $LN157@stbi__crea

; 4847 :       // force the image data from big-endian to platform-native.
; 4848 :       // this is done in a separate pass due to the decoding relying
; 4849 :       // on the data being untouched, but could probably be done
; 4850 :       // per-line during decode if care is taken.
; 4851 :       stbi_uc *cur = a->out;

  017cf	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  017d7	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  017db	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cur$9[rsp], rax

; 4852 :       stbi__uint16 *cur16 = (stbi__uint16*)cur;

  017e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cur$9[rsp]
  017eb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur16$10[rsp], rax

; 4853 : 
; 4854 :       for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {

  017f3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  017fb	eb 32		 jmp	 SHORT $LN97@stbi__crea
$LN95@stbi__crea:
  017fd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  01801	ff c0		 inc	 eax
  01803	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  01807	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cur16$10[rsp]
  0180f	48 83 c0 02	 add	 rax, 2
  01813	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur16$10[rsp], rax
  0181b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cur$9[rsp]
  01823	48 83 c0 02	 add	 rax, 2
  01827	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cur$9[rsp], rax
$LN97@stbi__crea:
  0182f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  01836	0f af 84 24 08
	01 00 00	 imul	 eax, DWORD PTR y$[rsp]
  0183e	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  01846	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0184a	73 3f		 jae	 SHORT $LN96@stbi__crea

; 4855 :          *cur16 = (cur[0] << 8) | cur[1];

  0184c	b8 01 00 00 00	 mov	 eax, 1
  01851	48 6b c0 00	 imul	 rax, rax, 0
  01855	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cur$9[rsp]
  0185d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01861	c1 e0 08	 shl	 eax, 8
  01864	b9 01 00 00 00	 mov	 ecx, 1
  01869	48 6b c9 01	 imul	 rcx, rcx, 1
  0186d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR cur$9[rsp]
  01875	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01879	0b c1		 or	 eax, ecx
  0187b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cur16$10[rsp]
  01883	66 89 01	 mov	 WORD PTR [rcx], ax

; 4856 :       }

  01886	e9 72 ff ff ff	 jmp	 $LN95@stbi__crea
$LN96@stbi__crea:
$LN157@stbi__crea:
$LN137@stbi__crea:

; 4857 :    }
; 4858 : 
; 4859 :    return 1;

  0188b	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4860 : }

  01890	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  01897	5f		 pop	 rdi
  01898	5e		 pop	 rsi
  01899	c3		 ret	 0
  0189a	66 90		 npad	 2
$LN168@stbi__crea:
  0189c	00 00 00 00	 DD	 $LN105@stbi__crea
  018a0	00 00 00 00	 DD	 $LN106@stbi__crea
  018a4	00 00 00 00	 DD	 $LN107@stbi__crea
  018a8	00 00 00 00	 DD	 $LN108@stbi__crea
  018ac	00 00 00 00	 DD	 $LN109@stbi__crea
  018b0	00 00 00 00	 DD	 $LN110@stbi__crea
  018b4	00 00 00 00	 DD	 $LN111@stbi__crea
$LN167@stbi__crea:
  018b8	00 00 00 00	 DD	 $LN121@stbi__crea
  018bc	00 00 00 00	 DD	 $LN122@stbi__crea
  018c0	00 00 00 00	 DD	 $LN123@stbi__crea
  018c4	00 00 00 00	 DD	 $LN124@stbi__crea
  018c8	00 00 00 00	 DD	 $LN125@stbi__crea
  018cc	00 00 00 00	 DD	 $LN126@stbi__crea
  018d0	00 00 00 00	 DD	 $LN127@stbi__crea
$LN166@stbi__crea:
  018d4	00 00 00 00	 DD	 $LN128@stbi__crea
  018d8	00 00 00 00	 DD	 $LN129@stbi__crea
  018dc	00 00 00 00	 DD	 $LN130@stbi__crea
  018e0	00 00 00 00	 DD	 $LN131@stbi__crea
  018e4	00 00 00 00	 DD	 $LN132@stbi__crea
  018e8	00 00 00 00	 DD	 $LN133@stbi__crea
  018ec	00 00 00 00	 DD	 $LN134@stbi__crea
stbi__create_png_image_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
bytes$ = 64
out_bytes$ = 68
final$ = 72
p$ = 80
xorig$7 = 104
yorig$8 = 168
xspc$9 = 232
yspc$10 = 296
i$11 = 340
j$12 = 344
x$13 = 348
y$14 = 352
img_len$15 = 356
out_y$16 = 360
out_x$17 = 364
tv65 = 368
a$ = 416
image_data$ = 424
image_data_len$ = 432
out_n$ = 440
depth$ = 448
color$ = 456
interlaced$ = 464
stbi__create_png_image PROC

; 4863 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001d	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00022	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR [rsp+416]
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4864 :    int bytes = (depth == 16 ? 2 : 1);

  00042	83 bc 24 c0 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  0004a	75 0d		 jne	 SHORT $LN16@stbi__crea
  0004c	c7 84 24 70 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv65[rsp], 2
  00057	eb 0b		 jmp	 SHORT $LN17@stbi__crea
$LN16@stbi__crea:
  00059	c7 84 24 70 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv65[rsp], 1
$LN17@stbi__crea:
  00064	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  0006b	89 44 24 40	 mov	 DWORD PTR bytes$[rsp], eax

; 4865 :    int out_bytes = out_n * bytes;

  0006f	8b 84 24 b8 01
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00076	0f af 44 24 40	 imul	 eax, DWORD PTR bytes$[rsp]
  0007b	89 44 24 44	 mov	 DWORD PTR out_bytes$[rsp], eax

; 4866 :    stbi_uc *final;
; 4867 :    int p;
; 4868 :    if (!interlaced)

  0007f	83 bc 24 d0 01
	00 00 00	 cmp	 DWORD PTR interlaced$[rsp], 0
  00087	75 63		 jne	 SHORT $LN11@stbi__crea

; 4869 :       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

  00089	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00091	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00094	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0009c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009f	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR color$[rsp]
  000a6	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000aa	8b 94 24 c0 01
	00 00		 mov	 edx, DWORD PTR depth$[rsp]
  000b1	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  000b5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000bc	8b 01		 mov	 eax, DWORD PTR [rcx]
  000be	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c2	44 8b 8c 24 b8
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  000ca	44 8b 84 24 b0
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  000d2	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  000da	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e2	e8 00 00 00 00	 call	 stbi__create_png_image_raw
  000e7	e9 55 04 00 00	 jmp	 $LN1@stbi__crea
$LN11@stbi__crea:

; 4870 : 
; 4871 :    // de-interlacing
; 4872 :    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

  000ec	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f7	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000ff	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00102	45 33 c9	 xor	 r9d, r9d
  00105	44 8b 44 24 44	 mov	 r8d, DWORD PTR out_bytes$[rsp]
  0010a	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0010d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0010f	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00114	48 89 44 24 48	 mov	 QWORD PTR final$[rsp], rax

; 4873 :    if (!final) return stbi__err("outofmem", "Out of memory");

  00119	48 83 7c 24 48
	00		 cmp	 QWORD PTR final$[rsp], 0
  0011f	75 11		 jne	 SHORT $LN12@stbi__crea
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00128	e8 00 00 00 00	 call	 stbi__err
  0012d	e9 0f 04 00 00	 jmp	 $LN1@stbi__crea
$LN12@stbi__crea:

; 4874 :    for (p=0; p < 7; ++p) {

  00132	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR p$[rsp], 0
  0013a	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  0013c	8b 44 24 50	 mov	 eax, DWORD PTR p$[rsp]
  00140	ff c0		 inc	 eax
  00142	89 44 24 50	 mov	 DWORD PTR p$[rsp], eax
$LN4@stbi__crea:
  00146	83 7c 24 50 07	 cmp	 DWORD PTR p$[rsp], 7
  0014b	0f 8d da 03 00
	00		 jge	 $LN3@stbi__crea

; 4875 :       int xorig[] = { 0,4,0,2,0,1,0 };

  00151	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR xorig$7[rsp], 0
  00159	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR xorig$7[rsp+4], 4
  00161	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR xorig$7[rsp+8], 0
  00169	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR xorig$7[rsp+12], 2
  00171	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR xorig$7[rsp+16], 0
  00179	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR xorig$7[rsp+20], 1
  00181	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$7[rsp+24], 0

; 4876 :       int yorig[] = { 0,0,4,0,2,0,1 };

  0018c	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$8[rsp], 0
  00197	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+4], 0
  001a2	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+8], 4
  001ad	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+12], 0
  001b8	c7 84 24 b8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+16], 2
  001c3	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+20], 0
  001ce	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR yorig$8[rsp+24], 1

; 4877 :       int xspc[]  = { 8,8,4,4,2,2,1 };

  001d9	c7 84 24 e8 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp], 8
  001e4	c7 84 24 ec 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+4], 8
  001ef	c7 84 24 f0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+8], 4
  001fa	c7 84 24 f4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+12], 4
  00205	c7 84 24 f8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+16], 2
  00210	c7 84 24 fc 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+20], 2
  0021b	c7 84 24 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+24], 1

; 4878 :       int yspc[]  = { 8,8,8,4,4,2,2 };

  00226	c7 84 24 28 01
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$10[rsp], 8
  00231	c7 84 24 2c 01
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+4], 8
  0023c	c7 84 24 30 01
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+8], 8
  00247	c7 84 24 34 01
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+12], 4
  00252	c7 84 24 38 01
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+16], 4
  0025d	c7 84 24 3c 01
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+20], 2
  00268	c7 84 24 40 01
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$10[rsp+24], 2

; 4879 :       int i,j,x,y;
; 4880 :       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4881 :       x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

  00273	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0027b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0027e	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  00283	8b 4c 8c 68	 mov	 ecx, DWORD PTR xorig$7[rsp+rcx*4]
  00287	8b 00		 mov	 eax, DWORD PTR [rax]
  00289	2b c1		 sub	 eax, ecx
  0028b	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  00290	8b 8c 8c e8 00
	00 00		 mov	 ecx, DWORD PTR xspc$9[rsp+rcx*4]
  00297	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0029b	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  002a0	33 d2		 xor	 edx, edx
  002a2	f7 b4 8c e8 00
	00 00		 div	 DWORD PTR xspc$9[rsp+rcx*4]
  002a9	89 84 24 5c 01
	00 00		 mov	 DWORD PTR x$13[rsp], eax

; 4882 :       y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

  002b0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002bb	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  002c0	8b 8c 8c a8 00
	00 00		 mov	 ecx, DWORD PTR yorig$8[rsp+rcx*4]
  002c7	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002ca	2b c1		 sub	 eax, ecx
  002cc	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  002d1	8b 8c 8c 28 01
	00 00		 mov	 ecx, DWORD PTR yspc$10[rsp+rcx*4]
  002d8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002dc	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  002e1	33 d2		 xor	 edx, edx
  002e3	f7 b4 8c 28 01
	00 00		 div	 DWORD PTR yspc$10[rsp+rcx*4]
  002ea	89 84 24 60 01
	00 00		 mov	 DWORD PTR y$14[rsp], eax

; 4883 :       if (x && y) {

  002f1	83 bc 24 5c 01
	00 00 00	 cmp	 DWORD PTR x$13[rsp], 0
  002f9	0f 84 27 02 00
	00		 je	 $LN13@stbi__crea
  002ff	83 bc 24 60 01
	00 00 00	 cmp	 DWORD PTR y$14[rsp], 0
  00307	0f 84 19 02 00
	00		 je	 $LN13@stbi__crea

; 4884 :          stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

  0030d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00315	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00318	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0031b	0f af 84 24 5c
	01 00 00	 imul	 eax, DWORD PTR x$13[rsp]
  00323	0f af 84 24 c0
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  0032b	83 c0 07	 add	 eax, 7
  0032e	c1 f8 03	 sar	 eax, 3
  00331	ff c0		 inc	 eax
  00333	0f af 84 24 60
	01 00 00	 imul	 eax, DWORD PTR y$14[rsp]
  0033b	89 84 24 64 01
	00 00		 mov	 DWORD PTR img_len$15[rsp], eax

; 4885 :          if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

  00342	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  00349	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0034d	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR depth$[rsp]
  00354	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00358	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR y$14[rsp]
  0035f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00363	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR x$13[rsp]
  0036a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0036e	44 8b 8c 24 b8
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  00376	44 8b 84 24 b0
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  0037e	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  00386	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0038e	e8 00 00 00 00	 call	 stbi__create_png_image_raw
  00393	85 c0		 test	 eax, eax
  00395	75 12		 jne	 SHORT $LN14@stbi__crea

; 4886 :             STBI_FREE(final);

  00397	48 8b 4c 24 48	 mov	 rcx, QWORD PTR final$[rsp]
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4887 :             return 0;

  003a2	33 c0		 xor	 eax, eax
  003a4	e9 98 01 00 00	 jmp	 $LN1@stbi__crea
$LN14@stbi__crea:

; 4888 :          }
; 4889 :          for (j=0; j < y; ++j) {

  003a9	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR j$12[rsp], 0
  003b4	eb 10		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  003b6	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR j$12[rsp]
  003bd	ff c0		 inc	 eax
  003bf	89 84 24 58 01
	00 00		 mov	 DWORD PTR j$12[rsp], eax
$LN7@stbi__crea:
  003c6	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR y$14[rsp]
  003cd	39 84 24 58 01
	00 00		 cmp	 DWORD PTR j$12[rsp], eax
  003d4	0f 8d 04 01 00
	00		 jge	 $LN6@stbi__crea

; 4890 :             for (i=0; i < x; ++i) {

  003da	c7 84 24 54 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$11[rsp], 0
  003e5	eb 10		 jmp	 SHORT $LN10@stbi__crea
$LN8@stbi__crea:
  003e7	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR i$11[rsp]
  003ee	ff c0		 inc	 eax
  003f0	89 84 24 54 01
	00 00		 mov	 DWORD PTR i$11[rsp], eax
$LN10@stbi__crea:
  003f7	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR x$13[rsp]
  003fe	39 84 24 54 01
	00 00		 cmp	 DWORD PTR i$11[rsp], eax
  00405	0f 8d ce 00 00
	00		 jge	 $LN9@stbi__crea

; 4891 :                int out_y = j*yspc[p]+yorig[p];

  0040b	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00410	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR j$12[rsp]
  00417	0f af 8c 84 28
	01 00 00	 imul	 ecx, DWORD PTR yspc$10[rsp+rax*4]
  0041f	8b c1		 mov	 eax, ecx
  00421	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  00426	03 84 8c a8 00
	00 00		 add	 eax, DWORD PTR yorig$8[rsp+rcx*4]
  0042d	89 84 24 68 01
	00 00		 mov	 DWORD PTR out_y$16[rsp], eax

; 4892 :                int out_x = i*xspc[p]+xorig[p];

  00434	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00439	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR i$11[rsp]
  00440	0f af 8c 84 e8
	00 00 00	 imul	 ecx, DWORD PTR xspc$9[rsp+rax*4]
  00448	8b c1		 mov	 eax, ecx
  0044a	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  0044f	03 44 8c 68	 add	 eax, DWORD PTR xorig$7[rsp+rcx*4]
  00453	89 84 24 6c 01
	00 00		 mov	 DWORD PTR out_x$17[rsp], eax

; 4893 :                memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,

  0045a	48 63 44 24 44	 movsxd	 rax, DWORD PTR out_bytes$[rsp]
  0045f	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR j$12[rsp]
  00466	0f af 8c 24 5c
	01 00 00	 imul	 ecx, DWORD PTR x$13[rsp]
  0046e	03 8c 24 54 01
	00 00		 add	 ecx, DWORD PTR i$11[rsp]
  00475	0f af 4c 24 44	 imul	 ecx, DWORD PTR out_bytes$[rsp]
  0047a	48 63 c9	 movsxd	 rcx, ecx
  0047d	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00485	48 03 4a 18	 add	 rcx, QWORD PTR [rdx+24]
  00489	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00491	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00494	44 8b 84 24 68
	01 00 00	 mov	 r8d, DWORD PTR out_y$16[rsp]
  0049c	44 0f af 02	 imul	 r8d, DWORD PTR [rdx]
  004a0	41 8b d0	 mov	 edx, r8d
  004a3	0f af 54 24 44	 imul	 edx, DWORD PTR out_bytes$[rsp]
  004a8	8b d2		 mov	 edx, edx
  004aa	4c 8b 44 24 48	 mov	 r8, QWORD PTR final$[rsp]
  004af	4c 03 c2	 add	 r8, rdx
  004b2	49 8b d0	 mov	 rdx, r8
  004b5	44 8b 84 24 6c
	01 00 00	 mov	 r8d, DWORD PTR out_x$17[rsp]
  004bd	44 0f af 44 24
	44		 imul	 r8d, DWORD PTR out_bytes$[rsp]
  004c3	4d 63 c0	 movsxd	 r8, r8d
  004c6	49 03 d0	 add	 rdx, r8
  004c9	48 8b fa	 mov	 rdi, rdx
  004cc	48 8b f1	 mov	 rsi, rcx
  004cf	48 8b c8	 mov	 rcx, rax
  004d2	f3 a4		 rep movsb

; 4894 :                       a->out + (j*x+i)*out_bytes, out_bytes);
; 4895 :             }

  004d4	e9 0e ff ff ff	 jmp	 $LN8@stbi__crea
$LN9@stbi__crea:

; 4896 :          }

  004d9	e9 d8 fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4897 :          STBI_FREE(a->out);

  004de	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004e6	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  004ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4898 :          image_data += img_len;

  004f0	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR img_len$15[rsp]
  004f7	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR image_data$[rsp]
  004ff	48 03 c8	 add	 rcx, rax
  00502	48 8b c1	 mov	 rax, rcx
  00505	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR image_data$[rsp], rax

; 4899 :          image_data_len -= img_len;

  0050d	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR img_len$15[rsp]
  00514	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR image_data_len$[rsp]
  0051b	2b c8		 sub	 ecx, eax
  0051d	8b c1		 mov	 eax, ecx
  0051f	89 84 24 b0 01
	00 00		 mov	 DWORD PTR image_data_len$[rsp], eax
$LN13@stbi__crea:

; 4900 :       }
; 4901 :    }

  00526	e9 11 fc ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4902 :    a->out = final;

  0052b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00533	48 8b 4c 24 48	 mov	 rcx, QWORD PTR final$[rsp]
  00538	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4903 : 
; 4904 :    return 1;

  0053c	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4905 : }

  00541	48 8b f8	 mov	 rdi, rax
  00544	48 8b cc	 mov	 rcx, rsp
  00547	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__create_png_image$rtcFrameData
  0054e	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00553	48 8b c7	 mov	 rax, rdi
  00556	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  0055d	5f		 pop	 rdi
  0055e	5e		 pop	 rsi
  0055f	c3		 ret	 0
stbi__create_png_image ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 32
i$ = 40
pixel_count$ = 44
p$ = 48
tv87 = 56
z$ = 80
tc$ = 88
out_n$ = 96
stbi__compute_transparency PROC

; 4908 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4909 :    stbi__context *s = z->s;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 4910 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00037	8b 00		 mov	 eax, DWORD PTR [rax]
  00039	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0003d	89 44 24 2c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4911 :    stbi_uc *p = z->out;

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4912 : 
; 4913 :    // compute color-based transparency, assuming we've
; 4914 :    // already got 255 as the alpha value in the output
; 4915 :    STBI_ASSERT(out_n == 2 || out_n == 4);

  0004f	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00054	74 23		 je	 SHORT $LN12@stbi__comp
  00056	83 7c 24 60 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0005b	74 1c		 je	 SHORT $LN12@stbi__comp
  0005d	41 b8 33 13 00
	00		 mov	 r8d, 4915		; 00001333H
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4916 : 
; 4917 :    if (out_n == 2) {

  00079	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  0007e	0f 85 83 00 00
	00		 jne	 $LN8@stbi__comp

; 4918 :       for (i=0; i < pixel_count; ++i) {

  00084	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008c	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0008e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00092	ff c0		 inc	 eax
  00094	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  00098	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0009c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000a0	73 60		 jae	 SHORT $LN3@stbi__comp

; 4919 :          p[1] = (p[0] == tc[0] ? 0 : 255);

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 00	 imul	 rcx, rcx, 0
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  000c2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c6	3b c1		 cmp	 eax, ecx
  000c8	75 0a		 jne	 SHORT $LN13@stbi__comp
  000ca	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000d2	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000d4	c7 44 24 38 ff
	00 00 00	 mov	 DWORD PTR tv87[rsp], 255 ; 000000ffH
$LN14@stbi__comp:
  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	48 6b c0 01	 imul	 rax, rax, 1
  000e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000ea	0f b6 54 24 38	 movzx	 edx, BYTE PTR tv87[rsp]
  000ef	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4920 :          p += 2;

  000f2	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  000f7	48 83 c0 02	 add	 rax, 2
  000fb	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4921 :       }

  00100	eb 8c		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4922 :    } else {

  00102	e9 bf 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4923 :       for (i=0; i < pixel_count; ++i) {

  00107	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0010f	eb 0a		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  00111	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00115	ff c0		 inc	 eax
  00117	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  0011b	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0011f	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00123	0f 83 9d 00 00
	00		 jae	 $LN6@stbi__comp

; 4924 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 00	 imul	 rax, rax, 0
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00137	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0013b	b9 01 00 00 00	 mov	 ecx, 1
  00140	48 6b c9 00	 imul	 rcx, rcx, 0
  00144	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00149	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0014d	3b c1		 cmp	 eax, ecx
  0014f	75 62		 jne	 SHORT $LN10@stbi__comp
  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	48 6b c0 01	 imul	 rax, rax, 1
  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0015f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 01	 imul	 rcx, rcx, 1
  0016c	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00171	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00175	3b c1		 cmp	 eax, ecx
  00177	75 3a		 jne	 SHORT $LN10@stbi__comp
  00179	b8 01 00 00 00	 mov	 eax, 1
  0017e	48 6b c0 02	 imul	 rax, rax, 2
  00182	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00187	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0018b	b9 01 00 00 00	 mov	 ecx, 1
  00190	48 6b c9 02	 imul	 rcx, rcx, 2
  00194	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00199	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0019d	3b c1		 cmp	 eax, ecx
  0019f	75 12		 jne	 SHORT $LN10@stbi__comp

; 4925 :             p[3] = 0;

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	48 6b c0 03	 imul	 rax, rax, 3
  001aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001af	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN10@stbi__comp:

; 4926 :          p += 4;

  001b3	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001b8	48 83 c0 04	 add	 rax, 4
  001bc	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4927 :       }

  001c1	e9 4b ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4928 :    }
; 4929 :    return 1;

  001c6	b8 01 00 00 00	 mov	 eax, 1

; 4930 : }

  001cb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001cf	5f		 pop	 rdi
  001d0	c3		 ret	 0
stbi__compute_transparency ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 32
i$ = 40
pixel_count$ = 44
p$ = 48
tv87 = 56
z$ = 80
tc$ = 88
out_n$ = 96
stbi__compute_transparency16 PROC

; 4933 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4934 :    stbi__context *s = z->s;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 4935 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00037	8b 00		 mov	 eax, DWORD PTR [rax]
  00039	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0003d	89 44 24 2c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4936 :    stbi__uint16 *p = (stbi__uint16*) z->out;

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00046	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004a	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4937 : 
; 4938 :    // compute color-based transparency, assuming we've
; 4939 :    // already got 65535 as the alpha value in the output
; 4940 :    STBI_ASSERT(out_n == 2 || out_n == 4);

  0004f	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00054	74 23		 je	 SHORT $LN12@stbi__comp
  00056	83 7c 24 60 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0005b	74 1c		 je	 SHORT $LN12@stbi__comp
  0005d	41 b8 4c 13 00
	00		 mov	 r8d, 4940		; 0000134cH
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BMIDKOPK@?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4941 : 
; 4942 :    if (out_n == 2) {

  00079	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  0007e	0f 85 84 00 00
	00		 jne	 $LN8@stbi__comp

; 4943 :       for (i = 0; i < pixel_count; ++i) {

  00084	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008c	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0008e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00092	ff c0		 inc	 eax
  00094	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  00098	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0009c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000a0	73 61		 jae	 SHORT $LN3@stbi__comp

; 4944 :          p[1] = (p[0] == tc[0] ? 0 : 65535);

  000a2	b8 02 00 00 00	 mov	 eax, 2
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000b0	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000b4	b9 02 00 00 00	 mov	 ecx, 2
  000b9	48 6b c9 00	 imul	 rcx, rcx, 0
  000bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  000c2	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  000c6	3b c1		 cmp	 eax, ecx
  000c8	75 0a		 jne	 SHORT $LN13@stbi__comp
  000ca	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000d2	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000d4	c7 44 24 38 ff
	ff 00 00	 mov	 DWORD PTR tv87[rsp], 65535 ; 0000ffffH
$LN14@stbi__comp:
  000dc	b8 02 00 00 00	 mov	 eax, 2
  000e1	48 6b c0 01	 imul	 rax, rax, 1
  000e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000ea	0f b7 54 24 38	 movzx	 edx, WORD PTR tv87[rsp]
  000ef	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 4945 :          p += 2;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  000f8	48 83 c0 04	 add	 rax, 4
  000fc	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4946 :       }

  00101	eb 8b		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4947 :    } else {

  00103	e9 c1 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4948 :       for (i = 0; i < pixel_count; ++i) {

  00108	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00110	eb 0a		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  00112	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00116	ff c0		 inc	 eax
  00118	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  0011c	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00120	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00124	0f 83 9f 00 00
	00		 jae	 $LN6@stbi__comp

; 4949 :          if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  0012a	b8 02 00 00 00	 mov	 eax, 2
  0012f	48 6b c0 00	 imul	 rax, rax, 0
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00138	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0013c	b9 02 00 00 00	 mov	 ecx, 2
  00141	48 6b c9 00	 imul	 rcx, rcx, 0
  00145	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0014a	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0014e	3b c1		 cmp	 eax, ecx
  00150	75 64		 jne	 SHORT $LN10@stbi__comp
  00152	b8 02 00 00 00	 mov	 eax, 2
  00157	48 6b c0 01	 imul	 rax, rax, 1
  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00160	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00164	b9 02 00 00 00	 mov	 ecx, 2
  00169	48 6b c9 01	 imul	 rcx, rcx, 1
  0016d	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00172	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00176	3b c1		 cmp	 eax, ecx
  00178	75 3c		 jne	 SHORT $LN10@stbi__comp
  0017a	b8 02 00 00 00	 mov	 eax, 2
  0017f	48 6b c0 02	 imul	 rax, rax, 2
  00183	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00188	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0018c	b9 02 00 00 00	 mov	 ecx, 2
  00191	48 6b c9 02	 imul	 rcx, rcx, 2
  00195	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0019a	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0019e	3b c1		 cmp	 eax, ecx
  001a0	75 14		 jne	 SHORT $LN10@stbi__comp

; 4950 :             p[3] = 0;

  001a2	b8 02 00 00 00	 mov	 eax, 2
  001a7	48 6b c0 03	 imul	 rax, rax, 3
  001ab	33 c9		 xor	 ecx, ecx
  001ad	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001b2	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
$LN10@stbi__comp:

; 4951 :          p += 4;

  001b6	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001bb	48 83 c0 08	 add	 rax, 8
  001bf	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4952 :       }

  001c4	e9 49 ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4953 :    }
; 4954 :    return 1;

  001c9	b8 01 00 00 00	 mov	 eax, 1

; 4955 : }

  001ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001d2	5f		 pop	 rdi
  001d3	c3		 ret	 0
stbi__compute_transparency16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
pixel_count$ = 36
p$ = 40
temp_out$ = 48
orig$ = 56
n$1 = 64
n$2 = 68
a$ = 96
palette$ = 104
len$ = 112
pal_img_n$ = 120
stbi__expand_png_palette PROC

; 4958 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4959 :    stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00032	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00035	8b 00		 mov	 eax, DWORD PTR [rax]
  00037	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0003b	89 44 24 24	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4960 :    stbi_uc *p, *temp_out, *orig = a->out;

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00044	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00048	48 89 44 24 38	 mov	 QWORD PTR orig$[rsp], rax

; 4961 : 
; 4962 :    p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);

  0004d	45 33 c0	 xor	 r8d, r8d
  00050	8b 54 24 78	 mov	 edx, DWORD PTR pal_img_n$[rsp]
  00054	8b 4c 24 24	 mov	 ecx, DWORD PTR pixel_count$[rsp]
  00058	e8 00 00 00 00	 call	 stbi__malloc_mad2
  0005d	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 4963 :    if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  00068	75 11		 jne	 SHORT $LN8@stbi__expa
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00071	e8 00 00 00 00	 call	 stbi__err
  00076	e9 c0 01 00 00	 jmp	 $LN1@stbi__expa
$LN8@stbi__expa:

; 4964 : 
; 4965 :    // between here and free(out) below, exitting would leak
; 4966 :    temp_out = p;

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00080	48 89 44 24 30	 mov	 QWORD PTR temp_out$[rsp], rax

; 4967 : 
; 4968 :    if (pal_img_n == 3) {

  00085	83 7c 24 78 03	 cmp	 DWORD PTR pal_img_n$[rsp], 3
  0008a	0f 85 b5 00 00
	00		 jne	 $LN9@stbi__expa

; 4969 :       for (i=0; i < pixel_count; ++i) {

  00090	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00098	eb 0a		 jmp	 SHORT $LN4@stbi__expa
$LN2@stbi__expa:
  0009a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009e	ff c0		 inc	 eax
  000a0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__expa:
  000a4	8b 44 24 24	 mov	 eax, DWORD PTR pixel_count$[rsp]
  000a8	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000ac	0f 83 8e 00 00
	00		 jae	 $LN3@stbi__expa

; 4970 :          int n = orig[i]*4;

  000b2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  000bb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bf	c1 e0 02	 shl	 eax, 2
  000c2	89 44 24 40	 mov	 DWORD PTR n$1[rsp], eax

; 4971 :          p[0] = palette[n  ];

  000c6	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	48 6b c9 00	 imul	 rcx, rcx, 0
  000d4	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  000d9	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  000de	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000e3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4972 :          p[1] = palette[n+1];

  000e6	8b 44 24 40	 mov	 eax, DWORD PTR n$1[rsp]
  000ea	ff c0		 inc	 eax
  000ec	48 98		 cdqe
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	48 6b c9 01	 imul	 rcx, rcx, 1
  000f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  000fc	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00101	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00106	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4973 :          p[2] = palette[n+2];

  00109	8b 44 24 40	 mov	 eax, DWORD PTR n$1[rsp]
  0010d	83 c0 02	 add	 eax, 2
  00110	48 98		 cdqe
  00112	b9 01 00 00 00	 mov	 ecx, 1
  00117	48 6b c9 02	 imul	 rcx, rcx, 2
  0011b	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  00120	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00125	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0012a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4974 :          p += 3;

  0012d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00132	48 83 c0 03	 add	 rax, 3
  00136	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 4975 :       }

  0013b	e9 5a ff ff ff	 jmp	 $LN2@stbi__expa
$LN3@stbi__expa:

; 4976 :    } else {

  00140	e9 d4 00 00 00	 jmp	 $LN10@stbi__expa
$LN9@stbi__expa:

; 4977 :       for (i=0; i < pixel_count; ++i) {

  00145	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0014d	eb 0a		 jmp	 SHORT $LN7@stbi__expa
$LN5@stbi__expa:
  0014f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00153	ff c0		 inc	 eax
  00155	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__expa:
  00159	8b 44 24 24	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0015d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00161	0f 83 b2 00 00
	00		 jae	 $LN6@stbi__expa

; 4978 :          int n = orig[i]*4;

  00167	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  00170	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00174	c1 e0 02	 shl	 eax, 2
  00177	89 44 24 44	 mov	 DWORD PTR n$2[rsp], eax

; 4979 :          p[0] = palette[n  ];

  0017b	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	48 6b c9 00	 imul	 rcx, rcx, 0
  00189	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  0018e	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00193	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00198	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4980 :          p[1] = palette[n+1];

  0019b	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  0019f	ff c0		 inc	 eax
  001a1	48 98		 cdqe
  001a3	b9 01 00 00 00	 mov	 ecx, 1
  001a8	48 6b c9 01	 imul	 rcx, rcx, 1
  001ac	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  001b1	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001b6	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001bb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4981 :          p[2] = palette[n+2];

  001be	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001c2	83 c0 02	 add	 eax, 2
  001c5	48 98		 cdqe
  001c7	b9 01 00 00 00	 mov	 ecx, 1
  001cc	48 6b c9 02	 imul	 rcx, rcx, 2
  001d0	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  001d5	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001da	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001df	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4982 :          p[3] = palette[n+3];

  001e2	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001e6	83 c0 03	 add	 eax, 3
  001e9	48 98		 cdqe
  001eb	b9 01 00 00 00	 mov	 ecx, 1
  001f0	48 6b c9 03	 imul	 rcx, rcx, 3
  001f4	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  001f9	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001fe	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00203	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4983 :          p += 4;

  00206	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0020b	48 83 c0 04	 add	 rax, 4
  0020f	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 4984 :       }

  00214	e9 36 ff ff ff	 jmp	 $LN5@stbi__expa
$LN6@stbi__expa:
$LN10@stbi__expa:

; 4985 :    }
; 4986 :    STBI_FREE(a->out);

  00219	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0021e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4987 :    a->out = temp_out;

  00228	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0022d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp_out$[rsp]
  00232	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4988 : 
; 4989 :    STBI_NOTUSED(len);
; 4990 : 
; 4991 :    return 1;

  00236	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__expa:

; 4992 : }

  0023b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0023f	5f		 pop	 rdi
  00240	c3		 ret	 0
stbi__expand_png_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 48
stbi_set_unpremultiply_on_load PROC

; 4998 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 4999 :    stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;

  00015	8b 44 24 30	 mov	 eax, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  00019	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__unpremultiply_on_load_global, eax

; 5000 : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 48
stbi_convert_iphone_png_to_rgb PROC

; 5003 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5004 :    stbi__de_iphone_flag_global = flag_true_if_should_convert;

  00015	8b 44 24 30	 mov	 eax, DWORD PTR flag_true_if_should_convert$[rsp]
  00019	89 05 00 00 00
	00		 mov	 DWORD PTR stbi__de_iphone_flag_global, eax

; 5005 : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 48
stbi_set_unpremultiply_on_load_thread PROC

; 5015 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5016 :    stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_local
  0001a	8b c0		 mov	 eax, eax
  0001c	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	8b 54 24 30	 mov	 edx, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  0002c	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 5017 :    stbi__unpremultiply_on_load_set = 1;

  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_set
  00034	8b c0		 mov	 eax, eax
  00036	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 5018 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
stbi_set_unpremultiply_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 48
stbi_convert_iphone_png_to_rgb_thread PROC

; 5021 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5022 :    stbi__de_iphone_flag_local = flag_true_if_should_convert;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_local
  0001a	8b c0		 mov	 eax, eax
  0001c	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	8b 54 24 30	 mov	 edx, DWORD PTR flag_true_if_should_convert$[rsp]
  0002c	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 5023 :    stbi__de_iphone_flag_set = 1;

  0002f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_set
  00034	8b c0		 mov	 eax, eax
  00036	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 5024 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
stbi_convert_iphone_png_to_rgb_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 32
i$ = 40
pixel_count$ = 44
p$ = 48
t$1 = 56
a$2 = 57
t$3 = 58
half$4 = 59
t$5 = 60
tv95 = 64
z$ = 96
stbi__de_iphone PROC

; 5035 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5036 :    stbi__context *s = z->s;

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR z$[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 5037 :    stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0002d	8b 00		 mov	 eax, DWORD PTR [rax]
  0002f	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00033	89 44 24 2c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 5038 :    stbi_uc *p = z->out;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR z$[rsp]
  0003c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00040	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5039 : 
; 5040 :    if (s->img_out_n == 3) {  // convert bgr to rgb

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004a	83 78 0c 03	 cmp	 DWORD PTR [rax+12], 3
  0004e	0f 85 83 00 00
	00		 jne	 $LN11@stbi__de_i

; 5041 :       for (i=0; i < pixel_count; ++i) {

  00054	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0005c	eb 0a		 jmp	 SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
  0005e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00062	ff c0		 inc	 eax
  00064	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__de_i:
  00068	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0006c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00070	73 60		 jae	 SHORT $LN3@stbi__de_i

; 5042 :          stbi_uc t = p[0];

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	48 6b c0 00	 imul	 rax, rax, 0
  0007b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00080	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00084	88 44 24 38	 mov	 BYTE PTR t$1[rsp], al

; 5043 :          p[0] = p[2];

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	48 6b c0 02	 imul	 rax, rax, 2
  00091	b9 01 00 00 00	 mov	 ecx, 1
  00096	48 6b c9 00	 imul	 rcx, rcx, 0
  0009a	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0009f	4c 8b 44 24 30	 mov	 r8, QWORD PTR p$[rsp]
  000a4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5044 :          p[2] = t;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 02	 imul	 rax, rax, 2
  000b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000ba	0f b6 54 24 38	 movzx	 edx, BYTE PTR t$1[rsp]
  000bf	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5045 :          p += 3;

  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  000c7	48 83 c0 03	 add	 rax, 3
  000cb	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5046 :       }

  000d0	eb 8c		 jmp	 SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 5047 :    } else {

  000d2	e9 44 02 00 00	 jmp	 $LN12@stbi__de_i
$LN11@stbi__de_i:

; 5048 :       STBI_ASSERT(s->img_out_n == 4);

  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000dc	83 78 0c 04	 cmp	 DWORD PTR [rax+12], 4
  000e0	74 1c		 je	 SHORT $LN18@stbi__de_i
  000e2	41 b8 b8 13 00
	00		 mov	 r8d, 5048		; 000013b8H
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GKIDJEJM@?$AAs?$AA?9?$AA?$DO?$AAi?$AAm?$AAg?$AA_?$AAo?$AAu?$AAt?$AA_?$AAn?$AA?5?$AA?$DN?$AA?$DN@
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fc	33 c0		 xor	 eax, eax
$LN18@stbi__de_i:

; 5049 :       if (stbi__unpremultiply_on_load) {

  000fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_set
  00103	8b c0		 mov	 eax, eax
  00105	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0010e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00111	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00115	74 1c		 je	 SHORT $LN19@stbi__de_i
  00117	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__unpremultiply_on_load_local
  0011c	8b c0		 mov	 eax, eax
  0011e	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00127	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0012a	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  0012d	89 44 24 40	 mov	 DWORD PTR tv95[rsp], eax
  00131	eb 0a		 jmp	 SHORT $LN20@stbi__de_i
$LN19@stbi__de_i:
  00133	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__unpremultiply_on_load_global
  00139	89 44 24 40	 mov	 DWORD PTR tv95[rsp], eax
$LN20@stbi__de_i:
  0013d	83 7c 24 40 00	 cmp	 DWORD PTR tv95[rsp], 0
  00142	0f 84 55 01 00
	00		 je	 $LN13@stbi__de_i

; 5050 :          // convert bgr to rgb and unpremultiply
; 5051 :          for (i=0; i < pixel_count; ++i) {

  00148	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00150	eb 0a		 jmp	 SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
  00152	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00156	ff c0		 inc	 eax
  00158	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__de_i:
  0015c	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00160	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00164	0f 83 31 01 00
	00		 jae	 $LN6@stbi__de_i

; 5052 :             stbi_uc a = p[3];

  0016a	b8 01 00 00 00	 mov	 eax, 1
  0016f	48 6b c0 03	 imul	 rax, rax, 3
  00173	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00178	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017c	88 44 24 39	 mov	 BYTE PTR a$2[rsp], al

; 5053 :             stbi_uc t = p[0];

  00180	b8 01 00 00 00	 mov	 eax, 1
  00185	48 6b c0 00	 imul	 rax, rax, 0
  00189	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0018e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00192	88 44 24 3a	 mov	 BYTE PTR t$3[rsp], al

; 5054 :             if (a) {

  00196	0f b6 44 24 39	 movzx	 eax, BYTE PTR a$2[rsp]
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 ab 00 00
	00		 je	 $LN15@stbi__de_i

; 5055 :                stbi_uc half = a / 2;

  001a3	0f b6 44 24 39	 movzx	 eax, BYTE PTR a$2[rsp]
  001a8	99		 cdq
  001a9	2b c2		 sub	 eax, edx
  001ab	d1 f8		 sar	 eax, 1
  001ad	88 44 24 3b	 mov	 BYTE PTR half$4[rsp], al

; 5056 :                p[0] = (p[2] * 255 + half) / a;

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 02	 imul	 rax, rax, 2
  001ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  001c9	0f b6 4c 24 3b	 movzx	 ecx, BYTE PTR half$4[rsp]
  001ce	03 c1		 add	 eax, ecx
  001d0	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR a$2[rsp]
  001d5	99		 cdq
  001d6	f7 f9		 idiv	 ecx
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	48 6b c9 00	 imul	 rcx, rcx, 0
  001e1	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001e6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5057 :                p[1] = (p[1] * 255 + half) / a;

  001e9	b8 01 00 00 00	 mov	 eax, 1
  001ee	48 6b c0 01	 imul	 rax, rax, 1
  001f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fb	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  00201	0f b6 4c 24 3b	 movzx	 ecx, BYTE PTR half$4[rsp]
  00206	03 c1		 add	 eax, ecx
  00208	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR a$2[rsp]
  0020d	99		 cdq
  0020e	f7 f9		 idiv	 ecx
  00210	b9 01 00 00 00	 mov	 ecx, 1
  00215	48 6b c9 01	 imul	 rcx, rcx, 1
  00219	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0021e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5058 :                p[2] = ( t   * 255 + half) / a;

  00221	0f b6 44 24 3a	 movzx	 eax, BYTE PTR t$3[rsp]
  00226	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  0022c	0f b6 4c 24 3b	 movzx	 ecx, BYTE PTR half$4[rsp]
  00231	03 c1		 add	 eax, ecx
  00233	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR a$2[rsp]
  00238	99		 cdq
  00239	f7 f9		 idiv	 ecx
  0023b	b9 01 00 00 00	 mov	 ecx, 1
  00240	48 6b c9 02	 imul	 rcx, rcx, 2
  00244	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00249	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5059 :             } else {

  0024c	eb 3a		 jmp	 SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 5060 :                p[0] = p[2];

  0024e	b8 01 00 00 00	 mov	 eax, 1
  00253	48 6b c0 02	 imul	 rax, rax, 2
  00257	b9 01 00 00 00	 mov	 ecx, 1
  0025c	48 6b c9 00	 imul	 rcx, rcx, 0
  00260	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00265	4c 8b 44 24 30	 mov	 r8, QWORD PTR p$[rsp]
  0026a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0026f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5061 :                p[2] = t;

  00272	b8 01 00 00 00	 mov	 eax, 1
  00277	48 6b c0 02	 imul	 rax, rax, 2
  0027b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00280	0f b6 54 24 3a	 movzx	 edx, BYTE PTR t$3[rsp]
  00285	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN16@stbi__de_i:

; 5062 :             }
; 5063 :             p += 4;

  00288	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0028d	48 83 c0 04	 add	 rax, 4
  00291	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5064 :          }

  00296	e9 b7 fe ff ff	 jmp	 $LN5@stbi__de_i
$LN6@stbi__de_i:

; 5065 :       } else {

  0029b	eb 7e		 jmp	 SHORT $LN14@stbi__de_i
$LN13@stbi__de_i:

; 5066 :          // convert bgr to rgb
; 5067 :          for (i=0; i < pixel_count; ++i) {

  0029d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a5	eb 0a		 jmp	 SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
  002a7	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  002ab	ff c0		 inc	 eax
  002ad	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__de_i:
  002b1	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  002b5	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  002b9	73 60		 jae	 SHORT $LN9@stbi__de_i

; 5068 :             stbi_uc t = p[0];

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	48 6b c0 00	 imul	 rax, rax, 0
  002c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  002c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002cd	88 44 24 3c	 mov	 BYTE PTR t$5[rsp], al

; 5069 :             p[0] = p[2];

  002d1	b8 01 00 00 00	 mov	 eax, 1
  002d6	48 6b c0 02	 imul	 rax, rax, 2
  002da	b9 01 00 00 00	 mov	 ecx, 1
  002df	48 6b c9 00	 imul	 rcx, rcx, 0
  002e3	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  002e8	4c 8b 44 24 30	 mov	 r8, QWORD PTR p$[rsp]
  002ed	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002f2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5070 :             p[2] = t;

  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 02	 imul	 rax, rax, 2
  002fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00303	0f b6 54 24 3c	 movzx	 edx, BYTE PTR t$5[rsp]
  00308	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5071 :             p += 4;

  0030b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00310	48 83 c0 04	 add	 rax, 4
  00314	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5072 :          }

  00319	eb 8c		 jmp	 SHORT $LN8@stbi__de_i
$LN9@stbi__de_i:
$LN14@stbi__de_i:
$LN12@stbi__de_i:

; 5073 :       }
; 5074 :    }
; 5075 : }

  0031b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0031f	5f		 pop	 rdi
  00320	c3		 ret	 0
stbi__de_iphone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
palette$ = 80
pal_img_n$ = 1108
has_trans$ = 1109
tc$ = 1124
tc16$ = 1156
ioff$ = 1172
idata_limit$ = 1176
i$ = 1180
pal_len$ = 1184
first$ = 1188
k$ = 1192
interlace$ = 1196
color$ = 1200
is_iphone$ = 1204
s$ = 1208
c$8 = 1224
comp$9 = 1236
filter$10 = 1240
idata_limit_old$11 = 1244
p$12 = 1248
raw_len$13 = 1268
bpl$14 = 1284
$T15 = 1296
$T16 = 1297
$T17 = 1298
$T18 = 1299
$T19 = 1300
$T20 = 1301
$T21 = 1302
$T22 = 1303
$T23 = 1304
tv78 = 1308
tv531 = 1312
tv540 = 1313
tv548 = 1314
tv557 = 1315
tv565 = 1316
tv574 = 1317
tv614 = 1318
tv623 = 1319
tv631 = 1320
tv640 = 1321
tv194 = 1324
tv197 = 1328
tv648 = 1332
tv657 = 1333
tv665 = 1334
tv674 = 1335
tv682 = 1336
tv691 = 1337
tv699 = 1338
tv708 = 1339
tv345 = 1340
tv394 = 1344
tv455 = 1348
__$ArrayPad$ = 1352
z$ = 1376
scan$ = 1384
req_comp$ = 1392
stbi__parse_png_file PROC

; 5080 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 50 05
	00 00		 sub	 rsp, 1360		; 00000550H
  00016	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  0001b	b9 44 01 00 00	 mov	 ecx, 324		; 00000144H
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1376]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00036	48 33 c4	 xor	 rax, rsp
  00039	48 89 84 24 48
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5081 :    stbi_uc palette[1024], pal_img_n=0;

  0004d	c6 84 24 54 04
	00 00 00	 mov	 BYTE PTR pal_img_n$[rsp], 0

; 5082 :    stbi_uc has_trans=0, tc[3]={0};

  00055	c6 84 24 55 04
	00 00 00	 mov	 BYTE PTR has_trans$[rsp], 0
  0005d	48 8d 84 24 64
	04 00 00	 lea	 rax, QWORD PTR tc$[rsp]
  00065	48 8b f8	 mov	 rdi, rax
  00068	33 c0		 xor	 eax, eax
  0006a	b9 03 00 00 00	 mov	 ecx, 3
  0006f	f3 aa		 rep stosb

; 5083 :    stbi__uint16 tc16[3];
; 5084 :    stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;

  00071	c7 84 24 94 04
	00 00 00 00 00
	00		 mov	 DWORD PTR ioff$[rsp], 0
  0007c	c7 84 24 98 04
	00 00 00 00 00
	00		 mov	 DWORD PTR idata_limit$[rsp], 0
  00087	c7 84 24 a0 04
	00 00 00 00 00
	00		 mov	 DWORD PTR pal_len$[rsp], 0

; 5085 :    int first=1,k,interlace=0, color=0, is_iphone=0;

  00092	c7 84 24 a4 04
	00 00 01 00 00
	00		 mov	 DWORD PTR first$[rsp], 1
  0009d	c7 84 24 ac 04
	00 00 00 00 00
	00		 mov	 DWORD PTR interlace$[rsp], 0
  000a8	c7 84 24 b0 04
	00 00 00 00 00
	00		 mov	 DWORD PTR color$[rsp], 0
  000b3	c7 84 24 b4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 0

; 5086 :    stbi__context *s = z->s;

  000be	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c9	48 89 84 24 b8
	04 00 00	 mov	 QWORD PTR s$[rsp], rax

; 5087 : 
; 5088 :    z->expanded = NULL;

  000d1	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000d9	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5089 :    z->idata = NULL;

  000e1	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000e9	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5090 :    z->out = NULL;

  000f1	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000f9	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5091 : 
; 5092 :    if (!stbi__check_png_header(s)) return 0;

  00101	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00109	e8 00 00 00 00	 call	 stbi__check_png_header
  0010e	85 c0		 test	 eax, eax
  00110	75 07		 jne	 SHORT $LN21@stbi__pars
  00112	33 c0		 xor	 eax, eax
  00114	e9 fe 15 00 00	 jmp	 $LN1@stbi__pars
$LN21@stbi__pars:

; 5093 : 
; 5094 :    if (scan == STBI__SCAN_type) return 1;

  00119	83 bc 24 68 05
	00 00 01	 cmp	 DWORD PTR scan$[rsp], 1
  00121	75 0a		 jne	 SHORT $LN22@stbi__pars
  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	e9 ea 15 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:
$LN2@stbi__pars:

; 5095 : 
; 5096 :    for (;;) {
; 5097 :       stbi__pngchunk c = stbi__get_chunk_header(s);

  0012d	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00135	e8 00 00 00 00	 call	 stbi__get_chunk_header
  0013a	48 89 84 24 c8
	04 00 00	 mov	 QWORD PTR c$8[rsp], rax

; 5098 :       switch (c.type) {

  00142	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  00149	89 84 24 1c 05
	00 00		 mov	 DWORD PTR tv78[rsp], eax
  00150	81 bc 24 1c 05
	00 00 52 44 48
	49		 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  0015b	77 45		 ja	 SHORT $LN107@stbi__pars
  0015d	81 bc 24 1c 05
	00 00 52 44 48
	49		 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  00168	0f 84 80 00 00
	00		 je	 $LN24@stbi__pars
  0016e	81 bc 24 1c 05
	00 00 49 42 67
	43		 cmp	 DWORD PTR tv78[rsp], 1130840649 ; 43674249H
  00179	74 4e		 je	 SHORT $LN23@stbi__pars
  0017b	81 bc 24 1c 05
	00 00 54 41 44
	49		 cmp	 DWORD PTR tv78[rsp], 1229209940 ; 49444154H
  00186	0f 84 d1 0e 00
	00		 je	 $LN61@stbi__pars
  0018c	81 bc 24 1c 05
	00 00 44 4e 45
	49		 cmp	 DWORD PTR tv78[rsp], 1229278788 ; 49454e44H
  00197	0f 84 c0 10 00
	00		 je	 $LN72@stbi__pars
  0019d	e9 8b 14 00 00	 jmp	 $LN93@stbi__pars
$LN107@stbi__pars:
  001a2	81 bc 24 1c 05
	00 00 45 54 4c
	50		 cmp	 DWORD PTR tv78[rsp], 1347179589 ; 504c5445H
  001ad	0f 84 d7 07 00
	00		 je	 $LN44@stbi__pars
  001b3	81 bc 24 1c 05
	00 00 53 4e 52
	74		 cmp	 DWORD PTR tv78[rsp], 1951551059 ; 74524e53H
  001be	0f 84 63 0b 00
	00		 je	 $LN48@stbi__pars
  001c4	e9 64 14 00 00	 jmp	 $LN93@stbi__pars
$LN23@stbi__pars:

; 5099 :          case STBI__PNG_TYPE('C','g','B','I'):
; 5100 :             is_iphone = 1;

  001c9	c7 84 24 b4 04
	00 00 01 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 1

; 5101 :             stbi__skip(s, c.length);

  001d4	8b 94 24 c8 04
	00 00		 mov	 edx, DWORD PTR c$8[rsp]
  001db	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e3	e8 00 00 00 00	 call	 stbi__skip
  001e8	90		 npad	 1

; 5102 :             break;

  001e9	e9 16 15 00 00	 jmp	 $LN5@stbi__pars
$LN24@stbi__pars:

; 5103 :          case STBI__PNG_TYPE('I','H','D','R'): {
; 5104 :             int comp,filter;
; 5105 :             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

  001ee	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  001f6	75 11		 jne	 SHORT $LN25@stbi__pars
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@KBHBNJOK@multiple?5IHDR@
  001ff	e8 00 00 00 00	 call	 stbi__err
  00204	e9 0e 15 00 00	 jmp	 $LN1@stbi__pars
$LN25@stbi__pars:

; 5106 :             first = 0;

  00209	c7 84 24 a4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR first$[rsp], 0

; 5107 :             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

  00214	83 bc 24 c8 04
	00 00 0d	 cmp	 DWORD PTR c$8[rsp], 13
  0021c	74 11		 je	 SHORT $LN26@stbi__pars
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@POJLKMKK@bad?5IHDR?5len@
  00225	e8 00 00 00 00	 call	 stbi__err
  0022a	e9 e8 14 00 00	 jmp	 $LN1@stbi__pars
$LN26@stbi__pars:

; 5108 :             s->img_x = stbi__get32be(s);

  0022f	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00237	e8 00 00 00 00	 call	 stbi__get32be
  0023c	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00244	89 01		 mov	 DWORD PTR [rcx], eax

; 5109 :             s->img_y = stbi__get32be(s);

  00246	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0024e	e8 00 00 00 00	 call	 stbi__get32be
  00253	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0025b	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5110 :             if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  0025e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00266	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  0026d	76 11		 jbe	 SHORT $LN27@stbi__pars
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00276	e8 00 00 00 00	 call	 stbi__err
  0027b	e9 97 14 00 00	 jmp	 $LN1@stbi__pars
$LN27@stbi__pars:

; 5111 :             if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00280	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00288	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  0028e	76 11		 jbe	 SHORT $LN28@stbi__pars
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00297	e8 00 00 00 00	 call	 stbi__err
  0029c	e9 76 14 00 00	 jmp	 $LN1@stbi__pars
$LN28@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  002a1	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002a9	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002b1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002b8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002bf	73 4b		 jae	 SHORT $LN109@stbi__pars

; 1615 :       return *s->img_buffer++;

  002c1	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002d3	88 84 24 20 05
	00 00		 mov	 BYTE PTR tv531[rsp], al
  002da	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002e2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002e9	48 ff c0	 inc	 rax
  002ec	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002f4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002fb	0f b6 84 24 20
	05 00 00	 movzx	 eax, BYTE PTR tv531[rsp]
  00303	88 84 24 10 05
	00 00		 mov	 BYTE PTR $T15[rsp], al
  0030a	eb 6e		 jmp	 SHORT $LN108@stbi__pars
$LN109@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  0030c	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00314	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00318	74 58		 je	 SHORT $LN110@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  0031a	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00322	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00327	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0032f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00336	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00339	88 84 24 21 05
	00 00		 mov	 BYTE PTR tv540[rsp], al
  00340	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00348	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0034f	48 ff c0	 inc	 rax
  00352	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00361	0f b6 84 24 21
	05 00 00	 movzx	 eax, BYTE PTR tv540[rsp]
  00369	88 84 24 10 05
	00 00		 mov	 BYTE PTR $T15[rsp], al
  00370	eb 08		 jmp	 SHORT $LN108@stbi__pars
$LN110@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00372	c6 84 24 10 05
	00 00 00	 mov	 BYTE PTR $T15[rsp], 0
$LN108@stbi__pars:

; 5112 :             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

  0037a	0f b6 84 24 10
	05 00 00	 movzx	 eax, BYTE PTR $T15[rsp]
  00382	0f b6 c0	 movzx	 eax, al
  00385	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0038d	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  00390	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00398	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  0039c	74 49		 je	 SHORT $LN29@stbi__pars
  0039e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003a6	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  003aa	74 3b		 je	 SHORT $LN29@stbi__pars
  003ac	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003b4	83 78 20 04	 cmp	 DWORD PTR [rax+32], 4
  003b8	74 2d		 je	 SHORT $LN29@stbi__pars
  003ba	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003c2	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  003c6	74 1f		 je	 SHORT $LN29@stbi__pars
  003c8	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003d0	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  003d4	74 11		 je	 SHORT $LN29@stbi__pars
  003d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@EJHIPKNO@1?12?14?18?116?9bit?5only@
  003dd	e8 00 00 00 00	 call	 stbi__err
  003e2	e9 30 13 00 00	 jmp	 $LN1@stbi__pars
$LN29@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  003e7	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ef	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f7	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  003fe	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00405	73 4b		 jae	 SHORT $LN113@stbi__pars

; 1615 :       return *s->img_buffer++;

  00407	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0040f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00416	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00419	88 84 24 22 05
	00 00		 mov	 BYTE PTR tv548[rsp], al
  00420	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00428	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0042f	48 ff c0	 inc	 rax
  00432	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0043a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00441	0f b6 84 24 22
	05 00 00	 movzx	 eax, BYTE PTR tv548[rsp]
  00449	88 84 24 11 05
	00 00		 mov	 BYTE PTR $T16[rsp], al
  00450	eb 6e		 jmp	 SHORT $LN112@stbi__pars
$LN113@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  00452	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0045a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0045e	74 58		 je	 SHORT $LN114@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  00460	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00468	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0046d	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00475	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0047c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0047f	88 84 24 23 05
	00 00		 mov	 BYTE PTR tv557[rsp], al
  00486	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0048e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00495	48 ff c0	 inc	 rax
  00498	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004a7	0f b6 84 24 23
	05 00 00	 movzx	 eax, BYTE PTR tv557[rsp]
  004af	88 84 24 11 05
	00 00		 mov	 BYTE PTR $T16[rsp], al
  004b6	eb 08		 jmp	 SHORT $LN112@stbi__pars
$LN114@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  004b8	c6 84 24 11 05
	00 00 00	 mov	 BYTE PTR $T16[rsp], 0
$LN112@stbi__pars:

; 5113 :             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");

  004c0	0f b6 84 24 11
	05 00 00	 movzx	 eax, BYTE PTR $T16[rsp]
  004c8	0f b6 c0	 movzx	 eax, al
  004cb	89 84 24 b0 04
	00 00		 mov	 DWORD PTR color$[rsp], eax
  004d2	83 bc 24 b0 04
	00 00 06	 cmp	 DWORD PTR color$[rsp], 6
  004da	7e 11		 jle	 SHORT $LN30@stbi__pars
  004dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  004e3	e8 00 00 00 00	 call	 stbi__err
  004e8	e9 2a 12 00 00	 jmp	 $LN1@stbi__pars
$LN30@stbi__pars:

; 5114 :             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");

  004ed	83 bc 24 b0 04
	00 00 03	 cmp	 DWORD PTR color$[rsp], 3
  004f5	75 1f		 jne	 SHORT $LN31@stbi__pars
  004f7	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004ff	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00503	75 11		 jne	 SHORT $LN31@stbi__pars
  00505	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  0050c	e8 00 00 00 00	 call	 stbi__err
  00511	e9 01 12 00 00	 jmp	 $LN1@stbi__pars
$LN31@stbi__pars:

; 5115 :             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");

  00516	83 bc 24 b0 04
	00 00 03	 cmp	 DWORD PTR color$[rsp], 3
  0051e	75 0a		 jne	 SHORT $LN32@stbi__pars
  00520	c6 84 24 54 04
	00 00 03	 mov	 BYTE PTR pal_img_n$[rsp], 3
  00528	eb 1f		 jmp	 SHORT $LN33@stbi__pars
$LN32@stbi__pars:
  0052a	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  00531	83 e0 01	 and	 eax, 1
  00534	85 c0		 test	 eax, eax
  00536	74 11		 je	 SHORT $LN34@stbi__pars
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MBBNGCKB@bad?5ctype@
  0053f	e8 00 00 00 00	 call	 stbi__err
  00544	e9 ce 11 00 00	 jmp	 $LN1@stbi__pars
$LN34@stbi__pars:
$LN33@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00549	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00551	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00559	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00560	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00567	73 4b		 jae	 SHORT $LN117@stbi__pars

; 1615 :       return *s->img_buffer++;

  00569	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00571	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00578	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0057b	88 84 24 24 05
	00 00		 mov	 BYTE PTR tv565[rsp], al
  00582	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0058a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00591	48 ff c0	 inc	 rax
  00594	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0059c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005a3	0f b6 84 24 24
	05 00 00	 movzx	 eax, BYTE PTR tv565[rsp]
  005ab	88 84 24 12 05
	00 00		 mov	 BYTE PTR $T17[rsp], al
  005b2	eb 6e		 jmp	 SHORT $LN116@stbi__pars
$LN117@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  005b4	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005bc	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  005c0	74 58		 je	 SHORT $LN118@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  005c2	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ca	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  005cf	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005d7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005de	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005e1	88 84 24 25 05
	00 00		 mov	 BYTE PTR tv574[rsp], al
  005e8	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005f0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005f7	48 ff c0	 inc	 rax
  005fa	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00602	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00609	0f b6 84 24 25
	05 00 00	 movzx	 eax, BYTE PTR tv574[rsp]
  00611	88 84 24 12 05
	00 00		 mov	 BYTE PTR $T17[rsp], al
  00618	eb 08		 jmp	 SHORT $LN116@stbi__pars
$LN118@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  0061a	c6 84 24 12 05
	00 00 00	 mov	 BYTE PTR $T17[rsp], 0
$LN116@stbi__pars:

; 5116 :             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

  00622	0f b6 84 24 12
	05 00 00	 movzx	 eax, BYTE PTR $T17[rsp]
  0062a	0f b6 c0	 movzx	 eax, al
  0062d	89 84 24 d4 04
	00 00		 mov	 DWORD PTR comp$9[rsp], eax
  00634	83 bc 24 d4 04
	00 00 00	 cmp	 DWORD PTR comp$9[rsp], 0
  0063c	74 11		 je	 SHORT $LN35@stbi__pars
  0063e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MDMBDDFG@bad?5comp?5method@
  00645	e8 00 00 00 00	 call	 stbi__err
  0064a	e9 c8 10 00 00	 jmp	 $LN1@stbi__pars
$LN35@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0064f	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00657	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065f	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00666	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0066d	73 4b		 jae	 SHORT $LN121@stbi__pars

; 1615 :       return *s->img_buffer++;

  0066f	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00677	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0067e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00681	88 84 24 26 05
	00 00		 mov	 BYTE PTR tv614[rsp], al
  00688	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00690	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00697	48 ff c0	 inc	 rax
  0069a	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006a2	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006a9	0f b6 84 24 26
	05 00 00	 movzx	 eax, BYTE PTR tv614[rsp]
  006b1	88 84 24 13 05
	00 00		 mov	 BYTE PTR $T18[rsp], al
  006b8	eb 6e		 jmp	 SHORT $LN120@stbi__pars
$LN121@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  006ba	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006c2	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  006c6	74 58		 je	 SHORT $LN122@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  006c8	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006d0	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  006d5	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006dd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006e4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006e7	88 84 24 27 05
	00 00		 mov	 BYTE PTR tv623[rsp], al
  006ee	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006f6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006fd	48 ff c0	 inc	 rax
  00700	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00708	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0070f	0f b6 84 24 27
	05 00 00	 movzx	 eax, BYTE PTR tv623[rsp]
  00717	88 84 24 13 05
	00 00		 mov	 BYTE PTR $T18[rsp], al
  0071e	eb 08		 jmp	 SHORT $LN120@stbi__pars
$LN122@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00720	c6 84 24 13 05
	00 00 00	 mov	 BYTE PTR $T18[rsp], 0
$LN120@stbi__pars:

; 5117 :             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

  00728	0f b6 84 24 13
	05 00 00	 movzx	 eax, BYTE PTR $T18[rsp]
  00730	0f b6 c0	 movzx	 eax, al
  00733	89 84 24 d8 04
	00 00		 mov	 DWORD PTR filter$10[rsp], eax
  0073a	83 bc 24 d8 04
	00 00 00	 cmp	 DWORD PTR filter$10[rsp], 0
  00742	74 11		 je	 SHORT $LN36@stbi__pars
  00744	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GHLIKKMD@bad?5filter?5method@
  0074b	e8 00 00 00 00	 call	 stbi__err
  00750	e9 c2 0f 00 00	 jmp	 $LN1@stbi__pars
$LN36@stbi__pars:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00755	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0075d	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00765	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0076c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00773	73 4b		 jae	 SHORT $LN125@stbi__pars

; 1615 :       return *s->img_buffer++;

  00775	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0077d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00784	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00787	88 84 24 28 05
	00 00		 mov	 BYTE PTR tv631[rsp], al
  0078e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00796	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0079d	48 ff c0	 inc	 rax
  007a0	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007a8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  007af	0f b6 84 24 28
	05 00 00	 movzx	 eax, BYTE PTR tv631[rsp]
  007b7	88 84 24 14 05
	00 00		 mov	 BYTE PTR $T19[rsp], al
  007be	eb 6e		 jmp	 SHORT $LN124@stbi__pars
$LN125@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  007c0	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007cc	74 58		 je	 SHORT $LN126@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  007ce	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  007db	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007ed	88 84 24 29 05
	00 00		 mov	 BYTE PTR tv640[rsp], al
  007f4	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007fc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00803	48 ff c0	 inc	 rax
  00806	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0080e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00815	0f b6 84 24 29
	05 00 00	 movzx	 eax, BYTE PTR tv640[rsp]
  0081d	88 84 24 14 05
	00 00		 mov	 BYTE PTR $T19[rsp], al
  00824	eb 08		 jmp	 SHORT $LN124@stbi__pars
$LN126@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00826	c6 84 24 14 05
	00 00 00	 mov	 BYTE PTR $T19[rsp], 0
$LN124@stbi__pars:

; 5118 :             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

  0082e	0f b6 84 24 14
	05 00 00	 movzx	 eax, BYTE PTR $T19[rsp]
  00836	0f b6 c0	 movzx	 eax, al
  00839	89 84 24 ac 04
	00 00		 mov	 DWORD PTR interlace$[rsp], eax
  00840	83 bc 24 ac 04
	00 00 01	 cmp	 DWORD PTR interlace$[rsp], 1
  00848	7e 11		 jle	 SHORT $LN37@stbi__pars
  0084a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@JCGDPBAA@bad?5interlace?5method@
  00851	e8 00 00 00 00	 call	 stbi__err
  00856	e9 bc 0e 00 00	 jmp	 $LN1@stbi__pars
$LN37@stbi__pars:

; 5119 :             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

  0085b	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00863	83 38 00	 cmp	 DWORD PTR [rax], 0
  00866	74 0e		 je	 SHORT $LN39@stbi__pars
  00868	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00870	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00874	75 11		 jne	 SHORT $LN38@stbi__pars
$LN39@stbi__pars:
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FNFBHCOO@0?9pixel?5image@
  0087d	e8 00 00 00 00	 call	 stbi__err
  00882	e9 90 0e 00 00	 jmp	 $LN1@stbi__pars
$LN38@stbi__pars:

; 5120 :             if (!pal_img_n) {

  00887	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  0088f	85 c0		 test	 eax, eax
  00891	0f 85 a7 00 00
	00		 jne	 $LN40@stbi__pars

; 5121 :                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

  00897	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  0089e	83 e0 02	 and	 eax, 2
  008a1	85 c0		 test	 eax, eax
  008a3	74 0d		 je	 SHORT $LN97@stbi__pars
  008a5	c7 84 24 2c 05
	00 00 03 00 00
	00		 mov	 DWORD PTR tv194[rsp], 3
  008b0	eb 0b		 jmp	 SHORT $LN98@stbi__pars
$LN97@stbi__pars:
  008b2	c7 84 24 2c 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv194[rsp], 1
$LN98@stbi__pars:
  008bd	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  008c4	83 e0 04	 and	 eax, 4
  008c7	85 c0		 test	 eax, eax
  008c9	74 0d		 je	 SHORT $LN99@stbi__pars
  008cb	c7 84 24 30 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv197[rsp], 1
  008d6	eb 0b		 jmp	 SHORT $LN100@stbi__pars
$LN99@stbi__pars:
  008d8	c7 84 24 30 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN100@stbi__pars:
  008e3	8b 84 24 30 05
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  008ea	8b 8c 24 2c 05
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  008f1	03 c8		 add	 ecx, eax
  008f3	8b c1		 mov	 eax, ecx
  008f5	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008fd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5122 :                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

  00900	33 d2		 xor	 edx, edx
  00902	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00907	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0090f	f7 31		 div	 DWORD PTR [rcx]
  00911	33 d2		 xor	 edx, edx
  00913	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0091b	f7 71 08	 div	 DWORD PTR [rcx+8]
  0091e	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00926	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00929	73 11		 jae	 SHORT $LN42@stbi__pars
  0092b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00932	e8 00 00 00 00	 call	 stbi__err
  00937	e9 db 0d 00 00	 jmp	 $LN1@stbi__pars
$LN42@stbi__pars:

; 5123 :             } else {

  0093c	eb 47		 jmp	 SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 5124 :                // if paletted, then pal_n is our final components, and
; 5125 :                // img_n is # components to decompress/filter.
; 5126 :                s->img_n = 1;

  0093e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00946	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1

; 5127 :                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");

  0094d	33 d2		 xor	 edx, edx
  0094f	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00954	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0095c	f7 31		 div	 DWORD PTR [rcx]
  0095e	33 d2		 xor	 edx, edx
  00960	b9 04 00 00 00	 mov	 ecx, 4
  00965	f7 f1		 div	 ecx
  00967	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0096f	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00972	73 11		 jae	 SHORT $LN43@stbi__pars
  00974	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0097b	e8 00 00 00 00	 call	 stbi__err
  00980	e9 92 0d 00 00	 jmp	 $LN1@stbi__pars
$LN43@stbi__pars:
$LN41@stbi__pars:

; 5128 :             }
; 5129 :             // even with SCAN_header, have to scan to see if we have a tRNS
; 5130 :             break;

  00985	e9 7a 0d 00 00	 jmp	 $LN5@stbi__pars
$LN44@stbi__pars:

; 5131 :          }
; 5132 : 
; 5133 :          case STBI__PNG_TYPE('P','L','T','E'):  {
; 5134 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0098a	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  00992	74 11		 je	 SHORT $LN45@stbi__pars
  00994	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  0099b	e8 00 00 00 00	 call	 stbi__err
  009a0	e9 72 0d 00 00	 jmp	 $LN1@stbi__pars
$LN45@stbi__pars:

; 5135 :             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");

  009a5	81 bc 24 c8 04
	00 00 00 03 00
	00		 cmp	 DWORD PTR c$8[rsp], 768	; 00000300H
  009b0	76 11		 jbe	 SHORT $LN46@stbi__pars
  009b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JCPAJAKB@invalid?5PLTE@
  009b9	e8 00 00 00 00	 call	 stbi__err
  009be	e9 54 0d 00 00	 jmp	 $LN1@stbi__pars
$LN46@stbi__pars:

; 5136 :             pal_len = c.length / 3;

  009c3	33 d2		 xor	 edx, edx
  009c5	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  009cc	b9 03 00 00 00	 mov	 ecx, 3
  009d1	f7 f1		 div	 ecx
  009d3	89 84 24 a0 04
	00 00		 mov	 DWORD PTR pal_len$[rsp], eax

; 5137 :             if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");

  009da	6b 84 24 a0 04
	00 00 03	 imul	 eax, DWORD PTR pal_len$[rsp], 3
  009e2	3b 84 24 c8 04
	00 00		 cmp	 eax, DWORD PTR c$8[rsp]
  009e9	74 11		 je	 SHORT $LN47@stbi__pars
  009eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JCPAJAKB@invalid?5PLTE@
  009f2	e8 00 00 00 00	 call	 stbi__err
  009f7	e9 1b 0d 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 5138 :             for (i=0; i < pal_len; ++i) {

  009fc	c7 84 24 9c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00a07	eb 10		 jmp	 SHORT $LN9@stbi__pars
$LN7@stbi__pars:
  00a09	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00a10	ff c0		 inc	 eax
  00a12	89 84 24 9c 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN9@stbi__pars:
  00a19	8b 84 24 a0 04
	00 00		 mov	 eax, DWORD PTR pal_len$[rsp]
  00a20	39 84 24 9c 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00a27	0f 83 f5 02 00
	00		 jae	 $LN8@stbi__pars

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00a2d	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a35	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a3d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00a44	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00a4b	73 4b		 jae	 SHORT $LN129@stbi__pars

; 1615 :       return *s->img_buffer++;

  00a4d	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a55	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a5c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a5f	88 84 24 34 05
	00 00		 mov	 BYTE PTR tv648[rsp], al
  00a66	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a6e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a75	48 ff c0	 inc	 rax
  00a78	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a80	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00a87	0f b6 84 24 34
	05 00 00	 movzx	 eax, BYTE PTR tv648[rsp]
  00a8f	88 84 24 15 05
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00a96	eb 6e		 jmp	 SHORT $LN128@stbi__pars
$LN129@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  00a98	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aa0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00aa4	74 58		 je	 SHORT $LN130@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  00aa6	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aae	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00ab3	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00abb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ac2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ac5	88 84 24 35 05
	00 00		 mov	 BYTE PTR tv657[rsp], al
  00acc	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ad4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00adb	48 ff c0	 inc	 rax
  00ade	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ae6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00aed	0f b6 84 24 35
	05 00 00	 movzx	 eax, BYTE PTR tv657[rsp]
  00af5	88 84 24 15 05
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00afc	eb 08		 jmp	 SHORT $LN128@stbi__pars
$LN130@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00afe	c6 84 24 15 05
	00 00 00	 mov	 BYTE PTR $T20[rsp], 0
$LN128@stbi__pars:

; 5139 :                palette[i*4+0] = stbi__get8(s);

  00b06	0f b6 84 24 15
	05 00 00	 movzx	 eax, BYTE PTR $T20[rsp]
  00b0e	8b 8c 24 9c 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00b15	c1 e1 02	 shl	 ecx, 2
  00b18	8b c9		 mov	 ecx, ecx
  00b1a	88 44 0c 50	 mov	 BYTE PTR palette$[rsp+rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00b1e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b26	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b2e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00b35	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00b3c	73 4b		 jae	 SHORT $LN133@stbi__pars

; 1615 :       return *s->img_buffer++;

  00b3e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b46	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b4d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b50	88 84 24 36 05
	00 00		 mov	 BYTE PTR tv665[rsp], al
  00b57	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b5f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b66	48 ff c0	 inc	 rax
  00b69	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b71	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b78	0f b6 84 24 36
	05 00 00	 movzx	 eax, BYTE PTR tv665[rsp]
  00b80	88 84 24 16 05
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00b87	eb 6e		 jmp	 SHORT $LN132@stbi__pars
$LN133@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  00b89	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b91	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00b95	74 58		 je	 SHORT $LN134@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  00b97	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b9f	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00ba4	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bac	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00bb3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00bb6	88 84 24 37 05
	00 00		 mov	 BYTE PTR tv674[rsp], al
  00bbd	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bc5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00bcc	48 ff c0	 inc	 rax
  00bcf	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bd7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00bde	0f b6 84 24 37
	05 00 00	 movzx	 eax, BYTE PTR tv674[rsp]
  00be6	88 84 24 16 05
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00bed	eb 08		 jmp	 SHORT $LN132@stbi__pars
$LN134@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00bef	c6 84 24 16 05
	00 00 00	 mov	 BYTE PTR $T21[rsp], 0
$LN132@stbi__pars:

; 5140 :                palette[i*4+1] = stbi__get8(s);

  00bf7	0f b6 84 24 16
	05 00 00	 movzx	 eax, BYTE PTR $T21[rsp]
  00bff	8b 8c 24 9c 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00c06	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  00c0d	8b c9		 mov	 ecx, ecx
  00c0f	88 44 0c 50	 mov	 BYTE PTR palette$[rsp+rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00c13	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c1b	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c23	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00c2a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00c31	73 4b		 jae	 SHORT $LN137@stbi__pars

; 1615 :       return *s->img_buffer++;

  00c33	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c3b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c42	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c45	88 84 24 38 05
	00 00		 mov	 BYTE PTR tv682[rsp], al
  00c4c	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c54	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c5b	48 ff c0	 inc	 rax
  00c5e	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c66	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00c6d	0f b6 84 24 38
	05 00 00	 movzx	 eax, BYTE PTR tv682[rsp]
  00c75	88 84 24 17 05
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00c7c	eb 6e		 jmp	 SHORT $LN136@stbi__pars
$LN137@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  00c7e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c86	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00c8a	74 58		 je	 SHORT $LN138@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  00c8c	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c94	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00c99	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ca1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ca8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00cab	88 84 24 39 05
	00 00		 mov	 BYTE PTR tv691[rsp], al
  00cb2	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cba	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00cc1	48 ff c0	 inc	 rax
  00cc4	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ccc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00cd3	0f b6 84 24 39
	05 00 00	 movzx	 eax, BYTE PTR tv691[rsp]
  00cdb	88 84 24 17 05
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00ce2	eb 08		 jmp	 SHORT $LN136@stbi__pars
$LN138@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00ce4	c6 84 24 17 05
	00 00 00	 mov	 BYTE PTR $T22[rsp], 0
$LN136@stbi__pars:

; 5141 :                palette[i*4+2] = stbi__get8(s);

  00cec	0f b6 84 24 17
	05 00 00	 movzx	 eax, BYTE PTR $T22[rsp]
  00cf4	8b 8c 24 9c 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00cfb	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  00d02	8b c9		 mov	 ecx, ecx
  00d04	88 44 0c 50	 mov	 BYTE PTR palette$[rsp+rcx], al

; 5142 :                palette[i*4+3] = 255;

  00d08	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00d0f	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  00d16	8b c0		 mov	 eax, eax
  00d18	c6 44 04 50 ff	 mov	 BYTE PTR palette$[rsp+rax], 255 ; 000000ffH

; 5143 :             }

  00d1d	e9 e7 fc ff ff	 jmp	 $LN7@stbi__pars
$LN8@stbi__pars:

; 5144 :             break;

  00d22	e9 dd 09 00 00	 jmp	 $LN5@stbi__pars
$LN48@stbi__pars:

; 5145 :          }
; 5146 : 
; 5147 :          case STBI__PNG_TYPE('t','R','N','S'): {
; 5148 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00d27	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  00d2f	74 11		 je	 SHORT $LN49@stbi__pars
  00d31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  00d38	e8 00 00 00 00	 call	 stbi__err
  00d3d	e9 d5 09 00 00	 jmp	 $LN1@stbi__pars
$LN49@stbi__pars:

; 5149 :             if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

  00d42	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d4a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00d4f	74 11		 je	 SHORT $LN50@stbi__pars
  00d51	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@PCPJHDKJ@tRNS?5after?5IDAT@
  00d58	e8 00 00 00 00	 call	 stbi__err
  00d5d	e9 b5 09 00 00	 jmp	 $LN1@stbi__pars
$LN50@stbi__pars:

; 5150 :             if (pal_img_n) {

  00d62	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00d6a	85 c0		 test	 eax, eax
  00d6c	0f 84 97 01 00
	00		 je	 $LN51@stbi__pars

; 5151 :                if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

  00d72	83 bc 24 68 05
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  00d7a	75 19		 jne	 SHORT $LN53@stbi__pars
  00d7c	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d84	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [rax+8], 4
  00d8b	b8 01 00 00 00	 mov	 eax, 1
  00d90	e9 82 09 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 5152 :                if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

  00d95	83 bc 24 a0 04
	00 00 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  00d9d	75 11		 jne	 SHORT $LN54@stbi__pars
  00d9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@CEDNNLBG@tRNS?5before?5PLTE@
  00da6	e8 00 00 00 00	 call	 stbi__err
  00dab	e9 67 09 00 00	 jmp	 $LN1@stbi__pars
$LN54@stbi__pars:

; 5153 :                if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");

  00db0	8b 84 24 a0 04
	00 00		 mov	 eax, DWORD PTR pal_len$[rsp]
  00db7	39 84 24 c8 04
	00 00		 cmp	 DWORD PTR c$8[rsp], eax
  00dbe	76 11		 jbe	 SHORT $LN55@stbi__pars
  00dc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
  00dc7	e8 00 00 00 00	 call	 stbi__err
  00dcc	e9 46 09 00 00	 jmp	 $LN1@stbi__pars
$LN55@stbi__pars:

; 5154 :                pal_img_n = 4;

  00dd1	c6 84 24 54 04
	00 00 04	 mov	 BYTE PTR pal_img_n$[rsp], 4

; 5155 :                for (i=0; i < c.length; ++i)

  00dd9	c7 84 24 9c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00de4	eb 10		 jmp	 SHORT $LN12@stbi__pars
$LN10@stbi__pars:
  00de6	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00ded	ff c0		 inc	 eax
  00def	89 84 24 9c 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__pars:
  00df6	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  00dfd	39 84 24 9c 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00e04	0f 83 fa 00 00
	00		 jae	 $LN11@stbi__pars

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00e0a	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e12	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e1a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00e21	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00e28	73 4b		 jae	 SHORT $LN141@stbi__pars

; 1615 :       return *s->img_buffer++;

  00e2a	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e32	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e39	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e3c	88 84 24 3a 05
	00 00		 mov	 BYTE PTR tv699[rsp], al
  00e43	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e4b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e52	48 ff c0	 inc	 rax
  00e55	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e5d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00e64	0f b6 84 24 3a
	05 00 00	 movzx	 eax, BYTE PTR tv699[rsp]
  00e6c	88 84 24 18 05
	00 00		 mov	 BYTE PTR $T23[rsp], al
  00e73	eb 6e		 jmp	 SHORT $LN140@stbi__pars
$LN141@stbi__pars:

; 1616 :    if (s->read_from_callbacks) {

  00e75	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e7d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00e81	74 58		 je	 SHORT $LN142@stbi__pars

; 1617 :       stbi__refill_buffer(s);

  00e83	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e8b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00e90	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e98	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e9f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ea2	88 84 24 3b 05
	00 00		 mov	 BYTE PTR tv708[rsp], al
  00ea9	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00eb1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00eb8	48 ff c0	 inc	 rax
  00ebb	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ec3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00eca	0f b6 84 24 3b
	05 00 00	 movzx	 eax, BYTE PTR tv708[rsp]
  00ed2	88 84 24 18 05
	00 00		 mov	 BYTE PTR $T23[rsp], al
  00ed9	eb 08		 jmp	 SHORT $LN140@stbi__pars
$LN142@stbi__pars:

; 1619 :    }
; 1620 :    return 0;

  00edb	c6 84 24 18 05
	00 00 00	 mov	 BYTE PTR $T23[rsp], 0
$LN140@stbi__pars:

; 5156 :                   palette[i*4+3] = stbi__get8(s);

  00ee3	0f b6 84 24 18
	05 00 00	 movzx	 eax, BYTE PTR $T23[rsp]
  00eeb	8b 8c 24 9c 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00ef2	8d 0c 8d 03 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+3]
  00ef9	8b c9		 mov	 ecx, ecx
  00efb	88 44 0c 50	 mov	 BYTE PTR palette$[rsp+rcx], al
  00eff	e9 e2 fe ff ff	 jmp	 $LN10@stbi__pars
$LN11@stbi__pars:

; 5157 :             } else {

  00f04	e9 4f 01 00 00	 jmp	 $LN52@stbi__pars
$LN51@stbi__pars:

; 5158 :                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

  00f09	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f11	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00f14	83 e0 01	 and	 eax, 1
  00f17	85 c0		 test	 eax, eax
  00f19	75 11		 jne	 SHORT $LN56@stbi__pars
  00f1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ENDPGCHB@tRNS?5with?5alpha@
  00f22	e8 00 00 00 00	 call	 stbi__err
  00f27	e9 eb 07 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 5159 :                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");

  00f2c	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f34	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00f37	d1 e0		 shl	 eax, 1
  00f39	39 84 24 c8 04
	00 00		 cmp	 DWORD PTR c$8[rsp], eax
  00f40	74 11		 je	 SHORT $LN57@stbi__pars
  00f42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KDLCCKCH@bad?5tRNS?5len@
  00f49	e8 00 00 00 00	 call	 stbi__err
  00f4e	e9 c4 07 00 00	 jmp	 $LN1@stbi__pars
$LN57@stbi__pars:

; 5160 :                has_trans = 1;

  00f53	c6 84 24 55 04
	00 00 01	 mov	 BYTE PTR has_trans$[rsp], 1

; 5161 :                // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5162 :                if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }

  00f5b	83 bc 24 68 05
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  00f63	75 22		 jne	 SHORT $LN58@stbi__pars
  00f65	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f6d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00f70	ff c0		 inc	 eax
  00f72	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f7a	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00f7d	b8 01 00 00 00	 mov	 eax, 1
  00f82	e9 90 07 00 00	 jmp	 $LN1@stbi__pars
$LN58@stbi__pars:

; 5163 :                if (z->depth == 16) {

  00f87	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f8f	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00f93	75 52		 jne	 SHORT $LN59@stbi__pars

; 5164 :                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

  00f95	c7 84 24 a8 04
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  00fa0	eb 10		 jmp	 SHORT $LN15@stbi__pars
$LN13@stbi__pars:
  00fa2	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00fa9	ff c0		 inc	 eax
  00fab	89 84 24 a8 04
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN15@stbi__pars:
  00fb2	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00fba	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00fbd	39 84 24 a8 04
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  00fc4	7d 1f		 jge	 SHORT $LN14@stbi__pars
  00fc6	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00fce	e8 00 00 00 00	 call	 stbi__get16be
  00fd3	48 63 8c 24 a8
	04 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  00fdb	66 89 84 4c 84
	04 00 00	 mov	 WORD PTR tc16$[rsp+rcx*2], ax
  00fe3	eb bd		 jmp	 SHORT $LN13@stbi__pars
$LN14@stbi__pars:

; 5165 :                } else {

  00fe5	eb 71		 jmp	 SHORT $LN60@stbi__pars
$LN59@stbi__pars:

; 5166 :                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

  00fe7	c7 84 24 a8 04
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  00ff2	eb 10		 jmp	 SHORT $LN18@stbi__pars
$LN16@stbi__pars:
  00ff4	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00ffb	ff c0		 inc	 eax
  00ffd	89 84 24 a8 04
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__pars:
  01004	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0100c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0100f	39 84 24 a8 04
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  01016	7d 40		 jge	 SHORT $LN17@stbi__pars
  01018	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01020	e8 00 00 00 00	 call	 stbi__get16be
  01025	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0102a	0f b6 c0	 movzx	 eax, al
  0102d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01035	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  01039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__depth_scale_table
  01040	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01044	0f af c1	 imul	 eax, ecx
  01047	48 63 8c 24 a8
	04 00 00	 movsxd	 rcx, DWORD PTR k$[rsp]
  0104f	88 84 0c 64 04
	00 00		 mov	 BYTE PTR tc$[rsp+rcx], al
  01056	eb 9c		 jmp	 SHORT $LN16@stbi__pars
$LN17@stbi__pars:
$LN60@stbi__pars:
$LN52@stbi__pars:

; 5167 :                }
; 5168 :             }
; 5169 :             break;

  01058	e9 a7 06 00 00	 jmp	 $LN5@stbi__pars
$LN61@stbi__pars:

; 5170 :          }
; 5171 : 
; 5172 :          case STBI__PNG_TYPE('I','D','A','T'): {
; 5173 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0105d	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  01065	74 11		 je	 SHORT $LN62@stbi__pars
  01067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  0106e	e8 00 00 00 00	 call	 stbi__err
  01073	e9 9f 06 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 5174 :             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

  01078	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  01080	85 c0		 test	 eax, eax
  01082	74 1b		 je	 SHORT $LN63@stbi__pars
  01084	83 bc 24 a0 04
	00 00 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  0108c	75 11		 jne	 SHORT $LN63@stbi__pars
  0108e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CKIELOEH@no?5PLTE@
  01095	e8 00 00 00 00	 call	 stbi__err
  0109a	e9 78 06 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:

; 5175 :             if (scan == STBI__SCAN_header) {

  0109f	83 bc 24 68 05
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  010a7	75 29		 jne	 SHORT $LN64@stbi__pars

; 5176 :                // header scan definitely stops at first IDAT
; 5177 :                if (pal_img_n)

  010a9	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  010b1	85 c0		 test	 eax, eax
  010b3	74 13		 je	 SHORT $LN65@stbi__pars

; 5178 :                   s->img_n = pal_img_n;

  010b5	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  010bd	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  010c5	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN65@stbi__pars:

; 5179 :                return 1;

  010c8	b8 01 00 00 00	 mov	 eax, 1
  010cd	e9 45 06 00 00	 jmp	 $LN1@stbi__pars
$LN64@stbi__pars:

; 5180 :             }
; 5181 :             if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");

  010d2	81 bc 24 c8 04
	00 00 00 00 00
	40		 cmp	 DWORD PTR c$8[rsp], 1073741824 ; 40000000H
  010dd	76 11		 jbe	 SHORT $LN66@stbi__pars
  010df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@PLHGLONG@IDAT?5size?5limit@
  010e6	e8 00 00 00 00	 call	 stbi__err
  010eb	e9 27 06 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 5182 :             if ((int)(ioff + c.length) < (int)ioff) return 0;

  010f0	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  010f7	8b 8c 24 94 04
	00 00		 mov	 ecx, DWORD PTR ioff$[rsp]
  010fe	03 c8		 add	 ecx, eax
  01100	8b c1		 mov	 eax, ecx
  01102	3b 84 24 94 04
	00 00		 cmp	 eax, DWORD PTR ioff$[rsp]
  01109	7d 07		 jge	 SHORT $LN67@stbi__pars
  0110b	33 c0		 xor	 eax, eax
  0110d	e9 05 06 00 00	 jmp	 $LN1@stbi__pars
$LN67@stbi__pars:

; 5183 :             if (ioff + c.length > idata_limit) {

  01112	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  01119	8b 8c 24 94 04
	00 00		 mov	 ecx, DWORD PTR ioff$[rsp]
  01120	03 c8		 add	 ecx, eax
  01122	8b c1		 mov	 eax, ecx
  01124	3b 84 24 98 04
	00 00		 cmp	 eax, DWORD PTR idata_limit$[rsp]
  0112b	0f 86 ce 00 00
	00		 jbe	 $LN68@stbi__pars

; 5184 :                stbi__uint32 idata_limit_old = idata_limit;

  01131	8b 84 24 98 04
	00 00		 mov	 eax, DWORD PTR idata_limit$[rsp]
  01138	89 84 24 dc 04
	00 00		 mov	 DWORD PTR idata_limit_old$11[rsp], eax

; 5185 :                stbi_uc *p;
; 5186 :                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

  0113f	83 bc 24 98 04
	00 00 00	 cmp	 DWORD PTR idata_limit$[rsp], 0
  01147	75 36		 jne	 SHORT $LN69@stbi__pars
  01149	81 bc 24 c8 04
	00 00 00 10 00
	00		 cmp	 DWORD PTR c$8[rsp], 4096 ; 00001000H
  01154	76 10		 jbe	 SHORT $LN101@stbi__pars
  01156	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  0115d	89 84 24 3c 05
	00 00		 mov	 DWORD PTR tv345[rsp], eax
  01164	eb 0b		 jmp	 SHORT $LN102@stbi__pars
$LN101@stbi__pars:
  01166	c7 84 24 3c 05
	00 00 00 10 00
	00		 mov	 DWORD PTR tv345[rsp], 4096 ; 00001000H
$LN102@stbi__pars:
  01171	8b 84 24 3c 05
	00 00		 mov	 eax, DWORD PTR tv345[rsp]
  01178	89 84 24 98 04
	00 00		 mov	 DWORD PTR idata_limit$[rsp], eax
$LN69@stbi__pars:
$LN19@stbi__pars:

; 5187 :                while (ioff + c.length > idata_limit)

  0117f	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  01186	8b 8c 24 94 04
	00 00		 mov	 ecx, DWORD PTR ioff$[rsp]
  0118d	03 c8		 add	 ecx, eax
  0118f	8b c1		 mov	 eax, ecx
  01191	3b 84 24 98 04
	00 00		 cmp	 eax, DWORD PTR idata_limit$[rsp]
  01198	76 12		 jbe	 SHORT $LN20@stbi__pars

; 5188 :                   idata_limit *= 2;

  0119a	8b 84 24 98 04
	00 00		 mov	 eax, DWORD PTR idata_limit$[rsp]
  011a1	d1 e0		 shl	 eax, 1
  011a3	89 84 24 98 04
	00 00		 mov	 DWORD PTR idata_limit$[rsp], eax
  011aa	eb d3		 jmp	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:

; 5189 :                STBI_NOTUSED(idata_limit_old);
; 5190 :                p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

  011ac	8b 84 24 98 04
	00 00		 mov	 eax, DWORD PTR idata_limit$[rsp]
  011b3	8b d0		 mov	 edx, eax
  011b5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  011bd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  011c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  011c7	48 89 84 24 e0
	04 00 00	 mov	 QWORD PTR p$12[rsp], rax
  011cf	48 83 bc 24 e0
	04 00 00 00	 cmp	 QWORD PTR p$12[rsp], 0
  011d8	75 11		 jne	 SHORT $LN70@stbi__pars
  011da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  011e1	e8 00 00 00 00	 call	 stbi__err
  011e6	e9 2c 05 00 00	 jmp	 $LN1@stbi__pars
$LN70@stbi__pars:

; 5191 :                z->idata = p;

  011eb	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  011f3	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR p$12[rsp]
  011fb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN68@stbi__pars:

; 5192 :             }
; 5193 :             if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

  011ff	8b 84 24 94 04
	00 00		 mov	 eax, DWORD PTR ioff$[rsp]
  01206	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0120e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  01212	44 8b 84 24 c8
	04 00 00	 mov	 r8d, DWORD PTR c$8[rsp]
  0121a	48 8b d0	 mov	 rdx, rax
  0121d	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01225	e8 00 00 00 00	 call	 stbi__getn
  0122a	85 c0		 test	 eax, eax
  0122c	75 11		 jne	 SHORT $LN71@stbi__pars
  0122e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MNNCNKEO@outofdata@
  01235	e8 00 00 00 00	 call	 stbi__err
  0123a	e9 d8 04 00 00	 jmp	 $LN1@stbi__pars
$LN71@stbi__pars:

; 5194 :             ioff += c.length;

  0123f	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp]
  01246	8b 8c 24 94 04
	00 00		 mov	 ecx, DWORD PTR ioff$[rsp]
  0124d	03 c8		 add	 ecx, eax
  0124f	8b c1		 mov	 eax, ecx
  01251	89 84 24 94 04
	00 00		 mov	 DWORD PTR ioff$[rsp], eax

; 5195 :             break;

  01258	e9 a7 04 00 00	 jmp	 $LN5@stbi__pars
$LN72@stbi__pars:

; 5196 :          }
; 5197 : 
; 5198 :          case STBI__PNG_TYPE('I','E','N','D'): {
; 5199 :             stbi__uint32 raw_len, bpl;
; 5200 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0125d	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  01265	74 11		 je	 SHORT $LN73@stbi__pars
  01267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  0126e	e8 00 00 00 00	 call	 stbi__err
  01273	e9 9f 04 00 00	 jmp	 $LN1@stbi__pars
$LN73@stbi__pars:

; 5201 :             if (scan != STBI__SCAN_load) return 1;

  01278	83 bc 24 68 05
	00 00 00	 cmp	 DWORD PTR scan$[rsp], 0
  01280	74 0a		 je	 SHORT $LN74@stbi__pars
  01282	b8 01 00 00 00	 mov	 eax, 1
  01287	e9 8b 04 00 00	 jmp	 $LN1@stbi__pars
$LN74@stbi__pars:

; 5202 :             if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

  0128c	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01294	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  01299	75 11		 jne	 SHORT $LN75@stbi__pars
  0129b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MLPECBNA@no?5IDAT@
  012a2	e8 00 00 00 00	 call	 stbi__err
  012a7	e9 6b 04 00 00	 jmp	 $LN1@stbi__pars
$LN75@stbi__pars:

; 5203 :             // initial guess for decoded data size to avoid unnecessary reallocs
; 5204 :             bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

  012ac	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  012b4	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  012bc	8b 00		 mov	 eax, DWORD PTR [rax]
  012be	0f af 41 20	 imul	 eax, DWORD PTR [rcx+32]
  012c2	83 c0 07	 add	 eax, 7
  012c5	33 d2		 xor	 edx, edx
  012c7	b9 08 00 00 00	 mov	 ecx, 8
  012cc	f7 f1		 div	 ecx
  012ce	89 84 24 04 05
	00 00		 mov	 DWORD PTR bpl$14[rsp], eax

; 5205 :             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

  012d5	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  012dd	8b 8c 24 04 05
	00 00		 mov	 ecx, DWORD PTR bpl$14[rsp]
  012e4	0f af 48 04	 imul	 ecx, DWORD PTR [rax+4]
  012e8	8b c1		 mov	 eax, ecx
  012ea	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  012f2	0f af 41 08	 imul	 eax, DWORD PTR [rcx+8]
  012f6	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  012fe	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  01301	89 84 24 f4 04
	00 00		 mov	 DWORD PTR raw_len$13[rsp], eax

; 5206 :             z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

  01308	83 bc 24 b4 04
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  01310	75 0d		 jne	 SHORT $LN103@stbi__pars
  01312	c7 84 24 40 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv394[rsp], 1
  0131d	eb 0b		 jmp	 SHORT $LN104@stbi__pars
$LN103@stbi__pars:
  0131f	c7 84 24 40 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv394[rsp], 0
$LN104@stbi__pars:
  0132a	8b 84 24 40 05
	00 00		 mov	 eax, DWORD PTR tv394[rsp]
  01331	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01335	4c 8d 8c 24 f4
	04 00 00	 lea	 r9, QWORD PTR raw_len$13[rsp]
  0133d	44 8b 84 24 f4
	04 00 00	 mov	 r8d, DWORD PTR raw_len$13[rsp]
  01345	8b 94 24 94 04
	00 00		 mov	 edx, DWORD PTR ioff$[rsp]
  0134c	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01354	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  01358	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize_headerflag
  0135d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01365	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 5207 :             if (z->expanded == NULL) return 0; // zlib should set error

  01369	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01371	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  01376	75 07		 jne	 SHORT $LN76@stbi__pars
  01378	33 c0		 xor	 eax, eax
  0137a	e9 98 03 00 00	 jmp	 $LN1@stbi__pars
$LN76@stbi__pars:

; 5208 :             STBI_FREE(z->idata); z->idata = NULL;

  0137f	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01387	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0138b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  01391	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01399	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5209 :             if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

  013a1	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  013a9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  013ac	ff c0		 inc	 eax
  013ae	39 84 24 70 05
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  013b5	75 16		 jne	 SHORT $LN80@stbi__pars
  013b7	83 bc 24 70 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  013bf	74 0c		 je	 SHORT $LN80@stbi__pars
  013c1	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  013c9	85 c0		 test	 eax, eax
  013cb	74 0c		 je	 SHORT $LN79@stbi__pars
$LN80@stbi__pars:
  013cd	0f b6 84 24 55
	04 00 00	 movzx	 eax, BYTE PTR has_trans$[rsp]
  013d5	85 c0		 test	 eax, eax
  013d7	74 1a		 je	 SHORT $LN77@stbi__pars
$LN79@stbi__pars:

; 5210 :                s->img_out_n = s->img_n+1;

  013d9	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  013e1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  013e4	ff c0		 inc	 eax
  013e6	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  013ee	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  013f1	eb 16		 jmp	 SHORT $LN78@stbi__pars
$LN77@stbi__pars:

; 5211 :             else
; 5212 :                s->img_out_n = s->img_n;

  013f3	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  013fb	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01403	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  01406	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN78@stbi__pars:

; 5213 :             if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

  01409	8b 84 24 ac 04
	00 00		 mov	 eax, DWORD PTR interlace$[rsp]
  01410	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01414	8b 84 24 b0 04
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  0141b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0141f	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01427	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0142a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0142e	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01436	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  0143a	44 8b 84 24 f4
	04 00 00	 mov	 r8d, DWORD PTR raw_len$13[rsp]
  01442	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0144a	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0144e	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01456	e8 00 00 00 00	 call	 stbi__create_png_image
  0145b	85 c0		 test	 eax, eax
  0145d	75 07		 jne	 SHORT $LN81@stbi__pars
  0145f	33 c0		 xor	 eax, eax
  01461	e9 b1 02 00 00	 jmp	 $LN1@stbi__pars
$LN81@stbi__pars:

; 5214 :             if (has_trans) {

  01466	0f b6 84 24 55
	04 00 00	 movzx	 eax, BYTE PTR has_trans$[rsp]
  0146e	85 c0		 test	 eax, eax
  01470	74 68		 je	 SHORT $LN82@stbi__pars

; 5215 :                if (z->depth == 16) {

  01472	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0147a	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  0147e	75 2e		 jne	 SHORT $LN83@stbi__pars

; 5216 :                   if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

  01480	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01488	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  0148c	48 8d 94 24 84
	04 00 00	 lea	 rdx, QWORD PTR tc16$[rsp]
  01494	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0149c	e8 00 00 00 00	 call	 stbi__compute_transparency16
  014a1	85 c0		 test	 eax, eax
  014a3	75 07		 jne	 SHORT $LN85@stbi__pars
  014a5	33 c0		 xor	 eax, eax
  014a7	e9 6b 02 00 00	 jmp	 $LN1@stbi__pars
$LN85@stbi__pars:

; 5217 :                } else {

  014ac	eb 2c		 jmp	 SHORT $LN84@stbi__pars
$LN83@stbi__pars:

; 5218 :                   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

  014ae	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  014b6	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  014ba	48 8d 94 24 64
	04 00 00	 lea	 rdx, QWORD PTR tc$[rsp]
  014c2	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  014ca	e8 00 00 00 00	 call	 stbi__compute_transparency
  014cf	85 c0		 test	 eax, eax
  014d1	75 07		 jne	 SHORT $LN86@stbi__pars
  014d3	33 c0		 xor	 eax, eax
  014d5	e9 3d 02 00 00	 jmp	 $LN1@stbi__pars
$LN86@stbi__pars:
$LN84@stbi__pars:
$LN82@stbi__pars:

; 5219 :                }
; 5220 :             }
; 5221 :             if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

  014da	83 bc 24 b4 04
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  014e2	74 6b		 je	 SHORT $LN87@stbi__pars
  014e4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_set
  014e9	8b c0		 mov	 eax, eax
  014eb	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  014f4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  014f7	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  014fb	74 1f		 je	 SHORT $LN105@stbi__pars
  014fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__de_iphone_flag_local
  01502	8b c0		 mov	 eax, eax
  01504	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  0150d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01510	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  01513	89 84 24 44 05
	00 00		 mov	 DWORD PTR tv455[rsp], eax
  0151a	eb 0d		 jmp	 SHORT $LN106@stbi__pars
$LN105@stbi__pars:
  0151c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR stbi__de_iphone_flag_global
  01522	89 84 24 44 05
	00 00		 mov	 DWORD PTR tv455[rsp], eax
$LN106@stbi__pars:
  01529	83 bc 24 44 05
	00 00 00	 cmp	 DWORD PTR tv455[rsp], 0
  01531	74 1c		 je	 SHORT $LN87@stbi__pars
  01533	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0153b	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  0153f	7e 0e		 jle	 SHORT $LN87@stbi__pars

; 5222 :                stbi__de_iphone(z);

  01541	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01549	e8 00 00 00 00	 call	 stbi__de_iphone
  0154e	90		 npad	 1
$LN87@stbi__pars:

; 5223 :             if (pal_img_n) {

  0154f	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  01557	85 c0		 test	 eax, eax
  01559	74 75		 je	 SHORT $LN88@stbi__pars

; 5224 :                // pal_img_n == 3 or 4
; 5225 :                s->img_n = pal_img_n; // record the actual colors we had

  0155b	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  01563	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0156b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5226 :                s->img_out_n = pal_img_n;

  0156e	0f b6 84 24 54
	04 00 00	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  01576	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0157e	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5227 :                if (req_comp >= 3) s->img_out_n = req_comp;

  01581	83 bc 24 70 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  01589	7c 12		 jl	 SHORT $LN90@stbi__pars
  0158b	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01593	8b 8c 24 70 05
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  0159a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN90@stbi__pars:

; 5228 :                if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

  0159d	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  015a5	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  015a9	44 8b 84 24 a0
	04 00 00	 mov	 r8d, DWORD PTR pal_len$[rsp]
  015b1	48 8d 54 24 50	 lea	 rdx, QWORD PTR palette$[rsp]
  015b6	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  015be	e8 00 00 00 00	 call	 stbi__expand_png_palette
  015c3	85 c0		 test	 eax, eax
  015c5	75 07		 jne	 SHORT $LN91@stbi__pars

; 5229 :                   return 0;

  015c7	33 c0		 xor	 eax, eax
  015c9	e9 49 01 00 00	 jmp	 $LN1@stbi__pars
$LN91@stbi__pars:

; 5230 :             } else if (has_trans) {

  015ce	eb 24		 jmp	 SHORT $LN89@stbi__pars
$LN88@stbi__pars:
  015d0	0f b6 84 24 55
	04 00 00	 movzx	 eax, BYTE PTR has_trans$[rsp]
  015d8	85 c0		 test	 eax, eax
  015da	74 18		 je	 SHORT $LN92@stbi__pars

; 5231 :                // non-paletted image with tRNS -> source image has (constant) alpha
; 5232 :                ++s->img_n;

  015dc	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR s$[rsp]
  015e4	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  015e7	ff c0		 inc	 eax
  015e9	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  015f1	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN92@stbi__pars:
$LN89@stbi__pars:

; 5233 :             }
; 5234 :             STBI_FREE(z->expanded); z->expanded = NULL;

  015f4	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  015fc	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  01600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  01606	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0160e	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5235 :             // end of PNG chunk, read and skip CRC
; 5236 :             stbi__get32be(s);

  01616	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0161e	e8 00 00 00 00	 call	 stbi__get32be

; 5237 :             return 1;

  01623	b8 01 00 00 00	 mov	 eax, 1
  01628	e9 ea 00 00 00	 jmp	 $LN1@stbi__pars
$LN93@stbi__pars:

; 5238 :          }
; 5239 : 
; 5240 :          default:
; 5241 :             // if critical, fail
; 5242 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0162d	83 bc 24 a4 04
	00 00 00	 cmp	 DWORD PTR first$[rsp], 0
  01635	74 11		 je	 SHORT $LN94@stbi__pars
  01637	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JEAFOMAF@first?5not?5IHDR@
  0163e	e8 00 00 00 00	 call	 stbi__err
  01643	e9 cf 00 00 00	 jmp	 $LN1@stbi__pars
$LN94@stbi__pars:

; 5243 :             if ((c.type & (1 << 29)) == 0) {

  01648	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  0164f	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  01654	85 c0		 test	 eax, eax
  01656	0f 85 93 00 00
	00		 jne	 $LN95@stbi__pars

; 5244 :                #ifndef STBI_NO_FAILURE_STRINGS
; 5245 :                // not threadsafe
; 5246 :                static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5247 :                invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

  0165c	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  01663	c1 e8 18	 shr	 eax, 24
  01666	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0166b	b9 01 00 00 00	 mov	 ecx, 1
  01670	48 6b c9 00	 imul	 rcx, rcx, 0
  01674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  0167b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5248 :                invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

  0167e	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  01685	c1 e8 10	 shr	 eax, 16
  01688	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0168d	b9 01 00 00 00	 mov	 ecx, 1
  01692	48 6b c9 01	 imul	 rcx, rcx, 1
  01696	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  0169d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5249 :                invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);

  016a0	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  016a7	c1 e8 08	 shr	 eax, 8
  016aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  016af	b9 01 00 00 00	 mov	 ecx, 1
  016b4	48 6b c9 02	 imul	 rcx, rcx, 2
  016b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  016bf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5250 :                invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);

  016c2	8b 84 24 cc 04
	00 00		 mov	 eax, DWORD PTR c$8[rsp+4]
  016c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  016ce	b9 01 00 00 00	 mov	 ecx, 1
  016d3	48 6b c9 03	 imul	 rcx, rcx, 3
  016d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  016de	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5251 :                #endif
; 5252 :                return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

  016e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?invalid_chunk@?BP@??stbi__parse_png_file@@9@9
  016e8	e8 00 00 00 00	 call	 stbi__err
  016ed	eb 28		 jmp	 SHORT $LN1@stbi__pars
$LN95@stbi__pars:

; 5253 :             }
; 5254 :             stbi__skip(s, c.length);

  016ef	8b 94 24 c8 04
	00 00		 mov	 edx, DWORD PTR c$8[rsp]
  016f6	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  016fe	e8 00 00 00 00	 call	 stbi__skip
  01703	90		 npad	 1
$LN5@stbi__pars:

; 5255 :             break;
; 5256 :       }
; 5257 :       // end of PNG chunk, read and skip CRC
; 5258 :       stbi__get32be(s);

  01704	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0170c	e8 00 00 00 00	 call	 stbi__get32be
  01711	90		 npad	 1

; 5259 :    }

  01712	e9 16 ea ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 5260 : }

  01717	48 8b f8	 mov	 rdi, rax
  0171a	48 8b cc	 mov	 rcx, rsp
  0171d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__parse_png_file$rtcFrameData
  01724	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01729	48 8b c7	 mov	 rax, rdi
  0172c	48 8b 8c 24 48
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01734	48 33 cc	 xor	 rcx, rsp
  01737	e8 00 00 00 00	 call	 __security_check_cookie
  0173c	48 81 c4 50 05
	00 00		 add	 rsp, 1360		; 00000550H
  01743	5f		 pop	 rdi
  01744	c3		 ret	 0
stbi__parse_png_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
tv69 = 56
tv84 = 64
p$ = 96
x$ = 104
y$ = 112
n$ = 120
req_comp$ = 128
ri$ = 136
stbi__do_png PROC

; 5263 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5264 :    void *result=NULL;

  00025	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 5265 :    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  0002e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00036	7c 0a		 jl	 SHORT $LN3@stbi__do_p
  00038	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00040	7e 2e		 jle	 SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@KBPNPPBJ@bad?5req_comp@
  00049	e8 00 00 00 00	 call	 stbi__err
  0004e	85 c0		 test	 eax, eax
  00050	74 0b		 je	 SHORT $LN15@stbi__do_p
  00052	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv69[rsp], 0
  0005b	eb 09		 jmp	 SHORT $LN16@stbi__do_p
$LN15@stbi__do_p:
  0005d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv69[rsp], 0
$LN16@stbi__do_p:
  00066	48 8b 44 24 38	 mov	 rax, QWORD PTR tv69[rsp]
  0006b	e9 02 02 00 00	 jmp	 $LN1@stbi__do_p
$LN2@stbi__do_p:

; 5266 :    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

  00070	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00078	33 d2		 xor	 edx, edx
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0007f	e8 00 00 00 00	 call	 stbi__parse_png_file
  00084	85 c0		 test	 eax, eax
  00086	0f 84 8d 01 00
	00		 je	 $LN4@stbi__do_p

; 5267 :       if (p->depth <= 8)

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00091	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  00095	7f 10		 jg	 SHORT $LN5@stbi__do_p

; 5268 :          ri->bits_per_channel = 8;

  00097	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0009f	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
  000a5	eb 49		 jmp	 SHORT $LN6@stbi__do_p
$LN5@stbi__do_p:

; 5269 :       else if (p->depth == 16)

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000ac	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  000b0	75 10		 jne	 SHORT $LN7@stbi__do_p

; 5270 :          ri->bits_per_channel = 16;

  000b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000ba	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16
  000c0	eb 2e		 jmp	 SHORT $LN8@stbi__do_p
$LN7@stbi__do_p:

; 5271 :       else
; 5272 :          return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NOEEEFMF@bad?5bits_per_channel@
  000c9	e8 00 00 00 00	 call	 stbi__err
  000ce	85 c0		 test	 eax, eax
  000d0	74 0b		 je	 SHORT $LN17@stbi__do_p
  000d2	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
  000db	eb 09		 jmp	 SHORT $LN18@stbi__do_p
$LN17@stbi__do_p:
  000dd	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
$LN18@stbi__do_p:
  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv84[rsp]
  000eb	e9 82 01 00 00	 jmp	 $LN1@stbi__do_p
$LN8@stbi__do_p:
$LN6@stbi__do_p:

; 5273 :       result = p->out;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000f5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f9	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 5274 :       p->out = NULL;

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00103	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5275 :       if (req_comp && req_comp != p->s->img_out_n) {

  0010b	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00113	0f 84 c3 00 00
	00		 je	 $LN9@stbi__do_p
  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0011e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00121	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00124	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  0012b	0f 84 ab 00 00
	00		 je	 $LN9@stbi__do_p

; 5276 :          if (ri->bits_per_channel == 8)

  00131	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00139	83 38 08	 cmp	 DWORD PTR [rax], 8
  0013c	75 3e		 jne	 SHORT $LN10@stbi__do_p

; 5277 :             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  0013e	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00143	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00146	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0014b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014e	48 8b 54 24 60	 mov	 rdx, QWORD PTR p$[rsp]
  00153	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00156	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00159	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0015d	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00160	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00168	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0016b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00170	e8 00 00 00 00	 call	 stbi__convert_format
  00175	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
  0017a	eb 3c		 jmp	 SHORT $LN11@stbi__do_p
$LN10@stbi__do_p:

; 5278 :          else
; 5279 :             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00181	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00184	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00189	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0018c	48 8b 54 24 60	 mov	 rdx, QWORD PTR p$[rsp]
  00191	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00194	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00197	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0019b	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  0019e	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  001a6	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  001a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  001ae	e8 00 00 00 00	 call	 stbi__convert_format16
  001b3	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN11@stbi__do_p:

; 5280 :          p->s->img_out_n = req_comp;

  001b8	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  001c7	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5281 :          if (result == NULL) return result;

  001ca	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  001d0	75 0a		 jne	 SHORT $LN12@stbi__do_p
  001d2	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  001d7	e9 96 00 00 00	 jmp	 $LN1@stbi__do_p
$LN12@stbi__do_p:
$LN9@stbi__do_p:

; 5282 :       }
; 5283 :       *x = p->s->img_x;

  001dc	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  001e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  001e9	8b 00		 mov	 eax, DWORD PTR [rax]
  001eb	89 01		 mov	 DWORD PTR [rcx], eax

; 5284 :       *y = p->s->img_y;

  001ed	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  001f2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR y$[rsp]
  001fa	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001fd	89 01		 mov	 DWORD PTR [rcx], eax

; 5285 :       if (n) *n = p->s->img_n;

  001ff	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  00205	74 12		 je	 SHORT $LN13@stbi__do_p
  00207	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0020c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  00214	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00217	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@stbi__do_p:
$LN4@stbi__do_p:

; 5286 :    }
; 5287 :    STBI_FREE(p->out);      p->out      = NULL;

  00219	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0021e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00228	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0022d	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5288 :    STBI_FREE(p->expanded); p->expanded = NULL;

  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0023a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00244	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00249	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5289 :    STBI_FREE(p->idata);    p->idata    = NULL;

  00251	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00256	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00260	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00265	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5290 : 
; 5291 :    return result;

  0026d	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__do_p:

; 5292 : }

  00272	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00276	5f		 pop	 rdi
  00277	c3		 ret	 0
stbi__do_png ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 56
__$ArrayPad$ = 112
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
ri$ = 184
stbi__png_load PROC

; 5295 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 14 00 00 00	 mov	 ecx, 20
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5296 :    stbi__png p;
; 5297 :    p.s = s;

  00050	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00058	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax

; 5298 :    return stbi__do_png(&p, x,y,comp,req_comp, ri);

  0005d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00065	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006a	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00071	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00075	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0007d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00085	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0008d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR p$[rsp]
  00092	e8 00 00 00 00	 call	 stbi__do_png

; 5299 : }

  00097	48 8b f8	 mov	 rdi, rax
  0009a	48 8b cc	 mov	 rcx, rsp
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_load$rtcFrameData
  000a4	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a9	48 8b c7	 mov	 rax, rdi
  000ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b1	48 33 cc	 xor	 rcx, rsp
  000b4	e8 00 00 00 00	 call	 __security_check_cookie
  000b9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
stbi__png_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
stbi__png_test PROC

; 5302 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5303 :    int r;
; 5304 :    r = stbi__check_png_header(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__check_png_header
  00020	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5305 :    stbi__rewind(s);

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__rewind

; 5306 :    return r;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5307 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
stbi__png_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 48
x$ = 56
y$ = 64
comp$ = 72
stbi__png_info_raw PROC

; 5310 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5311 :    if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

  00025	45 33 c0	 xor	 r8d, r8d
  00028	ba 02 00 00 00	 mov	 edx, 2
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00032	e8 00 00 00 00	 call	 stbi__parse_png_file
  00037	85 c0		 test	 eax, eax
  00039	75 11		 jne	 SHORT $LN2@stbi__png_

; 5312 :       stbi__rewind( p->s );

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00040	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00043	e8 00 00 00 00	 call	 stbi__rewind

; 5313 :       return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 52		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5314 :    }
; 5315 :    if (x) *x = p->s->img_x;

  0004c	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$[rsp], 0
  00052	74 11		 je	 SHORT $LN3@stbi__png_
  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$[rsp]
  00061	8b 00		 mov	 eax, DWORD PTR [rax]
  00063	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__png_:

; 5316 :    if (y) *y = p->s->img_y;

  00065	48 83 7c 24 40
	00		 cmp	 QWORD PTR y$[rsp], 0
  0006b	74 12		 je	 SHORT $LN4@stbi__png_
  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y$[rsp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007d	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__png_:

; 5317 :    if (comp) *comp = p->s->img_n;

  0007f	48 83 7c 24 48
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00085	74 12		 je	 SHORT $LN5@stbi__png_
  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0008c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR comp$[rsp]
  00094	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00097	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__png_:

; 5318 :    return 1;

  00099	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5319 : }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
stbi__png_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 40
__$ArrayPad$ = 96
s$ = 128
x$ = 136
y$ = 144
comp$ = 152
stbi__png_info PROC

; 5322 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 14 00 00 00	 mov	 ecx, 20
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00039	48 33 c4	 xor	 rax, rsp
  0003c	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5323 :    stbi__png p;
; 5324 :    p.s = s;

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00055	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5325 :    return stbi__png_info_raw(&p, x, y, comp);

  0005a	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00062	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0006a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00072	48 8d 4c 24 28	 lea	 rcx, QWORD PTR p$[rsp]
  00077	e8 00 00 00 00	 call	 stbi__png_info_raw

; 5326 : }

  0007c	48 8b f8	 mov	 rdi, rax
  0007f	48 8b cc	 mov	 rcx, rsp
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_info$rtcFrameData
  00089	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0008e	48 8b c7	 mov	 rax, rdi
  00091	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
stbi__png_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 40
__$ArrayPad$ = 96
s$ = 128
stbi__png_is16 PROC

; 5329 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000f	b9 14 00 00 00	 mov	 ecx, 20
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00039	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5330 :    stbi__png p;
; 5331 :    p.s = s;

  0003e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00046	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5332 :    if (!stbi__png_info_raw(&p, NULL, NULL, NULL))

  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	45 33 c0	 xor	 r8d, r8d
  00051	33 d2		 xor	 edx, edx
  00053	48 8d 4c 24 28	 lea	 rcx, QWORD PTR p$[rsp]
  00058	e8 00 00 00 00	 call	 stbi__png_info_raw
  0005d	85 c0		 test	 eax, eax
  0005f	75 04		 jne	 SHORT $LN2@stbi__png_

; 5333 : 	   return 0;

  00061	33 c0		 xor	 eax, eax
  00063	eb 1a		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5334 :    if (p.depth != 16) {

  00065	83 7c 24 48 10	 cmp	 DWORD PTR p$[rsp+32], 16
  0006a	74 0e		 je	 SHORT $LN3@stbi__png_

; 5335 :       stbi__rewind(p.s);

  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00071	e8 00 00 00 00	 call	 stbi__rewind

; 5336 :       return 0;

  00076	33 c0		 xor	 eax, eax
  00078	eb 05		 jmp	 SHORT $LN1@stbi__png_
$LN3@stbi__png_:

; 5337 :    }
; 5338 :    return 1;

  0007a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5339 : }

  0007f	48 8b f8	 mov	 rdi, rax
  00082	48 8b cc	 mov	 rcx, rsp
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__png_is16$rtcFrameData
  0008c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00091	48 8b c7	 mov	 rax, rdi
  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00099	48 33 cc	 xor	 rcx, rsp
  0009c	e8 00 00 00 00	 call	 __security_check_cookie
  000a1	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
stbi__png_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
sz$ = 36
$T1 = 40
$T2 = 41
tv93 = 42
tv134 = 43
tv142 = 44
tv151 = 45
tv83 = 48
s$ = 80
stbi__bmp_test_raw PROC

; 5346 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 39		 jae	 SHORT $LN8@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 2a	 mov	 BYTE PTR tv93[rsp], al
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 2a	 movzx	 eax, BYTE PTR tv93[rsp]
  00063	88 44 24 28	 mov	 BYTE PTR $T1[rsp], al
  00067	eb 53		 jmp	 SHORT $LN7@stbi__bmp_
$LN8@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00072	74 43		 je	 SHORT $LN9@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	88 44 24 2b	 mov	 BYTE PTR tv134[rsp], al
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00096	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009d	48 ff c0	 inc	 rax
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ac	0f b6 44 24 2b	 movzx	 eax, BYTE PTR tv134[rsp]
  000b1	88 44 24 28	 mov	 BYTE PTR $T1[rsp], al
  000b5	eb 05		 jmp	 SHORT $LN7@stbi__bmp_
$LN9@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  000b7	c6 44 24 28 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__bmp_:

; 5347 :    int r;
; 5348 :    int sz;
; 5349 :    if (stbi__get8(s) != 'B') return 0;

  000bc	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T1[rsp]
  000c1	0f b6 c0	 movzx	 eax, al
  000c4	83 f8 42	 cmp	 eax, 66			; 00000042H
  000c7	74 07		 je	 SHORT $LN2@stbi__bmp_
  000c9	33 c0		 xor	 eax, eax
  000cb	e9 2e 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000da	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000e1	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000e8	73 39		 jae	 SHORT $LN12@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ef	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f9	88 44 24 2c	 mov	 BYTE PTR tv142[rsp], al
  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00102	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00109	48 ff c0	 inc	 rax
  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00111	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00118	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv142[rsp]
  0011d	88 44 24 29	 mov	 BYTE PTR $T2[rsp], al
  00121	eb 53		 jmp	 SHORT $LN11@stbi__bmp_
$LN12@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00123	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00128	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0012c	74 43		 je	 SHORT $LN13@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  0012e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00133	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0013d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00144	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00147	88 44 24 2d	 mov	 BYTE PTR tv151[rsp], al
  0014b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00150	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00157	48 ff c0	 inc	 rax
  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0015f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00166	0f b6 44 24 2d	 movzx	 eax, BYTE PTR tv151[rsp]
  0016b	88 44 24 29	 mov	 BYTE PTR $T2[rsp], al
  0016f	eb 05		 jmp	 SHORT $LN11@stbi__bmp_
$LN13@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00171	c6 44 24 29 00	 mov	 BYTE PTR $T2[rsp], 0
$LN11@stbi__bmp_:

; 5350 :    if (stbi__get8(s) != 'M') return 0;

  00176	0f b6 44 24 29	 movzx	 eax, BYTE PTR $T2[rsp]
  0017b	0f b6 c0	 movzx	 eax, al
  0017e	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00181	74 04		 je	 SHORT $LN3@stbi__bmp_
  00183	33 c0		 xor	 eax, eax
  00185	eb 77		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5351 :    stbi__get32le(s); // discard filesize

  00187	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0018c	e8 00 00 00 00	 call	 stbi__get32le

; 5352 :    stbi__get16le(s); // discard reserved

  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00196	e8 00 00 00 00	 call	 stbi__get16le

; 5353 :    stbi__get16le(s); // discard reserved

  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001a0	e8 00 00 00 00	 call	 stbi__get16le

; 5354 :    stbi__get32le(s); // discard data offset

  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	e8 00 00 00 00	 call	 stbi__get32le

; 5355 :    sz = stbi__get32le(s);

  001af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001b4	e8 00 00 00 00	 call	 stbi__get32le
  001b9	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5356 :    r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

  001bd	83 7c 24 24 0c	 cmp	 DWORD PTR sz$[rsp], 12
  001c2	74 26		 je	 SHORT $LN5@stbi__bmp_
  001c4	83 7c 24 24 28	 cmp	 DWORD PTR sz$[rsp], 40	; 00000028H
  001c9	74 1f		 je	 SHORT $LN5@stbi__bmp_
  001cb	83 7c 24 24 38	 cmp	 DWORD PTR sz$[rsp], 56	; 00000038H
  001d0	74 18		 je	 SHORT $LN5@stbi__bmp_
  001d2	83 7c 24 24 6c	 cmp	 DWORD PTR sz$[rsp], 108	; 0000006cH
  001d7	74 11		 je	 SHORT $LN5@stbi__bmp_
  001d9	83 7c 24 24 7c	 cmp	 DWORD PTR sz$[rsp], 124	; 0000007cH
  001de	74 0a		 je	 SHORT $LN5@stbi__bmp_
  001e0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  001e8	eb 08		 jmp	 SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
  001ea	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
$LN6@stbi__bmp_:
  001f2	8b 44 24 30	 mov	 eax, DWORD PTR tv83[rsp]
  001f6	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5357 :    return r;

  001fa	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__bmp_:

; 5358 : }

  001fe	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00202	5f		 pop	 rdi
  00203	c3		 ret	 0
stbi__bmp_test_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
stbi__bmp_test PROC

; 5361 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5362 :    int r = stbi__bmp_test_raw(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__bmp_test_raw
  00020	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5363 :    stbi__rewind(s);

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__rewind

; 5364 :    return r;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5365 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
stbi__bmp_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
n$ = 32
z$ = 64
stbi__high_bit PROC

; 5370 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5371 :    int n=0;

  00015	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 5372 :    if (z == 0) return -1;

  0001d	83 7c 24 40 00	 cmp	 DWORD PTR z$[rsp], 0
  00022	75 0a		 jne	 SHORT $LN2@stbi__high
  00024	b8 ff ff ff ff	 mov	 eax, -1
  00029	e9 8f 00 00 00	 jmp	 $LN1@stbi__high
$LN2@stbi__high:

; 5373 :    if (z >= 0x10000) { n += 16; z >>= 16; }

  0002e	81 7c 24 40 00
	00 01 00	 cmp	 DWORD PTR z$[rsp], 65536 ; 00010000H
  00036	72 16		 jb	 SHORT $LN3@stbi__high
  00038	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0003c	83 c0 10	 add	 eax, 16
  0003f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  00043	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  00047	c1 e8 10	 shr	 eax, 16
  0004a	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
$LN3@stbi__high:

; 5374 :    if (z >= 0x00100) { n +=  8; z >>=  8; }

  0004e	81 7c 24 40 00
	01 00 00	 cmp	 DWORD PTR z$[rsp], 256	; 00000100H
  00056	72 16		 jb	 SHORT $LN4@stbi__high
  00058	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0005c	83 c0 08	 add	 eax, 8
  0005f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  00063	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  00067	c1 e8 08	 shr	 eax, 8
  0006a	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
$LN4@stbi__high:

; 5375 :    if (z >= 0x00010) { n +=  4; z >>=  4; }

  0006e	83 7c 24 40 10	 cmp	 DWORD PTR z$[rsp], 16
  00073	72 16		 jb	 SHORT $LN5@stbi__high
  00075	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00079	83 c0 04	 add	 eax, 4
  0007c	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  00080	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  00084	c1 e8 04	 shr	 eax, 4
  00087	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
$LN5@stbi__high:

; 5376 :    if (z >= 0x00004) { n +=  2; z >>=  2; }

  0008b	83 7c 24 40 04	 cmp	 DWORD PTR z$[rsp], 4
  00090	72 16		 jb	 SHORT $LN6@stbi__high
  00092	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00096	83 c0 02	 add	 eax, 2
  00099	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  0009d	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  000a1	c1 e8 02	 shr	 eax, 2
  000a4	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
$LN6@stbi__high:

; 5377 :    if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }

  000a8	83 7c 24 40 02	 cmp	 DWORD PTR z$[rsp], 2
  000ad	72 0a		 jb	 SHORT $LN7@stbi__high
  000af	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000b3	ff c0		 inc	 eax
  000b5	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN7@stbi__high:

; 5378 :    return n;

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
$LN1@stbi__high:

; 5379 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
stbi__high_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
a$ = 48
stbi__bitcount PROC

; 5382 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5383 :    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

  00015	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00019	25 55 55 55 55	 and	 eax, 1431655765		; 55555555H
  0001e	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00022	d1 e9		 shr	 ecx, 1
  00024	81 e1 55 55 55
	55		 and	 ecx, 1431655765		; 55555555H
  0002a	03 c1		 add	 eax, ecx
  0002c	89 44 24 30	 mov	 DWORD PTR a$[rsp], eax

; 5384 :    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

  00030	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00034	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  00039	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  0003d	c1 e9 02	 shr	 ecx, 2
  00040	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H
  00046	03 c1		 add	 eax, ecx
  00048	89 44 24 30	 mov	 DWORD PTR a$[rsp], eax

; 5385 :    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

  0004c	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00050	c1 e8 04	 shr	 eax, 4
  00053	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00057	03 c8		 add	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	25 0f 0f 0f 0f	 and	 eax, 252645135		; 0f0f0f0fH
  00060	89 44 24 30	 mov	 DWORD PTR a$[rsp], eax

; 5386 :    a = (a + (a >> 8)); // max 16 per 8 bits

  00064	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00068	c1 e8 08	 shr	 eax, 8
  0006b	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  0006f	03 c8		 add	 ecx, eax
  00071	8b c1		 mov	 eax, ecx
  00073	89 44 24 30	 mov	 DWORD PTR a$[rsp], eax

; 5387 :    a = (a + (a >> 16)); // max 32 per 8 bits

  00077	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  0007b	c1 e8 10	 shr	 eax, 16
  0007e	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00082	03 c8		 add	 ecx, eax
  00084	8b c1		 mov	 eax, ecx
  00086	89 44 24 30	 mov	 DWORD PTR a$[rsp], eax

; 5388 :    return a & 0xff;

  0008a	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 5389 : }

  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
stbi__bitcount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
v$ = 48
shift$ = 56
bits$ = 64
stbi__shiftsigned PROC

; 5395 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5396 :    static unsigned int mul_table[9] = {
; 5397 :       0,
; 5398 :       0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5399 :       0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5400 :    };
; 5401 :    static unsigned int shift_table[9] = {
; 5402 :       0, 0,0,1,0,2,4,6,0,
; 5403 :    };
; 5404 :    if (shift < 0)

  0001e	83 7c 24 38 00	 cmp	 DWORD PTR shift$[rsp], 0
  00023	7d 15		 jge	 SHORT $LN2@stbi__shif

; 5405 :       v <<= -shift;

  00025	8b 44 24 38	 mov	 eax, DWORD PTR shift$[rsp]
  00029	f7 d8		 neg	 eax
  0002b	0f b6 c8	 movzx	 ecx, al
  0002e	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00032	d3 e0		 shl	 eax, cl
  00034	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax
  00038	eb 11		 jmp	 SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 5406 :    else
; 5407 :       v >>= shift;

  0003a	8b 44 24 38	 mov	 eax, DWORD PTR shift$[rsp]
  0003e	0f b6 c8	 movzx	 ecx, al
  00041	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00045	d3 e8		 shr	 eax, cl
  00047	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax
$LN3@stbi__shif:

; 5408 :    STBI_ASSERT(v < 256);

  0004b	81 7c 24 30 00
	01 00 00	 cmp	 DWORD PTR v$[rsp], 256	; 00000100H
  00053	72 1c		 jb	 SHORT $LN5@stbi__shif
  00055	41 b8 20 15 00
	00		 mov	 r8d, 5408		; 00001520H
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@EKLGALLJ@?$AAv?$AA?5?$AA?$DM?$AA?5?$AA2?$AA5?$AA6@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006f	33 c0		 xor	 eax, eax
$LN5@stbi__shif:

; 5409 :    v >>= (8-bits);

  00071	b8 08 00 00 00	 mov	 eax, 8
  00076	2b 44 24 40	 sub	 eax, DWORD PTR bits$[rsp]
  0007a	0f b6 c8	 movzx	 ecx, al
  0007d	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00081	d3 e8		 shr	 eax, cl
  00083	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax

; 5410 :    STBI_ASSERT(bits >= 0 && bits <= 8);

  00087	83 7c 24 40 00	 cmp	 DWORD PTR bits$[rsp], 0
  0008c	7c 07		 jl	 SHORT $LN6@stbi__shif
  0008e	83 7c 24 40 08	 cmp	 DWORD PTR bits$[rsp], 8
  00093	7e 1c		 jle	 SHORT $LN7@stbi__shif
$LN6@stbi__shif:
  00095	41 b8 22 15 00
	00		 mov	 r8d, 5410		; 00001522H
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@LIFEKNEP@?$AAb?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAi@
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000af	33 c0		 xor	 eax, eax
$LN7@stbi__shif:

; 5411 :    return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

  000b1	48 63 44 24 40	 movsxd	 rax, DWORD PTR bits$[rsp]
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mul_table@?1??stbi__shiftsigned@@9@9
  000bd	8b 54 24 30	 mov	 edx, DWORD PTR v$[rsp]
  000c1	0f af 14 81	 imul	 edx, DWORD PTR [rcx+rax*4]
  000c5	8b c2		 mov	 eax, edx
  000c7	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR bits$[rsp]
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?shift_table@?1??stbi__shiftsigned@@9@9
  000d3	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  000d6	d3 f8		 sar	 eax, cl

; 5412 : }

  000d8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
stbi__shiftsigned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
info$ = 48
compress$ = 56
stbi__bmp_set_mask_defaults PROC

; 5422 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5423 :    // BI_BITFIELDS specifies masks explicitly, don't override
; 5424 :    if (compress == 3)

  0001a	83 7c 24 38 03	 cmp	 DWORD PTR compress$[rsp], 3
  0001f	75 0a		 jne	 SHORT $LN2@stbi__bmp_

; 5425 :       return 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	e9 bc 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5426 : 
; 5427 :    if (compress == 0) {

  0002b	83 7c 24 38 00	 cmp	 DWORD PTR compress$[rsp], 0
  00030	0f 85 af 00 00
	00		 jne	 $LN3@stbi__bmp_

; 5428 :       if (info->bpp == 16) {

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0003b	83 38 10	 cmp	 DWORD PTR [rax], 16
  0003e	75 26		 jne	 SHORT $LN4@stbi__bmp_

; 5429 :          info->mr = 31u << 10;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00045	c7 40 0c 00 7c
	00 00		 mov	 DWORD PTR [rax+12], 31744 ; 00007c00H

; 5430 :          info->mg = 31u <<  5;

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00051	c7 40 10 e0 03
	00 00		 mov	 DWORD PTR [rax+16], 992	; 000003e0H

; 5431 :          info->mb = 31u <<  0;

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0005d	c7 40 14 1f 00
	00 00		 mov	 DWORD PTR [rax+20], 31
  00064	eb 78		 jmp	 SHORT $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 5432 :       } else if (info->bpp == 32) {

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0006b	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  0006e	75 3e		 jne	 SHORT $LN6@stbi__bmp_

; 5433 :          info->mr = 0xffu << 16;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00075	c7 40 0c 00 00
	ff 00		 mov	 DWORD PTR [rax+12], 16711680 ; 00ff0000H

; 5434 :          info->mg = 0xffu <<  8;

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00081	c7 40 10 00 ff
	00 00		 mov	 DWORD PTR [rax+16], 65280 ; 0000ff00H

; 5435 :          info->mb = 0xffu <<  0;

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0008d	c7 40 14 ff 00
	00 00		 mov	 DWORD PTR [rax+20], 255	; 000000ffH

; 5436 :          info->ma = 0xffu << 24;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00099	c7 40 18 00 00
	00 ff		 mov	 DWORD PTR [rax+24], -16777216 ; ff000000H

; 5437 :          info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

  000a0	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  000a5	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 5438 :       } else {

  000ac	eb 30		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 5439 :          // otherwise, use defaults, which is all-0
; 5440 :          info->mr = info->mg = info->mb = info->ma = 0;

  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  000b3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  000bf	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  000cb	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  000d7	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 5441 :       }
; 5442 :       return 1;

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	eb 02		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5443 :    }
; 5444 :    return 0; // error

  000e5	33 c0		 xor	 eax, eax
$LN1@stbi__bmp_:

; 5445 : }

  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5f		 pop	 rdi
  000ec	c3		 ret	 0
stbi__bmp_set_mask_defaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
hsz$ = 32
compress$1 = 36
i$2 = 40
$T3 = 44
$T4 = 45
tv268 = 46
tv277 = 47
tv285 = 48
tv294 = 49
tv75 = 56
tv95 = 64
tv136 = 72
tv156 = 80
tv168 = 88
tv173 = 96
tv182 = 104
tv224 = 112
tv228 = 120
tv234 = 128
s$ = 160
info$ = 168
stbi__bmp_parse_header PROC

; 5448 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0001e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00026	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00035	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0003c	73 42		 jae	 SHORT $LN53@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  0003e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00046	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00050	88 44 24 2e	 mov	 BYTE PTR tv268[rsp], al
  00054	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00063	48 ff c0	 inc	 rax
  00066	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00075	0f b6 44 24 2e	 movzx	 eax, BYTE PTR tv268[rsp]
  0007a	88 44 24 2c	 mov	 BYTE PTR $T3[rsp], al
  0007e	eb 62		 jmp	 SHORT $LN52@stbi__bmp_
$LN53@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00080	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00088	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0008c	74 4f		 je	 SHORT $LN54@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  0008e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00096	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0009b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ad	88 44 24 2f	 mov	 BYTE PTR tv277[rsp], al
  000b1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000c0	48 ff c0	 inc	 rax
  000c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cb	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d2	0f b6 44 24 2f	 movzx	 eax, BYTE PTR tv277[rsp]
  000d7	88 44 24 2c	 mov	 BYTE PTR $T3[rsp], al
  000db	eb 05		 jmp	 SHORT $LN52@stbi__bmp_
$LN54@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  000dd	c6 44 24 2c 00	 mov	 BYTE PTR $T3[rsp], 0
$LN52@stbi__bmp_:

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

  000e2	0f b6 44 24 2c	 movzx	 eax, BYTE PTR $T3[rsp]
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	83 f8 42	 cmp	 eax, 66			; 00000042H
  000ed	0f 85 d1 00 00
	00		 jne	 $LN6@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00103	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0010a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00111	73 42		 jae	 SHORT $LN57@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00113	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0011b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00122	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00125	88 44 24 30	 mov	 BYTE PTR tv285[rsp], al
  00129	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00131	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00138	48 ff c0	 inc	 rax
  0013b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00143	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0014a	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv285[rsp]
  0014f	88 44 24 2d	 mov	 BYTE PTR $T4[rsp], al
  00153	eb 62		 jmp	 SHORT $LN56@stbi__bmp_
$LN57@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00155	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0015d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00161	74 4f		 je	 SHORT $LN58@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  00163	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00170	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00178	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0017f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00182	88 44 24 31	 mov	 BYTE PTR tv294[rsp], al
  00186	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0018e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00195	48 ff c0	 inc	 rax
  00198	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001a7	0f b6 44 24 31	 movzx	 eax, BYTE PTR tv294[rsp]
  001ac	88 44 24 2d	 mov	 BYTE PTR $T4[rsp], al
  001b0	eb 05		 jmp	 SHORT $LN56@stbi__bmp_
$LN58@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  001b2	c6 44 24 2d 00	 mov	 BYTE PTR $T4[rsp], 0
$LN56@stbi__bmp_:

; 5449 :    int hsz;
; 5450 :    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

  001b7	0f b6 44 24 2d	 movzx	 eax, BYTE PTR $T4[rsp]
  001bc	0f b6 c0	 movzx	 eax, al
  001bf	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  001c2	74 2e		 je	 SHORT $LN5@stbi__bmp_
$LN6@stbi__bmp_:
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IANEBNLB@not?5BMP@
  001cb	e8 00 00 00 00	 call	 stbi__err
  001d0	85 c0		 test	 eax, eax
  001d2	74 0b		 je	 SHORT $LN32@stbi__bmp_
  001d4	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
  001dd	eb 09		 jmp	 SHORT $LN33@stbi__bmp_
$LN32@stbi__bmp_:
  001df	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
$LN33@stbi__bmp_:
  001e8	48 8b 44 24 38	 mov	 rax, QWORD PTR tv75[rsp]
  001ed	e9 d3 05 00 00	 jmp	 $LN1@stbi__bmp_
$LN5@stbi__bmp_:

; 5451 :    stbi__get32le(s); // discard filesize

  001f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001fa	e8 00 00 00 00	 call	 stbi__get32le

; 5452 :    stbi__get16le(s); // discard reserved

  001ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00207	e8 00 00 00 00	 call	 stbi__get16le

; 5453 :    stbi__get16le(s); // discard reserved

  0020c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00214	e8 00 00 00 00	 call	 stbi__get16le

; 5454 :    info->offset = stbi__get32le(s);

  00219	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00221	e8 00 00 00 00	 call	 stbi__get32le
  00226	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0022e	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5455 :    info->hsz = hsz = stbi__get32le(s);

  00231	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00239	e8 00 00 00 00	 call	 stbi__get32le
  0023e	89 44 24 20	 mov	 DWORD PTR hsz$[rsp], eax
  00242	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0024a	8b 4c 24 20	 mov	 ecx, DWORD PTR hsz$[rsp]
  0024e	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5456 :    info->mr = info->mg = info->mb = info->ma = 0;

  00251	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00259	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  00260	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00268	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  0026f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00277	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  0027e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00286	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 5457 :    info->extra_read = 14;

  0028d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00295	c7 40 20 0e 00
	00 00		 mov	 DWORD PTR [rax+32], 14

; 5458 : 
; 5459 :    if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

  0029c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  002a4	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  002a8	7d 2e		 jge	 SHORT $LN7@stbi__bmp_
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  002b1	e8 00 00 00 00	 call	 stbi__err
  002b6	85 c0		 test	 eax, eax
  002b8	74 0b		 je	 SHORT $LN34@stbi__bmp_
  002ba	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
  002c3	eb 09		 jmp	 SHORT $LN35@stbi__bmp_
$LN34@stbi__bmp_:
  002c5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
$LN35@stbi__bmp_:
  002ce	48 8b 44 24 40	 mov	 rax, QWORD PTR tv95[rsp]
  002d3	e9 ed 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 5460 : 
; 5461 :    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

  002d8	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  002dd	74 4a		 je	 SHORT $LN8@stbi__bmp_
  002df	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  002e4	74 43		 je	 SHORT $LN8@stbi__bmp_
  002e6	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  002eb	74 3c		 je	 SHORT $LN8@stbi__bmp_
  002ed	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  002f2	74 35		 je	 SHORT $LN8@stbi__bmp_
  002f4	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  002f9	74 2e		 je	 SHORT $LN8@stbi__bmp_
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KHBIBJBG@unknown?5BMP@
  00302	e8 00 00 00 00	 call	 stbi__err
  00307	85 c0		 test	 eax, eax
  00309	74 0b		 je	 SHORT $LN36@stbi__bmp_
  0030b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv136[rsp], 0
  00314	eb 09		 jmp	 SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:
  00316	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv136[rsp], 0
$LN37@stbi__bmp_:
  0031f	48 8b 44 24 48	 mov	 rax, QWORD PTR tv136[rsp]
  00324	e9 9c 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN8@stbi__bmp_:

; 5462 :    if (hsz == 12) {

  00329	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  0032e	75 31		 jne	 SHORT $LN9@stbi__bmp_

; 5463 :       s->img_x = stbi__get16le(s);

  00330	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00338	e8 00 00 00 00	 call	 stbi__get16le
  0033d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00345	89 01		 mov	 DWORD PTR [rcx], eax

; 5464 :       s->img_y = stbi__get16le(s);

  00347	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0034f	e8 00 00 00 00	 call	 stbi__get16le
  00354	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035c	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5465 :    } else {

  0035f	eb 2f		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:

; 5466 :       s->img_x = stbi__get32le(s);

  00361	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00369	e8 00 00 00 00	 call	 stbi__get32le
  0036e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00376	89 01		 mov	 DWORD PTR [rcx], eax

; 5467 :       s->img_y = stbi__get32le(s);

  00378	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00380	e8 00 00 00 00	 call	 stbi__get32le
  00385	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038d	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@stbi__bmp_:

; 5468 :    }
; 5469 :    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

  00390	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00398	e8 00 00 00 00	 call	 stbi__get16le
  0039d	83 f8 01	 cmp	 eax, 1
  003a0	74 2e		 je	 SHORT $LN11@stbi__bmp_
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  003a9	e8 00 00 00 00	 call	 stbi__err
  003ae	85 c0		 test	 eax, eax
  003b0	74 0b		 je	 SHORT $LN38@stbi__bmp_
  003b2	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv156[rsp], 0
  003bb	eb 09		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:
  003bd	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv156[rsp], 0
$LN39@stbi__bmp_:
  003c6	48 8b 44 24 50	 mov	 rax, QWORD PTR tv156[rsp]
  003cb	e9 f5 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN11@stbi__bmp_:

; 5470 :    info->bpp = stbi__get16le(s);

  003d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d8	e8 00 00 00 00	 call	 stbi__get16le
  003dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  003e5	89 01		 mov	 DWORD PTR [rcx], eax

; 5471 :    if (hsz != 12) {

  003e7	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  003ec	0f 84 ce 03 00
	00		 je	 $LN12@stbi__bmp_

; 5472 :       int compress = stbi__get32le(s);

  003f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003fa	e8 00 00 00 00	 call	 stbi__get32le
  003ff	89 44 24 24	 mov	 DWORD PTR compress$1[rsp], eax

; 5473 :       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

  00403	83 7c 24 24 01	 cmp	 DWORD PTR compress$1[rsp], 1
  00408	74 07		 je	 SHORT $LN14@stbi__bmp_
  0040a	83 7c 24 24 02	 cmp	 DWORD PTR compress$1[rsp], 2
  0040f	75 2e		 jne	 SHORT $LN13@stbi__bmp_
$LN14@stbi__bmp_:
  00411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IMHMNOIB@BMP?5RLE@
  00418	e8 00 00 00 00	 call	 stbi__err
  0041d	85 c0		 test	 eax, eax
  0041f	74 0b		 je	 SHORT $LN40@stbi__bmp_
  00421	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv168[rsp], 0
  0042a	eb 09		 jmp	 SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:
  0042c	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv168[rsp], 0
$LN41@stbi__bmp_:
  00435	48 8b 44 24 58	 mov	 rax, QWORD PTR tv168[rsp]
  0043a	e9 86 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN13@stbi__bmp_:

; 5474 :       if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

  0043f	83 7c 24 24 04	 cmp	 DWORD PTR compress$1[rsp], 4
  00444	7c 2e		 jl	 SHORT $LN15@stbi__bmp_
  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@ODCBCBFN@BMP?5JPEG?1PNG@
  0044d	e8 00 00 00 00	 call	 stbi__err
  00452	85 c0		 test	 eax, eax
  00454	74 0b		 je	 SHORT $LN42@stbi__bmp_
  00456	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv173[rsp], 0
  0045f	eb 09		 jmp	 SHORT $LN43@stbi__bmp_
$LN42@stbi__bmp_:
  00461	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv173[rsp], 0
$LN43@stbi__bmp_:
  0046a	48 8b 44 24 60	 mov	 rax, QWORD PTR tv173[rsp]
  0046f	e9 51 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN15@stbi__bmp_:

; 5475 :       if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel

  00474	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  00479	75 48		 jne	 SHORT $LN16@stbi__bmp_
  0047b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00483	83 38 10	 cmp	 DWORD PTR [rax], 16
  00486	74 3b		 je	 SHORT $LN16@stbi__bmp_
  00488	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00490	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  00493	74 2e		 je	 SHORT $LN16@stbi__bmp_
  00495	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  0049c	e8 00 00 00 00	 call	 stbi__err
  004a1	85 c0		 test	 eax, eax
  004a3	74 0b		 je	 SHORT $LN44@stbi__bmp_
  004a5	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv182[rsp], 0
  004ae	eb 09		 jmp	 SHORT $LN45@stbi__bmp_
$LN44@stbi__bmp_:
  004b0	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv182[rsp], 0
$LN45@stbi__bmp_:
  004b9	48 8b 44 24 68	 mov	 rax, QWORD PTR tv182[rsp]
  004be	e9 02 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN16@stbi__bmp_:

; 5476 :       stbi__get32le(s); // discard sizeof

  004c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004cb	e8 00 00 00 00	 call	 stbi__get32le

; 5477 :       stbi__get32le(s); // discard hres

  004d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d8	e8 00 00 00 00	 call	 stbi__get32le

; 5478 :       stbi__get32le(s); // discard vres

  004dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e5	e8 00 00 00 00	 call	 stbi__get32le

; 5479 :       stbi__get32le(s); // discard colorsused

  004ea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004f2	e8 00 00 00 00	 call	 stbi__get32le

; 5480 :       stbi__get32le(s); // discard max important

  004f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ff	e8 00 00 00 00	 call	 stbi__get32le

; 5481 :       if (hsz == 40 || hsz == 56) {

  00504	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  00509	74 0b		 je	 SHORT $LN19@stbi__bmp_
  0050b	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  00510	0f 85 77 01 00
	00		 jne	 $LN17@stbi__bmp_
$LN19@stbi__bmp_:

; 5482 :          if (hsz == 56) {

  00516	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  0051b	75 35		 jne	 SHORT $LN20@stbi__bmp_

; 5483 :             stbi__get32le(s);

  0051d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00525	e8 00 00 00 00	 call	 stbi__get32le

; 5484 :             stbi__get32le(s);

  0052a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00532	e8 00 00 00 00	 call	 stbi__get32le

; 5485 :             stbi__get32le(s);

  00537	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0053f	e8 00 00 00 00	 call	 stbi__get32le

; 5486 :             stbi__get32le(s);

  00544	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0054c	e8 00 00 00 00	 call	 stbi__get32le
  00551	90		 npad	 1
$LN20@stbi__bmp_:

; 5487 :          }
; 5488 :          if (info->bpp == 16 || info->bpp == 32) {

  00552	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0055a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0055d	74 11		 je	 SHORT $LN22@stbi__bmp_
  0055f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00567	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  0056a	0f 85 18 01 00
	00		 jne	 $LN21@stbi__bmp_
$LN22@stbi__bmp_:

; 5489 :             if (compress == 0) {

  00570	83 7c 24 24 00	 cmp	 DWORD PTR compress$1[rsp], 0
  00575	75 17		 jne	 SHORT $LN23@stbi__bmp_

; 5490 :                stbi__bmp_set_mask_defaults(info, compress);

  00577	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  0057b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00583	e8 00 00 00 00	 call	 stbi__bmp_set_mask_defaults
  00588	90		 npad	 1
  00589	e9 fa 00 00 00	 jmp	 $LN24@stbi__bmp_
$LN23@stbi__bmp_:

; 5491 :             } else if (compress == 3) {

  0058e	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  00593	0f 85 c1 00 00
	00		 jne	 $LN25@stbi__bmp_

; 5492 :                info->mr = stbi__get32le(s);

  00599	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a1	e8 00 00 00 00	 call	 stbi__get32le
  005a6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  005ae	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5493 :                info->mg = stbi__get32le(s);

  005b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005b9	e8 00 00 00 00	 call	 stbi__get32le
  005be	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  005c6	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5494 :                info->mb = stbi__get32le(s);

  005c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d1	e8 00 00 00 00	 call	 stbi__get32le
  005d6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  005de	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5495 :                info->extra_read += 12;

  005e1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  005e9	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  005ec	83 c0 0c	 add	 eax, 12
  005ef	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  005f7	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 5496 :                // not documented, but generated by photoshop and handled by mspaint
; 5497 :                if (info->mr == info->mg && info->mg == info->mb) {

  005fa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00602	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0060a	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0060d	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  00610	75 46		 jne	 SHORT $LN27@stbi__bmp_
  00612	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0061a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00622	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00625	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00628	75 2e		 jne	 SHORT $LN27@stbi__bmp_

; 5498 :                   // ?!?!?
; 5499 :                   return stbi__errpuc("bad BMP", "bad BMP");

  0062a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  00631	e8 00 00 00 00	 call	 stbi__err
  00636	85 c0		 test	 eax, eax
  00638	74 0b		 je	 SHORT $LN46@stbi__bmp_
  0063a	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv224[rsp], 0
  00643	eb 09		 jmp	 SHORT $LN47@stbi__bmp_
$LN46@stbi__bmp_:
  00645	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv224[rsp], 0
$LN47@stbi__bmp_:
  0064e	48 8b 44 24 70	 mov	 rax, QWORD PTR tv224[rsp]
  00653	e9 6d 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN27@stbi__bmp_:

; 5500 :                }
; 5501 :             } else

  00658	eb 2e		 jmp	 SHORT $LN26@stbi__bmp_
$LN25@stbi__bmp_:

; 5502 :                return stbi__errpuc("bad BMP", "bad BMP");

  0065a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  00661	e8 00 00 00 00	 call	 stbi__err
  00666	85 c0		 test	 eax, eax
  00668	74 0b		 je	 SHORT $LN48@stbi__bmp_
  0066a	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv228[rsp], 0
  00673	eb 09		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:
  00675	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv228[rsp], 0
$LN49@stbi__bmp_:
  0067e	48 8b 44 24 78	 mov	 rax, QWORD PTR tv228[rsp]
  00683	e9 3d 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN26@stbi__bmp_:
$LN24@stbi__bmp_:
$LN21@stbi__bmp_:

; 5503 :          }
; 5504 :       } else {

  00688	e9 33 01 00 00	 jmp	 $LN18@stbi__bmp_
$LN17@stbi__bmp_:

; 5505 :          // V4/V5 header
; 5506 :          int i;
; 5507 :          if (hsz != 108 && hsz != 124)

  0068d	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  00692	74 3e		 je	 SHORT $LN28@stbi__bmp_
  00694	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  00699	74 37		 je	 SHORT $LN28@stbi__bmp_

; 5508 :             return stbi__errpuc("bad BMP", "bad BMP");

  0069b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IEJCHBDI@bad?5BMP@
  006a2	e8 00 00 00 00	 call	 stbi__err
  006a7	85 c0		 test	 eax, eax
  006a9	74 0e		 je	 SHORT $LN50@stbi__bmp_
  006ab	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv234[rsp], 0
  006b7	eb 0c		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:
  006b9	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv234[rsp], 0
$LN51@stbi__bmp_:
  006c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv234[rsp]
  006cd	e9 f3 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN28@stbi__bmp_:

; 5509 :          info->mr = stbi__get32le(s);

  006d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006da	e8 00 00 00 00	 call	 stbi__get32le
  006df	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  006e7	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5510 :          info->mg = stbi__get32le(s);

  006ea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f2	e8 00 00 00 00	 call	 stbi__get32le
  006f7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  006ff	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5511 :          info->mb = stbi__get32le(s);

  00702	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0070a	e8 00 00 00 00	 call	 stbi__get32le
  0070f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00717	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5512 :          info->ma = stbi__get32le(s);

  0071a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00722	e8 00 00 00 00	 call	 stbi__get32le
  00727	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0072f	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 5513 :          if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs

  00732	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  00737	74 12		 je	 SHORT $LN29@stbi__bmp_

; 5514 :             stbi__bmp_set_mask_defaults(info, compress);

  00739	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  0073d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00745	e8 00 00 00 00	 call	 stbi__bmp_set_mask_defaults
  0074a	90		 npad	 1
$LN29@stbi__bmp_:

; 5515 :          stbi__get32le(s); // discard color space

  0074b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00753	e8 00 00 00 00	 call	 stbi__get32le
  00758	90		 npad	 1

; 5516 :          for (i=0; i < 12; ++i)

  00759	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00761	eb 0a		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  00763	8b 44 24 28	 mov	 eax, DWORD PTR i$2[rsp]
  00767	ff c0		 inc	 eax
  00769	89 44 24 28	 mov	 DWORD PTR i$2[rsp], eax
$LN4@stbi__bmp_:
  0076d	83 7c 24 28 0c	 cmp	 DWORD PTR i$2[rsp], 12
  00772	7d 10		 jge	 SHORT $LN3@stbi__bmp_

; 5517 :             stbi__get32le(s); // discard color space parameters

  00774	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0077c	e8 00 00 00 00	 call	 stbi__get32le
  00781	90		 npad	 1
  00782	eb df		 jmp	 SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5518 :          if (hsz == 124) {

  00784	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  00789	75 35		 jne	 SHORT $LN30@stbi__bmp_

; 5519 :             stbi__get32le(s); // discard rendering intent

  0078b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00793	e8 00 00 00 00	 call	 stbi__get32le

; 5520 :             stbi__get32le(s); // discard offset of profile data

  00798	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007a0	e8 00 00 00 00	 call	 stbi__get32le

; 5521 :             stbi__get32le(s); // discard size of profile data

  007a5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ad	e8 00 00 00 00	 call	 stbi__get32le

; 5522 :             stbi__get32le(s); // discard reserved

  007b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ba	e8 00 00 00 00	 call	 stbi__get32le
  007bf	90		 npad	 1
$LN30@stbi__bmp_:
$LN18@stbi__bmp_:
$LN12@stbi__bmp_:

; 5523 :          }
; 5524 :       }
; 5525 :    }
; 5526 :    return (void *) 1;

  007c0	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 5527 : }

  007c5	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  007cc	5f		 pop	 rdi
  007cd	c3		 ret	 0
stbi__bmp_parse_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
out$ = 48
mr$ = 56
mg$ = 60
mb$ = 64
ma$ = 68
all_a$ = 72
pal$ = 96
psize$ = 1124
i$ = 1128
j$ = 1132
width$ = 1136
flip_vertically$ = 1140
pad$ = 1144
target$ = 1148
info$ = 1160
bytes_read_so_far$5 = 1204
header_limit$6 = 1208
extra_data_limit$7 = 1212
z$8 = 1216
bit_offset$9 = 1220
v$10 = 1224
color$11 = 1228
v$12 = 1232
v2$13 = 1236
rshift$14 = 1240
gshift$15 = 1244
bshift$16 = 1248
ashift$17 = 1252
rcount$18 = 1256
gcount$19 = 1260
bcount$20 = 1264
acount$21 = 1268
z$22 = 1272
easy$23 = 1276
a$24 = 1280
bpp$25 = 1284
v$26 = 1288
a$27 = 1292
t$28 = 1296
p1$29 = 1304
p2$30 = 1312
$T31 = 1328
$T32 = 1329
$T33 = 1330
$T34 = 1331
$T35 = 1332
$T36 = 1333
$T37 = 1334
$T38 = 1335
$T39 = 1336
$T40 = 1337
$T41 = 1338
tv70 = 1340
tv80 = 1344
tv86 = 1352
tv172 = 1360
tv179 = 1368
tv188 = 1376
tv203 = 1384
tv215 = 1392
tv223 = 1400
tv675 = 1408
tv684 = 1409
tv692 = 1410
tv701 = 1411
tv709 = 1412
tv718 = 1413
tv726 = 1414
tv735 = 1415
tv257 = 1416
tv276 = 1424
tv743 = 1432
tv752 = 1433
tv760 = 1434
tv769 = 1435
tv777 = 1436
tv786 = 1437
tv794 = 1438
tv803 = 1439
tv384 = 1440
tv445 = 1448
tv474 = 1456
tv811 = 1464
tv820 = 1465
tv828 = 1466
tv837 = 1467
tv845 = 1468
tv854 = 1469
tv862 = 1470
tv871 = 1471
tv505 = 1472
tv522 = 1476
tv562 = 1480
__$ArrayPad$ = 1488
s$ = 1520
x$ = 1528
y$ = 1536
comp$ = 1544
req_comp$ = 1552
ri$ = 1560
stbi__bmp_load PROC

; 5531 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 05
	00 00		 sub	 rsp, 1504		; 000005e0H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 6c 01 00 00	 mov	 ecx, 364		; 0000016cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1520]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 d0
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5532 :    stbi_uc *out;
; 5533 :    unsigned int mr=0,mg=0,mb=0,ma=0, all_a;

  00053	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR mr$[rsp], 0
  0005b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR mg$[rsp], 0
  00063	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR mb$[rsp], 0
  0006b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR ma$[rsp], 0

; 5534 :    stbi_uc pal[256][4];
; 5535 :    int psize=0,i,j,width;

  00073	c7 84 24 64 04
	00 00 00 00 00
	00		 mov	 DWORD PTR psize$[rsp], 0

; 5536 :    int flip_vertically, pad, target;
; 5537 :    stbi__bmp_data info;
; 5538 :    STBI_NOTUSED(ri);
; 5539 : 
; 5540 :    info.all_a = 255;

  0007e	c7 84 24 a4 04
	00 00 ff 00 00
	00		 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 5541 :    if (stbi__bmp_parse_header(s, &info) == NULL)

  00089	48 8d 94 24 88
	04 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  00091	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00099	e8 00 00 00 00	 call	 stbi__bmp_parse_header
  0009e	48 85 c0	 test	 rax, rax
  000a1	75 07		 jne	 SHORT $LN35@stbi__bmp_

; 5542 :       return NULL; // error code already set

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 c6 1d 00 00	 jmp	 $LN1@stbi__bmp_
$LN35@stbi__bmp_:

; 5543 : 
; 5544 :    flip_vertically = ((int) s->img_y) > 0;

  000aa	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b2	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  000b6	7e 0d		 jle	 SHORT $LN97@stbi__bmp_
  000b8	c7 84 24 3c 05
	00 00 01 00 00
	00		 mov	 DWORD PTR tv70[rsp], 1
  000c3	eb 0b		 jmp	 SHORT $LN98@stbi__bmp_
$LN97@stbi__bmp_:
  000c5	c7 84 24 3c 05
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
$LN98@stbi__bmp_:
  000d0	8b 84 24 3c 05
	00 00		 mov	 eax, DWORD PTR tv70[rsp]
  000d7	89 84 24 74 04
	00 00		 mov	 DWORD PTR flip_vertically$[rsp], eax

; 5545 :    s->img_y = abs((int) s->img_y);

  000de	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000e9	f7 d8		 neg	 eax
  000eb	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f3	0f 48 41 04	 cmovs	 eax, DWORD PTR [rcx+4]
  000f7	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5546 : 
; 5547 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00102	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0010a	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00111	76 37		 jbe	 SHORT $LN36@stbi__bmp_
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0011a	e8 00 00 00 00	 call	 stbi__err
  0011f	85 c0		 test	 eax, eax
  00121	74 0e		 je	 SHORT $LN99@stbi__bmp_
  00123	48 c7 84 24 40
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
  0012f	eb 0c		 jmp	 SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
  00131	48 c7 84 24 40
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
$LN100@stbi__bmp_:
  0013d	48 8b 84 24 40
	05 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  00145	e9 26 1d 00 00	 jmp	 $LN1@stbi__bmp_
$LN36@stbi__bmp_:

; 5548 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0014a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00152	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00158	76 37		 jbe	 SHORT $LN37@stbi__bmp_
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00161	e8 00 00 00 00	 call	 stbi__err
  00166	85 c0		 test	 eax, eax
  00168	74 0e		 je	 SHORT $LN101@stbi__bmp_
  0016a	48 c7 84 24 48
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv86[rsp], 0
  00176	eb 0c		 jmp	 SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:
  00178	48 c7 84 24 48
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv86[rsp], 0
$LN102@stbi__bmp_:
  00184	48 8b 84 24 48
	05 00 00	 mov	 rax, QWORD PTR tv86[rsp]
  0018c	e9 df 1c 00 00	 jmp	 $LN1@stbi__bmp_
$LN37@stbi__bmp_:

; 5549 : 
; 5550 :    mr = info.mr;

  00191	8b 84 24 94 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+12]
  00198	89 44 24 38	 mov	 DWORD PTR mr$[rsp], eax

; 5551 :    mg = info.mg;

  0019c	8b 84 24 98 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+16]
  001a3	89 44 24 3c	 mov	 DWORD PTR mg$[rsp], eax

; 5552 :    mb = info.mb;

  001a7	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+20]
  001ae	89 44 24 40	 mov	 DWORD PTR mb$[rsp], eax

; 5553 :    ma = info.ma;

  001b2	8b 84 24 a0 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+24]
  001b9	89 44 24 44	 mov	 DWORD PTR ma$[rsp], eax

; 5554 :    all_a = info.all_a;

  001bd	8b 84 24 a4 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+28]
  001c4	89 44 24 48	 mov	 DWORD PTR all_a$[rsp], eax

; 5555 : 
; 5556 :    if (info.hsz == 12) {

  001c8	83 bc 24 90 04
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  001d0	75 30		 jne	 SHORT $LN38@stbi__bmp_

; 5557 :       if (info.bpp < 24)

  001d2	83 bc 24 88 04
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  001da	7d 24		 jge	 SHORT $LN40@stbi__bmp_

; 5558 :          psize = (info.offset - info.extra_read - 24) / 3;

  001dc	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  001e3	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  001ea	2b c8		 sub	 ecx, eax
  001ec	8b c1		 mov	 eax, ecx
  001ee	83 e8 18	 sub	 eax, 24
  001f1	99		 cdq
  001f2	b9 03 00 00 00	 mov	 ecx, 3
  001f7	f7 f9		 idiv	 ecx
  001f9	89 84 24 64 04
	00 00		 mov	 DWORD PTR psize$[rsp], eax
$LN40@stbi__bmp_:

; 5559 :    } else {

  00200	eb 2d		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:

; 5560 :       if (info.bpp < 16)

  00202	83 bc 24 88 04
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  0020a	7d 23		 jge	 SHORT $LN41@stbi__bmp_

; 5561 :          psize = (info.offset - info.extra_read - info.hsz) >> 2;

  0020c	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  00213	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  0021a	2b c8		 sub	 ecx, eax
  0021c	8b c1		 mov	 eax, ecx
  0021e	2b 84 24 90 04
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  00225	c1 f8 02	 sar	 eax, 2
  00228	89 84 24 64 04
	00 00		 mov	 DWORD PTR psize$[rsp], eax
$LN41@stbi__bmp_:
$LN39@stbi__bmp_:

; 5562 :    }
; 5563 :    if (psize == 0) {

  0022f	83 bc 24 64 04
	00 00 00	 cmp	 DWORD PTR psize$[rsp], 0
  00237	0f 85 23 01 00
	00		 jne	 $LN42@stbi__bmp_

; 5564 :       // accept some number of extra bytes after the header, but if the offset points either to before
; 5565 :       // the header ends or implies a large amount of extra data, reject the file as malformed
; 5566 :       int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);

  0023d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00245	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0024d	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00254	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0025b	48 2b c1	 sub	 rax, rcx
  0025e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00266	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  0026c	89 84 24 b4 04
	00 00		 mov	 DWORD PTR bytes_read_so_far$5[rsp], eax

; 5567 :       int header_limit = 1024; // max we actually read is below 256 bytes currently.

  00273	c7 84 24 b8 04
	00 00 00 04 00
	00		 mov	 DWORD PTR header_limit$6[rsp], 1024 ; 00000400H

; 5568 :       int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.

  0027e	c7 84 24 bc 04
	00 00 00 04 00
	00		 mov	 DWORD PTR extra_data_limit$7[rsp], 1024 ; 00000400H

; 5569 :       if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {

  00289	83 bc 24 b4 04
	00 00 00	 cmp	 DWORD PTR bytes_read_so_far$5[rsp], 0
  00291	7e 10		 jle	 SHORT $LN44@stbi__bmp_
  00293	8b 84 24 b8 04
	00 00		 mov	 eax, DWORD PTR header_limit$6[rsp]
  0029a	39 84 24 b4 04
	00 00		 cmp	 DWORD PTR bytes_read_so_far$5[rsp], eax
  002a1	7e 37		 jle	 SHORT $LN43@stbi__bmp_
$LN44@stbi__bmp_:

; 5570 :          return stbi__errpuc("bad header", "Corrupt BMP");

  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PJHPAMCH@bad?5header@
  002aa	e8 00 00 00 00	 call	 stbi__err
  002af	85 c0		 test	 eax, eax
  002b1	74 0e		 je	 SHORT $LN103@stbi__bmp_
  002b3	48 c7 84 24 50
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv172[rsp], 0
  002bf	eb 0c		 jmp	 SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
  002c1	48 c7 84 24 50
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv172[rsp], 0
$LN104@stbi__bmp_:
  002cd	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR tv172[rsp]
  002d5	e9 96 1b 00 00	 jmp	 $LN1@stbi__bmp_
$LN43@stbi__bmp_:

; 5571 :       }
; 5572 :       // we established that bytes_read_so_far is positive and sensible.
; 5573 :       // the first half of this test rejects offsets that are either too small positives, or
; 5574 :       // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5575 :       // ensures the number computed in the second half of the test can't overflow.
; 5576 :       if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {

  002da	8b 84 24 b4 04
	00 00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rsp]
  002e1	39 84 24 8c 04
	00 00		 cmp	 DWORD PTR info$[rsp+4], eax
  002e8	7c 1b		 jl	 SHORT $LN47@stbi__bmp_
  002ea	8b 84 24 b4 04
	00 00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rsp]
  002f1	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  002f8	2b c8		 sub	 ecx, eax
  002fa	8b c1		 mov	 eax, ecx
  002fc	3b 84 24 bc 04
	00 00		 cmp	 eax, DWORD PTR extra_data_limit$7[rsp]
  00303	7e 39		 jle	 SHORT $LN45@stbi__bmp_
$LN47@stbi__bmp_:

; 5577 :          return stbi__errpuc("bad offset", "Corrupt BMP");

  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JDPIFELH@bad?5offset@
  0030c	e8 00 00 00 00	 call	 stbi__err
  00311	85 c0		 test	 eax, eax
  00313	74 0e		 je	 SHORT $LN105@stbi__bmp_
  00315	48 c7 84 24 58
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv179[rsp], 0
  00321	eb 0c		 jmp	 SHORT $LN106@stbi__bmp_
$LN105@stbi__bmp_:
  00323	48 c7 84 24 58
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv179[rsp], 0
$LN106@stbi__bmp_:
  0032f	48 8b 84 24 58
	05 00 00	 mov	 rax, QWORD PTR tv179[rsp]
  00337	e9 34 1b 00 00	 jmp	 $LN1@stbi__bmp_

; 5578 :       } else {

  0033c	eb 22		 jmp	 SHORT $LN46@stbi__bmp_
$LN45@stbi__bmp_:

; 5579 :          stbi__skip(s, info.offset - bytes_read_so_far);

  0033e	8b 84 24 b4 04
	00 00		 mov	 eax, DWORD PTR bytes_read_so_far$5[rsp]
  00345	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  0034c	2b c8		 sub	 ecx, eax
  0034e	8b c1		 mov	 eax, ecx
  00350	8b d0		 mov	 edx, eax
  00352	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035a	e8 00 00 00 00	 call	 stbi__skip
  0035f	90		 npad	 1
$LN46@stbi__bmp_:
$LN42@stbi__bmp_:

; 5580 :       }
; 5581 :    }
; 5582 : 
; 5583 :    if (info.bpp == 24 && ma == 0xff000000)

  00360	83 bc 24 88 04
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00368	75 1b		 jne	 SHORT $LN48@stbi__bmp_
  0036a	81 7c 24 44 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  00372	75 11		 jne	 SHORT $LN48@stbi__bmp_

; 5584 :       s->img_n = 3;

  00374	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0037c	c7 40 08 03 00
	00 00		 mov	 DWORD PTR [rax+8], 3
  00383	eb 31		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:

; 5585 :    else
; 5586 :       s->img_n = ma ? 4 : 3;

  00385	83 7c 24 44 00	 cmp	 DWORD PTR ma$[rsp], 0
  0038a	74 0d		 je	 SHORT $LN107@stbi__bmp_
  0038c	c7 84 24 60 05
	00 00 04 00 00
	00		 mov	 DWORD PTR tv188[rsp], 4
  00397	eb 0b		 jmp	 SHORT $LN108@stbi__bmp_
$LN107@stbi__bmp_:
  00399	c7 84 24 60 05
	00 00 03 00 00
	00		 mov	 DWORD PTR tv188[rsp], 3
$LN108@stbi__bmp_:
  003a4	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ac	8b 8c 24 60 05
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  003b3	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN49@stbi__bmp_:

; 5587 :    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

  003b6	83 bc 24 10 06
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  003be	74 1a		 je	 SHORT $LN50@stbi__bmp_
  003c0	83 bc 24 10 06
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  003c8	7c 10		 jl	 SHORT $LN50@stbi__bmp_

; 5588 :       target = req_comp;

  003ca	8b 84 24 10 06
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  003d1	89 84 24 7c 04
	00 00		 mov	 DWORD PTR target$[rsp], eax
  003d8	eb 12		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:

; 5589 :    else
; 5590 :       target = s->img_n; // if they want monochrome, we'll post-convert

  003da	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003e2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003e5	89 84 24 7c 04
	00 00		 mov	 DWORD PTR target$[rsp], eax
$LN51@stbi__bmp_:

; 5591 : 
; 5592 :    // sanity-check size
; 5593 :    if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

  003ec	45 33 c9	 xor	 r9d, r9d
  003ef	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003f7	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  003fb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00403	8b 10		 mov	 edx, DWORD PTR [rax]
  00405	8b 8c 24 7c 04
	00 00		 mov	 ecx, DWORD PTR target$[rsp]
  0040c	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00411	85 c0		 test	 eax, eax
  00413	75 37		 jne	 SHORT $LN52@stbi__bmp_

; 5594 :       return stbi__errpuc("too large", "Corrupt BMP");

  00415	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0041c	e8 00 00 00 00	 call	 stbi__err
  00421	85 c0		 test	 eax, eax
  00423	74 0e		 je	 SHORT $LN109@stbi__bmp_
  00425	48 c7 84 24 68
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv203[rsp], 0
  00431	eb 0c		 jmp	 SHORT $LN110@stbi__bmp_
$LN109@stbi__bmp_:
  00433	48 c7 84 24 68
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv203[rsp], 0
$LN110@stbi__bmp_:
  0043f	48 8b 84 24 68
	05 00 00	 mov	 rax, QWORD PTR tv203[rsp]
  00447	e9 24 1a 00 00	 jmp	 $LN1@stbi__bmp_
$LN52@stbi__bmp_:

; 5595 : 
; 5596 :    out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

  0044c	45 33 c9	 xor	 r9d, r9d
  0044f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00457	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0045b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00463	8b 10		 mov	 edx, DWORD PTR [rax]
  00465	8b 8c 24 7c 04
	00 00		 mov	 ecx, DWORD PTR target$[rsp]
  0046c	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00471	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 5597 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

  00476	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  0047c	75 37		 jne	 SHORT $LN53@stbi__bmp_
  0047e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00485	e8 00 00 00 00	 call	 stbi__err
  0048a	85 c0		 test	 eax, eax
  0048c	74 0e		 je	 SHORT $LN111@stbi__bmp_
  0048e	48 c7 84 24 70
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv215[rsp], 0
  0049a	eb 0c		 jmp	 SHORT $LN112@stbi__bmp_
$LN111@stbi__bmp_:
  0049c	48 c7 84 24 70
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv215[rsp], 0
$LN112@stbi__bmp_:
  004a8	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  004b0	e9 bb 19 00 00	 jmp	 $LN1@stbi__bmp_
$LN53@stbi__bmp_:

; 5598 :    if (info.bpp < 16) {

  004b5	83 bc 24 88 04
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  004bd	0f 8d c6 0d 00
	00		 jge	 $LN54@stbi__bmp_

; 5599 :       int z=0;

  004c3	c7 84 24 c0 04
	00 00 00 00 00
	00		 mov	 DWORD PTR z$8[rsp], 0

; 5600 :       if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

  004ce	83 bc 24 64 04
	00 00 00	 cmp	 DWORD PTR psize$[rsp], 0
  004d6	74 0d		 je	 SHORT $LN57@stbi__bmp_
  004d8	81 bc 24 64 04
	00 00 00 01 00
	00		 cmp	 DWORD PTR psize$[rsp], 256 ; 00000100H
  004e3	7e 42		 jle	 SHORT $LN56@stbi__bmp_
$LN57@stbi__bmp_:
  004e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  004ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  004f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MALOAKCI@invalid@
  004f7	e8 00 00 00 00	 call	 stbi__err
  004fc	85 c0		 test	 eax, eax
  004fe	74 0e		 je	 SHORT $LN113@stbi__bmp_
  00500	48 c7 84 24 78
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv223[rsp], 0
  0050c	eb 0c		 jmp	 SHORT $LN114@stbi__bmp_
$LN113@stbi__bmp_:
  0050e	48 c7 84 24 78
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv223[rsp], 0
$LN114@stbi__bmp_:
  0051a	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  00522	e9 49 19 00 00	 jmp	 $LN1@stbi__bmp_
$LN56@stbi__bmp_:

; 5601 :       for (i=0; i < psize; ++i) {

  00527	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00532	eb 10		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  00534	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0053b	ff c0		 inc	 eax
  0053d	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__bmp_:
  00544	8b 84 24 64 04
	00 00		 mov	 eax, DWORD PTR psize$[rsp]
  0054b	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00552	0f 8d cc 03 00
	00		 jge	 $LN3@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00558	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00560	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00568	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0056f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00576	73 4b		 jae	 SHORT $LN132@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00578	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00580	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00587	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0058a	88 84 24 80 05
	00 00		 mov	 BYTE PTR tv675[rsp], al
  00591	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00599	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005a0	48 ff c0	 inc	 rax
  005a3	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ab	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005b2	0f b6 84 24 80
	05 00 00	 movzx	 eax, BYTE PTR tv675[rsp]
  005ba	88 84 24 30 05
	00 00		 mov	 BYTE PTR $T31[rsp], al
  005c1	eb 6e		 jmp	 SHORT $LN131@stbi__bmp_
$LN132@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  005c3	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005cb	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  005cf	74 58		 je	 SHORT $LN133@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  005d1	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d9	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  005de	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005e6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005ed	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005f0	88 84 24 81 05
	00 00		 mov	 BYTE PTR tv684[rsp], al
  005f7	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ff	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00606	48 ff c0	 inc	 rax
  00609	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00611	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00618	0f b6 84 24 81
	05 00 00	 movzx	 eax, BYTE PTR tv684[rsp]
  00620	88 84 24 30 05
	00 00		 mov	 BYTE PTR $T31[rsp], al
  00627	eb 08		 jmp	 SHORT $LN131@stbi__bmp_
$LN133@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00629	c6 84 24 30 05
	00 00 00	 mov	 BYTE PTR $T31[rsp], 0
$LN131@stbi__bmp_:

; 5602 :          pal[i][2] = stbi__get8(s);

  00631	0f b6 84 24 30
	05 00 00	 movzx	 eax, BYTE PTR $T31[rsp]
  00639	48 63 8c 24 68
	04 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00641	48 8d 4c 8c 60	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  00646	ba 01 00 00 00	 mov	 edx, 1
  0064b	48 6b d2 02	 imul	 rdx, rdx, 2
  0064f	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00652	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0065a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00662	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00669	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00670	73 4b		 jae	 SHORT $LN136@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00672	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0067a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00681	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00684	88 84 24 82 05
	00 00		 mov	 BYTE PTR tv692[rsp], al
  0068b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00693	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0069a	48 ff c0	 inc	 rax
  0069d	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006ac	0f b6 84 24 82
	05 00 00	 movzx	 eax, BYTE PTR tv692[rsp]
  006b4	88 84 24 31 05
	00 00		 mov	 BYTE PTR $T32[rsp], al
  006bb	eb 6e		 jmp	 SHORT $LN135@stbi__bmp_
$LN136@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  006bd	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006c5	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  006c9	74 58		 je	 SHORT $LN137@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  006cb	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006d3	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  006d8	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006ea	88 84 24 83 05
	00 00		 mov	 BYTE PTR tv701[rsp], al
  006f1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006f9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00700	48 ff c0	 inc	 rax
  00703	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0070b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00712	0f b6 84 24 83
	05 00 00	 movzx	 eax, BYTE PTR tv701[rsp]
  0071a	88 84 24 31 05
	00 00		 mov	 BYTE PTR $T32[rsp], al
  00721	eb 08		 jmp	 SHORT $LN135@stbi__bmp_
$LN137@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00723	c6 84 24 31 05
	00 00 00	 mov	 BYTE PTR $T32[rsp], 0
$LN135@stbi__bmp_:

; 5603 :          pal[i][1] = stbi__get8(s);

  0072b	0f b6 84 24 31
	05 00 00	 movzx	 eax, BYTE PTR $T32[rsp]
  00733	48 63 8c 24 68
	04 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0073b	48 8d 4c 8c 60	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  00740	ba 01 00 00 00	 mov	 edx, 1
  00745	48 6b d2 01	 imul	 rdx, rdx, 1
  00749	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0074c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00754	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0075c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00763	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0076a	73 4b		 jae	 SHORT $LN140@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  0076c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00774	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0077b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0077e	88 84 24 84 05
	00 00		 mov	 BYTE PTR tv709[rsp], al
  00785	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0078d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00794	48 ff c0	 inc	 rax
  00797	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0079f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  007a6	0f b6 84 24 84
	05 00 00	 movzx	 eax, BYTE PTR tv709[rsp]
  007ae	88 84 24 32 05
	00 00		 mov	 BYTE PTR $T33[rsp], al
  007b5	eb 6e		 jmp	 SHORT $LN139@stbi__bmp_
$LN140@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  007b7	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007bf	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007c3	74 58		 je	 SHORT $LN141@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  007c5	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007cd	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  007d2	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007da	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007e1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007e4	88 84 24 85 05
	00 00		 mov	 BYTE PTR tv718[rsp], al
  007eb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007f3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007fa	48 ff c0	 inc	 rax
  007fd	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00805	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0080c	0f b6 84 24 85
	05 00 00	 movzx	 eax, BYTE PTR tv718[rsp]
  00814	88 84 24 32 05
	00 00		 mov	 BYTE PTR $T33[rsp], al
  0081b	eb 08		 jmp	 SHORT $LN139@stbi__bmp_
$LN141@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  0081d	c6 84 24 32 05
	00 00 00	 mov	 BYTE PTR $T33[rsp], 0
$LN139@stbi__bmp_:

; 5604 :          pal[i][0] = stbi__get8(s);

  00825	0f b6 84 24 32
	05 00 00	 movzx	 eax, BYTE PTR $T33[rsp]
  0082d	48 63 8c 24 68
	04 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00835	48 8d 4c 8c 60	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  0083a	ba 01 00 00 00	 mov	 edx, 1
  0083f	48 6b d2 00	 imul	 rdx, rdx, 0
  00843	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5605 :          if (info.hsz != 12) stbi__get8(s);

  00846	83 bc 24 90 04
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  0084e	0f 84 b1 00 00
	00		 je	 $LN58@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00854	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00864	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0086b	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00872	73 3c		 jae	 SHORT $LN144@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00874	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0087c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00883	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00886	88 84 24 86 05
	00 00		 mov	 BYTE PTR tv726[rsp], al
  0088d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00895	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0089c	48 ff c0	 inc	 rax
  0089f	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008a7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  008ae	eb 55		 jmp	 SHORT $LN143@stbi__bmp_
$LN144@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  008b0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008b8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  008bc	74 47		 je	 SHORT $LN145@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  008be	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008c6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  008cb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008d3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  008da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008dd	88 84 24 87 05
	00 00		 mov	 BYTE PTR tv735[rsp], al
  008e4	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008ec	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  008f3	48 ff c0	 inc	 rax
  008f6	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008fe	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN145@stbi__bmp_:
$LN143@stbi__bmp_:
$LN58@stbi__bmp_:

; 5606 :          pal[i][3] = 255;

  00905	48 63 84 24 68
	04 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0090d	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00912	b9 01 00 00 00	 mov	 ecx, 1
  00917	48 6b c9 03	 imul	 rcx, rcx, 3
  0091b	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 5607 :       }

  0091f	e9 10 fc ff ff	 jmp	 $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5608 :       stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

  00924	83 bc 24 90 04
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  0092c	75 0d		 jne	 SHORT $LN115@stbi__bmp_
  0092e	c7 84 24 88 05
	00 00 03 00 00
	00		 mov	 DWORD PTR tv257[rsp], 3
  00939	eb 0b		 jmp	 SHORT $LN116@stbi__bmp_
$LN115@stbi__bmp_:
  0093b	c7 84 24 88 05
	00 00 04 00 00
	00		 mov	 DWORD PTR tv257[rsp], 4
$LN116@stbi__bmp_:
  00946	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  0094d	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  00954	2b c8		 sub	 ecx, eax
  00956	8b c1		 mov	 eax, ecx
  00958	2b 84 24 90 04
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  0095f	8b 8c 24 64 04
	00 00		 mov	 ecx, DWORD PTR psize$[rsp]
  00966	0f af 8c 24 88
	05 00 00	 imul	 ecx, DWORD PTR tv257[rsp]
  0096e	2b c1		 sub	 eax, ecx
  00970	8b d0		 mov	 edx, eax
  00972	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0097a	e8 00 00 00 00	 call	 stbi__skip

; 5609 :       if (info.bpp == 1) width = (s->img_x + 7) >> 3;

  0097f	83 bc 24 88 04
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  00987	75 1c		 jne	 SHORT $LN59@stbi__bmp_
  00989	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00991	8b 00		 mov	 eax, DWORD PTR [rax]
  00993	83 c0 07	 add	 eax, 7
  00996	c1 e8 03	 shr	 eax, 3
  00999	89 84 24 70 04
	00 00		 mov	 DWORD PTR width$[rsp], eax
  009a0	e9 80 00 00 00	 jmp	 $LN60@stbi__bmp_
$LN59@stbi__bmp_:

; 5610 :       else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

  009a5	83 bc 24 88 04
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  009ad	75 17		 jne	 SHORT $LN61@stbi__bmp_
  009af	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009b7	8b 00		 mov	 eax, DWORD PTR [rax]
  009b9	ff c0		 inc	 eax
  009bb	d1 e8		 shr	 eax, 1
  009bd	89 84 24 70 04
	00 00		 mov	 DWORD PTR width$[rsp], eax
  009c4	eb 5f		 jmp	 SHORT $LN62@stbi__bmp_
$LN61@stbi__bmp_:

; 5611 :       else if (info.bpp == 8) width = s->img_x;

  009c6	83 bc 24 88 04
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  009ce	75 13		 jne	 SHORT $LN63@stbi__bmp_
  009d0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009d8	8b 00		 mov	 eax, DWORD PTR [rax]
  009da	89 84 24 70 04
	00 00		 mov	 DWORD PTR width$[rsp], eax
  009e1	eb 42		 jmp	 SHORT $LN64@stbi__bmp_
$LN63@stbi__bmp_:

; 5612 :       else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

  009e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  009e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07JNJHIMGH@bad?5bpp@
  009f5	e8 00 00 00 00	 call	 stbi__err
  009fa	85 c0		 test	 eax, eax
  009fc	74 0e		 je	 SHORT $LN117@stbi__bmp_
  009fe	48 c7 84 24 90
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv276[rsp], 0
  00a0a	eb 0c		 jmp	 SHORT $LN118@stbi__bmp_
$LN117@stbi__bmp_:
  00a0c	48 c7 84 24 90
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv276[rsp], 0
$LN118@stbi__bmp_:
  00a18	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR tv276[rsp]
  00a20	e9 4b 14 00 00	 jmp	 $LN1@stbi__bmp_
$LN64@stbi__bmp_:
$LN62@stbi__bmp_:
$LN60@stbi__bmp_:

; 5613 :       pad = (-width)&3;

  00a25	8b 84 24 70 04
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  00a2c	f7 d8		 neg	 eax
  00a2e	83 e0 03	 and	 eax, 3
  00a31	89 84 24 78 04
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5614 :       if (info.bpp == 1) {

  00a38	83 bc 24 88 04
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  00a40	0f 85 aa 03 00
	00		 jne	 $LN65@stbi__bmp_

; 5615 :          for (j=0; j < (int) s->img_y; ++j) {

  00a46	c7 84 24 6c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00a51	eb 10		 jmp	 SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
  00a53	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00a5a	ff c0		 inc	 eax
  00a5c	89 84 24 6c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__bmp_:
  00a63	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a6b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00a6e	39 84 24 6c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00a75	0f 8d 70 03 00
	00		 jge	 $LN6@stbi__bmp_

; 5616 :             int bit_offset = 7, v = stbi__get8(s);

  00a7b	c7 84 24 c4 04
	00 00 07 00 00
	00		 mov	 DWORD PTR bit_offset$9[rsp], 7

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00a86	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a8e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a96	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00a9d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00aa4	73 4b		 jae	 SHORT $LN148@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00aa6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aae	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ab5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ab8	88 84 24 98 05
	00 00		 mov	 BYTE PTR tv743[rsp], al
  00abf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ac7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ace	48 ff c0	 inc	 rax
  00ad1	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ad9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00ae0	0f b6 84 24 98
	05 00 00	 movzx	 eax, BYTE PTR tv743[rsp]
  00ae8	88 84 24 33 05
	00 00		 mov	 BYTE PTR $T34[rsp], al
  00aef	eb 6e		 jmp	 SHORT $LN147@stbi__bmp_
$LN148@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00af1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00af9	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00afd	74 58		 je	 SHORT $LN149@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  00aff	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b07	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00b0c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b14	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b1b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b1e	88 84 24 99 05
	00 00		 mov	 BYTE PTR tv752[rsp], al
  00b25	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b2d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b34	48 ff c0	 inc	 rax
  00b37	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b3f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b46	0f b6 84 24 99
	05 00 00	 movzx	 eax, BYTE PTR tv752[rsp]
  00b4e	88 84 24 33 05
	00 00		 mov	 BYTE PTR $T34[rsp], al
  00b55	eb 08		 jmp	 SHORT $LN147@stbi__bmp_
$LN149@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00b57	c6 84 24 33 05
	00 00 00	 mov	 BYTE PTR $T34[rsp], 0
$LN147@stbi__bmp_:

; 5616 :             int bit_offset = 7, v = stbi__get8(s);

  00b5f	0f b6 84 24 33
	05 00 00	 movzx	 eax, BYTE PTR $T34[rsp]
  00b67	0f b6 c0	 movzx	 eax, al
  00b6a	89 84 24 c8 04
	00 00		 mov	 DWORD PTR v$10[rsp], eax

; 5617 :             for (i=0; i < (int) s->img_x; ++i) {

  00b71	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00b7c	eb 10		 jmp	 SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
  00b7e	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00b85	ff c0		 inc	 eax
  00b87	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__bmp_:
  00b8e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b96	8b 00		 mov	 eax, DWORD PTR [rax]
  00b98	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00b9f	0f 8d 2c 02 00
	00		 jge	 $LN9@stbi__bmp_

; 5618 :                int color = (v>>bit_offset)&0x1;

  00ba5	8b 84 24 c4 04
	00 00		 mov	 eax, DWORD PTR bit_offset$9[rsp]
  00bac	0f b6 c8	 movzx	 ecx, al
  00baf	8b 84 24 c8 04
	00 00		 mov	 eax, DWORD PTR v$10[rsp]
  00bb6	d3 f8		 sar	 eax, cl
  00bb8	83 e0 01	 and	 eax, 1
  00bbb	89 84 24 cc 04
	00 00		 mov	 DWORD PTR color$11[rsp], eax

; 5619 :                out[z++] = pal[color][0];

  00bc2	48 63 84 24 cc
	04 00 00	 movsxd	 rax, DWORD PTR color$11[rsp]
  00bca	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00bcf	b9 01 00 00 00	 mov	 ecx, 1
  00bd4	48 6b c9 00	 imul	 rcx, rcx, 0
  00bd8	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  00be0	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  00be5	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00be9	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00bed	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00bf4	ff c0		 inc	 eax
  00bf6	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5620 :                out[z++] = pal[color][1];

  00bfd	48 63 84 24 cc
	04 00 00	 movsxd	 rax, DWORD PTR color$11[rsp]
  00c05	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00c0a	b9 01 00 00 00	 mov	 ecx, 1
  00c0f	48 6b c9 01	 imul	 rcx, rcx, 1
  00c13	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  00c1b	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  00c20	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c24	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00c28	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00c2f	ff c0		 inc	 eax
  00c31	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5621 :                out[z++] = pal[color][2];

  00c38	48 63 84 24 cc
	04 00 00	 movsxd	 rax, DWORD PTR color$11[rsp]
  00c40	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00c45	b9 01 00 00 00	 mov	 ecx, 1
  00c4a	48 6b c9 02	 imul	 rcx, rcx, 2
  00c4e	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  00c56	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  00c5b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c5f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00c63	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00c6a	ff c0		 inc	 eax
  00c6c	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5622 :                if (target == 4) out[z++] = 255;

  00c73	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  00c7b	75 21		 jne	 SHORT $LN67@stbi__bmp_
  00c7d	48 63 84 24 c0
	04 00 00	 movsxd	 rax, DWORD PTR z$8[rsp]
  00c85	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00c8a	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00c8e	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00c95	ff c0		 inc	 eax
  00c97	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax
$LN67@stbi__bmp_:

; 5623 :                if (i+1 == (int) s->img_x) break;

  00c9e	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00ca5	ff c0		 inc	 eax
  00ca7	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00caf	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00cb1	75 05		 jne	 SHORT $LN68@stbi__bmp_
  00cb3	e9 19 01 00 00	 jmp	 $LN9@stbi__bmp_
$LN68@stbi__bmp_:

; 5624 :                if((--bit_offset) < 0) {

  00cb8	8b 84 24 c4 04
	00 00		 mov	 eax, DWORD PTR bit_offset$9[rsp]
  00cbf	ff c8		 dec	 eax
  00cc1	89 84 24 c4 04
	00 00		 mov	 DWORD PTR bit_offset$9[rsp], eax
  00cc8	83 bc 24 c4 04
	00 00 00	 cmp	 DWORD PTR bit_offset$9[rsp], 0
  00cd0	0f 8d f6 00 00
	00		 jge	 $LN69@stbi__bmp_

; 5625 :                   bit_offset = 7;

  00cd6	c7 84 24 c4 04
	00 00 07 00 00
	00		 mov	 DWORD PTR bit_offset$9[rsp], 7

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00ce1	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ce9	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cf1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00cf8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00cff	73 4b		 jae	 SHORT $LN152@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00d01	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d09	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d10	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d13	88 84 24 9a 05
	00 00		 mov	 BYTE PTR tv760[rsp], al
  00d1a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d22	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d29	48 ff c0	 inc	 rax
  00d2c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d34	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00d3b	0f b6 84 24 9a
	05 00 00	 movzx	 eax, BYTE PTR tv760[rsp]
  00d43	88 84 24 34 05
	00 00		 mov	 BYTE PTR $T35[rsp], al
  00d4a	eb 6e		 jmp	 SHORT $LN151@stbi__bmp_
$LN152@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00d4c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d54	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00d58	74 58		 je	 SHORT $LN153@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  00d5a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d62	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00d67	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d6f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d76	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d79	88 84 24 9b 05
	00 00		 mov	 BYTE PTR tv769[rsp], al
  00d80	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d88	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d8f	48 ff c0	 inc	 rax
  00d92	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d9a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00da1	0f b6 84 24 9b
	05 00 00	 movzx	 eax, BYTE PTR tv769[rsp]
  00da9	88 84 24 34 05
	00 00		 mov	 BYTE PTR $T35[rsp], al
  00db0	eb 08		 jmp	 SHORT $LN151@stbi__bmp_
$LN153@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00db2	c6 84 24 34 05
	00 00 00	 mov	 BYTE PTR $T35[rsp], 0
$LN151@stbi__bmp_:

; 5626 :                   v = stbi__get8(s);

  00dba	0f b6 84 24 34
	05 00 00	 movzx	 eax, BYTE PTR $T35[rsp]
  00dc2	0f b6 c0	 movzx	 eax, al
  00dc5	89 84 24 c8 04
	00 00		 mov	 DWORD PTR v$10[rsp], eax
$LN69@stbi__bmp_:

; 5627 :                }
; 5628 :             }

  00dcc	e9 ad fd ff ff	 jmp	 $LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 5629 :             stbi__skip(s, pad);

  00dd1	8b 94 24 78 04
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  00dd8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00de0	e8 00 00 00 00	 call	 stbi__skip
  00de5	90		 npad	 1

; 5630 :          }

  00de6	e9 68 fc ff ff	 jmp	 $LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 5631 :       } else {

  00deb	e9 94 04 00 00	 jmp	 $LN66@stbi__bmp_
$LN65@stbi__bmp_:

; 5632 :          for (j=0; j < (int) s->img_y; ++j) {

  00df0	c7 84 24 6c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00dfb	eb 10		 jmp	 SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
  00dfd	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00e04	ff c0		 inc	 eax
  00e06	89 84 24 6c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__bmp_:
  00e0d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e15	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00e18	39 84 24 6c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00e1f	0f 8d 5f 04 00
	00		 jge	 $LN12@stbi__bmp_

; 5633 :             for (i=0; i < (int) s->img_x; i += 2) {

  00e25	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00e30	eb 11		 jmp	 SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
  00e32	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00e39	83 c0 02	 add	 eax, 2
  00e3c	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__bmp_:
  00e43	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e4b	8b 00		 mov	 eax, DWORD PTR [rax]
  00e4d	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00e54	0f 8d 10 04 00
	00		 jge	 $LN15@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00e5a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e62	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e6a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00e71	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00e78	73 4b		 jae	 SHORT $LN156@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  00e7a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e82	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e89	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e8c	88 84 24 9c 05
	00 00		 mov	 BYTE PTR tv777[rsp], al
  00e93	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e9b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ea2	48 ff c0	 inc	 rax
  00ea5	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ead	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00eb4	0f b6 84 24 9c
	05 00 00	 movzx	 eax, BYTE PTR tv777[rsp]
  00ebc	88 84 24 35 05
	00 00		 mov	 BYTE PTR $T36[rsp], al
  00ec3	eb 6e		 jmp	 SHORT $LN155@stbi__bmp_
$LN156@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  00ec5	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ecd	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00ed1	74 58		 je	 SHORT $LN157@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  00ed3	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00edb	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00ee0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ee8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00eef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ef2	88 84 24 9d 05
	00 00		 mov	 BYTE PTR tv786[rsp], al
  00ef9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f01	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00f08	48 ff c0	 inc	 rax
  00f0b	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f13	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00f1a	0f b6 84 24 9d
	05 00 00	 movzx	 eax, BYTE PTR tv786[rsp]
  00f22	88 84 24 35 05
	00 00		 mov	 BYTE PTR $T36[rsp], al
  00f29	eb 08		 jmp	 SHORT $LN155@stbi__bmp_
$LN157@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  00f2b	c6 84 24 35 05
	00 00 00	 mov	 BYTE PTR $T36[rsp], 0
$LN155@stbi__bmp_:

; 5634 :                int v=stbi__get8(s),v2=0;

  00f33	0f b6 84 24 35
	05 00 00	 movzx	 eax, BYTE PTR $T36[rsp]
  00f3b	0f b6 c0	 movzx	 eax, al
  00f3e	89 84 24 d0 04
	00 00		 mov	 DWORD PTR v$12[rsp], eax
  00f45	c7 84 24 d4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR v2$13[rsp], 0

; 5635 :                if (info.bpp == 4) {

  00f50	83 bc 24 88 04
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  00f58	75 22		 jne	 SHORT $LN70@stbi__bmp_

; 5636 :                   v2 = v & 15;

  00f5a	8b 84 24 d0 04
	00 00		 mov	 eax, DWORD PTR v$12[rsp]
  00f61	83 e0 0f	 and	 eax, 15
  00f64	89 84 24 d4 04
	00 00		 mov	 DWORD PTR v2$13[rsp], eax

; 5637 :                   v >>= 4;

  00f6b	8b 84 24 d0 04
	00 00		 mov	 eax, DWORD PTR v$12[rsp]
  00f72	c1 f8 04	 sar	 eax, 4
  00f75	89 84 24 d0 04
	00 00		 mov	 DWORD PTR v$12[rsp], eax
$LN70@stbi__bmp_:

; 5638 :                }
; 5639 :                out[z++] = pal[v][0];

  00f7c	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  00f84	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00f89	b9 01 00 00 00	 mov	 ecx, 1
  00f8e	48 6b c9 00	 imul	 rcx, rcx, 0
  00f92	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  00f9a	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  00f9f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00fa3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00fa7	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00fae	ff c0		 inc	 eax
  00fb0	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5640 :                out[z++] = pal[v][1];

  00fb7	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  00fbf	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00fc4	b9 01 00 00 00	 mov	 ecx, 1
  00fc9	48 6b c9 01	 imul	 rcx, rcx, 1
  00fcd	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  00fd5	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  00fda	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00fde	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00fe2	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  00fe9	ff c0		 inc	 eax
  00feb	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5641 :                out[z++] = pal[v][2];

  00ff2	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  00ffa	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00fff	b9 01 00 00 00	 mov	 ecx, 1
  01004	48 6b c9 02	 imul	 rcx, rcx, 2
  01008	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  01010	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  01015	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01019	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0101d	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  01024	ff c0		 inc	 eax
  01026	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5642 :                if (target == 4) out[z++] = 255;

  0102d	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  01035	75 21		 jne	 SHORT $LN71@stbi__bmp_
  01037	48 63 84 24 c0
	04 00 00	 movsxd	 rax, DWORD PTR z$8[rsp]
  0103f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01044	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  01048	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  0104f	ff c0		 inc	 eax
  01051	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax
$LN71@stbi__bmp_:

; 5643 :                if (i+1 == (int) s->img_x) break;

  01058	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0105f	ff c0		 inc	 eax
  01061	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01069	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0106b	75 05		 jne	 SHORT $LN72@stbi__bmp_
  0106d	e9 f8 01 00 00	 jmp	 $LN15@stbi__bmp_
$LN72@stbi__bmp_:

; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;

  01072	83 bc 24 88 04
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  0107a	0f 85 ed 00 00
	00		 jne	 $LN119@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  01080	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01088	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01090	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  01097	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0109e	73 4b		 jae	 SHORT $LN160@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  010a0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010a8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  010af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  010b2	88 84 24 9e 05
	00 00		 mov	 BYTE PTR tv794[rsp], al
  010b9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010c1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  010c8	48 ff c0	 inc	 rax
  010cb	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  010d3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  010da	0f b6 84 24 9e
	05 00 00	 movzx	 eax, BYTE PTR tv794[rsp]
  010e2	88 84 24 36 05
	00 00		 mov	 BYTE PTR $T37[rsp], al
  010e9	eb 6e		 jmp	 SHORT $LN159@stbi__bmp_
$LN160@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  010eb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010f3	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  010f7	74 58		 je	 SHORT $LN161@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  010f9	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01101	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  01106	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0110e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01115	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01118	88 84 24 9f 05
	00 00		 mov	 BYTE PTR tv803[rsp], al
  0111f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01127	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0112e	48 ff c0	 inc	 rax
  01131	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01139	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  01140	0f b6 84 24 9f
	05 00 00	 movzx	 eax, BYTE PTR tv803[rsp]
  01148	88 84 24 36 05
	00 00		 mov	 BYTE PTR $T37[rsp], al
  0114f	eb 08		 jmp	 SHORT $LN159@stbi__bmp_
$LN161@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  01151	c6 84 24 36 05
	00 00 00	 mov	 BYTE PTR $T37[rsp], 0
$LN159@stbi__bmp_:

; 5644 :                v = (info.bpp == 8) ? stbi__get8(s) : v2;

  01159	0f b6 84 24 36
	05 00 00	 movzx	 eax, BYTE PTR $T37[rsp]
  01161	0f b6 c0	 movzx	 eax, al
  01164	89 84 24 a0 05
	00 00		 mov	 DWORD PTR tv384[rsp], eax
  0116b	eb 0e		 jmp	 SHORT $LN120@stbi__bmp_
$LN119@stbi__bmp_:
  0116d	8b 84 24 d4 04
	00 00		 mov	 eax, DWORD PTR v2$13[rsp]
  01174	89 84 24 a0 05
	00 00		 mov	 DWORD PTR tv384[rsp], eax
$LN120@stbi__bmp_:
  0117b	8b 84 24 a0 05
	00 00		 mov	 eax, DWORD PTR tv384[rsp]
  01182	89 84 24 d0 04
	00 00		 mov	 DWORD PTR v$12[rsp], eax

; 5645 :                out[z++] = pal[v][0];

  01189	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  01191	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  01196	b9 01 00 00 00	 mov	 ecx, 1
  0119b	48 6b c9 00	 imul	 rcx, rcx, 0
  0119f	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  011a7	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  011ac	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  011b0	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  011b4	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  011bb	ff c0		 inc	 eax
  011bd	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5646 :                out[z++] = pal[v][1];

  011c4	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  011cc	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  011d1	b9 01 00 00 00	 mov	 ecx, 1
  011d6	48 6b c9 01	 imul	 rcx, rcx, 1
  011da	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  011e2	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  011e7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  011eb	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  011ef	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  011f6	ff c0		 inc	 eax
  011f8	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5647 :                out[z++] = pal[v][2];

  011ff	48 63 84 24 d0
	04 00 00	 movsxd	 rax, DWORD PTR v$12[rsp]
  01207	48 8d 44 84 60	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0120c	b9 01 00 00 00	 mov	 ecx, 1
  01211	48 6b c9 02	 imul	 rcx, rcx, 2
  01215	48 63 94 24 c0
	04 00 00	 movsxd	 rdx, DWORD PTR z$8[rsp]
  0121d	4c 8b 44 24 30	 mov	 r8, QWORD PTR out$[rsp]
  01222	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01226	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0122a	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  01231	ff c0		 inc	 eax
  01233	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax

; 5648 :                if (target == 4) out[z++] = 255;

  0123a	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  01242	75 21		 jne	 SHORT $LN73@stbi__bmp_
  01244	48 63 84 24 c0
	04 00 00	 movsxd	 rax, DWORD PTR z$8[rsp]
  0124c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01251	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  01255	8b 84 24 c0 04
	00 00		 mov	 eax, DWORD PTR z$8[rsp]
  0125c	ff c0		 inc	 eax
  0125e	89 84 24 c0 04
	00 00		 mov	 DWORD PTR z$8[rsp], eax
$LN73@stbi__bmp_:

; 5649 :             }

  01265	e9 c8 fb ff ff	 jmp	 $LN14@stbi__bmp_
$LN15@stbi__bmp_:

; 5650 :             stbi__skip(s, pad);

  0126a	8b 94 24 78 04
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  01271	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01279	e8 00 00 00 00	 call	 stbi__skip
  0127e	90		 npad	 1

; 5651 :          }

  0127f	e9 79 fb ff ff	 jmp	 $LN11@stbi__bmp_
$LN12@stbi__bmp_:
$LN66@stbi__bmp_:

; 5652 :       }
; 5653 :    } else {

  01284	e9 83 09 00 00	 jmp	 $LN55@stbi__bmp_
$LN54@stbi__bmp_:

; 5654 :       int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;

  01289	c7 84 24 d8 04
	00 00 00 00 00
	00		 mov	 DWORD PTR rshift$14[rsp], 0
  01294	c7 84 24 dc 04
	00 00 00 00 00
	00		 mov	 DWORD PTR gshift$15[rsp], 0
  0129f	c7 84 24 e0 04
	00 00 00 00 00
	00		 mov	 DWORD PTR bshift$16[rsp], 0
  012aa	c7 84 24 e4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR ashift$17[rsp], 0
  012b5	c7 84 24 e8 04
	00 00 00 00 00
	00		 mov	 DWORD PTR rcount$18[rsp], 0
  012c0	c7 84 24 ec 04
	00 00 00 00 00
	00		 mov	 DWORD PTR gcount$19[rsp], 0
  012cb	c7 84 24 f0 04
	00 00 00 00 00
	00		 mov	 DWORD PTR bcount$20[rsp], 0
  012d6	c7 84 24 f4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR acount$21[rsp], 0

; 5655 :       int z = 0;

  012e1	c7 84 24 f8 04
	00 00 00 00 00
	00		 mov	 DWORD PTR z$22[rsp], 0

; 5656 :       int easy=0;

  012ec	c7 84 24 fc 04
	00 00 00 00 00
	00		 mov	 DWORD PTR easy$23[rsp], 0

; 5657 :       stbi__skip(s, info.offset - info.extra_read - info.hsz);

  012f7	8b 84 24 a8 04
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  012fe	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  01305	2b c8		 sub	 ecx, eax
  01307	8b c1		 mov	 eax, ecx
  01309	2b 84 24 90 04
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  01310	8b d0		 mov	 edx, eax
  01312	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0131a	e8 00 00 00 00	 call	 stbi__skip

; 5658 :       if (info.bpp == 24) width = 3 * s->img_x;

  0131f	83 bc 24 88 04
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  01327	75 14		 jne	 SHORT $LN74@stbi__bmp_
  01329	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01331	6b 00 03	 imul	 eax, DWORD PTR [rax], 3
  01334	89 84 24 70 04
	00 00		 mov	 DWORD PTR width$[rsp], eax
  0133b	eb 2a		 jmp	 SHORT $LN75@stbi__bmp_
$LN74@stbi__bmp_:

; 5659 :       else if (info.bpp == 16) width = 2*s->img_x;

  0133d	83 bc 24 88 04
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  01345	75 15		 jne	 SHORT $LN76@stbi__bmp_
  01347	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0134f	8b 00		 mov	 eax, DWORD PTR [rax]
  01351	d1 e0		 shl	 eax, 1
  01353	89 84 24 70 04
	00 00		 mov	 DWORD PTR width$[rsp], eax
  0135a	eb 0b		 jmp	 SHORT $LN77@stbi__bmp_
$LN76@stbi__bmp_:

; 5660 :       else /* bpp = 32 and pad = 0 */ width=0;

  0135c	c7 84 24 70 04
	00 00 00 00 00
	00		 mov	 DWORD PTR width$[rsp], 0
$LN77@stbi__bmp_:
$LN75@stbi__bmp_:

; 5661 :       pad = (-width) & 3;

  01367	8b 84 24 70 04
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  0136e	f7 d8		 neg	 eax
  01370	83 e0 03	 and	 eax, 3
  01373	89 84 24 78 04
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5662 :       if (info.bpp == 24) {

  0137a	83 bc 24 88 04
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  01382	75 0d		 jne	 SHORT $LN78@stbi__bmp_

; 5663 :          easy = 1;

  01384	c7 84 24 fc 04
	00 00 01 00 00
	00		 mov	 DWORD PTR easy$23[rsp], 1
  0138f	eb 3d		 jmp	 SHORT $LN79@stbi__bmp_
$LN78@stbi__bmp_:

; 5664 :       } else if (info.bpp == 32) {

  01391	83 bc 24 88 04
	00 00 20	 cmp	 DWORD PTR info$[rsp], 32 ; 00000020H
  01399	75 33		 jne	 SHORT $LN80@stbi__bmp_

; 5665 :          if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

  0139b	81 7c 24 40 ff
	00 00 00	 cmp	 DWORD PTR mb$[rsp], 255	; 000000ffH
  013a3	75 29		 jne	 SHORT $LN81@stbi__bmp_
  013a5	81 7c 24 3c 00
	ff 00 00	 cmp	 DWORD PTR mg$[rsp], 65280 ; 0000ff00H
  013ad	75 1f		 jne	 SHORT $LN81@stbi__bmp_
  013af	81 7c 24 38 00
	00 ff 00	 cmp	 DWORD PTR mr$[rsp], 16711680 ; 00ff0000H
  013b7	75 15		 jne	 SHORT $LN81@stbi__bmp_
  013b9	81 7c 24 44 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  013c1	75 0b		 jne	 SHORT $LN81@stbi__bmp_

; 5666 :             easy = 2;

  013c3	c7 84 24 fc 04
	00 00 02 00 00
	00		 mov	 DWORD PTR easy$23[rsp], 2
$LN81@stbi__bmp_:
$LN80@stbi__bmp_:
$LN79@stbi__bmp_:

; 5667 :       }
; 5668 :       if (!easy) {

  013ce	83 bc 24 fc 04
	00 00 00	 cmp	 DWORD PTR easy$23[rsp], 0
  013d6	0f 85 4d 01 00
	00		 jne	 $LN82@stbi__bmp_

; 5669 :          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  013dc	83 7c 24 38 00	 cmp	 DWORD PTR mr$[rsp], 0
  013e1	74 0e		 je	 SHORT $LN84@stbi__bmp_
  013e3	83 7c 24 3c 00	 cmp	 DWORD PTR mg$[rsp], 0
  013e8	74 07		 je	 SHORT $LN84@stbi__bmp_
  013ea	83 7c 24 40 00	 cmp	 DWORD PTR mb$[rsp], 0
  013ef	75 42		 jne	 SHORT $LN83@stbi__bmp_
$LN84@stbi__bmp_:
  013f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  013f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  013fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DAEBACAB@bad?5masks@
  01403	e8 00 00 00 00	 call	 stbi__err
  01408	85 c0		 test	 eax, eax
  0140a	74 0e		 je	 SHORT $LN121@stbi__bmp_
  0140c	48 c7 84 24 a8
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv445[rsp], 0
  01418	eb 0c		 jmp	 SHORT $LN122@stbi__bmp_
$LN121@stbi__bmp_:
  0141a	48 c7 84 24 a8
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv445[rsp], 0
$LN122@stbi__bmp_:
  01426	48 8b 84 24 a8
	05 00 00	 mov	 rax, QWORD PTR tv445[rsp]
  0142e	e9 3d 0a 00 00	 jmp	 $LN1@stbi__bmp_
$LN83@stbi__bmp_:

; 5670 :          // right shift amt to put high bit in position #7
; 5671 :          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

  01433	8b 4c 24 38	 mov	 ecx, DWORD PTR mr$[rsp]
  01437	e8 00 00 00 00	 call	 stbi__high_bit
  0143c	83 e8 07	 sub	 eax, 7
  0143f	89 84 24 d8 04
	00 00		 mov	 DWORD PTR rshift$14[rsp], eax
  01446	8b 4c 24 38	 mov	 ecx, DWORD PTR mr$[rsp]
  0144a	e8 00 00 00 00	 call	 stbi__bitcount
  0144f	89 84 24 e8 04
	00 00		 mov	 DWORD PTR rcount$18[rsp], eax

; 5672 :          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

  01456	8b 4c 24 3c	 mov	 ecx, DWORD PTR mg$[rsp]
  0145a	e8 00 00 00 00	 call	 stbi__high_bit
  0145f	83 e8 07	 sub	 eax, 7
  01462	89 84 24 dc 04
	00 00		 mov	 DWORD PTR gshift$15[rsp], eax
  01469	8b 4c 24 3c	 mov	 ecx, DWORD PTR mg$[rsp]
  0146d	e8 00 00 00 00	 call	 stbi__bitcount
  01472	89 84 24 ec 04
	00 00		 mov	 DWORD PTR gcount$19[rsp], eax

; 5673 :          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

  01479	8b 4c 24 40	 mov	 ecx, DWORD PTR mb$[rsp]
  0147d	e8 00 00 00 00	 call	 stbi__high_bit
  01482	83 e8 07	 sub	 eax, 7
  01485	89 84 24 e0 04
	00 00		 mov	 DWORD PTR bshift$16[rsp], eax
  0148c	8b 4c 24 40	 mov	 ecx, DWORD PTR mb$[rsp]
  01490	e8 00 00 00 00	 call	 stbi__bitcount
  01495	89 84 24 f0 04
	00 00		 mov	 DWORD PTR bcount$20[rsp], eax

; 5674 :          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

  0149c	8b 4c 24 44	 mov	 ecx, DWORD PTR ma$[rsp]
  014a0	e8 00 00 00 00	 call	 stbi__high_bit
  014a5	83 e8 07	 sub	 eax, 7
  014a8	89 84 24 e4 04
	00 00		 mov	 DWORD PTR ashift$17[rsp], eax
  014af	8b 4c 24 44	 mov	 ecx, DWORD PTR ma$[rsp]
  014b3	e8 00 00 00 00	 call	 stbi__bitcount
  014b8	89 84 24 f4 04
	00 00		 mov	 DWORD PTR acount$21[rsp], eax

; 5675 :          if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  014bf	83 bc 24 e8 04
	00 00 08	 cmp	 DWORD PTR rcount$18[rsp], 8
  014c7	7f 1e		 jg	 SHORT $LN86@stbi__bmp_
  014c9	83 bc 24 ec 04
	00 00 08	 cmp	 DWORD PTR gcount$19[rsp], 8
  014d1	7f 14		 jg	 SHORT $LN86@stbi__bmp_
  014d3	83 bc 24 f0 04
	00 00 08	 cmp	 DWORD PTR bcount$20[rsp], 8
  014db	7f 0a		 jg	 SHORT $LN86@stbi__bmp_
  014dd	83 bc 24 f4 04
	00 00 08	 cmp	 DWORD PTR acount$21[rsp], 8
  014e5	7e 42		 jle	 SHORT $LN85@stbi__bmp_
$LN86@stbi__bmp_:
  014e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  014ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  014f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DAEBACAB@bad?5masks@
  014f9	e8 00 00 00 00	 call	 stbi__err
  014fe	85 c0		 test	 eax, eax
  01500	74 0e		 je	 SHORT $LN123@stbi__bmp_
  01502	48 c7 84 24 b0
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv474[rsp], 0
  0150e	eb 0c		 jmp	 SHORT $LN124@stbi__bmp_
$LN123@stbi__bmp_:
  01510	48 c7 84 24 b0
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv474[rsp], 0
$LN124@stbi__bmp_:
  0151c	48 8b 84 24 b0
	05 00 00	 mov	 rax, QWORD PTR tv474[rsp]
  01524	e9 47 09 00 00	 jmp	 $LN1@stbi__bmp_
$LN85@stbi__bmp_:
$LN82@stbi__bmp_:

; 5676 :       }
; 5677 :       for (j=0; j < (int) s->img_y; ++j) {

  01529	c7 84 24 6c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  01534	eb 10		 jmp	 SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
  01536	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0153d	ff c0		 inc	 eax
  0153f	89 84 24 6c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__bmp_:
  01546	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0154e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01551	39 84 24 6c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  01558	0f 8d ae 06 00
	00		 jge	 $LN18@stbi__bmp_

; 5678 :          if (easy) {

  0155e	83 bc 24 fc 04
	00 00 00	 cmp	 DWORD PTR easy$23[rsp], 0
  01566	0f 84 88 04 00
	00		 je	 $LN87@stbi__bmp_

; 5679 :             for (i=0; i < (int) s->img_x; ++i) {

  0156c	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01577	eb 10		 jmp	 SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
  01579	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01580	ff c0		 inc	 eax
  01582	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN22@stbi__bmp_:
  01589	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01591	8b 00		 mov	 eax, DWORD PTR [rax]
  01593	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0159a	0f 8d 4f 04 00
	00		 jge	 $LN21@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  015a0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  015a8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  015b0	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  015b7	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  015be	73 4b		 jae	 SHORT $LN164@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  015c0	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  015c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  015cf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  015d2	88 84 24 b8 05
	00 00		 mov	 BYTE PTR tv811[rsp], al
  015d9	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  015e1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  015e8	48 ff c0	 inc	 rax
  015eb	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  015f3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  015fa	0f b6 84 24 b8
	05 00 00	 movzx	 eax, BYTE PTR tv811[rsp]
  01602	88 84 24 37 05
	00 00		 mov	 BYTE PTR $T38[rsp], al
  01609	eb 6e		 jmp	 SHORT $LN163@stbi__bmp_
$LN164@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  0160b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01613	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01617	74 58		 je	 SHORT $LN165@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  01619	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01621	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  01626	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0162e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01635	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01638	88 84 24 b9 05
	00 00		 mov	 BYTE PTR tv820[rsp], al
  0163f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01647	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0164e	48 ff c0	 inc	 rax
  01651	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01659	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  01660	0f b6 84 24 b9
	05 00 00	 movzx	 eax, BYTE PTR tv820[rsp]
  01668	88 84 24 37 05
	00 00		 mov	 BYTE PTR $T38[rsp], al
  0166f	eb 08		 jmp	 SHORT $LN163@stbi__bmp_
$LN165@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  01671	c6 84 24 37 05
	00 00 00	 mov	 BYTE PTR $T38[rsp], 0
$LN163@stbi__bmp_:

; 5680 :                unsigned char a;
; 5681 :                out[z+2] = stbi__get8(s);

  01679	0f b6 84 24 37
	05 00 00	 movzx	 eax, BYTE PTR $T38[rsp]
  01681	8b 8c 24 f8 04
	00 00		 mov	 ecx, DWORD PTR z$22[rsp]
  01688	83 c1 02	 add	 ecx, 2
  0168b	48 63 c9	 movsxd	 rcx, ecx
  0168e	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01693	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  01696	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0169e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  016a6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  016ad	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  016b4	73 4b		 jae	 SHORT $LN168@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  016b6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  016be	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  016c5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  016c8	88 84 24 ba 05
	00 00		 mov	 BYTE PTR tv828[rsp], al
  016cf	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  016d7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  016de	48 ff c0	 inc	 rax
  016e1	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  016e9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  016f0	0f b6 84 24 ba
	05 00 00	 movzx	 eax, BYTE PTR tv828[rsp]
  016f8	88 84 24 38 05
	00 00		 mov	 BYTE PTR $T39[rsp], al
  016ff	eb 6e		 jmp	 SHORT $LN167@stbi__bmp_
$LN168@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  01701	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01709	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0170d	74 58		 je	 SHORT $LN169@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  0170f	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01717	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0171c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01724	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0172b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0172e	88 84 24 bb 05
	00 00		 mov	 BYTE PTR tv837[rsp], al
  01735	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0173d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01744	48 ff c0	 inc	 rax
  01747	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0174f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  01756	0f b6 84 24 bb
	05 00 00	 movzx	 eax, BYTE PTR tv837[rsp]
  0175e	88 84 24 38 05
	00 00		 mov	 BYTE PTR $T39[rsp], al
  01765	eb 08		 jmp	 SHORT $LN167@stbi__bmp_
$LN169@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  01767	c6 84 24 38 05
	00 00 00	 mov	 BYTE PTR $T39[rsp], 0
$LN167@stbi__bmp_:

; 5682 :                out[z+1] = stbi__get8(s);

  0176f	0f b6 84 24 38
	05 00 00	 movzx	 eax, BYTE PTR $T39[rsp]
  01777	8b 8c 24 f8 04
	00 00		 mov	 ecx, DWORD PTR z$22[rsp]
  0177e	ff c1		 inc	 ecx
  01780	48 63 c9	 movsxd	 rcx, ecx
  01783	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01788	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0178b	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01793	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0179b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  017a2	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  017a9	73 4b		 jae	 SHORT $LN172@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  017ab	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  017b3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  017ba	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  017bd	88 84 24 bc 05
	00 00		 mov	 BYTE PTR tv845[rsp], al
  017c4	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  017cc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  017d3	48 ff c0	 inc	 rax
  017d6	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  017de	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  017e5	0f b6 84 24 bc
	05 00 00	 movzx	 eax, BYTE PTR tv845[rsp]
  017ed	88 84 24 39 05
	00 00		 mov	 BYTE PTR $T40[rsp], al
  017f4	eb 6e		 jmp	 SHORT $LN171@stbi__bmp_
$LN172@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  017f6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  017fe	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01802	74 58		 je	 SHORT $LN173@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  01804	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0180c	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  01811	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01819	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01820	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01823	88 84 24 bd 05
	00 00		 mov	 BYTE PTR tv854[rsp], al
  0182a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01832	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01839	48 ff c0	 inc	 rax
  0183c	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01844	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0184b	0f b6 84 24 bd
	05 00 00	 movzx	 eax, BYTE PTR tv854[rsp]
  01853	88 84 24 39 05
	00 00		 mov	 BYTE PTR $T40[rsp], al
  0185a	eb 08		 jmp	 SHORT $LN171@stbi__bmp_
$LN173@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  0185c	c6 84 24 39 05
	00 00 00	 mov	 BYTE PTR $T40[rsp], 0
$LN171@stbi__bmp_:

; 5683 :                out[z+0] = stbi__get8(s);

  01864	0f b6 84 24 39
	05 00 00	 movzx	 eax, BYTE PTR $T40[rsp]
  0186c	8b 8c 24 f8 04
	00 00		 mov	 ecx, DWORD PTR z$22[rsp]
  01873	48 63 c9	 movsxd	 rcx, ecx
  01876	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  0187b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5684 :                z += 3;

  0187e	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  01885	83 c0 03	 add	 eax, 3
  01888	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax

; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);

  0188f	83 bc 24 fc 04
	00 00 02	 cmp	 DWORD PTR easy$23[rsp], 2
  01897	0f 85 ed 00 00
	00		 jne	 $LN125@stbi__bmp_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0189d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  018a5	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  018ad	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  018b4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  018bb	73 4b		 jae	 SHORT $LN176@stbi__bmp_

; 1615 :       return *s->img_buffer++;

  018bd	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  018c5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  018cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  018cf	88 84 24 be 05
	00 00		 mov	 BYTE PTR tv862[rsp], al
  018d6	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  018de	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  018e5	48 ff c0	 inc	 rax
  018e8	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  018f0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  018f7	0f b6 84 24 be
	05 00 00	 movzx	 eax, BYTE PTR tv862[rsp]
  018ff	88 84 24 3a 05
	00 00		 mov	 BYTE PTR $T41[rsp], al
  01906	eb 6e		 jmp	 SHORT $LN175@stbi__bmp_
$LN176@stbi__bmp_:

; 1616 :    if (s->read_from_callbacks) {

  01908	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01910	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01914	74 58		 je	 SHORT $LN177@stbi__bmp_

; 1617 :       stbi__refill_buffer(s);

  01916	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0191e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  01923	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0192b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01932	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01935	88 84 24 bf 05
	00 00		 mov	 BYTE PTR tv871[rsp], al
  0193c	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01944	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0194b	48 ff c0	 inc	 rax
  0194e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01956	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0195d	0f b6 84 24 bf
	05 00 00	 movzx	 eax, BYTE PTR tv871[rsp]
  01965	88 84 24 3a 05
	00 00		 mov	 BYTE PTR $T41[rsp], al
  0196c	eb 08		 jmp	 SHORT $LN175@stbi__bmp_
$LN177@stbi__bmp_:

; 1619 :    }
; 1620 :    return 0;

  0196e	c6 84 24 3a 05
	00 00 00	 mov	 BYTE PTR $T41[rsp], 0
$LN175@stbi__bmp_:

; 5685 :                a = (easy == 2 ? stbi__get8(s) : 255);

  01976	0f b6 84 24 3a
	05 00 00	 movzx	 eax, BYTE PTR $T41[rsp]
  0197e	0f b6 c0	 movzx	 eax, al
  01981	89 84 24 c0 05
	00 00		 mov	 DWORD PTR tv505[rsp], eax
  01988	eb 0b		 jmp	 SHORT $LN126@stbi__bmp_
$LN125@stbi__bmp_:
  0198a	c7 84 24 c0 05
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv505[rsp], 255 ; 000000ffH
$LN126@stbi__bmp_:
  01995	0f b6 84 24 c0
	05 00 00	 movzx	 eax, BYTE PTR tv505[rsp]
  0199d	88 84 24 00 05
	00 00		 mov	 BYTE PTR a$24[rsp], al

; 5686 :                all_a |= a;

  019a4	0f b6 84 24 00
	05 00 00	 movzx	 eax, BYTE PTR a$24[rsp]
  019ac	8b 4c 24 48	 mov	 ecx, DWORD PTR all_a$[rsp]
  019b0	0b c8		 or	 ecx, eax
  019b2	8b c1		 mov	 eax, ecx
  019b4	89 44 24 48	 mov	 DWORD PTR all_a$[rsp], eax

; 5687 :                if (target == 4) out[z++] = a;

  019b8	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  019c0	75 28		 jne	 SHORT $LN89@stbi__bmp_
  019c2	48 63 84 24 f8
	04 00 00	 movsxd	 rax, DWORD PTR z$22[rsp]
  019ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  019cf	0f b6 94 24 00
	05 00 00	 movzx	 edx, BYTE PTR a$24[rsp]
  019d7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  019da	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  019e1	ff c0		 inc	 eax
  019e3	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax
$LN89@stbi__bmp_:

; 5688 :             }

  019ea	e9 8a fb ff ff	 jmp	 $LN20@stbi__bmp_
$LN21@stbi__bmp_:

; 5689 :          } else {

  019ef	e9 fe 01 00 00	 jmp	 $LN88@stbi__bmp_
$LN87@stbi__bmp_:

; 5690 :             int bpp = info.bpp;

  019f4	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR info$[rsp]
  019fb	89 84 24 04 05
	00 00		 mov	 DWORD PTR bpp$25[rsp], eax

; 5691 :             for (i=0; i < (int) s->img_x; ++i) {

  01a02	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01a0d	eb 10		 jmp	 SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
  01a0f	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01a16	ff c0		 inc	 eax
  01a18	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__bmp_:
  01a1f	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01a27	8b 00		 mov	 eax, DWORD PTR [rax]
  01a29	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01a30	0f 8d bc 01 00
	00		 jge	 $LN24@stbi__bmp_

; 5692 :                stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

  01a36	83 bc 24 04 05
	00 00 10	 cmp	 DWORD PTR bpp$25[rsp], 16
  01a3e	75 16		 jne	 SHORT $LN127@stbi__bmp_
  01a40	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01a48	e8 00 00 00 00	 call	 stbi__get16le
  01a4d	89 84 24 c4 05
	00 00		 mov	 DWORD PTR tv522[rsp], eax
  01a54	eb 14		 jmp	 SHORT $LN128@stbi__bmp_
$LN127@stbi__bmp_:
  01a56	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01a5e	e8 00 00 00 00	 call	 stbi__get32le
  01a63	89 84 24 c4 05
	00 00		 mov	 DWORD PTR tv522[rsp], eax
$LN128@stbi__bmp_:
  01a6a	8b 84 24 c4 05
	00 00		 mov	 eax, DWORD PTR tv522[rsp]
  01a71	89 84 24 08 05
	00 00		 mov	 DWORD PTR v$26[rsp], eax

; 5693 :                unsigned int a;
; 5694 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

  01a78	8b 44 24 38	 mov	 eax, DWORD PTR mr$[rsp]
  01a7c	8b 8c 24 08 05
	00 00		 mov	 ecx, DWORD PTR v$26[rsp]
  01a83	23 c8		 and	 ecx, eax
  01a85	8b c1		 mov	 eax, ecx
  01a87	44 8b 84 24 e8
	04 00 00	 mov	 r8d, DWORD PTR rcount$18[rsp]
  01a8f	8b 94 24 d8 04
	00 00		 mov	 edx, DWORD PTR rshift$14[rsp]
  01a96	8b c8		 mov	 ecx, eax
  01a98	e8 00 00 00 00	 call	 stbi__shiftsigned
  01a9d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01aa2	48 63 8c 24 f8
	04 00 00	 movsxd	 rcx, DWORD PTR z$22[rsp]
  01aaa	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01aaf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01ab2	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  01ab9	ff c0		 inc	 eax
  01abb	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax

; 5695 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

  01ac2	8b 44 24 3c	 mov	 eax, DWORD PTR mg$[rsp]
  01ac6	8b 8c 24 08 05
	00 00		 mov	 ecx, DWORD PTR v$26[rsp]
  01acd	23 c8		 and	 ecx, eax
  01acf	8b c1		 mov	 eax, ecx
  01ad1	44 8b 84 24 ec
	04 00 00	 mov	 r8d, DWORD PTR gcount$19[rsp]
  01ad9	8b 94 24 dc 04
	00 00		 mov	 edx, DWORD PTR gshift$15[rsp]
  01ae0	8b c8		 mov	 ecx, eax
  01ae2	e8 00 00 00 00	 call	 stbi__shiftsigned
  01ae7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01aec	48 63 8c 24 f8
	04 00 00	 movsxd	 rcx, DWORD PTR z$22[rsp]
  01af4	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01af9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01afc	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  01b03	ff c0		 inc	 eax
  01b05	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax

; 5696 :                out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

  01b0c	8b 44 24 40	 mov	 eax, DWORD PTR mb$[rsp]
  01b10	8b 8c 24 08 05
	00 00		 mov	 ecx, DWORD PTR v$26[rsp]
  01b17	23 c8		 and	 ecx, eax
  01b19	8b c1		 mov	 eax, ecx
  01b1b	44 8b 84 24 f0
	04 00 00	 mov	 r8d, DWORD PTR bcount$20[rsp]
  01b23	8b 94 24 e0 04
	00 00		 mov	 edx, DWORD PTR bshift$16[rsp]
  01b2a	8b c8		 mov	 ecx, eax
  01b2c	e8 00 00 00 00	 call	 stbi__shiftsigned
  01b31	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01b36	48 63 8c 24 f8
	04 00 00	 movsxd	 rcx, DWORD PTR z$22[rsp]
  01b3e	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01b43	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01b46	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  01b4d	ff c0		 inc	 eax
  01b4f	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax

; 5697 :                a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

  01b56	83 7c 24 44 00	 cmp	 DWORD PTR ma$[rsp], 0
  01b5b	74 2e		 je	 SHORT $LN129@stbi__bmp_
  01b5d	8b 44 24 44	 mov	 eax, DWORD PTR ma$[rsp]
  01b61	8b 8c 24 08 05
	00 00		 mov	 ecx, DWORD PTR v$26[rsp]
  01b68	23 c8		 and	 ecx, eax
  01b6a	8b c1		 mov	 eax, ecx
  01b6c	44 8b 84 24 f4
	04 00 00	 mov	 r8d, DWORD PTR acount$21[rsp]
  01b74	8b 94 24 e4 04
	00 00		 mov	 edx, DWORD PTR ashift$17[rsp]
  01b7b	8b c8		 mov	 ecx, eax
  01b7d	e8 00 00 00 00	 call	 stbi__shiftsigned
  01b82	89 84 24 c8 05
	00 00		 mov	 DWORD PTR tv562[rsp], eax
  01b89	eb 0b		 jmp	 SHORT $LN130@stbi__bmp_
$LN129@stbi__bmp_:
  01b8b	c7 84 24 c8 05
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv562[rsp], 255 ; 000000ffH
$LN130@stbi__bmp_:
  01b96	8b 84 24 c8 05
	00 00		 mov	 eax, DWORD PTR tv562[rsp]
  01b9d	89 84 24 0c 05
	00 00		 mov	 DWORD PTR a$27[rsp], eax

; 5698 :                all_a |= a;

  01ba4	8b 84 24 0c 05
	00 00		 mov	 eax, DWORD PTR a$27[rsp]
  01bab	8b 4c 24 48	 mov	 ecx, DWORD PTR all_a$[rsp]
  01baf	0b c8		 or	 ecx, eax
  01bb1	8b c1		 mov	 eax, ecx
  01bb3	89 44 24 48	 mov	 DWORD PTR all_a$[rsp], eax

; 5699 :                if (target == 4) out[z++] = STBI__BYTECAST(a);

  01bb7	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  01bbf	75 2c		 jne	 SHORT $LN90@stbi__bmp_
  01bc1	8b 84 24 0c 05
	00 00		 mov	 eax, DWORD PTR a$27[rsp]
  01bc8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01bcd	48 63 8c 24 f8
	04 00 00	 movsxd	 rcx, DWORD PTR z$22[rsp]
  01bd5	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  01bda	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01bdd	8b 84 24 f8 04
	00 00		 mov	 eax, DWORD PTR z$22[rsp]
  01be4	ff c0		 inc	 eax
  01be6	89 84 24 f8 04
	00 00		 mov	 DWORD PTR z$22[rsp], eax
$LN90@stbi__bmp_:

; 5700 :             }

  01bed	e9 1d fe ff ff	 jmp	 $LN23@stbi__bmp_
$LN24@stbi__bmp_:
$LN88@stbi__bmp_:

; 5701 :          }
; 5702 :          stbi__skip(s, pad);

  01bf2	8b 94 24 78 04
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  01bf9	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01c01	e8 00 00 00 00	 call	 stbi__skip
  01c06	90		 npad	 1

; 5703 :       }

  01c07	e9 2a f9 ff ff	 jmp	 $LN17@stbi__bmp_
$LN18@stbi__bmp_:
$LN55@stbi__bmp_:

; 5704 :    }
; 5705 : 
; 5706 :    // if alpha channel is all 0s, replace with all 255s
; 5707 :    if (target == 4 && all_a == 0)

  01c0c	83 bc 24 7c 04
	00 00 04	 cmp	 DWORD PTR target$[rsp], 4
  01c14	75 59		 jne	 SHORT $LN91@stbi__bmp_
  01c16	83 7c 24 48 00	 cmp	 DWORD PTR all_a$[rsp], 0
  01c1b	75 52		 jne	 SHORT $LN91@stbi__bmp_

; 5708 :       for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)

  01c1d	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01c25	8b 00		 mov	 eax, DWORD PTR [rax]
  01c27	c1 e0 02	 shl	 eax, 2
  01c2a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01c32	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  01c36	ff c8		 dec	 eax
  01c38	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
  01c3f	eb 11		 jmp	 SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
  01c41	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01c48	83 e8 04	 sub	 eax, 4
  01c4b	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__bmp_:
  01c52	83 bc 24 68 04
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  01c5a	7c 13		 jl	 SHORT $LN27@stbi__bmp_

; 5709 :          out[i] = 255;

  01c5c	48 63 84 24 68
	04 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01c64	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01c69	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  01c6d	eb d2		 jmp	 SHORT $LN26@stbi__bmp_
$LN27@stbi__bmp_:
$LN91@stbi__bmp_:

; 5710 : 
; 5711 :    if (flip_vertically) {

  01c6f	83 bc 24 74 04
	00 00 00	 cmp	 DWORD PTR flip_vertically$[rsp], 0
  01c77	0f 84 44 01 00
	00		 je	 $LN92@stbi__bmp_

; 5712 :       stbi_uc t;
; 5713 :       for (j=0; j < (int) s->img_y>>1; ++j) {

  01c7d	c7 84 24 6c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  01c88	eb 10		 jmp	 SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
  01c8a	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  01c91	ff c0		 inc	 eax
  01c93	89 84 24 6c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN31@stbi__bmp_:
  01c9a	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01ca2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01ca5	d1 f8		 sar	 eax, 1
  01ca7	39 84 24 6c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  01cae	0f 8d 0d 01 00
	00		 jge	 $LN30@stbi__bmp_

; 5714 :          stbi_uc *p1 = out +      j     *s->img_x*target;

  01cb4	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01cbc	8b 8c 24 6c 04
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  01cc3	0f af 08	 imul	 ecx, DWORD PTR [rax]
  01cc6	8b c1		 mov	 eax, ecx
  01cc8	0f af 84 24 7c
	04 00 00	 imul	 eax, DWORD PTR target$[rsp]
  01cd0	8b c0		 mov	 eax, eax
  01cd2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01cd7	48 03 c8	 add	 rcx, rax
  01cda	48 8b c1	 mov	 rax, rcx
  01cdd	48 89 84 24 18
	05 00 00	 mov	 QWORD PTR p1$29[rsp], rax

; 5715 :          stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

  01ce5	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01ced	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01cf0	ff c8		 dec	 eax
  01cf2	2b 84 24 6c 04
	00 00		 sub	 eax, DWORD PTR j$[rsp]
  01cf9	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01d01	0f af 01	 imul	 eax, DWORD PTR [rcx]
  01d04	0f af 84 24 7c
	04 00 00	 imul	 eax, DWORD PTR target$[rsp]
  01d0c	8b c0		 mov	 eax, eax
  01d0e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01d13	48 03 c8	 add	 rcx, rax
  01d16	48 8b c1	 mov	 rax, rcx
  01d19	48 89 84 24 20
	05 00 00	 mov	 QWORD PTR p2$30[rsp], rax

; 5716 :          for (i=0; i < (int) s->img_x*target; ++i) {

  01d21	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01d2c	eb 10		 jmp	 SHORT $LN34@stbi__bmp_
$LN32@stbi__bmp_:
  01d2e	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01d35	ff c0		 inc	 eax
  01d37	89 84 24 68 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN34@stbi__bmp_:
  01d3e	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01d46	8b 00		 mov	 eax, DWORD PTR [rax]
  01d48	0f af 84 24 7c
	04 00 00	 imul	 eax, DWORD PTR target$[rsp]
  01d50	39 84 24 68 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01d57	7d 63		 jge	 SHORT $LN33@stbi__bmp_

; 5717 :             t = p1[i]; p1[i] = p2[i]; p2[i] = t;

  01d59	48 63 84 24 68
	04 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01d61	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR p1$29[rsp]
  01d69	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01d6d	88 84 24 10 05
	00 00		 mov	 BYTE PTR t$28[rsp], al
  01d74	48 63 84 24 68
	04 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01d7c	48 63 8c 24 68
	04 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  01d84	48 8b 94 24 18
	05 00 00	 mov	 rdx, QWORD PTR p1$29[rsp]
  01d8c	4c 8b 84 24 20
	05 00 00	 mov	 r8, QWORD PTR p2$30[rsp]
  01d94	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01d99	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01d9c	48 63 84 24 68
	04 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01da4	48 8b 8c 24 20
	05 00 00	 mov	 rcx, QWORD PTR p2$30[rsp]
  01dac	0f b6 94 24 10
	05 00 00	 movzx	 edx, BYTE PTR t$28[rsp]
  01db4	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5718 :          }

  01db7	e9 72 ff ff ff	 jmp	 $LN32@stbi__bmp_
$LN33@stbi__bmp_:

; 5719 :       }

  01dbc	e9 c9 fe ff ff	 jmp	 $LN29@stbi__bmp_
$LN30@stbi__bmp_:
$LN92@stbi__bmp_:

; 5720 :    }
; 5721 : 
; 5722 :    if (req_comp && req_comp != target) {

  01dc1	83 bc 24 10 06
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  01dc9	74 57		 je	 SHORT $LN93@stbi__bmp_
  01dcb	8b 84 24 7c 04
	00 00		 mov	 eax, DWORD PTR target$[rsp]
  01dd2	39 84 24 10 06
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  01dd9	74 47		 je	 SHORT $LN93@stbi__bmp_

; 5723 :       out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

  01ddb	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01de3	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01de6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01dea	48 8b 84 24 f0
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01df2	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  01df5	44 8b 84 24 10
	06 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  01dfd	8b 94 24 7c 04
	00 00		 mov	 edx, DWORD PTR target$[rsp]
  01e04	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  01e09	e8 00 00 00 00	 call	 stbi__convert_format
  01e0e	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 5724 :       if (out == NULL) return out; // stbi__convert_format frees input on failure

  01e13	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  01e19	75 07		 jne	 SHORT $LN94@stbi__bmp_
  01e1b	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  01e20	eb 4e		 jmp	 SHORT $LN1@stbi__bmp_
$LN94@stbi__bmp_:
$LN93@stbi__bmp_:

; 5725 :    }
; 5726 : 
; 5727 :    *x = s->img_x;

  01e22	48 8b 84 24 f8
	05 00 00	 mov	 rax, QWORD PTR x$[rsp]
  01e2a	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01e32	8b 09		 mov	 ecx, DWORD PTR [rcx]
  01e34	89 08		 mov	 DWORD PTR [rax], ecx

; 5728 :    *y = s->img_y;

  01e36	48 8b 84 24 00
	06 00 00	 mov	 rax, QWORD PTR y$[rsp]
  01e3e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01e46	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  01e49	89 08		 mov	 DWORD PTR [rax], ecx

; 5729 :    if (comp) *comp = s->img_n;

  01e4b	48 83 bc 24 08
	06 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  01e54	74 15		 je	 SHORT $LN95@stbi__bmp_
  01e56	48 8b 84 24 08
	06 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  01e5e	48 8b 8c 24 f0
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01e66	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  01e69	89 08		 mov	 DWORD PTR [rax], ecx
$LN95@stbi__bmp_:

; 5730 :    return out;

  01e6b	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__bmp_:

; 5731 : }

  01e70	48 8b f8	 mov	 rdi, rax
  01e73	48 8b cc	 mov	 rcx, rsp
  01e76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmp_load$rtcFrameData
  01e7d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01e82	48 8b c7	 mov	 rax, rdi
  01e85	48 8b 8c 24 d0
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01e8d	48 33 cc	 xor	 rcx, rsp
  01e90	e8 00 00 00 00	 call	 __security_check_cookie
  01e95	48 81 c4 e0 05
	00 00		 add	 rsp, 1504		; 000005e0H
  01e9c	5f		 pop	 rdi
  01e9d	c3		 ret	 0
stbi__bmp_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv65 = 32
bits_per_pixel$ = 64
is_grey$ = 72
is_rgb16$ = 80
stbi__tga_get_comp PROC

; 5739 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5740 :    // only RGB or RGBA (incl. 16bit) or grey allowed
; 5741 :    if (is_rgb16) *is_rgb16 = 0;

  0001e	48 83 7c 24 50
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00024	74 0b		 je	 SHORT $LN4@stbi__tga_
  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@stbi__tga_:

; 5742 :    switch(bits_per_pixel) {

  00031	8b 44 24 40	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  00035	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00039	83 7c 24 20 08	 cmp	 DWORD PTR tv65[rsp], 8
  0003e	74 1e		 je	 SHORT $LN5@stbi__tga_
  00040	83 7c 24 20 0f	 cmp	 DWORD PTR tv65[rsp], 15
  00045	74 2c		 je	 SHORT $LN8@stbi__tga_
  00047	83 7c 24 20 10	 cmp	 DWORD PTR tv65[rsp], 16
  0004c	74 17		 je	 SHORT $LN6@stbi__tga_
  0004e	83 7c 24 20 18	 cmp	 DWORD PTR tv65[rsp], 24
  00053	74 38		 je	 SHORT $LN10@stbi__tga_
  00055	83 7c 24 20 20	 cmp	 DWORD PTR tv65[rsp], 32	; 00000020H
  0005a	74 31		 je	 SHORT $LN11@stbi__tga_
  0005c	eb 3e		 jmp	 SHORT $LN12@stbi__tga_
$LN5@stbi__tga_:

; 5743 :       case 8:  return STBI_grey;

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	eb 39		 jmp	 SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5744 :       case 16: if(is_grey) return STBI_grey_alpha;

  00065	83 7c 24 48 00	 cmp	 DWORD PTR is_grey$[rsp], 0
  0006a	74 07		 je	 SHORT $LN7@stbi__tga_
  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	eb 2b		 jmp	 SHORT $LN1@stbi__tga_
$LN7@stbi__tga_:
$LN8@stbi__tga_:

; 5745 :                // fallthrough
; 5746 :       case 15: if(is_rgb16) *is_rgb16 = 1;

  00073	48 83 7c 24 50
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00079	74 0b		 je	 SHORT $LN9@stbi__tga_
  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  00080	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN9@stbi__tga_:

; 5747 :                return STBI_rgb;

  00086	b8 03 00 00 00	 mov	 eax, 3
  0008b	eb 11		 jmp	 SHORT $LN1@stbi__tga_
$LN10@stbi__tga_:
$LN11@stbi__tga_:

; 5748 :       case 24: // fallthrough
; 5749 :       case 32: return bits_per_pixel/8;

  0008d	8b 44 24 40	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  00091	99		 cdq
  00092	83 e2 07	 and	 edx, 7
  00095	03 c2		 add	 eax, edx
  00097	c1 f8 03	 sar	 eax, 3
  0009a	eb 02		 jmp	 SHORT $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5750 :       default: return 0;

  0009c	33 c0		 xor	 eax, eax
$LN1@stbi__tga_:

; 5751 :    }
; 5752 : }

  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
stbi__tga_get_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tga_w$ = 32
tga_h$ = 36
tga_comp$ = 40
tga_image_type$ = 44
tga_bits_per_pixel$ = 48
tga_colormap_bpp$ = 52
sz$ = 56
tga_colormap_type$ = 60
$T1 = 64
$T2 = 65
$T3 = 66
$T4 = 67
tv170 = 68
tv179 = 69
tv187 = 70
tv196 = 71
tv204 = 72
tv213 = 73
tv221 = 74
tv230 = 75
tv238 = 76
tv247 = 77
tv255 = 78
tv264 = 79
tv153 = 80
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
stbi__tga_info PROC

; 5755 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00025	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0002a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00036	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0003d	73 30		 jae	 SHORT $LN21@stbi__tga_

; 1615 :       return *s->img_buffer++;

  0003f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00044	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	88 44 24 44	 mov	 BYTE PTR tv170[rsp], al
  00052	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00057	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0005e	48 ff c0	 inc	 rax
  00061	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00066	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0006d	eb 43		 jmp	 SHORT $LN20@stbi__tga_
$LN21@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00074	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00078	74 38		 je	 SHORT $LN22@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  0007a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0007f	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00084	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00089	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00090	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00093	88 44 24 45	 mov	 BYTE PTR tv179[rsp], al
  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0009c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000a3	48 ff c0	 inc	 rax
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000ab	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN22@stbi__tga_:
$LN20@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000bc	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000c3	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000ca	73 39		 jae	 SHORT $LN25@stbi__tga_

; 1615 :       return *s->img_buffer++;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000d1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000db	88 44 24 46	 mov	 BYTE PTR tv187[rsp], al
  000df	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000e4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000eb	48 ff c0	 inc	 rax
  000ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000f3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000fa	0f b6 44 24 46	 movzx	 eax, BYTE PTR tv187[rsp]
  000ff	88 44 24 40	 mov	 BYTE PTR $T1[rsp], al
  00103	eb 53		 jmp	 SHORT $LN24@stbi__tga_
$LN25@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00105	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0010a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0010e	74 43		 je	 SHORT $LN26@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00110	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00115	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0011a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0011f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00126	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00129	88 44 24 47	 mov	 BYTE PTR tv196[rsp], al
  0012d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00132	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00139	48 ff c0	 inc	 rax
  0013c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00141	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00148	0f b6 44 24 47	 movzx	 eax, BYTE PTR tv196[rsp]
  0014d	88 44 24 40	 mov	 BYTE PTR $T1[rsp], al
  00151	eb 05		 jmp	 SHORT $LN24@stbi__tga_
$LN26@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00153	c6 44 24 40 00	 mov	 BYTE PTR $T1[rsp], 0
$LN24@stbi__tga_:

; 5756 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5757 :     int sz, tga_colormap_type;
; 5758 :     stbi__get8(s);                   // discard Offset
; 5759 :     tga_colormap_type = stbi__get8(s); // colormap type

  00158	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T1[rsp]
  0015d	0f b6 c0	 movzx	 eax, al
  00160	89 44 24 3c	 mov	 DWORD PTR tga_colormap_type$[rsp], eax

; 5760 :     if( tga_colormap_type > 1 ) {

  00164	83 7c 24 3c 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00169	7e 11		 jle	 SHORT $LN2@stbi__tga_

; 5761 :         stbi__rewind(s);

  0016b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00170	e8 00 00 00 00	 call	 stbi__rewind

; 5762 :         return 0;      // only RGB or indexed allowed

  00175	33 c0		 xor	 eax, eax
  00177	e9 86 04 00 00	 jmp	 $LN1@stbi__tga_
$LN2@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0017c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00181	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00186	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0018d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00194	73 39		 jae	 SHORT $LN29@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0019b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a5	88 44 24 48	 mov	 BYTE PTR tv204[rsp], al
  001a9	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001ae	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001b5	48 ff c0	 inc	 rax
  001b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001bd	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001c4	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv204[rsp]
  001c9	88 44 24 41	 mov	 BYTE PTR $T2[rsp], al
  001cd	eb 53		 jmp	 SHORT $LN28@stbi__tga_
$LN29@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  001cf	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001d4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001d8	74 43		 je	 SHORT $LN30@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  001da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001df	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001e4	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001e9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f3	88 44 24 49	 mov	 BYTE PTR tv213[rsp], al
  001f7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001fc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00203	48 ff c0	 inc	 rax
  00206	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0020b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00212	0f b6 44 24 49	 movzx	 eax, BYTE PTR tv213[rsp]
  00217	88 44 24 41	 mov	 BYTE PTR $T2[rsp], al
  0021b	eb 05		 jmp	 SHORT $LN28@stbi__tga_
$LN30@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  0021d	c6 44 24 41 00	 mov	 BYTE PTR $T2[rsp], 0
$LN28@stbi__tga_:

; 5763 :     }
; 5764 :     tga_image_type = stbi__get8(s); // image type

  00222	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T2[rsp]
  00227	0f b6 c0	 movzx	 eax, al
  0022a	89 44 24 2c	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5765 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image

  0022e	83 7c 24 3c 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00233	0f 85 2d 01 00
	00		 jne	 $LN3@stbi__tga_

; 5766 :         if (tga_image_type != 1 && tga_image_type != 9) {

  00239	83 7c 24 2c 01	 cmp	 DWORD PTR tga_image_type$[rsp], 1
  0023e	74 18		 je	 SHORT $LN5@stbi__tga_
  00240	83 7c 24 2c 09	 cmp	 DWORD PTR tga_image_type$[rsp], 9
  00245	74 11		 je	 SHORT $LN5@stbi__tga_

; 5767 :             stbi__rewind(s);

  00247	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0024c	e8 00 00 00 00	 call	 stbi__rewind

; 5768 :             return 0;

  00251	33 c0		 xor	 eax, eax
  00253	e9 aa 03 00 00	 jmp	 $LN1@stbi__tga_
$LN5@stbi__tga_:

; 5769 :         }
; 5770 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  00258	ba 04 00 00 00	 mov	 edx, 4
  0025d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00262	e8 00 00 00 00	 call	 stbi__skip

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00267	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0026c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00271	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00278	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0027f	73 39		 jae	 SHORT $LN33@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00286	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0028d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00290	88 44 24 4a	 mov	 BYTE PTR tv221[rsp], al
  00294	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00299	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002a0	48 ff c0	 inc	 rax
  002a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002a8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002af	0f b6 44 24 4a	 movzx	 eax, BYTE PTR tv221[rsp]
  002b4	88 44 24 42	 mov	 BYTE PTR $T3[rsp], al
  002b8	eb 53		 jmp	 SHORT $LN32@stbi__tga_
$LN33@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  002ba	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002bf	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002c3	74 43		 je	 SHORT $LN34@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  002c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002ca	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002cf	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002d4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002de	88 44 24 4b	 mov	 BYTE PTR tv230[rsp], al
  002e2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002e7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002ee	48 ff c0	 inc	 rax
  002f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002f6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002fd	0f b6 44 24 4b	 movzx	 eax, BYTE PTR tv230[rsp]
  00302	88 44 24 42	 mov	 BYTE PTR $T3[rsp], al
  00306	eb 05		 jmp	 SHORT $LN32@stbi__tga_
$LN34@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00308	c6 44 24 42 00	 mov	 BYTE PTR $T3[rsp], 0
$LN32@stbi__tga_:

; 5771 :         sz = stbi__get8(s);    //   check bits per palette color entry

  0030d	0f b6 44 24 42	 movzx	 eax, BYTE PTR $T3[rsp]
  00312	0f b6 c0	 movzx	 eax, al
  00315	89 44 24 38	 mov	 DWORD PTR sz$[rsp], eax

; 5772 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {

  00319	83 7c 24 38 08	 cmp	 DWORD PTR sz$[rsp], 8
  0031e	74 2d		 je	 SHORT $LN6@stbi__tga_
  00320	83 7c 24 38 0f	 cmp	 DWORD PTR sz$[rsp], 15
  00325	74 26		 je	 SHORT $LN6@stbi__tga_
  00327	83 7c 24 38 10	 cmp	 DWORD PTR sz$[rsp], 16
  0032c	74 1f		 je	 SHORT $LN6@stbi__tga_
  0032e	83 7c 24 38 18	 cmp	 DWORD PTR sz$[rsp], 24
  00333	74 18		 je	 SHORT $LN6@stbi__tga_
  00335	83 7c 24 38 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  0033a	74 11		 je	 SHORT $LN6@stbi__tga_

; 5773 :             stbi__rewind(s);

  0033c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00341	e8 00 00 00 00	 call	 stbi__rewind

; 5774 :             return 0;

  00346	33 c0		 xor	 eax, eax
  00348	e9 b5 02 00 00	 jmp	 $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5775 :         }
; 5776 :         stbi__skip(s,4);       // skip image x and y origin

  0034d	ba 04 00 00 00	 mov	 edx, 4
  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00357	e8 00 00 00 00	 call	 stbi__skip

; 5777 :         tga_colormap_bpp = sz;

  0035c	8b 44 24 38	 mov	 eax, DWORD PTR sz$[rsp]
  00360	89 44 24 34	 mov	 DWORD PTR tga_colormap_bpp$[rsp], eax

; 5778 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE

  00364	eb 44		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5779 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {

  00366	83 7c 24 2c 02	 cmp	 DWORD PTR tga_image_type$[rsp], 2
  0036b	74 26		 je	 SHORT $LN7@stbi__tga_
  0036d	83 7c 24 2c 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  00372	74 1f		 je	 SHORT $LN7@stbi__tga_
  00374	83 7c 24 2c 0a	 cmp	 DWORD PTR tga_image_type$[rsp], 10
  00379	74 18		 je	 SHORT $LN7@stbi__tga_
  0037b	83 7c 24 2c 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  00380	74 11		 je	 SHORT $LN7@stbi__tga_

; 5780 :             stbi__rewind(s);

  00382	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00387	e8 00 00 00 00	 call	 stbi__rewind

; 5781 :             return 0; // only RGB or grey allowed, +/- RLE

  0038c	33 c0		 xor	 eax, eax
  0038e	e9 6f 02 00 00	 jmp	 $LN1@stbi__tga_
$LN7@stbi__tga_:

; 5782 :         }
; 5783 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

  00393	ba 09 00 00 00	 mov	 edx, 9
  00398	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0039d	e8 00 00 00 00	 call	 stbi__skip

; 5784 :         tga_colormap_bpp = 0;

  003a2	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tga_colormap_bpp$[rsp], 0
$LN4@stbi__tga_:

; 5785 :     }
; 5786 :     tga_w = stbi__get16le(s);

  003aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003af	e8 00 00 00 00	 call	 stbi__get16le
  003b4	89 44 24 20	 mov	 DWORD PTR tga_w$[rsp], eax

; 5787 :     if( tga_w < 1 ) {

  003b8	83 7c 24 20 01	 cmp	 DWORD PTR tga_w$[rsp], 1
  003bd	7d 11		 jge	 SHORT $LN8@stbi__tga_

; 5788 :         stbi__rewind(s);

  003bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003c4	e8 00 00 00 00	 call	 stbi__rewind

; 5789 :         return 0;   // test width

  003c9	33 c0		 xor	 eax, eax
  003cb	e9 32 02 00 00	 jmp	 $LN1@stbi__tga_
$LN8@stbi__tga_:

; 5790 :     }
; 5791 :     tga_h = stbi__get16le(s);

  003d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003d5	e8 00 00 00 00	 call	 stbi__get16le
  003da	89 44 24 24	 mov	 DWORD PTR tga_h$[rsp], eax

; 5792 :     if( tga_h < 1 ) {

  003de	83 7c 24 24 01	 cmp	 DWORD PTR tga_h$[rsp], 1
  003e3	7d 11		 jge	 SHORT $LN9@stbi__tga_

; 5793 :         stbi__rewind(s);

  003e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003ea	e8 00 00 00 00	 call	 stbi__rewind

; 5794 :         return 0;   // test height

  003ef	33 c0		 xor	 eax, eax
  003f1	e9 0c 02 00 00	 jmp	 $LN1@stbi__tga_
$LN9@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  003f6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00400	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00407	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0040e	73 39		 jae	 SHORT $LN37@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00410	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00415	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0041c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0041f	88 44 24 4c	 mov	 BYTE PTR tv238[rsp], al
  00423	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00428	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0042f	48 ff c0	 inc	 rax
  00432	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00437	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0043e	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv238[rsp]
  00443	88 44 24 43	 mov	 BYTE PTR $T4[rsp], al
  00447	eb 53		 jmp	 SHORT $LN36@stbi__tga_
$LN37@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00449	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0044e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00452	74 43		 je	 SHORT $LN38@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00454	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00459	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0045e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00463	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0046a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0046d	88 44 24 4d	 mov	 BYTE PTR tv247[rsp], al
  00471	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00476	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0047d	48 ff c0	 inc	 rax
  00480	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00485	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0048c	0f b6 44 24 4d	 movzx	 eax, BYTE PTR tv247[rsp]
  00491	88 44 24 43	 mov	 BYTE PTR $T4[rsp], al
  00495	eb 05		 jmp	 SHORT $LN36@stbi__tga_
$LN38@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00497	c6 44 24 43 00	 mov	 BYTE PTR $T4[rsp], 0
$LN36@stbi__tga_:

; 5795 :     }
; 5796 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel

  0049c	0f b6 44 24 43	 movzx	 eax, BYTE PTR $T4[rsp]
  004a1	0f b6 c0	 movzx	 eax, al
  004a4	89 44 24 30	 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  004a8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004b2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  004b9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  004c0	73 30		 jae	 SHORT $LN41@stbi__tga_

; 1615 :       return *s->img_buffer++;

  004c2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004c7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004ce	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004d1	88 44 24 4e	 mov	 BYTE PTR tv255[rsp], al
  004d5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004da	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004e1	48 ff c0	 inc	 rax
  004e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004e9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004f0	eb 43		 jmp	 SHORT $LN40@stbi__tga_
$LN41@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  004f2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004f7	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004fb	74 38		 je	 SHORT $LN42@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  004fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00502	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00507	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0050c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00513	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00516	88 44 24 4f	 mov	 BYTE PTR tv264[rsp], al
  0051a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0051f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00526	48 ff c0	 inc	 rax
  00529	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0052e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN42@stbi__tga_:
$LN40@stbi__tga_:

; 5797 :     stbi__get8(s); // ignore alpha bits
; 5798 :     if (tga_colormap_bpp != 0) {

  00535	83 7c 24 34 00	 cmp	 DWORD PTR tga_colormap_bpp$[rsp], 0
  0053a	74 33		 je	 SHORT $LN10@stbi__tga_

; 5799 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

  0053c	83 7c 24 30 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  00541	74 18		 je	 SHORT $LN12@stbi__tga_
  00543	83 7c 24 30 10	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 16
  00548	74 11		 je	 SHORT $LN12@stbi__tga_

; 5800 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5801 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5802 :             stbi__rewind(s);

  0054a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0054f	e8 00 00 00 00	 call	 stbi__rewind

; 5803 :             return 0;

  00554	33 c0		 xor	 eax, eax
  00556	e9 a7 00 00 00	 jmp	 $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5804 :         }
; 5805 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

  0055b	45 33 c0	 xor	 r8d, r8d
  0055e	33 d2		 xor	 edx, edx
  00560	8b 4c 24 34	 mov	 ecx, DWORD PTR tga_colormap_bpp$[rsp]
  00564	e8 00 00 00 00	 call	 stbi__tga_get_comp
  00569	89 44 24 28	 mov	 DWORD PTR tga_comp$[rsp], eax

; 5806 :     } else {

  0056d	eb 34		 jmp	 SHORT $LN11@stbi__tga_
$LN10@stbi__tga_:

; 5807 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

  0056f	83 7c 24 2c 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  00574	74 11		 je	 SHORT $LN18@stbi__tga_
  00576	83 7c 24 2c 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  0057b	74 0a		 je	 SHORT $LN18@stbi__tga_
  0057d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
  00585	eb 08		 jmp	 SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
  00587	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
$LN19@stbi__tga_:
  0058f	45 33 c0	 xor	 r8d, r8d
  00592	8b 54 24 50	 mov	 edx, DWORD PTR tv153[rsp]
  00596	8b 4c 24 30	 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  0059a	e8 00 00 00 00	 call	 stbi__tga_get_comp
  0059f	89 44 24 28	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN11@stbi__tga_:

; 5808 :     }
; 5809 :     if(!tga_comp) {

  005a3	83 7c 24 28 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  005a8	75 0e		 jne	 SHORT $LN13@stbi__tga_

; 5810 :       stbi__rewind(s);

  005aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  005af	e8 00 00 00 00	 call	 stbi__rewind

; 5811 :       return 0;

  005b4	33 c0		 xor	 eax, eax
  005b6	eb 4a		 jmp	 SHORT $LN1@stbi__tga_
$LN13@stbi__tga_:

; 5812 :     }
; 5813 :     if (x) *x = tga_w;

  005b8	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  005be	74 0b		 je	 SHORT $LN14@stbi__tga_
  005c0	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  005c5	8b 4c 24 20	 mov	 ecx, DWORD PTR tga_w$[rsp]
  005c9	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@stbi__tga_:

; 5814 :     if (y) *y = tga_h;

  005cb	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  005d4	74 0e		 je	 SHORT $LN15@stbi__tga_
  005d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  005de	8b 4c 24 24	 mov	 ecx, DWORD PTR tga_h$[rsp]
  005e2	89 08		 mov	 DWORD PTR [rax], ecx
$LN15@stbi__tga_:

; 5815 :     if (comp) *comp = tga_comp;

  005e4	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  005ed	74 0e		 je	 SHORT $LN16@stbi__tga_
  005ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  005f7	8b 4c 24 28	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  005fb	89 08		 mov	 DWORD PTR [rax], ecx
$LN16@stbi__tga_:

; 5816 :     return 1;                   // seems to have passed everything

  005fd	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__tga_:

; 5817 : }

  00602	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00606	5f		 pop	 rdi
  00607	c3		 ret	 0
stbi__tga_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
res$ = 32
sz$ = 36
tga_color_type$ = 40
$T1 = 44
$T2 = 45
$T3 = 46
$T4 = 47
tv152 = 48
tv161 = 49
tv169 = 50
tv178 = 51
tv186 = 52
tv195 = 53
tv203 = 54
tv212 = 55
tv220 = 56
tv229 = 57
s$ = 80
stbi__tga_test PROC

; 5820 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5821 :    int res = 0;

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0001e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00028	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0002f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00036	73 30		 jae	 SHORT $LN14@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00044	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00047	88 44 24 30	 mov	 BYTE PTR tv152[rsp], al
  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00050	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00057	48 ff c0	 inc	 rax
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00066	eb 43		 jmp	 SHORT $LN13@stbi__tga_
$LN14@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00068	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0006d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00071	74 38		 je	 SHORT $LN15@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00078	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00082	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00089	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008c	88 44 24 31	 mov	 BYTE PTR tv161[rsp], al
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00095	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009c	48 ff c0	 inc	 rax
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN15@stbi__tga_:
$LN13@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000bc	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000c3	73 39		 jae	 SHORT $LN18@stbi__tga_

; 1615 :       return *s->img_buffer++;

  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d4	88 44 24 32	 mov	 BYTE PTR tv169[rsp], al
  000d8	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000dd	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000e4	48 ff c0	 inc	 rax
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000ec	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000f3	0f b6 44 24 32	 movzx	 eax, BYTE PTR tv169[rsp]
  000f8	88 44 24 2c	 mov	 BYTE PTR $T1[rsp], al
  000fc	eb 53		 jmp	 SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  000fe	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00103	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00107	74 43		 je	 SHORT $LN19@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0010e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00113	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00118	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0011f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00122	88 44 24 33	 mov	 BYTE PTR tv178[rsp], al
  00126	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0012b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00132	48 ff c0	 inc	 rax
  00135	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0013a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00141	0f b6 44 24 33	 movzx	 eax, BYTE PTR tv178[rsp]
  00146	88 44 24 2c	 mov	 BYTE PTR $T1[rsp], al
  0014a	eb 05		 jmp	 SHORT $LN17@stbi__tga_
$LN19@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  0014c	c6 44 24 2c 00	 mov	 BYTE PTR $T1[rsp], 0
$LN17@stbi__tga_:

; 5822 :    int sz, tga_color_type;
; 5823 :    stbi__get8(s);      //   discard Offset
; 5824 :    tga_color_type = stbi__get8(s);   //   color type

  00151	0f b6 44 24 2c	 movzx	 eax, BYTE PTR $T1[rsp]
  00156	0f b6 c0	 movzx	 eax, al
  00159	89 44 24 28	 mov	 DWORD PTR tga_color_type$[rsp], eax

; 5825 :    if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed

  0015d	83 7c 24 28 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00162	7e 05		 jle	 SHORT $LN2@stbi__tga_
  00164	e9 1a 03 00 00	 jmp	 $errorEnd$33
$LN2@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00173	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0017a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00181	73 39		 jae	 SHORT $LN22@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00183	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00188	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0018f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00192	88 44 24 34	 mov	 BYTE PTR tv186[rsp], al
  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0019b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001a2	48 ff c0	 inc	 rax
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001b1	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv186[rsp]
  001b6	88 44 24 2d	 mov	 BYTE PTR $T2[rsp], al
  001ba	eb 53		 jmp	 SHORT $LN21@stbi__tga_
$LN22@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  001bc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001c1	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001c5	74 43		 je	 SHORT $LN23@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001cc	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001d1	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001d6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001dd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e0	88 44 24 35	 mov	 BYTE PTR tv195[rsp], al
  001e4	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001e9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001f0	48 ff c0	 inc	 rax
  001f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001f8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001ff	0f b6 44 24 35	 movzx	 eax, BYTE PTR tv195[rsp]
  00204	88 44 24 2d	 mov	 BYTE PTR $T2[rsp], al
  00208	eb 05		 jmp	 SHORT $LN21@stbi__tga_
$LN23@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  0020a	c6 44 24 2d 00	 mov	 BYTE PTR $T2[rsp], 0
$LN21@stbi__tga_:

; 5826 :    sz = stbi__get8(s);   //   image type

  0020f	0f b6 44 24 2d	 movzx	 eax, BYTE PTR $T2[rsp]
  00214	0f b6 c0	 movzx	 eax, al
  00217	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5827 :    if ( tga_color_type == 1 ) { // colormapped (paletted) image

  0021b	83 7c 24 28 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00220	0f 85 0e 01 00
	00		 jne	 $LN3@stbi__tga_

; 5828 :       if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

  00226	83 7c 24 24 01	 cmp	 DWORD PTR sz$[rsp], 1
  0022b	74 0c		 je	 SHORT $LN5@stbi__tga_
  0022d	83 7c 24 24 09	 cmp	 DWORD PTR sz$[rsp], 9
  00232	74 05		 je	 SHORT $LN5@stbi__tga_
  00234	e9 4a 02 00 00	 jmp	 $errorEnd$33
$LN5@stbi__tga_:

; 5829 :       stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  00239	ba 04 00 00 00	 mov	 edx, 4
  0023e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00243	e8 00 00 00 00	 call	 stbi__skip

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0024d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00252	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00259	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00260	73 39		 jae	 SHORT $LN26@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00262	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00267	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0026e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00271	88 44 24 36	 mov	 BYTE PTR tv203[rsp], al
  00275	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0027a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00281	48 ff c0	 inc	 rax
  00284	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00289	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00290	0f b6 44 24 36	 movzx	 eax, BYTE PTR tv203[rsp]
  00295	88 44 24 2e	 mov	 BYTE PTR $T3[rsp], al
  00299	eb 53		 jmp	 SHORT $LN25@stbi__tga_
$LN26@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  0029b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002a0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002a4	74 43		 je	 SHORT $LN27@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  002a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ab	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002b0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002bf	88 44 24 37	 mov	 BYTE PTR tv212[rsp], al
  002c3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002cf	48 ff c0	 inc	 rax
  002d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002d7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002de	0f b6 44 24 37	 movzx	 eax, BYTE PTR tv212[rsp]
  002e3	88 44 24 2e	 mov	 BYTE PTR $T3[rsp], al
  002e7	eb 05		 jmp	 SHORT $LN25@stbi__tga_
$LN27@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  002e9	c6 44 24 2e 00	 mov	 BYTE PTR $T3[rsp], 0
$LN25@stbi__tga_:

; 5830 :       sz = stbi__get8(s);    //   check bits per palette color entry

  002ee	0f b6 44 24 2e	 movzx	 eax, BYTE PTR $T3[rsp]
  002f3	0f b6 c0	 movzx	 eax, al
  002f6	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5831 :       if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  002fa	83 7c 24 24 08	 cmp	 DWORD PTR sz$[rsp], 8
  002ff	74 21		 je	 SHORT $LN6@stbi__tga_
  00301	83 7c 24 24 0f	 cmp	 DWORD PTR sz$[rsp], 15
  00306	74 1a		 je	 SHORT $LN6@stbi__tga_
  00308	83 7c 24 24 10	 cmp	 DWORD PTR sz$[rsp], 16
  0030d	74 13		 je	 SHORT $LN6@stbi__tga_
  0030f	83 7c 24 24 18	 cmp	 DWORD PTR sz$[rsp], 24
  00314	74 0c		 je	 SHORT $LN6@stbi__tga_
  00316	83 7c 24 24 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  0031b	74 05		 je	 SHORT $LN6@stbi__tga_
  0031d	e9 61 01 00 00	 jmp	 $errorEnd$33
$LN6@stbi__tga_:

; 5832 :       stbi__skip(s,4);       // skip image x and y origin

  00322	ba 04 00 00 00	 mov	 edx, 4
  00327	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	e8 00 00 00 00	 call	 stbi__skip
  00331	90		 npad	 1

; 5833 :    } else { // "normal" image w/o colormap

  00332	eb 31		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5834 :       if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE

  00334	83 7c 24 24 02	 cmp	 DWORD PTR sz$[rsp], 2
  00339	74 1a		 je	 SHORT $LN7@stbi__tga_
  0033b	83 7c 24 24 03	 cmp	 DWORD PTR sz$[rsp], 3
  00340	74 13		 je	 SHORT $LN7@stbi__tga_
  00342	83 7c 24 24 0a	 cmp	 DWORD PTR sz$[rsp], 10
  00347	74 0c		 je	 SHORT $LN7@stbi__tga_
  00349	83 7c 24 24 0b	 cmp	 DWORD PTR sz$[rsp], 11
  0034e	74 05		 je	 SHORT $LN7@stbi__tga_
  00350	e9 2e 01 00 00	 jmp	 $errorEnd$33
$LN7@stbi__tga_:

; 5835 :       stbi__skip(s,9); // skip colormap specification and image x/y origin

  00355	ba 09 00 00 00	 mov	 edx, 9
  0035a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0035f	e8 00 00 00 00	 call	 stbi__skip
  00364	90		 npad	 1
$LN4@stbi__tga_:

; 5836 :    }
; 5837 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width

  00365	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0036a	e8 00 00 00 00	 call	 stbi__get16le
  0036f	83 f8 01	 cmp	 eax, 1
  00372	7d 05		 jge	 SHORT $LN8@stbi__tga_
  00374	e9 0a 01 00 00	 jmp	 $errorEnd$33
$LN8@stbi__tga_:

; 5838 :    if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height

  00379	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0037e	e8 00 00 00 00	 call	 stbi__get16le
  00383	83 f8 01	 cmp	 eax, 1
  00386	7d 05		 jge	 SHORT $LN9@stbi__tga_
  00388	e9 f6 00 00 00	 jmp	 $errorEnd$33
$LN9@stbi__tga_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0038d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00392	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00397	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0039e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  003a5	73 39		 jae	 SHORT $LN30@stbi__tga_

; 1615 :       return *s->img_buffer++;

  003a7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003ac	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003b6	88 44 24 38	 mov	 BYTE PTR tv220[rsp], al
  003ba	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003bf	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003c6	48 ff c0	 inc	 rax
  003c9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003ce	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003d5	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv220[rsp]
  003da	88 44 24 2f	 mov	 BYTE PTR $T4[rsp], al
  003de	eb 53		 jmp	 SHORT $LN29@stbi__tga_
$LN30@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  003e0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003e5	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  003e9	74 43		 je	 SHORT $LN31@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  003eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003f0	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  003f5	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00401	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00404	88 44 24 39	 mov	 BYTE PTR tv229[rsp], al
  00408	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0040d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00414	48 ff c0	 inc	 rax
  00417	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0041c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00423	0f b6 44 24 39	 movzx	 eax, BYTE PTR tv229[rsp]
  00428	88 44 24 2f	 mov	 BYTE PTR $T4[rsp], al
  0042c	eb 05		 jmp	 SHORT $LN29@stbi__tga_
$LN31@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  0042e	c6 44 24 2f 00	 mov	 BYTE PTR $T4[rsp], 0
$LN29@stbi__tga_:

; 5839 :    sz = stbi__get8(s);   //   bits per pixel

  00433	0f b6 44 24 2f	 movzx	 eax, BYTE PTR $T4[rsp]
  00438	0f b6 c0	 movzx	 eax, al
  0043b	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5840 :    if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index

  0043f	83 7c 24 28 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00444	75 10		 jne	 SHORT $LN10@stbi__tga_
  00446	83 7c 24 24 08	 cmp	 DWORD PTR sz$[rsp], 8
  0044b	74 09		 je	 SHORT $LN10@stbi__tga_
  0044d	83 7c 24 24 10	 cmp	 DWORD PTR sz$[rsp], 16
  00452	74 02		 je	 SHORT $LN10@stbi__tga_
  00454	eb 2d		 jmp	 SHORT $errorEnd$33
$LN10@stbi__tga_:

; 5841 :    if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  00456	83 7c 24 24 08	 cmp	 DWORD PTR sz$[rsp], 8
  0045b	74 1e		 je	 SHORT $LN11@stbi__tga_
  0045d	83 7c 24 24 0f	 cmp	 DWORD PTR sz$[rsp], 15
  00462	74 17		 je	 SHORT $LN11@stbi__tga_
  00464	83 7c 24 24 10	 cmp	 DWORD PTR sz$[rsp], 16
  00469	74 10		 je	 SHORT $LN11@stbi__tga_
  0046b	83 7c 24 24 18	 cmp	 DWORD PTR sz$[rsp], 24
  00470	74 09		 je	 SHORT $LN11@stbi__tga_
  00472	83 7c 24 24 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  00477	74 02		 je	 SHORT $LN11@stbi__tga_
  00479	eb 08		 jmp	 SHORT $errorEnd$33
$LN11@stbi__tga_:

; 5842 : 
; 5843 :    res = 1; // if we got this far, everything's good and we can return 1 instead of 0

  0047b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR res$[rsp], 1
$errorEnd$33:

; 5844 : 
; 5845 : errorEnd:
; 5846 :    stbi__rewind(s);

  00483	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00488	e8 00 00 00 00	 call	 stbi__rewind

; 5847 :    return res;

  0048d	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]

; 5848 : }

  00491	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00495	5f		 pop	 rdi
  00496	c3		 ret	 0
stbi__tga_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
px$ = 32
fiveBitMask$ = 36
r$ = 40
g$ = 44
b$ = 48
s$ = 80
out$ = 88
stbi__tga_read_rgb16 PROC

; 5852 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5853 :    stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 stbi__get16le
  00025	66 89 44 24 20	 mov	 WORD PTR px$[rsp], ax

; 5854 :    stbi__uint16 fiveBitMask = 31;

  0002a	b8 1f 00 00 00	 mov	 eax, 31
  0002f	66 89 44 24 24	 mov	 WORD PTR fiveBitMask$[rsp], ax

; 5855 :    // we have 3 channels with 5bits each
; 5856 :    int r = (px >> 10) & fiveBitMask;

  00034	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  00039	c1 f8 0a	 sar	 eax, 10
  0003c	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00041	23 c1		 and	 eax, ecx
  00043	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 5857 :    int g = (px >> 5) & fiveBitMask;

  00047	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0004c	c1 f8 05	 sar	 eax, 5
  0004f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00054	23 c1		 and	 eax, ecx
  00056	89 44 24 2c	 mov	 DWORD PTR g$[rsp], eax

; 5858 :    int b = px & fiveBitMask;

  0005a	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0005f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00064	23 c1		 and	 eax, ecx
  00066	89 44 24 30	 mov	 DWORD PTR b$[rsp], eax

; 5859 :    // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5860 :    out[0] = (stbi_uc)((r * 255)/31);

  0006a	69 44 24 28 ff
	00 00 00	 imul	 eax, DWORD PTR r$[rsp], 255 ; 000000ffH
  00072	99		 cdq
  00073	b9 1f 00 00 00	 mov	 ecx, 31
  00078	f7 f9		 idiv	 ecx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	48 6b c9 00	 imul	 rcx, rcx, 0
  00083	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  00088	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5861 :    out[1] = (stbi_uc)((g * 255)/31);

  0008b	69 44 24 2c ff
	00 00 00	 imul	 eax, DWORD PTR g$[rsp], 255 ; 000000ffH
  00093	99		 cdq
  00094	b9 1f 00 00 00	 mov	 ecx, 31
  00099	f7 f9		 idiv	 ecx
  0009b	b9 01 00 00 00	 mov	 ecx, 1
  000a0	48 6b c9 01	 imul	 rcx, rcx, 1
  000a4	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  000a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5862 :    out[2] = (stbi_uc)((b * 255)/31);

  000ac	69 44 24 30 ff
	00 00 00	 imul	 eax, DWORD PTR b$[rsp], 255 ; 000000ffH
  000b4	99		 cdq
  000b5	b9 1f 00 00 00	 mov	 ecx, 31
  000ba	f7 f9		 idiv	 ecx
  000bc	b9 01 00 00 00	 mov	 ecx, 1
  000c1	48 6b c9 02	 imul	 rcx, rcx, 2
  000c5	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  000ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5863 : 
; 5864 :    // some people claim that the most significant bit might be used for alpha
; 5865 :    // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5866 :    // but that only made 16bit test images completely translucent..
; 5867 :    // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5868 : }

  000cd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
stbi__tga_read_rgb16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tga_offset$ = 48
tga_indexed$ = 52
tga_image_type$ = 56
tga_is_RLE$ = 60
tga_palette_start$ = 64
tga_palette_len$ = 68
tga_palette_bits$ = 72
tga_x_origin$ = 76
tga_y_origin$ = 80
tga_width$ = 84
tga_height$ = 88
tga_bits_per_pixel$ = 92
tga_comp$ = 96
tga_rgb16$ = 116
tga_inverted$ = 132
tga_data$ = 136
tga_palette$ = 144
i$ = 152
j$ = 156
raw_data$ = 164
RLE_count$ = 180
RLE_repeating$ = 184
read_next_pixel$ = 188
row$5 = 192
tga_row$6 = 200
pal_entry$7 = 208
RLE_cmd$8 = 216
pal_idx$9 = 220
index1$10 = 224
index2$11 = 228
temp$12 = 232
tga_pixel$13 = 240
temp$14 = 248
$T15 = 264
$T16 = 265
$T17 = 266
$T18 = 267
$T19 = 268
$T20 = 269
$T21 = 270
$T22 = 271
$T23 = 272
tv395 = 273
tv404 = 274
tv412 = 275
tv421 = 276
tv429 = 277
tv438 = 278
tv446 = 279
tv455 = 280
tv463 = 281
tv472 = 282
tv480 = 283
tv489 = 284
tv134 = 288
tv139 = 296
tv153 = 304
tv160 = 312
tv171 = 320
tv181 = 328
tv192 = 336
tv207 = 344
tv219 = 352
tv275 = 360
tv497 = 368
tv506 = 369
tv514 = 370
tv523 = 371
tv296 = 372
tv531 = 376
tv540 = 377
__$ArrayPad$ = 384
s$ = 416
x$ = 424
y$ = 432
comp$ = 440
req_comp$ = 448
ri$ = 456
stbi__tga_load PROC

; 5871 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR [rsp+416]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00053	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00063	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0006a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00071	73 4b		 jae	 SHORT $LN87@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00073	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00082	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00085	88 84 24 11 01
	00 00		 mov	 BYTE PTR tv395[rsp], al
  0008c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00094	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009b	48 ff c0	 inc	 rax
  0009e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ad	0f b6 84 24 11
	01 00 00	 movzx	 eax, BYTE PTR tv395[rsp]
  000b5	88 84 24 08 01
	00 00		 mov	 BYTE PTR $T15[rsp], al
  000bc	eb 6e		 jmp	 SHORT $LN86@stbi__tga_
$LN87@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  000be	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c6	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000ca	74 58		 je	 SHORT $LN88@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  000cc	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000d4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000d9	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	88 84 24 12 01
	00 00		 mov	 BYTE PTR tv404[rsp], al
  000f2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00101	48 ff c0	 inc	 rax
  00104	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00113	0f b6 84 24 12
	01 00 00	 movzx	 eax, BYTE PTR tv404[rsp]
  0011b	88 84 24 08 01
	00 00		 mov	 BYTE PTR $T15[rsp], al
  00122	eb 08		 jmp	 SHORT $LN86@stbi__tga_
$LN88@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00124	c6 84 24 08 01
	00 00 00	 mov	 BYTE PTR $T15[rsp], 0
$LN86@stbi__tga_:

; 5872 :    //   read in the TGA header stuff
; 5873 :    int tga_offset = stbi__get8(s);

  0012c	0f b6 84 24 08
	01 00 00	 movzx	 eax, BYTE PTR $T15[rsp]
  00134	0f b6 c0	 movzx	 eax, al
  00137	89 44 24 30	 mov	 DWORD PTR tga_offset$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0013b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00143	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0014b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00152	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00159	73 4b		 jae	 SHORT $LN91@stbi__tga_

; 1615 :       return *s->img_buffer++;

  0015b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00163	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0016a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016d	88 84 24 13 01
	00 00		 mov	 BYTE PTR tv412[rsp], al
  00174	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0017c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00183	48 ff c0	 inc	 rax
  00186	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0018e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00195	0f b6 84 24 13
	01 00 00	 movzx	 eax, BYTE PTR tv412[rsp]
  0019d	88 84 24 09 01
	00 00		 mov	 BYTE PTR $T16[rsp], al
  001a4	eb 6e		 jmp	 SHORT $LN90@stbi__tga_
$LN91@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  001a6	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ae	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001b2	74 58		 je	 SHORT $LN92@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  001b4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001bc	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001c1	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d3	88 84 24 14 01
	00 00		 mov	 BYTE PTR tv421[rsp], al
  001da	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001e9	48 ff c0	 inc	 rax
  001ec	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001f4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001fb	0f b6 84 24 14
	01 00 00	 movzx	 eax, BYTE PTR tv421[rsp]
  00203	88 84 24 09 01
	00 00		 mov	 BYTE PTR $T16[rsp], al
  0020a	eb 08		 jmp	 SHORT $LN90@stbi__tga_
$LN92@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  0020c	c6 84 24 09 01
	00 00 00	 mov	 BYTE PTR $T16[rsp], 0
$LN90@stbi__tga_:

; 5874 :    int tga_indexed = stbi__get8(s);

  00214	0f b6 84 24 09
	01 00 00	 movzx	 eax, BYTE PTR $T16[rsp]
  0021c	0f b6 c0	 movzx	 eax, al
  0021f	89 44 24 34	 mov	 DWORD PTR tga_indexed$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00223	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0022b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00233	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0023a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00241	73 4b		 jae	 SHORT $LN95@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00243	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0024b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00252	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00255	88 84 24 15 01
	00 00		 mov	 BYTE PTR tv429[rsp], al
  0025c	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00264	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0026b	48 ff c0	 inc	 rax
  0026e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00276	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0027d	0f b6 84 24 15
	01 00 00	 movzx	 eax, BYTE PTR tv429[rsp]
  00285	88 84 24 0a 01
	00 00		 mov	 BYTE PTR $T17[rsp], al
  0028c	eb 6e		 jmp	 SHORT $LN94@stbi__tga_
$LN95@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  0028e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00296	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0029a	74 58		 je	 SHORT $LN96@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  0029c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002a9	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002b8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002bb	88 84 24 16 01
	00 00		 mov	 BYTE PTR tv438[rsp], al
  002c2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002d1	48 ff c0	 inc	 rax
  002d4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002dc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002e3	0f b6 84 24 16
	01 00 00	 movzx	 eax, BYTE PTR tv438[rsp]
  002eb	88 84 24 0a 01
	00 00		 mov	 BYTE PTR $T17[rsp], al
  002f2	eb 08		 jmp	 SHORT $LN94@stbi__tga_
$LN96@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  002f4	c6 84 24 0a 01
	00 00 00	 mov	 BYTE PTR $T17[rsp], 0
$LN94@stbi__tga_:

; 5875 :    int tga_image_type = stbi__get8(s);

  002fc	0f b6 84 24 0a
	01 00 00	 movzx	 eax, BYTE PTR $T17[rsp]
  00304	0f b6 c0	 movzx	 eax, al
  00307	89 44 24 38	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5876 :    int tga_is_RLE = 0;

  0030b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tga_is_RLE$[rsp], 0

; 5877 :    int tga_palette_start = stbi__get16le(s);

  00313	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0031b	e8 00 00 00 00	 call	 stbi__get16le
  00320	89 44 24 40	 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 5878 :    int tga_palette_len = stbi__get16le(s);

  00324	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	e8 00 00 00 00	 call	 stbi__get16le
  00331	89 44 24 44	 mov	 DWORD PTR tga_palette_len$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00335	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0033d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00345	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0034c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00353	73 4b		 jae	 SHORT $LN99@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00355	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00364	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00367	88 84 24 17 01
	00 00		 mov	 BYTE PTR tv446[rsp], al
  0036e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00376	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0037d	48 ff c0	 inc	 rax
  00380	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00388	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0038f	0f b6 84 24 17
	01 00 00	 movzx	 eax, BYTE PTR tv446[rsp]
  00397	88 84 24 0b 01
	00 00		 mov	 BYTE PTR $T18[rsp], al
  0039e	eb 6e		 jmp	 SHORT $LN98@stbi__tga_
$LN99@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  003a0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  003ac	74 58		 je	 SHORT $LN100@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  003ae	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  003bb	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003c3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003ca	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003cd	88 84 24 18 01
	00 00		 mov	 BYTE PTR tv455[rsp], al
  003d4	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003dc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003e3	48 ff c0	 inc	 rax
  003e6	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ee	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003f5	0f b6 84 24 18
	01 00 00	 movzx	 eax, BYTE PTR tv455[rsp]
  003fd	88 84 24 0b 01
	00 00		 mov	 BYTE PTR $T18[rsp], al
  00404	eb 08		 jmp	 SHORT $LN98@stbi__tga_
$LN100@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00406	c6 84 24 0b 01
	00 00 00	 mov	 BYTE PTR $T18[rsp], 0
$LN98@stbi__tga_:

; 5879 :    int tga_palette_bits = stbi__get8(s);

  0040e	0f b6 84 24 0b
	01 00 00	 movzx	 eax, BYTE PTR $T18[rsp]
  00416	0f b6 c0	 movzx	 eax, al
  00419	89 44 24 48	 mov	 DWORD PTR tga_palette_bits$[rsp], eax

; 5880 :    int tga_x_origin = stbi__get16le(s);

  0041d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00425	e8 00 00 00 00	 call	 stbi__get16le
  0042a	89 44 24 4c	 mov	 DWORD PTR tga_x_origin$[rsp], eax

; 5881 :    int tga_y_origin = stbi__get16le(s);

  0042e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00436	e8 00 00 00 00	 call	 stbi__get16le
  0043b	89 44 24 50	 mov	 DWORD PTR tga_y_origin$[rsp], eax

; 5882 :    int tga_width = stbi__get16le(s);

  0043f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00447	e8 00 00 00 00	 call	 stbi__get16le
  0044c	89 44 24 54	 mov	 DWORD PTR tga_width$[rsp], eax

; 5883 :    int tga_height = stbi__get16le(s);

  00450	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00458	e8 00 00 00 00	 call	 stbi__get16le
  0045d	89 44 24 58	 mov	 DWORD PTR tga_height$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00461	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00469	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00471	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00478	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0047f	73 4b		 jae	 SHORT $LN103@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00481	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00489	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00490	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00493	88 84 24 19 01
	00 00		 mov	 BYTE PTR tv463[rsp], al
  0049a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004a2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004a9	48 ff c0	 inc	 rax
  004ac	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004bb	0f b6 84 24 19
	01 00 00	 movzx	 eax, BYTE PTR tv463[rsp]
  004c3	88 84 24 0c 01
	00 00		 mov	 BYTE PTR $T19[rsp], al
  004ca	eb 6e		 jmp	 SHORT $LN102@stbi__tga_
$LN103@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  004cc	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004d8	74 58		 je	 SHORT $LN104@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  004da	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  004e7	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ef	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004f9	88 84 24 1a 01
	00 00		 mov	 BYTE PTR tv472[rsp], al
  00500	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00508	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0050f	48 ff c0	 inc	 rax
  00512	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0051a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00521	0f b6 84 24 1a
	01 00 00	 movzx	 eax, BYTE PTR tv472[rsp]
  00529	88 84 24 0c 01
	00 00		 mov	 BYTE PTR $T19[rsp], al
  00530	eb 08		 jmp	 SHORT $LN102@stbi__tga_
$LN104@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00532	c6 84 24 0c 01
	00 00 00	 mov	 BYTE PTR $T19[rsp], 0
$LN102@stbi__tga_:

; 5884 :    int tga_bits_per_pixel = stbi__get8(s);

  0053a	0f b6 84 24 0c
	01 00 00	 movzx	 eax, BYTE PTR $T19[rsp]
  00542	0f b6 c0	 movzx	 eax, al
  00545	89 44 24 5c	 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 5885 :    int tga_comp, tga_rgb16=0;

  00549	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tga_rgb16$[rsp], 0

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00551	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00559	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00561	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00568	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0056f	73 4b		 jae	 SHORT $LN107@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00571	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00579	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00580	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00583	88 84 24 1b 01
	00 00		 mov	 BYTE PTR tv480[rsp], al
  0058a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00592	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00599	48 ff c0	 inc	 rax
  0059c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005ab	0f b6 84 24 1b
	01 00 00	 movzx	 eax, BYTE PTR tv480[rsp]
  005b3	88 84 24 0d 01
	00 00		 mov	 BYTE PTR $T20[rsp], al
  005ba	eb 6e		 jmp	 SHORT $LN106@stbi__tga_
$LN107@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  005bc	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005c4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  005c8	74 58		 je	 SHORT $LN108@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  005ca	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  005d7	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005df	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005e6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005e9	88 84 24 1c 01
	00 00		 mov	 BYTE PTR tv489[rsp], al
  005f0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005f8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005ff	48 ff c0	 inc	 rax
  00602	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0060a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00611	0f b6 84 24 1c
	01 00 00	 movzx	 eax, BYTE PTR tv489[rsp]
  00619	88 84 24 0d 01
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00620	eb 08		 jmp	 SHORT $LN106@stbi__tga_
$LN108@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00622	c6 84 24 0d 01
	00 00 00	 mov	 BYTE PTR $T20[rsp], 0
$LN106@stbi__tga_:

; 5886 :    int tga_inverted = stbi__get8(s);

  0062a	0f b6 84 24 0d
	01 00 00	 movzx	 eax, BYTE PTR $T20[rsp]
  00632	0f b6 c0	 movzx	 eax, al
  00635	89 84 24 84 00
	00 00		 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5887 :    // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5888 :    //   image data
; 5889 :    unsigned char *tga_data;
; 5890 :    unsigned char *tga_palette = NULL;

  0063c	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tga_palette$[rsp], 0

; 5891 :    int i, j;
; 5892 :    unsigned char raw_data[4] = {0};

  00648	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR raw_data$[rsp]
  00650	48 8b f8	 mov	 rdi, rax
  00653	33 c0		 xor	 eax, eax
  00655	b9 04 00 00 00	 mov	 ecx, 4
  0065a	f3 aa		 rep stosb

; 5893 :    int RLE_count = 0;

  0065c	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR RLE_count$[rsp], 0

; 5894 :    int RLE_repeating = 0;

  00667	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR RLE_repeating$[rsp], 0

; 5895 :    int read_next_pixel = 1;

  00672	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR read_next_pixel$[rsp], 1

; 5896 :    STBI_NOTUSED(ri);
; 5897 :    STBI_NOTUSED(tga_x_origin); // @TODO
; 5898 :    STBI_NOTUSED(tga_y_origin); // @TODO
; 5899 : 
; 5900 :    if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0067d	81 7c 24 58 00
	00 00 01	 cmp	 DWORD PTR tga_height$[rsp], 16777216 ; 01000000H
  00685	7e 37		 jle	 SHORT $LN29@stbi__tga_
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0068e	e8 00 00 00 00	 call	 stbi__err
  00693	85 c0		 test	 eax, eax
  00695	74 0e		 je	 SHORT $LN62@stbi__tga_
  00697	48 c7 84 24 20
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv134[rsp], 0
  006a3	eb 0c		 jmp	 SHORT $LN63@stbi__tga_
$LN62@stbi__tga_:
  006a5	48 c7 84 24 20
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv134[rsp], 0
$LN63@stbi__tga_:
  006b1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv134[rsp]
  006b9	e9 89 0c 00 00	 jmp	 $LN1@stbi__tga_
$LN29@stbi__tga_:

; 5901 :    if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  006be	81 7c 24 54 00
	00 00 01	 cmp	 DWORD PTR tga_width$[rsp], 16777216 ; 01000000H
  006c6	7e 37		 jle	 SHORT $LN30@stbi__tga_
  006c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  006cf	e8 00 00 00 00	 call	 stbi__err
  006d4	85 c0		 test	 eax, eax
  006d6	74 0e		 je	 SHORT $LN64@stbi__tga_
  006d8	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv139[rsp], 0
  006e4	eb 0c		 jmp	 SHORT $LN65@stbi__tga_
$LN64@stbi__tga_:
  006e6	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv139[rsp], 0
$LN65@stbi__tga_:
  006f2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv139[rsp]
  006fa	e9 48 0c 00 00	 jmp	 $LN1@stbi__tga_
$LN30@stbi__tga_:

; 5902 : 
; 5903 :    //   do a tiny bit of precessing
; 5904 :    if ( tga_image_type >= 8 )

  006ff	83 7c 24 38 08	 cmp	 DWORD PTR tga_image_type$[rsp], 8
  00704	7c 13		 jl	 SHORT $LN31@stbi__tga_

; 5905 :    {
; 5906 :       tga_image_type -= 8;

  00706	8b 44 24 38	 mov	 eax, DWORD PTR tga_image_type$[rsp]
  0070a	83 e8 08	 sub	 eax, 8
  0070d	89 44 24 38	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5907 :       tga_is_RLE = 1;

  00711	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tga_is_RLE$[rsp], 1
$LN31@stbi__tga_:

; 5908 :    }
; 5909 :    tga_inverted = 1 - ((tga_inverted >> 5) & 1);

  00719	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tga_inverted$[rsp]
  00720	c1 f8 05	 sar	 eax, 5
  00723	83 e0 01	 and	 eax, 1
  00726	b9 01 00 00 00	 mov	 ecx, 1
  0072b	2b c8		 sub	 ecx, eax
  0072d	8b c1		 mov	 eax, ecx
  0072f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5910 : 
; 5911 :    //   If I'm paletted, then I'll use the number of bits from the palette
; 5912 :    if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

  00736	83 7c 24 34 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  0073b	74 16		 je	 SHORT $LN32@stbi__tga_
  0073d	4c 8d 44 24 74	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  00742	33 d2		 xor	 edx, edx
  00744	8b 4c 24 48	 mov	 ecx, DWORD PTR tga_palette_bits$[rsp]
  00748	e8 00 00 00 00	 call	 stbi__tga_get_comp
  0074d	89 44 24 60	 mov	 DWORD PTR tga_comp$[rsp], eax
  00751	eb 38		 jmp	 SHORT $LN33@stbi__tga_
$LN32@stbi__tga_:

; 5913 :    else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

  00753	83 7c 24 38 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  00758	75 0d		 jne	 SHORT $LN66@stbi__tga_
  0075a	c7 84 24 30 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv153[rsp], 1
  00765	eb 0b		 jmp	 SHORT $LN67@stbi__tga_
$LN66@stbi__tga_:
  00767	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN67@stbi__tga_:
  00772	4c 8d 44 24 74	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  00777	8b 94 24 30 01
	00 00		 mov	 edx, DWORD PTR tv153[rsp]
  0077e	8b 4c 24 5c	 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  00782	e8 00 00 00 00	 call	 stbi__tga_get_comp
  00787	89 44 24 60	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN33@stbi__tga_:

; 5914 : 
; 5915 :    if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

  0078b	83 7c 24 60 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  00790	75 37		 jne	 SHORT $LN34@stbi__tga_

; 5916 :       return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

  00792	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00799	e8 00 00 00 00	 call	 stbi__err
  0079e	85 c0		 test	 eax, eax
  007a0	74 0e		 je	 SHORT $LN68@stbi__tga_
  007a2	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv160[rsp], 0
  007ae	eb 0c		 jmp	 SHORT $LN69@stbi__tga_
$LN68@stbi__tga_:
  007b0	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv160[rsp], 0
$LN69@stbi__tga_:
  007bc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv160[rsp]
  007c4	e9 7e 0b 00 00	 jmp	 $LN1@stbi__tga_
$LN34@stbi__tga_:

; 5917 : 
; 5918 :    //   tga info
; 5919 :    *x = tga_width;

  007c9	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  007d1	8b 4c 24 54	 mov	 ecx, DWORD PTR tga_width$[rsp]
  007d5	89 08		 mov	 DWORD PTR [rax], ecx

; 5920 :    *y = tga_height;

  007d7	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  007df	8b 4c 24 58	 mov	 ecx, DWORD PTR tga_height$[rsp]
  007e3	89 08		 mov	 DWORD PTR [rax], ecx

; 5921 :    if (comp) *comp = tga_comp;

  007e5	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  007ee	74 0e		 je	 SHORT $LN35@stbi__tga_
  007f0	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  007f8	8b 4c 24 60	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  007fc	89 08		 mov	 DWORD PTR [rax], ecx
$LN35@stbi__tga_:

; 5922 : 
; 5923 :    if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

  007fe	45 33 c9	 xor	 r9d, r9d
  00801	44 8b 44 24 60	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  00806	8b 54 24 58	 mov	 edx, DWORD PTR tga_height$[rsp]
  0080a	8b 4c 24 54	 mov	 ecx, DWORD PTR tga_width$[rsp]
  0080e	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00813	85 c0		 test	 eax, eax
  00815	75 37		 jne	 SHORT $LN36@stbi__tga_

; 5924 :       return stbi__errpuc("too large", "Corrupt TGA");

  00817	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0081e	e8 00 00 00 00	 call	 stbi__err
  00823	85 c0		 test	 eax, eax
  00825	74 0e		 je	 SHORT $LN70@stbi__tga_
  00827	48 c7 84 24 40
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv171[rsp], 0
  00833	eb 0c		 jmp	 SHORT $LN71@stbi__tga_
$LN70@stbi__tga_:
  00835	48 c7 84 24 40
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv171[rsp], 0
$LN71@stbi__tga_:
  00841	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv171[rsp]
  00849	e9 f9 0a 00 00	 jmp	 $LN1@stbi__tga_
$LN36@stbi__tga_:

; 5925 : 
; 5926 :    tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

  0084e	45 33 c9	 xor	 r9d, r9d
  00851	44 8b 44 24 60	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  00856	8b 54 24 58	 mov	 edx, DWORD PTR tga_height$[rsp]
  0085a	8b 4c 24 54	 mov	 ecx, DWORD PTR tga_width$[rsp]
  0085e	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00863	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tga_data$[rsp], rax

; 5927 :    if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

  0086b	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tga_data$[rsp], 0
  00874	75 37		 jne	 SHORT $LN37@stbi__tga_
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0087d	e8 00 00 00 00	 call	 stbi__err
  00882	85 c0		 test	 eax, eax
  00884	74 0e		 je	 SHORT $LN72@stbi__tga_
  00886	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv181[rsp], 0
  00892	eb 0c		 jmp	 SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
  00894	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv181[rsp], 0
$LN73@stbi__tga_:
  008a0	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv181[rsp]
  008a8	e9 9a 0a 00 00	 jmp	 $LN1@stbi__tga_
$LN37@stbi__tga_:

; 5928 : 
; 5929 :    // skip to the data's starting position (offset usually = 0)
; 5930 :    stbi__skip(s, tga_offset );

  008ad	8b 54 24 30	 mov	 edx, DWORD PTR tga_offset$[rsp]
  008b1	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008b9	e8 00 00 00 00	 call	 stbi__skip

; 5931 : 
; 5932 :    if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {

  008be	83 7c 24 34 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  008c3	0f 85 d9 00 00
	00		 jne	 $LN38@stbi__tga_
  008c9	83 7c 24 3c 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  008ce	0f 85 ce 00 00
	00		 jne	 $LN38@stbi__tga_
  008d4	83 7c 24 74 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  008d9	0f 85 c3 00 00
	00		 jne	 $LN38@stbi__tga_

; 5933 :       for (i=0; i < tga_height; ++i) {

  008df	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  008ea	eb 10		 jmp	 SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
  008ec	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  008f3	ff c0		 inc	 eax
  008f5	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__tga_:
  008fc	8b 44 24 58	 mov	 eax, DWORD PTR tga_height$[rsp]
  00900	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00907	0f 8d 90 00 00
	00		 jge	 $LN3@stbi__tga_

; 5934 :          int row = tga_inverted ? tga_height -i - 1 : i;

  0090d	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  00915	74 1a		 je	 SHORT $LN74@stbi__tga_
  00917	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0091e	8b 4c 24 58	 mov	 ecx, DWORD PTR tga_height$[rsp]
  00922	2b c8		 sub	 ecx, eax
  00924	8b c1		 mov	 eax, ecx
  00926	ff c8		 dec	 eax
  00928	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  0092f	eb 0e		 jmp	 SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
  00931	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00938	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv192[rsp], eax
$LN75@stbi__tga_:
  0093f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv192[rsp]
  00946	89 84 24 c0 00
	00 00		 mov	 DWORD PTR row$5[rsp], eax

; 5935 :          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;

  0094d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR row$5[rsp]
  00954	0f af 44 24 54	 imul	 eax, DWORD PTR tga_width$[rsp]
  00959	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0095e	48 98		 cdqe
  00960	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00968	48 03 c8	 add	 rcx, rax
  0096b	48 8b c1	 mov	 rax, rcx
  0096e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tga_row$6[rsp], rax

; 5936 :          stbi__getn(s, tga_row, tga_width * tga_comp);

  00976	8b 44 24 54	 mov	 eax, DWORD PTR tga_width$[rsp]
  0097a	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0097f	44 8b c0	 mov	 r8d, eax
  00982	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tga_row$6[rsp]
  0098a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00992	e8 00 00 00 00	 call	 stbi__getn
  00997	90		 npad	 1

; 5937 :       }

  00998	e9 4f ff ff ff	 jmp	 $LN2@stbi__tga_
$LN3@stbi__tga_:

; 5938 :    } else  {

  0099d	e9 56 08 00 00	 jmp	 $LN39@stbi__tga_
$LN38@stbi__tga_:

; 5939 :       //   do I need to load a palette?
; 5940 :       if ( tga_indexed)

  009a2	83 7c 24 34 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  009a7	0f 84 d9 01 00
	00		 je	 $LN40@stbi__tga_

; 5941 :       {
; 5942 :          if (tga_palette_len == 0) {  /* you have to have at least one entry! */

  009ad	83 7c 24 44 00	 cmp	 DWORD PTR tga_palette_len$[rsp], 0
  009b2	75 45		 jne	 SHORT $LN41@stbi__tga_

; 5943 :             STBI_FREE(tga_data);

  009b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  009bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5944 :             return stbi__errpuc("bad palette", "Corrupt TGA");

  009c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ILLOCNCO@bad?5palette@
  009c9	e8 00 00 00 00	 call	 stbi__err
  009ce	85 c0		 test	 eax, eax
  009d0	74 0e		 je	 SHORT $LN76@stbi__tga_
  009d2	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv207[rsp], 0
  009de	eb 0c		 jmp	 SHORT $LN77@stbi__tga_
$LN76@stbi__tga_:
  009e0	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv207[rsp], 0
$LN77@stbi__tga_:
  009ec	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR tv207[rsp]
  009f4	e9 4e 09 00 00	 jmp	 $LN1@stbi__tga_
$LN41@stbi__tga_:

; 5945 :          }
; 5946 : 
; 5947 :          //   any data to skip? (offset usually = 0)
; 5948 :          stbi__skip(s, tga_palette_start );

  009f9	8b 54 24 40	 mov	 edx, DWORD PTR tga_palette_start$[rsp]
  009fd	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a05	e8 00 00 00 00	 call	 stbi__skip

; 5949 :          //   load the palette
; 5950 :          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

  00a0a	45 33 c0	 xor	 r8d, r8d
  00a0d	8b 54 24 60	 mov	 edx, DWORD PTR tga_comp$[rsp]
  00a11	8b 4c 24 44	 mov	 ecx, DWORD PTR tga_palette_len$[rsp]
  00a15	e8 00 00 00 00	 call	 stbi__malloc_mad2
  00a1a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tga_palette$[rsp], rax

; 5951 :          if (!tga_palette) {

  00a22	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  00a2b	75 45		 jne	 SHORT $LN42@stbi__tga_

; 5952 :             STBI_FREE(tga_data);

  00a2d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00a35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5953 :             return stbi__errpuc("outofmem", "Out of memory");

  00a3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00a42	e8 00 00 00 00	 call	 stbi__err
  00a47	85 c0		 test	 eax, eax
  00a49	74 0e		 je	 SHORT $LN78@stbi__tga_
  00a4b	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv219[rsp], 0
  00a57	eb 0c		 jmp	 SHORT $LN79@stbi__tga_
$LN78@stbi__tga_:
  00a59	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv219[rsp], 0
$LN79@stbi__tga_:
  00a65	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR tv219[rsp]
  00a6d	e9 d5 08 00 00	 jmp	 $LN1@stbi__tga_
$LN42@stbi__tga_:

; 5954 :          }
; 5955 :          if (tga_rgb16) {

  00a72	83 7c 24 74 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00a77	0f 84 91 00 00
	00		 je	 $LN43@stbi__tga_

; 5956 :             stbi_uc *pal_entry = tga_palette;

  00a7d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tga_palette$[rsp]
  00a85	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pal_entry$7[rsp], rax

; 5957 :             STBI_ASSERT(tga_comp == STBI_rgb);

  00a8d	83 7c 24 60 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  00a92	74 1c		 je	 SHORT $LN80@stbi__tga_
  00a94	41 b8 45 17 00
	00		 mov	 r8d, 5957		; 00001745H
  00a9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
  00aa8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00aae	33 c0		 xor	 eax, eax
$LN80@stbi__tga_:

; 5958 :             for (i=0; i < tga_palette_len; ++i) {

  00ab0	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00abb	eb 10		 jmp	 SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
  00abd	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00ac4	ff c0		 inc	 eax
  00ac6	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__tga_:
  00acd	8b 44 24 44	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00ad1	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00ad8	7d 32		 jge	 SHORT $LN6@stbi__tga_

; 5959 :                stbi__tga_read_rgb16(s, pal_entry);

  00ada	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pal_entry$7[rsp]
  00ae2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aea	e8 00 00 00 00	 call	 stbi__tga_read_rgb16

; 5960 :                pal_entry += tga_comp;

  00aef	48 63 44 24 60	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  00af4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pal_entry$7[rsp]
  00afc	48 03 c8	 add	 rcx, rax
  00aff	48 8b c1	 mov	 rax, rcx
  00b02	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pal_entry$7[rsp], rax

; 5961 :             }

  00b0a	eb b1		 jmp	 SHORT $LN5@stbi__tga_
$LN6@stbi__tga_:

; 5962 :          } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

  00b0c	eb 78		 jmp	 SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:
  00b0e	8b 44 24 44	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00b12	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  00b17	44 8b c0	 mov	 r8d, eax
  00b1a	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  00b22	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b2a	e8 00 00 00 00	 call	 stbi__getn
  00b2f	85 c0		 test	 eax, eax
  00b31	75 53		 jne	 SHORT $LN45@stbi__tga_

; 5963 :                STBI_FREE(tga_data);

  00b33	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00b3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5964 :                STBI_FREE(tga_palette);

  00b41	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  00b49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5965 :                return stbi__errpuc("bad palette", "Corrupt TGA");

  00b4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@ILLOCNCO@bad?5palette@
  00b56	e8 00 00 00 00	 call	 stbi__err
  00b5b	85 c0		 test	 eax, eax
  00b5d	74 0e		 je	 SHORT $LN81@stbi__tga_
  00b5f	48 c7 84 24 68
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv275[rsp], 0
  00b6b	eb 0c		 jmp	 SHORT $LN82@stbi__tga_
$LN81@stbi__tga_:
  00b6d	48 c7 84 24 68
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv275[rsp], 0
$LN82@stbi__tga_:
  00b79	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR tv275[rsp]
  00b81	e9 c1 07 00 00	 jmp	 $LN1@stbi__tga_
$LN45@stbi__tga_:
$LN44@stbi__tga_:
$LN40@stbi__tga_:

; 5966 :          }
; 5967 :       }
; 5968 :       //   load the data
; 5969 :       for (i=0; i < tga_width * tga_height; ++i)

  00b86	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00b91	eb 10		 jmp	 SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
  00b93	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00b9a	ff c0		 inc	 eax
  00b9c	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__tga_:
  00ba3	8b 44 24 54	 mov	 eax, DWORD PTR tga_width$[rsp]
  00ba7	0f af 44 24 58	 imul	 eax, DWORD PTR tga_height$[rsp]
  00bac	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00bb3	0f 8d fa 04 00
	00		 jge	 $LN9@stbi__tga_

; 5970 :       {
; 5971 :          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5972 :          if ( tga_is_RLE )

  00bb9	83 7c 24 3c 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  00bbe	0f 84 41 01 00
	00		 je	 $LN46@stbi__tga_

; 5973 :          {
; 5974 :             if ( RLE_count == 0 )

  00bc4	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR RLE_count$[rsp], 0
  00bcc	0f 85 1c 01 00
	00		 jne	 $LN48@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00bd2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bda	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00be2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00be9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00bf0	73 4b		 jae	 SHORT $LN111@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00bf2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bfa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c01	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c04	88 84 24 70 01
	00 00		 mov	 BYTE PTR tv497[rsp], al
  00c0b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c13	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c1a	48 ff c0	 inc	 rax
  00c1d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c25	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00c2c	0f b6 84 24 70
	01 00 00	 movzx	 eax, BYTE PTR tv497[rsp]
  00c34	88 84 24 0e 01
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00c3b	eb 6e		 jmp	 SHORT $LN110@stbi__tga_
$LN111@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00c3d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c45	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00c49	74 58		 je	 SHORT $LN112@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00c4b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c53	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00c58	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c60	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c67	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c6a	88 84 24 71 01
	00 00		 mov	 BYTE PTR tv506[rsp], al
  00c71	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c79	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c80	48 ff c0	 inc	 rax
  00c83	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c8b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00c92	0f b6 84 24 71
	01 00 00	 movzx	 eax, BYTE PTR tv506[rsp]
  00c9a	88 84 24 0e 01
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00ca1	eb 08		 jmp	 SHORT $LN110@stbi__tga_
$LN112@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00ca3	c6 84 24 0e 01
	00 00 00	 mov	 BYTE PTR $T21[rsp], 0
$LN110@stbi__tga_:

; 5975 :             {
; 5976 :                //   yep, get the next byte as a RLE command
; 5977 :                int RLE_cmd = stbi__get8(s);

  00cab	0f b6 84 24 0e
	01 00 00	 movzx	 eax, BYTE PTR $T21[rsp]
  00cb3	0f b6 c0	 movzx	 eax, al
  00cb6	89 84 24 d8 00
	00 00		 mov	 DWORD PTR RLE_cmd$8[rsp], eax

; 5978 :                RLE_count = 1 + (RLE_cmd & 127);

  00cbd	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$8[rsp]
  00cc4	83 e0 7f	 and	 eax, 127		; 0000007fH
  00cc7	ff c0		 inc	 eax
  00cc9	89 84 24 b4 00
	00 00		 mov	 DWORD PTR RLE_count$[rsp], eax

; 5979 :                RLE_repeating = RLE_cmd >> 7;

  00cd0	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$8[rsp]
  00cd7	c1 f8 07	 sar	 eax, 7
  00cda	89 84 24 b8 00
	00 00		 mov	 DWORD PTR RLE_repeating$[rsp], eax

; 5980 :                read_next_pixel = 1;

  00ce1	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR read_next_pixel$[rsp], 1
  00cec	eb 15		 jmp	 SHORT $LN49@stbi__tga_
$LN48@stbi__tga_:

; 5981 :             } else if ( !RLE_repeating )

  00cee	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR RLE_repeating$[rsp], 0
  00cf6	75 0b		 jne	 SHORT $LN50@stbi__tga_

; 5982 :             {
; 5983 :                read_next_pixel = 1;

  00cf8	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN50@stbi__tga_:
$LN49@stbi__tga_:

; 5984 :             }
; 5985 :          } else

  00d03	eb 0b		 jmp	 SHORT $LN47@stbi__tga_
$LN46@stbi__tga_:

; 5986 :          {
; 5987 :             read_next_pixel = 1;

  00d05	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN47@stbi__tga_:

; 5988 :          }
; 5989 :          //   OK, if I need to read a pixel, do it now
; 5990 :          if ( read_next_pixel )

  00d10	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR read_next_pixel$[rsp], 0
  00d18	0f 84 23 03 00
	00		 je	 $LN51@stbi__tga_

; 5991 :          {
; 5992 :             //   load however much data we did have
; 5993 :             if ( tga_indexed )

  00d1e	83 7c 24 34 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  00d23	0f 84 a5 01 00
	00		 je	 $LN52@stbi__tga_

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

  00d29	83 7c 24 5c 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  00d2e	0f 85 ed 00 00
	00		 jne	 $LN83@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00d34	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d3c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d44	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00d4b	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00d52	73 4b		 jae	 SHORT $LN115@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00d54	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d5c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d63	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d66	88 84 24 72 01
	00 00		 mov	 BYTE PTR tv514[rsp], al
  00d6d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d75	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d7c	48 ff c0	 inc	 rax
  00d7f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d87	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00d8e	0f b6 84 24 72
	01 00 00	 movzx	 eax, BYTE PTR tv514[rsp]
  00d96	88 84 24 0f 01
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00d9d	eb 6e		 jmp	 SHORT $LN114@stbi__tga_
$LN115@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00d9f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00da7	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00dab	74 58		 je	 SHORT $LN116@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00dad	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00db5	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00dba	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dc2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00dc9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00dcc	88 84 24 73 01
	00 00		 mov	 BYTE PTR tv523[rsp], al
  00dd3	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ddb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00de2	48 ff c0	 inc	 rax
  00de5	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ded	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00df4	0f b6 84 24 73
	01 00 00	 movzx	 eax, BYTE PTR tv523[rsp]
  00dfc	88 84 24 0f 01
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00e03	eb 08		 jmp	 SHORT $LN114@stbi__tga_
$LN116@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  00e05	c6 84 24 0f 01
	00 00 00	 mov	 BYTE PTR $T22[rsp], 0
$LN114@stbi__tga_:

; 5994 :             {
; 5995 :                // read in index, then perform the lookup
; 5996 :                int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

  00e0d	0f b6 84 24 0f
	01 00 00	 movzx	 eax, BYTE PTR $T22[rsp]
  00e15	0f b6 c0	 movzx	 eax, al
  00e18	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv296[rsp], eax
  00e1f	eb 14		 jmp	 SHORT $LN84@stbi__tga_
$LN83@stbi__tga_:
  00e21	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e29	e8 00 00 00 00	 call	 stbi__get16le
  00e2e	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv296[rsp], eax
$LN84@stbi__tga_:
  00e35	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR tv296[rsp]
  00e3c	89 84 24 dc 00
	00 00		 mov	 DWORD PTR pal_idx$9[rsp], eax

; 5997 :                if ( pal_idx >= tga_palette_len ) {

  00e43	8b 44 24 44	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00e47	39 84 24 dc 00
	00 00		 cmp	 DWORD PTR pal_idx$9[rsp], eax
  00e4e	7c 0b		 jl	 SHORT $LN54@stbi__tga_

; 5998 :                   // invalid index
; 5999 :                   pal_idx = 0;

  00e50	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR pal_idx$9[rsp], 0
$LN54@stbi__tga_:

; 6000 :                }
; 6001 :                pal_idx *= tga_comp;

  00e5b	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR pal_idx$9[rsp]
  00e62	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  00e67	89 84 24 dc 00
	00 00		 mov	 DWORD PTR pal_idx$9[rsp], eax

; 6002 :                for (j = 0; j < tga_comp; ++j) {

  00e6e	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00e79	eb 10		 jmp	 SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
  00e7b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00e82	ff c0		 inc	 eax
  00e84	89 84 24 9c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__tga_:
  00e8b	8b 44 24 60	 mov	 eax, DWORD PTR tga_comp$[rsp]
  00e8f	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00e96	7d 31		 jge	 SHORT $LN12@stbi__tga_

; 6003 :                   raw_data[j] = tga_palette[pal_idx+j];

  00e98	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00e9f	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR pal_idx$9[rsp]
  00ea6	03 c8		 add	 ecx, eax
  00ea8	8b c1		 mov	 eax, ecx
  00eaa	48 98		 cdqe
  00eac	48 63 8c 24 9c
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  00eb4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  00ebc	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00ec0	88 84 0c a4 00
	00 00		 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 6004 :                }

  00ec7	eb b2		 jmp	 SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:

; 6005 :             } else if(tga_rgb16) {

  00ec9	e9 68 01 00 00	 jmp	 $LN53@stbi__tga_
$LN52@stbi__tga_:
  00ece	83 7c 24 74 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00ed3	74 3e		 je	 SHORT $LN55@stbi__tga_

; 6006 :                STBI_ASSERT(tga_comp == STBI_rgb);

  00ed5	83 7c 24 60 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  00eda	74 1c		 je	 SHORT $LN85@stbi__tga_
  00edc	41 b8 76 17 00
	00		 mov	 r8d, 6006		; 00001776H
  00ee2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@GJDALCKK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AA?2@
  00ee9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@GOOINIO@?$AAt?$AAg?$AAa?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAB@
  00ef0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00ef6	33 c0		 xor	 eax, eax
$LN85@stbi__tga_:

; 6007 :                stbi__tga_read_rgb16(s, raw_data);

  00ef8	48 8d 94 24 a4
	00 00 00	 lea	 rdx, QWORD PTR raw_data$[rsp]
  00f00	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f08	e8 00 00 00 00	 call	 stbi__tga_read_rgb16
  00f0d	90		 npad	 1

; 6008 :             } else {

  00f0e	e9 23 01 00 00	 jmp	 $LN56@stbi__tga_
$LN55@stbi__tga_:

; 6009 :                //   read in the data raw
; 6010 :                for (j = 0; j < tga_comp; ++j) {

  00f13	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00f1e	eb 10		 jmp	 SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
  00f20	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00f27	ff c0		 inc	 eax
  00f29	89 84 24 9c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN16@stbi__tga_:
  00f30	8b 44 24 60	 mov	 eax, DWORD PTR tga_comp$[rsp]
  00f34	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00f3b	0f 8d f5 00 00
	00		 jge	 $LN15@stbi__tga_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00f41	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f49	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f51	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00f58	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00f5f	73 4b		 jae	 SHORT $LN119@stbi__tga_

; 1615 :       return *s->img_buffer++;

  00f61	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f69	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00f70	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f73	88 84 24 78 01
	00 00		 mov	 BYTE PTR tv531[rsp], al
  00f7a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f82	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00f89	48 ff c0	 inc	 rax
  00f8c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f94	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00f9b	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR tv531[rsp]
  00fa3	88 84 24 10 01
	00 00		 mov	 BYTE PTR $T23[rsp], al
  00faa	eb 6e		 jmp	 SHORT $LN118@stbi__tga_
$LN119@stbi__tga_:

; 1616 :    if (s->read_from_callbacks) {

  00fac	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00fb4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00fb8	74 58		 je	 SHORT $LN120@stbi__tga_

; 1617 :       stbi__refill_buffer(s);

  00fba	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00fc2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00fc7	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00fcf	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00fd6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00fd9	88 84 24 79 01
	00 00		 mov	 BYTE PTR tv540[rsp], al
  00fe0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00fe8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00fef	48 ff c0	 inc	 rax
  00ff2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ffa	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  01001	0f b6 84 24 79
	01 00 00	 movzx	 eax, BYTE PTR tv540[rsp]
  01009	88 84 24 10 01
	00 00		 mov	 BYTE PTR $T23[rsp], al
  01010	eb 08		 jmp	 SHORT $LN118@stbi__tga_
$LN120@stbi__tga_:

; 1619 :    }
; 1620 :    return 0;

  01012	c6 84 24 10 01
	00 00 00	 mov	 BYTE PTR $T23[rsp], 0
$LN118@stbi__tga_:

; 6011 :                   raw_data[j] = stbi__get8(s);

  0101a	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR $T23[rsp]
  01022	48 63 8c 24 9c
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  0102a	88 84 0c a4 00
	00 00		 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 6012 :                }

  01031	e9 ea fe ff ff	 jmp	 $LN14@stbi__tga_
$LN15@stbi__tga_:
$LN56@stbi__tga_:
$LN53@stbi__tga_:

; 6013 :             }
; 6014 :             //   clear the reading flag for the next pixel
; 6015 :             read_next_pixel = 0;

  01036	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR read_next_pixel$[rsp], 0
$LN51@stbi__tga_:

; 6016 :          } // end of reading a pixel
; 6017 : 
; 6018 :          // copy data
; 6019 :          for (j = 0; j < tga_comp; ++j)

  01041	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  0104c	eb 10		 jmp	 SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
  0104e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  01055	ff c0		 inc	 eax
  01057	89 84 24 9c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__tga_:
  0105e	8b 44 24 60	 mov	 eax, DWORD PTR tga_comp$[rsp]
  01062	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  01069	7d 33		 jge	 SHORT $LN18@stbi__tga_

; 6020 :            tga_data[i*tga_comp+j] = raw_data[j];

  0106b	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  01073	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0107a	0f af 4c 24 60	 imul	 ecx, DWORD PTR tga_comp$[rsp]
  0107f	03 8c 24 9c 00
	00 00		 add	 ecx, DWORD PTR j$[rsp]
  01086	48 63 c9	 movsxd	 rcx, ecx
  01089	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tga_data$[rsp]
  01091	0f b6 84 04 a4
	00 00 00	 movzx	 eax, BYTE PTR raw_data$[rsp+rax]
  01099	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0109c	eb b0		 jmp	 SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 6021 : 
; 6022 :          //   in case we're in RLE mode, keep counting down
; 6023 :          --RLE_count;

  0109e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR RLE_count$[rsp]
  010a5	ff c8		 dec	 eax
  010a7	89 84 24 b4 00
	00 00		 mov	 DWORD PTR RLE_count$[rsp], eax

; 6024 :       }

  010ae	e9 e0 fa ff ff	 jmp	 $LN8@stbi__tga_
$LN9@stbi__tga_:

; 6025 :       //   do I need to invert the image?
; 6026 :       if ( tga_inverted )

  010b3	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  010bb	0f 84 1d 01 00
	00		 je	 $LN57@stbi__tga_

; 6027 :       {
; 6028 :          for (j = 0; j*2 < tga_height; ++j)

  010c1	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  010cc	eb 10		 jmp	 SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
  010ce	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  010d5	ff c0		 inc	 eax
  010d7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN22@stbi__tga_:
  010de	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  010e5	d1 e0		 shl	 eax, 1
  010e7	3b 44 24 58	 cmp	 eax, DWORD PTR tga_height$[rsp]
  010eb	0f 8d ed 00 00
	00		 jge	 $LN21@stbi__tga_

; 6029 :          {
; 6030 :             int index1 = j * tga_width * tga_comp;

  010f1	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  010f8	0f af 44 24 54	 imul	 eax, DWORD PTR tga_width$[rsp]
  010fd	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  01102	89 84 24 e0 00
	00 00		 mov	 DWORD PTR index1$10[rsp], eax

; 6031 :             int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

  01109	8b 44 24 58	 mov	 eax, DWORD PTR tga_height$[rsp]
  0110d	ff c8		 dec	 eax
  0110f	2b 84 24 9c 00
	00 00		 sub	 eax, DWORD PTR j$[rsp]
  01116	0f af 44 24 54	 imul	 eax, DWORD PTR tga_width$[rsp]
  0111b	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  01120	89 84 24 e4 00
	00 00		 mov	 DWORD PTR index2$11[rsp], eax

; 6032 :             for (i = tga_width * tga_comp; i > 0; --i)

  01127	8b 44 24 54	 mov	 eax, DWORD PTR tga_width$[rsp]
  0112b	0f af 44 24 60	 imul	 eax, DWORD PTR tga_comp$[rsp]
  01130	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  01137	eb 10		 jmp	 SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
  01139	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01140	ff c8		 dec	 eax
  01142	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__tga_:
  01149	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  01151	0f 8e 82 00 00
	00		 jle	 $LN24@stbi__tga_

; 6033 :             {
; 6034 :                unsigned char temp = tga_data[index1];

  01157	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR index1$10[rsp]
  0115f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  01167	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0116b	88 84 24 e8 00
	00 00		 mov	 BYTE PTR temp$12[rsp], al

; 6035 :                tga_data[index1] = tga_data[index2];

  01172	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR index2$11[rsp]
  0117a	48 63 8c 24 e0
	00 00 00	 movsxd	 rcx, DWORD PTR index1$10[rsp]
  01182	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tga_data$[rsp]
  0118a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR tga_data$[rsp]
  01192	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  01196	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6036 :                tga_data[index2] = temp;

  01199	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR index2$11[rsp]
  011a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  011a9	0f b6 94 24 e8
	00 00 00	 movzx	 edx, BYTE PTR temp$12[rsp]
  011b1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 6037 :                ++index1;

  011b4	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR index1$10[rsp]
  011bb	ff c0		 inc	 eax
  011bd	89 84 24 e0 00
	00 00		 mov	 DWORD PTR index1$10[rsp], eax

; 6038 :                ++index2;

  011c4	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR index2$11[rsp]
  011cb	ff c0		 inc	 eax
  011cd	89 84 24 e4 00
	00 00		 mov	 DWORD PTR index2$11[rsp], eax

; 6039 :             }

  011d4	e9 60 ff ff ff	 jmp	 $LN23@stbi__tga_
$LN24@stbi__tga_:

; 6040 :          }

  011d9	e9 f0 fe ff ff	 jmp	 $LN20@stbi__tga_
$LN21@stbi__tga_:
$LN57@stbi__tga_:

; 6041 :       }
; 6042 :       //   clear my palette, if I had one
; 6043 :       if ( tga_palette != NULL )

  011de	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  011e7	74 0f		 je	 SHORT $LN58@stbi__tga_

; 6044 :       {
; 6045 :          STBI_FREE( tga_palette );

  011e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  011f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  011f7	90		 npad	 1
$LN58@stbi__tga_:
$LN39@stbi__tga_:

; 6046 :       }
; 6047 :    }
; 6048 : 
; 6049 :    // swap RGB - if the source data was RGB16, it already is in the right order
; 6050 :    if (tga_comp >= 3 && !tga_rgb16)

  011f8	83 7c 24 60 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  011fd	0f 8c cf 00 00
	00		 jl	 $LN59@stbi__tga_
  01203	83 7c 24 74 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  01208	0f 85 c4 00 00
	00		 jne	 $LN59@stbi__tga_

; 6051 :    {
; 6052 :       unsigned char* tga_pixel = tga_data;

  0120e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tga_data$[rsp]
  01216	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tga_pixel$13[rsp], rax

; 6053 :       for (i=0; i < tga_width * tga_height; ++i)

  0121e	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01229	eb 10		 jmp	 SHORT $LN28@stbi__tga_
$LN26@stbi__tga_:
  0122b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01232	ff c0		 inc	 eax
  01234	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__tga_:
  0123b	8b 44 24 54	 mov	 eax, DWORD PTR tga_width$[rsp]
  0123f	0f af 44 24 58	 imul	 eax, DWORD PTR tga_height$[rsp]
  01244	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0124b	0f 8d 81 00 00
	00		 jge	 $LN27@stbi__tga_

; 6054 :       {
; 6055 :          unsigned char temp = tga_pixel[0];

  01251	b8 01 00 00 00	 mov	 eax, 1
  01256	48 6b c0 00	 imul	 rax, rax, 0
  0125a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$13[rsp]
  01262	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01266	88 84 24 f8 00
	00 00		 mov	 BYTE PTR temp$14[rsp], al

; 6056 :          tga_pixel[0] = tga_pixel[2];

  0126d	b8 01 00 00 00	 mov	 eax, 1
  01272	48 6b c0 02	 imul	 rax, rax, 2
  01276	b9 01 00 00 00	 mov	 ecx, 1
  0127b	48 6b c9 00	 imul	 rcx, rcx, 0
  0127f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR tga_pixel$13[rsp]
  01287	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR tga_pixel$13[rsp]
  0128f	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  01293	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6057 :          tga_pixel[2] = temp;

  01296	b8 01 00 00 00	 mov	 eax, 1
  0129b	48 6b c0 02	 imul	 rax, rax, 2
  0129f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$13[rsp]
  012a7	0f b6 94 24 f8
	00 00 00	 movzx	 edx, BYTE PTR temp$14[rsp]
  012af	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 6058 :          tga_pixel += tga_comp;

  012b2	48 63 44 24 60	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  012b7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$13[rsp]
  012bf	48 03 c8	 add	 rcx, rax
  012c2	48 8b c1	 mov	 rax, rcx
  012c5	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tga_pixel$13[rsp], rax

; 6059 :       }

  012cd	e9 59 ff ff ff	 jmp	 $LN26@stbi__tga_
$LN27@stbi__tga_:
$LN59@stbi__tga_:

; 6060 :    }
; 6061 : 
; 6062 :    // convert to target component count
; 6063 :    if (req_comp && req_comp != tga_comp)

  012d2	83 bc 24 c0 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  012da	74 3b		 je	 SHORT $LN60@stbi__tga_
  012dc	8b 44 24 60	 mov	 eax, DWORD PTR tga_comp$[rsp]
  012e0	39 84 24 c0 01
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  012e7	74 2e		 je	 SHORT $LN60@stbi__tga_

; 6064 :       tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

  012e9	8b 44 24 58	 mov	 eax, DWORD PTR tga_height$[rsp]
  012ed	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  012f1	44 8b 4c 24 54	 mov	 r9d, DWORD PTR tga_width$[rsp]
  012f6	44 8b 84 24 c0
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  012fe	8b 54 24 60	 mov	 edx, DWORD PTR tga_comp$[rsp]
  01302	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tga_data$[rsp]
  0130a	e8 00 00 00 00	 call	 stbi__convert_format
  0130f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tga_data$[rsp], rax
$LN60@stbi__tga_:

; 6065 : 
; 6066 :    //   the things I do to get rid of an error message, and yet keep
; 6067 :    //   Microsoft's C compilers happy... [8^(
; 6068 :    tga_palette_start = tga_palette_len = tga_palette_bits =

  01317	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tga_y_origin$[rsp], 0
  0131f	8b 44 24 50	 mov	 eax, DWORD PTR tga_y_origin$[rsp]
  01323	89 44 24 4c	 mov	 DWORD PTR tga_x_origin$[rsp], eax
  01327	8b 44 24 4c	 mov	 eax, DWORD PTR tga_x_origin$[rsp]
  0132b	89 44 24 48	 mov	 DWORD PTR tga_palette_bits$[rsp], eax
  0132f	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_bits$[rsp]
  01333	89 44 24 44	 mov	 DWORD PTR tga_palette_len$[rsp], eax
  01337	8b 44 24 44	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  0133b	89 44 24 40	 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 6069 :          tga_x_origin = tga_y_origin = 0;
; 6070 :    STBI_NOTUSED(tga_palette_start);
; 6071 :    //   OK, done
; 6072 :    return tga_data;

  0133f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tga_data$[rsp]
$LN1@stbi__tga_:

; 6073 : }

  01347	48 8b f8	 mov	 rdi, rax
  0134a	48 8b cc	 mov	 rcx, rsp
  0134d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__tga_load$rtcFrameData
  01354	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01359	48 8b c7	 mov	 rax, rdi
  0135c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01364	48 33 cc	 xor	 rcx, rsp
  01367	e8 00 00 00 00	 call	 __security_check_cookie
  0136c	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  01373	5f		 pop	 rdi
  01374	c3		 ret	 0
stbi__tga_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
tv67 = 36
s$ = 64
stbi__psd_test PROC

; 6081 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6082 :    int r = (stbi__get32be(s) == 0x38425053);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__get32be
  00020	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00025	75 0a		 jne	 SHORT $LN3@stbi__psd_
  00027	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
  00031	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__psd_:
  00039	8b 44 24 24	 mov	 eax, DWORD PTR tv67[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6083 :    stbi__rewind(s);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00046	e8 00 00 00 00	 call	 stbi__rewind

; 6084 :    return r;

  0004b	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6085 : }

  0004f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
stbi__psd_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
count$ = 32
nleft$ = 36
len$ = 40
val$1 = 44
$T2 = 45
$T3 = 46
$T4 = 47
tv129 = 48
tv138 = 49
tv146 = 50
tv155 = 51
tv163 = 52
tv172 = 53
s$ = 80
p$ = 88
pixelCount$ = 96
stbi__psd_decode_rle PROC

; 6088 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6089 :    int count, nleft, len;
; 6090 : 
; 6091 :    count = 0;

  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@stbi__psd_:

; 6092 :    while ((nleft = pixelCount - count) > 0) {

  00028	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  0002c	8b 4c 24 60	 mov	 ecx, DWORD PTR pixelCount$[rsp]
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 24	 mov	 DWORD PTR nleft$[rsp], eax
  00038	83 7c 24 24 00	 cmp	 DWORD PTR nleft$[rsp], 0
  0003d	0f 8e f6 02 00
	00		 jle	 $LN3@stbi__psd_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00054	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0005b	73 39		 jae	 SHORT $LN17@stbi__psd_

; 1615 :       return *s->img_buffer++;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00062	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	88 44 24 30	 mov	 BYTE PTR tv129[rsp], al
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00075	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0007c	48 ff c0	 inc	 rax
  0007f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00084	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0008b	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv129[rsp]
  00090	88 44 24 2d	 mov	 BYTE PTR $T2[rsp], al
  00094	eb 53		 jmp	 SHORT $LN16@stbi__psd_
$LN17@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009b	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0009f	74 43		 je	 SHORT $LN18@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000b7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ba	88 44 24 31	 mov	 BYTE PTR tv138[rsp], al
  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000c3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ca	48 ff c0	 inc	 rax
  000cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d9	0f b6 44 24 31	 movzx	 eax, BYTE PTR tv138[rsp]
  000de	88 44 24 2d	 mov	 BYTE PTR $T2[rsp], al
  000e2	eb 05		 jmp	 SHORT $LN16@stbi__psd_
$LN18@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

  000e4	c6 44 24 2d 00	 mov	 BYTE PTR $T2[rsp], 0
$LN16@stbi__psd_:

; 6093 :       len = stbi__get8(s);

  000e9	0f b6 44 24 2d	 movzx	 eax, BYTE PTR $T2[rsp]
  000ee	0f b6 c0	 movzx	 eax, al
  000f1	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6094 :       if (len == 128) {

  000f5	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  000fd	75 05		 jne	 SHORT $LN8@stbi__psd_
  000ff	e9 30 02 00 00	 jmp	 $LN9@stbi__psd_
$LN8@stbi__psd_:

; 6095 :          // No-op.
; 6096 :       } else if (len < 128) {

  00104	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  0010c	0f 8d 0a 01 00
	00		 jge	 $LN10@stbi__psd_

; 6097 :          // Copy next len+1 bytes literally.
; 6098 :          len++;

  00112	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00116	ff c0		 inc	 eax
  00118	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6099 :          if (len > nleft) return 0; // corrupt data

  0011c	8b 44 24 24	 mov	 eax, DWORD PTR nleft$[rsp]
  00120	39 44 24 28	 cmp	 DWORD PTR len$[rsp], eax
  00124	7e 07		 jle	 SHORT $LN12@stbi__psd_
  00126	33 c0		 xor	 eax, eax
  00128	e9 11 02 00 00	 jmp	 $LN1@stbi__psd_
$LN12@stbi__psd_:

; 6100 :          count += len;

  0012d	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00131	8b 4c 24 20	 mov	 ecx, DWORD PTR count$[rsp]
  00135	03 c8		 add	 ecx, eax
  00137	8b c1		 mov	 eax, ecx
  00139	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
$LN4@stbi__psd_:

; 6101 :          while (len) {

  0013d	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00142	0f 84 cf 00 00
	00		 je	 $LN5@stbi__psd_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0014d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00152	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00159	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00160	73 39		 jae	 SHORT $LN21@stbi__psd_

; 1615 :       return *s->img_buffer++;

  00162	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00167	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0016e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00171	88 44 24 32	 mov	 BYTE PTR tv146[rsp], al
  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0017a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00181	48 ff c0	 inc	 rax
  00184	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00189	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00190	0f b6 44 24 32	 movzx	 eax, BYTE PTR tv146[rsp]
  00195	88 44 24 2e	 mov	 BYTE PTR $T3[rsp], al
  00199	eb 53		 jmp	 SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001a0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001a4	74 43		 je	 SHORT $LN22@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

  001a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001b0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bf	88 44 24 33	 mov	 BYTE PTR tv155[rsp], al
  001c3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001cf	48 ff c0	 inc	 rax
  001d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001d7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001de	0f b6 44 24 33	 movzx	 eax, BYTE PTR tv155[rsp]
  001e3	88 44 24 2e	 mov	 BYTE PTR $T3[rsp], al
  001e7	eb 05		 jmp	 SHORT $LN20@stbi__psd_
$LN22@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

  001e9	c6 44 24 2e 00	 mov	 BYTE PTR $T3[rsp], 0
$LN20@stbi__psd_:

; 6102 :             *p = stbi__get8(s);

  001ee	0f b6 44 24 2e	 movzx	 eax, BYTE PTR $T3[rsp]
  001f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001f8	88 01		 mov	 BYTE PTR [rcx], al

; 6103 :             p += 4;

  001fa	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  001ff	48 83 c0 04	 add	 rax, 4
  00203	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 6104 :             len--;

  00208	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0020c	ff c8		 dec	 eax
  0020e	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6105 :          }

  00212	e9 26 ff ff ff	 jmp	 $LN4@stbi__psd_
$LN5@stbi__psd_:

; 6106 :       } else if (len > 128) {

  00217	e9 18 01 00 00	 jmp	 $LN11@stbi__psd_
$LN10@stbi__psd_:
  0021c	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  00224	0f 8e 0a 01 00
	00		 jle	 $LN13@stbi__psd_

; 6107 :          stbi_uc   val;
; 6108 :          // Next -len+1 bytes in the dest are replicated from next source byte.
; 6109 :          // (Interpret len as a negative 8-bit int.)
; 6110 :          len = 257 - len;

  0022a	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  0022f	2b 44 24 28	 sub	 eax, DWORD PTR len$[rsp]
  00233	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6111 :          if (len > nleft) return 0; // corrupt data

  00237	8b 44 24 24	 mov	 eax, DWORD PTR nleft$[rsp]
  0023b	39 44 24 28	 cmp	 DWORD PTR len$[rsp], eax
  0023f	7e 07		 jle	 SHORT $LN14@stbi__psd_
  00241	33 c0		 xor	 eax, eax
  00243	e9 f6 00 00 00	 jmp	 $LN1@stbi__psd_
$LN14@stbi__psd_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0024d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00252	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00259	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00260	73 39		 jae	 SHORT $LN25@stbi__psd_

; 1615 :       return *s->img_buffer++;

  00262	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00267	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0026e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00271	88 44 24 34	 mov	 BYTE PTR tv163[rsp], al
  00275	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0027a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00281	48 ff c0	 inc	 rax
  00284	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00289	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00290	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv163[rsp]
  00295	88 44 24 2f	 mov	 BYTE PTR $T4[rsp], al
  00299	eb 53		 jmp	 SHORT $LN24@stbi__psd_
$LN25@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

  0029b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002a0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002a4	74 43		 je	 SHORT $LN26@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

  002a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ab	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002b0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002bf	88 44 24 35	 mov	 BYTE PTR tv172[rsp], al
  002c3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002cf	48 ff c0	 inc	 rax
  002d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002d7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002de	0f b6 44 24 35	 movzx	 eax, BYTE PTR tv172[rsp]
  002e3	88 44 24 2f	 mov	 BYTE PTR $T4[rsp], al
  002e7	eb 05		 jmp	 SHORT $LN24@stbi__psd_
$LN26@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

  002e9	c6 44 24 2f 00	 mov	 BYTE PTR $T4[rsp], 0
$LN24@stbi__psd_:

; 6112 :          val = stbi__get8(s);

  002ee	0f b6 44 24 2f	 movzx	 eax, BYTE PTR $T4[rsp]
  002f3	88 44 24 2c	 mov	 BYTE PTR val$1[rsp], al

; 6113 :          count += len;

  002f7	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  002fb	8b 4c 24 20	 mov	 ecx, DWORD PTR count$[rsp]
  002ff	03 c8		 add	 ecx, eax
  00301	8b c1		 mov	 eax, ecx
  00303	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
$LN6@stbi__psd_:

; 6114 :          while (len) {

  00307	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  0030c	74 26		 je	 SHORT $LN7@stbi__psd_

; 6115 :             *p = val;

  0030e	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00313	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR val$1[rsp]
  00318	88 08		 mov	 BYTE PTR [rax], cl

; 6116 :             p += 4;

  0031a	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  0031f	48 83 c0 04	 add	 rax, 4
  00323	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 6117 :             len--;

  00328	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0032c	ff c8		 dec	 eax
  0032e	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6118 :          }

  00332	eb d3		 jmp	 SHORT $LN6@stbi__psd_
$LN7@stbi__psd_:
$LN13@stbi__psd_:
$LN11@stbi__psd_:
$LN9@stbi__psd_:

; 6119 :       }
; 6120 :    }

  00334	e9 ef fc ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6121 : 
; 6122 :    return 1;

  00339	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 6123 : }

  0033e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00342	5f		 pop	 rdi
  00343	c3		 ret	 0
stbi__psd_decode_rle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
pixelCount$ = 48
channelCount$ = 52
compression$ = 56
channel$ = 60
i$ = 64
bitdepth$ = 68
w$ = 72
h$ = 76
out$ = 80
p$1 = 88
q$2 = 96
val$3 = 104
p$4 = 112
val$5 = 120
q$6 = 128
p$7 = 136
pixel$8 = 144
a$9 = 152
ra$10 = 156
inv_a$11 = 160
pixel$12 = 168
a$13 = 176
ra$14 = 180
inv_a$15 = 184
$T16 = 188
tv70 = 192
tv77 = 200
tv87 = 208
tv128 = 216
tv133 = 224
tv141 = 232
tv148 = 240
tv167 = 248
tv177 = 256
tv196 = 264
tv212 = 272
tv223 = 280
tv233 = 288
tv241 = 292
tv409 = 296
tv450 = 297
s$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
ri$ = 360
bpc$ = 368
stbi__psd_load PROC

; 6126 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6127 :    int pixelCount;
; 6128 :    int channelCount, compression;
; 6129 :    int channel, i;
; 6130 :    int bitdepth;
; 6131 :    int w,h;
; 6132 :    stbi_uc *out;
; 6133 :    STBI_NOTUSED(ri);
; 6134 : 
; 6135 :    // Check identifier
; 6136 :    if (stbi__get32be(s) != 0x38425053)   // "8BPS"

  00028	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00030	e8 00 00 00 00	 call	 stbi__get32be
  00035	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0003a	74 37		 je	 SHORT $LN32@stbi__psd_

; 6137 :       return stbi__errpuc("not PSD", "Corrupt PSD image");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07ECNCNLIK@not?5PSD@
  00043	e8 00 00 00 00	 call	 stbi__err
  00048	85 c0		 test	 eax, eax
  0004a	74 0e		 je	 SHORT $LN69@stbi__psd_
  0004c	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv70[rsp], 0
  00058	eb 0c		 jmp	 SHORT $LN70@stbi__psd_
$LN69@stbi__psd_:
  0005a	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv70[rsp], 0
$LN70@stbi__psd_:
  00066	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv70[rsp]
  0006e	e9 5f 0c 00 00	 jmp	 $LN1@stbi__psd_
$LN32@stbi__psd_:

; 6138 : 
; 6139 :    // Check file type version.
; 6140 :    if (stbi__get16be(s) != 1)

  00073	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0007b	e8 00 00 00 00	 call	 stbi__get16be
  00080	83 f8 01	 cmp	 eax, 1
  00083	74 37		 je	 SHORT $LN33@stbi__psd_

; 6141 :       return stbi__errpuc("wrong version", "Unsupported version of PSD image");

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CHBCDKKC@wrong?5version@
  0008c	e8 00 00 00 00	 call	 stbi__err
  00091	85 c0		 test	 eax, eax
  00093	74 0e		 je	 SHORT $LN71@stbi__psd_
  00095	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv77[rsp], 0
  000a1	eb 0c		 jmp	 SHORT $LN72@stbi__psd_
$LN71@stbi__psd_:
  000a3	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv77[rsp], 0
$LN72@stbi__psd_:
  000af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv77[rsp]
  000b7	e9 16 0c 00 00	 jmp	 $LN1@stbi__psd_
$LN33@stbi__psd_:

; 6142 : 
; 6143 :    // Skip 6 reserved bytes.
; 6144 :    stbi__skip(s, 6 );

  000bc	ba 06 00 00 00	 mov	 edx, 6
  000c1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c9	e8 00 00 00 00	 call	 stbi__skip

; 6145 : 
; 6146 :    // Read the number of channels (R, G, B, A, etc).
; 6147 :    channelCount = stbi__get16be(s);

  000ce	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000d6	e8 00 00 00 00	 call	 stbi__get16be
  000db	89 44 24 34	 mov	 DWORD PTR channelCount$[rsp], eax

; 6148 :    if (channelCount < 0 || channelCount > 16)

  000df	83 7c 24 34 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000e4	7c 07		 jl	 SHORT $LN35@stbi__psd_
  000e6	83 7c 24 34 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000eb	7e 37		 jle	 SHORT $LN34@stbi__psd_
$LN35@stbi__psd_:

; 6149 :       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@PJBNGDBE@wrong?5channel?5count@
  000f4	e8 00 00 00 00	 call	 stbi__err
  000f9	85 c0		 test	 eax, eax
  000fb	74 0e		 je	 SHORT $LN73@stbi__psd_
  000fd	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv87[rsp], 0
  00109	eb 0c		 jmp	 SHORT $LN74@stbi__psd_
$LN73@stbi__psd_:
  0010b	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv87[rsp], 0
$LN74@stbi__psd_:
  00117	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv87[rsp]
  0011f	e9 ae 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN34@stbi__psd_:

; 6150 : 
; 6151 :    // Read the rows and columns of the image.
; 6152 :    h = stbi__get32be(s);

  00124	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	e8 00 00 00 00	 call	 stbi__get32be
  00131	89 44 24 4c	 mov	 DWORD PTR h$[rsp], eax

; 6153 :    w = stbi__get32be(s);

  00135	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	e8 00 00 00 00	 call	 stbi__get32be
  00142	89 44 24 48	 mov	 DWORD PTR w$[rsp], eax

; 6154 : 
; 6155 :    if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00146	81 7c 24 4c 00
	00 00 01	 cmp	 DWORD PTR h$[rsp], 16777216 ; 01000000H
  0014e	7e 37		 jle	 SHORT $LN36@stbi__psd_
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00157	e8 00 00 00 00	 call	 stbi__err
  0015c	85 c0		 test	 eax, eax
  0015e	74 0e		 je	 SHORT $LN75@stbi__psd_
  00160	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv128[rsp], 0
  0016c	eb 0c		 jmp	 SHORT $LN76@stbi__psd_
$LN75@stbi__psd_:
  0016e	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv128[rsp], 0
$LN76@stbi__psd_:
  0017a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv128[rsp]
  00182	e9 4b 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN36@stbi__psd_:

; 6156 :    if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00187	81 7c 24 48 00
	00 00 01	 cmp	 DWORD PTR w$[rsp], 16777216 ; 01000000H
  0018f	7e 37		 jle	 SHORT $LN37@stbi__psd_
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00198	e8 00 00 00 00	 call	 stbi__err
  0019d	85 c0		 test	 eax, eax
  0019f	74 0e		 je	 SHORT $LN77@stbi__psd_
  001a1	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv133[rsp], 0
  001ad	eb 0c		 jmp	 SHORT $LN78@stbi__psd_
$LN77@stbi__psd_:
  001af	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv133[rsp], 0
$LN78@stbi__psd_:
  001bb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  001c3	e9 0a 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN37@stbi__psd_:

; 6157 : 
; 6158 :    // Make sure the depth is 8 bits.
; 6159 :    bitdepth = stbi__get16be(s);

  001c8	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001d0	e8 00 00 00 00	 call	 stbi__get16be
  001d5	89 44 24 44	 mov	 DWORD PTR bitdepth$[rsp], eax

; 6160 :    if (bitdepth != 8 && bitdepth != 16)

  001d9	83 7c 24 44 08	 cmp	 DWORD PTR bitdepth$[rsp], 8
  001de	74 3e		 je	 SHORT $LN38@stbi__psd_
  001e0	83 7c 24 44 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  001e5	74 37		 je	 SHORT $LN38@stbi__psd_

; 6161 :       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@NOLDLPP@unsupported?5bit?5depth@
  001ee	e8 00 00 00 00	 call	 stbi__err
  001f3	85 c0		 test	 eax, eax
  001f5	74 0e		 je	 SHORT $LN79@stbi__psd_
  001f7	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv141[rsp], 0
  00203	eb 0c		 jmp	 SHORT $LN80@stbi__psd_
$LN79@stbi__psd_:
  00205	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv141[rsp], 0
$LN80@stbi__psd_:
  00211	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv141[rsp]
  00219	e9 b4 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN38@stbi__psd_:

; 6162 : 
; 6163 :    // Make sure the color mode is RGB.
; 6164 :    // Valid options are:
; 6165 :    //   0: Bitmap
; 6166 :    //   1: Grayscale
; 6167 :    //   2: Indexed color
; 6168 :    //   3: RGB color
; 6169 :    //   4: CMYK color
; 6170 :    //   7: Multichannel
; 6171 :    //   8: Duotone
; 6172 :    //   9: Lab color
; 6173 :    if (stbi__get16be(s) != 3)

  0021e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00226	e8 00 00 00 00	 call	 stbi__get16be
  0022b	83 f8 03	 cmp	 eax, 3
  0022e	74 37		 je	 SHORT $LN39@stbi__psd_

; 6174 :       return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IOGGBMNK@wrong?5color?5format@
  00237	e8 00 00 00 00	 call	 stbi__err
  0023c	85 c0		 test	 eax, eax
  0023e	74 0e		 je	 SHORT $LN81@stbi__psd_
  00240	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv148[rsp], 0
  0024c	eb 0c		 jmp	 SHORT $LN82@stbi__psd_
$LN81@stbi__psd_:
  0024e	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv148[rsp], 0
$LN82@stbi__psd_:
  0025a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv148[rsp]
  00262	e9 6b 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN39@stbi__psd_:

; 6175 : 
; 6176 :    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6177 :    stbi__skip(s,stbi__get32be(s) );

  00267	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0026f	e8 00 00 00 00	 call	 stbi__get32be
  00274	8b d0		 mov	 edx, eax
  00276	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0027e	e8 00 00 00 00	 call	 stbi__skip

; 6178 : 
; 6179 :    // Skip the image resources.  (resolution, pen tool paths, etc)
; 6180 :    stbi__skip(s, stbi__get32be(s) );

  00283	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0028b	e8 00 00 00 00	 call	 stbi__get32be
  00290	8b d0		 mov	 edx, eax
  00292	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0029a	e8 00 00 00 00	 call	 stbi__skip

; 6181 : 
; 6182 :    // Skip the reserved data.
; 6183 :    stbi__skip(s, stbi__get32be(s) );

  0029f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a7	e8 00 00 00 00	 call	 stbi__get32be
  002ac	8b d0		 mov	 edx, eax
  002ae	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002b6	e8 00 00 00 00	 call	 stbi__skip

; 6184 : 
; 6185 :    // Find out if the data is compressed.
; 6186 :    // Known values:
; 6187 :    //   0: no compression
; 6188 :    //   1: RLE compressed
; 6189 :    compression = stbi__get16be(s);

  002bb	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002c3	e8 00 00 00 00	 call	 stbi__get16be
  002c8	89 44 24 38	 mov	 DWORD PTR compression$[rsp], eax

; 6190 :    if (compression > 1)

  002cc	83 7c 24 38 01	 cmp	 DWORD PTR compression$[rsp], 1
  002d1	7e 37		 jle	 SHORT $LN40@stbi__psd_

; 6191 :       return stbi__errpuc("bad compression", "PSD has an unknown compression format");

  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MCNBDLPD@bad?5compression@
  002da	e8 00 00 00 00	 call	 stbi__err
  002df	85 c0		 test	 eax, eax
  002e1	74 0e		 je	 SHORT $LN83@stbi__psd_
  002e3	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv167[rsp], 0
  002ef	eb 0c		 jmp	 SHORT $LN84@stbi__psd_
$LN83@stbi__psd_:
  002f1	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv167[rsp], 0
$LN84@stbi__psd_:
  002fd	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv167[rsp]
  00305	e9 c8 09 00 00	 jmp	 $LN1@stbi__psd_
$LN40@stbi__psd_:

; 6192 : 
; 6193 :    // Check size
; 6194 :    if (!stbi__mad3sizes_valid(4, w, h, 0))

  0030a	45 33 c9	 xor	 r9d, r9d
  0030d	44 8b 44 24 4c	 mov	 r8d, DWORD PTR h$[rsp]
  00312	8b 54 24 48	 mov	 edx, DWORD PTR w$[rsp]
  00316	b9 04 00 00 00	 mov	 ecx, 4
  0031b	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00320	85 c0		 test	 eax, eax
  00322	75 37		 jne	 SHORT $LN41@stbi__psd_

; 6195 :       return stbi__errpuc("too large", "Corrupt PSD");

  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0032b	e8 00 00 00 00	 call	 stbi__err
  00330	85 c0		 test	 eax, eax
  00332	74 0e		 je	 SHORT $LN85@stbi__psd_
  00334	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv177[rsp], 0
  00340	eb 0c		 jmp	 SHORT $LN86@stbi__psd_
$LN85@stbi__psd_:
  00342	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv177[rsp], 0
$LN86@stbi__psd_:
  0034e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv177[rsp]
  00356	e9 77 09 00 00	 jmp	 $LN1@stbi__psd_
$LN41@stbi__psd_:

; 6196 : 
; 6197 :    // Create the destination image.
; 6198 : 
; 6199 :    if (!compression && bitdepth == 16 && bpc == 16) {

  0035b	83 7c 24 38 00	 cmp	 DWORD PTR compression$[rsp], 0
  00360	75 3c		 jne	 SHORT $LN42@stbi__psd_
  00362	83 7c 24 44 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00367	75 35		 jne	 SHORT $LN42@stbi__psd_
  00369	83 bc 24 70 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  00371	75 2b		 jne	 SHORT $LN42@stbi__psd_

; 6200 :       out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);

  00373	45 33 c9	 xor	 r9d, r9d
  00376	44 8b 44 24 4c	 mov	 r8d, DWORD PTR h$[rsp]
  0037b	8b 54 24 48	 mov	 edx, DWORD PTR w$[rsp]
  0037f	b9 08 00 00 00	 mov	 ecx, 8
  00384	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00389	48 89 44 24 50	 mov	 QWORD PTR out$[rsp], rax

; 6201 :       ri->bits_per_channel = 16;

  0038e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00396	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 6202 :    } else

  0039c	eb 1b		 jmp	 SHORT $LN43@stbi__psd_
$LN42@stbi__psd_:

; 6203 :       out = (stbi_uc *) stbi__malloc(4 * w*h);

  0039e	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  003a2	c1 e0 02	 shl	 eax, 2
  003a5	0f af 44 24 4c	 imul	 eax, DWORD PTR h$[rsp]
  003aa	48 98		 cdqe
  003ac	48 8b c8	 mov	 rcx, rax
  003af	e8 00 00 00 00	 call	 stbi__malloc
  003b4	48 89 44 24 50	 mov	 QWORD PTR out$[rsp], rax
$LN43@stbi__psd_:

; 6204 : 
; 6205 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

  003b9	48 83 7c 24 50
	00		 cmp	 QWORD PTR out$[rsp], 0
  003bf	75 37		 jne	 SHORT $LN44@stbi__psd_
  003c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  003c8	e8 00 00 00 00	 call	 stbi__err
  003cd	85 c0		 test	 eax, eax
  003cf	74 0e		 je	 SHORT $LN87@stbi__psd_
  003d1	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
  003dd	eb 0c		 jmp	 SHORT $LN88@stbi__psd_
$LN87@stbi__psd_:
  003df	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
$LN88@stbi__psd_:
  003eb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv196[rsp]
  003f3	e9 da 08 00 00	 jmp	 $LN1@stbi__psd_
$LN44@stbi__psd_:

; 6206 :    pixelCount = w*h;

  003f8	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  003fc	0f af 44 24 4c	 imul	 eax, DWORD PTR h$[rsp]
  00401	89 44 24 30	 mov	 DWORD PTR pixelCount$[rsp], eax

; 6207 : 
; 6208 :    // Initialize the data to zero.
; 6209 :    //memset( out, 0, pixelCount * 4 );
; 6210 : 
; 6211 :    // Finally, the image data.
; 6212 :    if (compression) {

  00405	83 7c 24 38 00	 cmp	 DWORD PTR compression$[rsp], 0
  0040a	0f 84 1e 01 00
	00		 je	 $LN45@stbi__psd_

; 6213 :       // RLE as used by .PSD and .TIFF
; 6214 :       // Loop until you get the number of unpacked bytes you are expecting:
; 6215 :       //     Read the next source byte into n.
; 6216 :       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6217 :       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6218 :       //     Else if n is 128, noop.
; 6219 :       // Endloop
; 6220 : 
; 6221 :       // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6222 :       // which we're going to just skip.
; 6223 :       stbi__skip(s, h * channelCount * 2 );

  00410	8b 44 24 4c	 mov	 eax, DWORD PTR h$[rsp]
  00414	0f af 44 24 34	 imul	 eax, DWORD PTR channelCount$[rsp]
  00419	d1 e0		 shl	 eax, 1
  0041b	8b d0		 mov	 edx, eax
  0041d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00425	e8 00 00 00 00	 call	 stbi__skip
  0042a	90		 npad	 1

; 6224 : 
; 6225 :       // Read the RLE data by channel.
; 6226 :       for (channel = 0; channel < 4; channel++) {

  0042b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00433	eb 0a		 jmp	 SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
  00435	8b 44 24 3c	 mov	 eax, DWORD PTR channel$[rsp]
  00439	ff c0		 inc	 eax
  0043b	89 44 24 3c	 mov	 DWORD PTR channel$[rsp], eax
$LN4@stbi__psd_:
  0043f	83 7c 24 3c 04	 cmp	 DWORD PTR channel$[rsp], 4
  00444	0f 8d df 00 00
	00		 jge	 $LN3@stbi__psd_

; 6227 :          stbi_uc *p;
; 6228 : 
; 6229 :          p = out+channel;

  0044a	48 63 44 24 3c	 movsxd	 rax, DWORD PTR channel$[rsp]
  0044f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00454	48 03 c8	 add	 rcx, rax
  00457	48 8b c1	 mov	 rax, rcx
  0045a	48 89 44 24 58	 mov	 QWORD PTR p$1[rsp], rax

; 6230 :          if (channel >= channelCount) {

  0045f	8b 44 24 34	 mov	 eax, DWORD PTR channelCount$[rsp]
  00463	39 44 24 3c	 cmp	 DWORD PTR channel$[rsp], eax
  00467	7c 5e		 jl	 SHORT $LN47@stbi__psd_

; 6231 :             // Fill this channel with default data.
; 6232 :             for (i = 0; i < pixelCount; i++, p += 4)

  00469	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00471	eb 18		 jmp	 SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
  00473	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00477	ff c0		 inc	 eax
  00479	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  0047d	48 8b 44 24 58	 mov	 rax, QWORD PTR p$1[rsp]
  00482	48 83 c0 04	 add	 rax, 4
  00486	48 89 44 24 58	 mov	 QWORD PTR p$1[rsp], rax
$LN7@stbi__psd_:
  0048b	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  0048f	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00493	7d 30		 jge	 SHORT $LN6@stbi__psd_

; 6233 :                *p = (channel == 3 ? 255 : 0);

  00495	83 7c 24 3c 03	 cmp	 DWORD PTR channel$[rsp], 3
  0049a	75 0d		 jne	 SHORT $LN89@stbi__psd_
  0049c	c7 84 24 10 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv212[rsp], 255 ; 000000ffH
  004a7	eb 0b		 jmp	 SHORT $LN90@stbi__psd_
$LN89@stbi__psd_:
  004a9	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN90@stbi__psd_:
  004b4	48 8b 44 24 58	 mov	 rax, QWORD PTR p$1[rsp]
  004b9	0f b6 8c 24 10
	01 00 00	 movzx	 ecx, BYTE PTR tv212[rsp]
  004c1	88 08		 mov	 BYTE PTR [rax], cl
  004c3	eb ae		 jmp	 SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 6234 :          } else {

  004c5	eb 5d		 jmp	 SHORT $LN48@stbi__psd_
$LN47@stbi__psd_:

; 6235 :             // Read the RLE data.
; 6236 :             if (!stbi__psd_decode_rle(s, p, pixelCount)) {

  004c7	44 8b 44 24 30	 mov	 r8d, DWORD PTR pixelCount$[rsp]
  004cc	48 8b 54 24 58	 mov	 rdx, QWORD PTR p$1[rsp]
  004d1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d9	e8 00 00 00 00	 call	 stbi__psd_decode_rle
  004de	85 c0		 test	 eax, eax
  004e0	75 42		 jne	 SHORT $LN49@stbi__psd_

; 6237 :                STBI_FREE(out);

  004e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6238 :                return stbi__errpuc("corrupt", "bad RLE data");

  004ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  004f4	e8 00 00 00 00	 call	 stbi__err
  004f9	85 c0		 test	 eax, eax
  004fb	74 0e		 je	 SHORT $LN91@stbi__psd_
  004fd	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv223[rsp], 0
  00509	eb 0c		 jmp	 SHORT $LN92@stbi__psd_
$LN91@stbi__psd_:
  0050b	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv223[rsp], 0
$LN92@stbi__psd_:
  00517	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv223[rsp]
  0051f	e9 ae 07 00 00	 jmp	 $LN1@stbi__psd_
$LN49@stbi__psd_:
$LN48@stbi__psd_:

; 6239 :             }
; 6240 :          }
; 6241 :       }

  00524	e9 0c ff ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6242 : 
; 6243 :    } else {

  00529	e9 4e 03 00 00	 jmp	 $LN46@stbi__psd_
$LN45@stbi__psd_:

; 6244 :       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6245 :       // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6246 : 
; 6247 :       // Read the data by channel.
; 6248 :       for (channel = 0; channel < 4; channel++) {

  0052e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00536	eb 0a		 jmp	 SHORT $LN10@stbi__psd_
$LN8@stbi__psd_:
  00538	8b 44 24 3c	 mov	 eax, DWORD PTR channel$[rsp]
  0053c	ff c0		 inc	 eax
  0053e	89 44 24 3c	 mov	 DWORD PTR channel$[rsp], eax
$LN10@stbi__psd_:
  00542	83 7c 24 3c 04	 cmp	 DWORD PTR channel$[rsp], 4
  00547	0f 8d 2f 03 00
	00		 jge	 $LN9@stbi__psd_

; 6249 :          if (channel >= channelCount) {

  0054d	8b 44 24 34	 mov	 eax, DWORD PTR channelCount$[rsp]
  00551	39 44 24 3c	 cmp	 DWORD PTR channel$[rsp], eax
  00555	0f 8c 10 01 00
	00		 jl	 $LN50@stbi__psd_

; 6250 :             // Fill this channel with default data.
; 6251 :             if (bitdepth == 16 && bpc == 16) {

  0055b	83 7c 24 44 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00560	0f 85 86 00 00
	00		 jne	 $LN52@stbi__psd_
  00566	83 bc 24 70 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  0056e	75 7c		 jne	 SHORT $LN52@stbi__psd_

; 6252 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  00570	48 63 44 24 3c	 movsxd	 rax, DWORD PTR channel$[rsp]
  00575	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  0057a	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0057e	48 89 44 24 60	 mov	 QWORD PTR q$2[rsp], rax

; 6253 :                stbi__uint16 val = channel == 3 ? 65535 : 0;

  00583	83 7c 24 3c 03	 cmp	 DWORD PTR channel$[rsp], 3
  00588	75 0d		 jne	 SHORT $LN93@stbi__psd_
  0058a	c7 84 24 20 01
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv233[rsp], 65535 ; 0000ffffH
  00595	eb 0b		 jmp	 SHORT $LN94@stbi__psd_
$LN93@stbi__psd_:
  00597	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
$LN94@stbi__psd_:
  005a2	0f b7 84 24 20
	01 00 00	 movzx	 eax, WORD PTR tv233[rsp]
  005aa	66 89 44 24 68	 mov	 WORD PTR val$3[rsp], ax

; 6254 :                for (i = 0; i < pixelCount; i++, q += 4)

  005af	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005b7	eb 18		 jmp	 SHORT $LN13@stbi__psd_
$LN11@stbi__psd_:
  005b9	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  005bd	ff c0		 inc	 eax
  005bf	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  005c3	48 8b 44 24 60	 mov	 rax, QWORD PTR q$2[rsp]
  005c8	48 83 c0 08	 add	 rax, 8
  005cc	48 89 44 24 60	 mov	 QWORD PTR q$2[rsp], rax
$LN13@stbi__psd_:
  005d1	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  005d5	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  005d9	7d 0f		 jge	 SHORT $LN12@stbi__psd_

; 6255 :                   *q = val;

  005db	48 8b 44 24 60	 mov	 rax, QWORD PTR q$2[rsp]
  005e0	0f b7 4c 24 68	 movzx	 ecx, WORD PTR val$3[rsp]
  005e5	66 89 08	 mov	 WORD PTR [rax], cx
  005e8	eb cf		 jmp	 SHORT $LN11@stbi__psd_
$LN12@stbi__psd_:

; 6256 :             } else {

  005ea	eb 7a		 jmp	 SHORT $LN53@stbi__psd_
$LN52@stbi__psd_:

; 6257 :                stbi_uc *p = out+channel;

  005ec	48 63 44 24 3c	 movsxd	 rax, DWORD PTR channel$[rsp]
  005f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  005f6	48 03 c8	 add	 rcx, rax
  005f9	48 8b c1	 mov	 rax, rcx
  005fc	48 89 44 24 70	 mov	 QWORD PTR p$4[rsp], rax

; 6258 :                stbi_uc val = channel == 3 ? 255 : 0;

  00601	83 7c 24 3c 03	 cmp	 DWORD PTR channel$[rsp], 3
  00606	75 0d		 jne	 SHORT $LN95@stbi__psd_
  00608	c7 84 24 24 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv241[rsp], 255 ; 000000ffH
  00613	eb 0b		 jmp	 SHORT $LN96@stbi__psd_
$LN95@stbi__psd_:
  00615	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv241[rsp], 0
$LN96@stbi__psd_:
  00620	0f b6 84 24 24
	01 00 00	 movzx	 eax, BYTE PTR tv241[rsp]
  00628	88 44 24 78	 mov	 BYTE PTR val$5[rsp], al

; 6259 :                for (i = 0; i < pixelCount; i++, p += 4)

  0062c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00634	eb 18		 jmp	 SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
  00636	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0063a	ff c0		 inc	 eax
  0063c	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00640	48 8b 44 24 70	 mov	 rax, QWORD PTR p$4[rsp]
  00645	48 83 c0 04	 add	 rax, 4
  00649	48 89 44 24 70	 mov	 QWORD PTR p$4[rsp], rax
$LN16@stbi__psd_:
  0064e	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00652	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00656	7d 0e		 jge	 SHORT $LN15@stbi__psd_

; 6260 :                   *p = val;

  00658	48 8b 44 24 70	 mov	 rax, QWORD PTR p$4[rsp]
  0065d	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR val$5[rsp]
  00662	88 08		 mov	 BYTE PTR [rax], cl
  00664	eb d0		 jmp	 SHORT $LN14@stbi__psd_
$LN15@stbi__psd_:
$LN53@stbi__psd_:

; 6261 :             }
; 6262 :          } else {

  00666	e9 0c 02 00 00	 jmp	 $LN51@stbi__psd_
$LN50@stbi__psd_:

; 6263 :             if (ri->bits_per_channel == 16) {    // output bpc

  0066b	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00673	83 38 10	 cmp	 DWORD PTR [rax], 16
  00676	75 67		 jne	 SHORT $LN54@stbi__psd_

; 6264 :                stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  00678	48 63 44 24 3c	 movsxd	 rax, DWORD PTR channel$[rsp]
  0067d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00682	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00686	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR q$6[rsp], rax

; 6265 :                for (i = 0; i < pixelCount; i++, q += 4)

  0068e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00696	eb 1e		 jmp	 SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
  00698	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0069c	ff c0		 inc	 eax
  0069e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  006a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$6[rsp]
  006aa	48 83 c0 08	 add	 rax, 8
  006ae	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR q$6[rsp], rax
$LN19@stbi__psd_:
  006b6	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  006ba	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  006be	7d 1a		 jge	 SHORT $LN18@stbi__psd_

; 6266 :                   *q = (stbi__uint16) stbi__get16be(s);

  006c0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006c8	e8 00 00 00 00	 call	 stbi__get16be
  006cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR q$6[rsp]
  006d5	66 89 01	 mov	 WORD PTR [rcx], ax
  006d8	eb be		 jmp	 SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 6267 :             } else {

  006da	e9 98 01 00 00	 jmp	 $LN55@stbi__psd_
$LN54@stbi__psd_:

; 6268 :                stbi_uc *p = out+channel;

  006df	48 63 44 24 3c	 movsxd	 rax, DWORD PTR channel$[rsp]
  006e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  006e9	48 03 c8	 add	 rcx, rax
  006ec	48 8b c1	 mov	 rax, rcx
  006ef	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$7[rsp], rax

; 6269 :                if (bitdepth == 16) {  // input bpc

  006f7	83 7c 24 44 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  006fc	75 53		 jne	 SHORT $LN56@stbi__psd_

; 6270 :                   for (i = 0; i < pixelCount; i++, p += 4)

  006fe	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00706	eb 1e		 jmp	 SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
  00708	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0070c	ff c0		 inc	 eax
  0070e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00712	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  0071a	48 83 c0 04	 add	 rax, 4
  0071e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$7[rsp], rax
$LN22@stbi__psd_:
  00726	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  0072a	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0072e	7d 1c		 jge	 SHORT $LN21@stbi__psd_

; 6271 :                      *p = (stbi_uc) (stbi__get16be(s) >> 8);

  00730	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00738	e8 00 00 00 00	 call	 stbi__get16be
  0073d	c1 f8 08	 sar	 eax, 8
  00740	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR p$7[rsp]
  00748	88 01		 mov	 BYTE PTR [rcx], al
  0074a	eb bc		 jmp	 SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 6272 :                } else {

  0074c	e9 26 01 00 00	 jmp	 $LN57@stbi__psd_
$LN56@stbi__psd_:

; 6273 :                   for (i = 0; i < pixelCount; i++, p += 4)

  00751	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00759	eb 1e		 jmp	 SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
  0075b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0075f	ff c0		 inc	 eax
  00761	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00765	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  0076d	48 83 c0 04	 add	 rax, 4
  00771	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR p$7[rsp], rax
$LN25@stbi__psd_:
  00779	8b 44 24 30	 mov	 eax, DWORD PTR pixelCount$[rsp]
  0077d	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00781	0f 8d f0 00 00
	00		 jge	 $LN24@stbi__psd_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00787	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0078f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00797	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0079e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  007a5	73 4b		 jae	 SHORT $LN98@stbi__psd_

; 1615 :       return *s->img_buffer++;

  007a7	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007af	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007b6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007b9	88 84 24 28 01
	00 00		 mov	 BYTE PTR tv409[rsp], al
  007c0	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007cf	48 ff c0	 inc	 rax
  007d2	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007da	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  007e1	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR tv409[rsp]
  007e9	88 84 24 bc 00
	00 00		 mov	 BYTE PTR $T16[rsp], al
  007f0	eb 6e		 jmp	 SHORT $LN97@stbi__psd_
$LN98@stbi__psd_:

; 1616 :    if (s->read_from_callbacks) {

  007f2	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007fa	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007fe	74 58		 je	 SHORT $LN99@stbi__psd_

; 1617 :       stbi__refill_buffer(s);

  00800	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00808	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0080d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00815	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0081c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0081f	88 84 24 29 01
	00 00		 mov	 BYTE PTR tv450[rsp], al
  00826	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0082e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00835	48 ff c0	 inc	 rax
  00838	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00840	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00847	0f b6 84 24 29
	01 00 00	 movzx	 eax, BYTE PTR tv450[rsp]
  0084f	88 84 24 bc 00
	00 00		 mov	 BYTE PTR $T16[rsp], al
  00856	eb 08		 jmp	 SHORT $LN97@stbi__psd_
$LN99@stbi__psd_:

; 1619 :    }
; 1620 :    return 0;

  00858	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR $T16[rsp], 0
$LN97@stbi__psd_:

; 6274 :                      *p = stbi__get8(s);

  00860	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR $T16[rsp]
  00868	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR p$7[rsp]
  00870	88 01		 mov	 BYTE PTR [rcx], al
  00872	e9 e4 fe ff ff	 jmp	 $LN23@stbi__psd_
$LN24@stbi__psd_:
$LN57@stbi__psd_:
$LN55@stbi__psd_:
$LN51@stbi__psd_:

; 6275 :                }
; 6276 :             }
; 6277 :          }
; 6278 :       }

  00877	e9 bc fc ff ff	 jmp	 $LN8@stbi__psd_
$LN9@stbi__psd_:
$LN46@stbi__psd_:

; 6279 :    }
; 6280 : 
; 6281 :    // remove weird white matte from PSD
; 6282 :    if (channelCount >= 4) {

  0087c	83 7c 24 34 04	 cmp	 DWORD PTR channelCount$[rsp], 4
  00881	0f 8c 8d 03 00
	00		 jl	 $LN58@stbi__psd_

; 6283 :       if (ri->bits_per_channel == 16) {

  00887	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0088f	83 38 10	 cmp	 DWORD PTR [rax], 16
  00892	0f 85 c1 01 00
	00		 jne	 $LN59@stbi__psd_

; 6284 :          for (i=0; i < w*h; ++i) {

  00898	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  008a0	eb 0a		 jmp	 SHORT $LN28@stbi__psd_
$LN26@stbi__psd_:
  008a2	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  008a6	ff c0		 inc	 eax
  008a8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__psd_:
  008ac	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  008b0	0f af 44 24 4c	 imul	 eax, DWORD PTR h$[rsp]
  008b5	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  008b9	0f 8d 95 01 00
	00		 jge	 $LN27@stbi__psd_

; 6285 :             stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;

  008bf	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  008c3	c1 e0 02	 shl	 eax, 2
  008c6	48 98		 cdqe
  008c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  008cd	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  008d1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pixel$8[rsp], rax

; 6286 :             if (pixel[3] != 0 && pixel[3] != 65535) {

  008d9	b8 02 00 00 00	 mov	 eax, 2
  008de	48 6b c0 03	 imul	 rax, rax, 3
  008e2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  008ea	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008ee	85 c0		 test	 eax, eax
  008f0	0f 84 59 01 00
	00		 je	 $LN61@stbi__psd_
  008f6	b8 02 00 00 00	 mov	 eax, 2
  008fb	48 6b c0 03	 imul	 rax, rax, 3
  008ff	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  00907	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0090b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00910	0f 84 39 01 00
	00		 je	 $LN61@stbi__psd_

; 6287 :                float a = pixel[3] / 65535.0f;

  00916	b8 02 00 00 00	 mov	 eax, 2
  0091b	48 6b c0 03	 imul	 rax, rax, 3
  0091f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  00927	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0092b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0092f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@477fff00
  00937	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR a$9[rsp], xmm0

; 6288 :                float ra = 1.0f / a;

  00940	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00948	f3 0f 5e 84 24
	98 00 00 00	 divss	 xmm0, DWORD PTR a$9[rsp]
  00951	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR ra$10[rsp], xmm0

; 6289 :                float inv_a = 65535.0f * (1 - ra);

  0095a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00962	f3 0f 5c 84 24
	9c 00 00 00	 subss	 xmm0, DWORD PTR ra$10[rsp]
  0096b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@477fff00
  00973	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00977	0f 28 c1	 movaps	 xmm0, xmm1
  0097a	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR inv_a$11[rsp], xmm0

; 6290 :                pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

  00983	b8 02 00 00 00	 mov	 eax, 2
  00988	48 6b c0 00	 imul	 rax, rax, 0
  0098c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  00994	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00998	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0099c	f3 0f 59 84 24
	9c 00 00 00	 mulss	 xmm0, DWORD PTR ra$10[rsp]
  009a5	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rsp]
  009ae	f3 0f 2c c0	 cvttss2si eax, xmm0
  009b2	b9 02 00 00 00	 mov	 ecx, 2
  009b7	48 6b c9 00	 imul	 rcx, rcx, 0
  009bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pixel$8[rsp]
  009c3	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6291 :                pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

  009c7	b8 02 00 00 00	 mov	 eax, 2
  009cc	48 6b c0 01	 imul	 rax, rax, 1
  009d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  009d8	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  009dc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  009e0	f3 0f 59 84 24
	9c 00 00 00	 mulss	 xmm0, DWORD PTR ra$10[rsp]
  009e9	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rsp]
  009f2	f3 0f 2c c0	 cvttss2si eax, xmm0
  009f6	b9 02 00 00 00	 mov	 ecx, 2
  009fb	48 6b c9 01	 imul	 rcx, rcx, 1
  009ff	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pixel$8[rsp]
  00a07	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6292 :                pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

  00a0b	b8 02 00 00 00	 mov	 eax, 2
  00a10	48 6b c0 02	 imul	 rax, rax, 2
  00a14	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pixel$8[rsp]
  00a1c	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00a20	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a24	f3 0f 59 84 24
	9c 00 00 00	 mulss	 xmm0, DWORD PTR ra$10[rsp]
  00a2d	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR inv_a$11[rsp]
  00a36	f3 0f 2c c0	 cvttss2si eax, xmm0
  00a3a	b9 02 00 00 00	 mov	 ecx, 2
  00a3f	48 6b c9 02	 imul	 rcx, rcx, 2
  00a43	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pixel$8[rsp]
  00a4b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN61@stbi__psd_:

; 6293 :             }
; 6294 :          }

  00a4f	e9 4e fe ff ff	 jmp	 $LN26@stbi__psd_
$LN27@stbi__psd_:

; 6295 :       } else {

  00a54	e9 bb 01 00 00	 jmp	 $LN60@stbi__psd_
$LN59@stbi__psd_:

; 6296 :          for (i=0; i < w*h; ++i) {

  00a59	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a61	eb 0a		 jmp	 SHORT $LN31@stbi__psd_
$LN29@stbi__psd_:
  00a63	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00a67	ff c0		 inc	 eax
  00a69	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN31@stbi__psd_:
  00a6d	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  00a71	0f af 44 24 4c	 imul	 eax, DWORD PTR h$[rsp]
  00a76	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00a7a	0f 8d 94 01 00
	00		 jge	 $LN30@stbi__psd_

; 6297 :             unsigned char *pixel = out + 4*i;

  00a80	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00a84	c1 e0 02	 shl	 eax, 2
  00a87	48 98		 cdqe
  00a89	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00a8e	48 03 c8	 add	 rcx, rax
  00a91	48 8b c1	 mov	 rax, rcx
  00a94	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pixel$12[rsp], rax

; 6298 :             if (pixel[3] != 0 && pixel[3] != 255) {

  00a9c	b8 01 00 00 00	 mov	 eax, 1
  00aa1	48 6b c0 03	 imul	 rax, rax, 3
  00aa5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00aad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ab1	85 c0		 test	 eax, eax
  00ab3	0f 84 56 01 00
	00		 je	 $LN62@stbi__psd_
  00ab9	b8 01 00 00 00	 mov	 eax, 1
  00abe	48 6b c0 03	 imul	 rax, rax, 3
  00ac2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00aca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ace	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00ad3	0f 84 36 01 00
	00		 je	 $LN62@stbi__psd_

; 6299 :                float a = pixel[3] / 255.0f;

  00ad9	b8 01 00 00 00	 mov	 eax, 1
  00ade	48 6b c0 03	 imul	 rax, rax, 3
  00ae2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00aea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00aee	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00af2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  00afa	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR a$13[rsp], xmm0

; 6300 :                float ra = 1.0f / a;

  00b03	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b0b	f3 0f 5e 84 24
	b0 00 00 00	 divss	 xmm0, DWORD PTR a$13[rsp]
  00b14	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR ra$14[rsp], xmm0

; 6301 :                float inv_a = 255.0f * (1 - ra);

  00b1d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b25	f3 0f 5c 84 24
	b4 00 00 00	 subss	 xmm0, DWORD PTR ra$14[rsp]
  00b2e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@437f0000
  00b36	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00b3a	0f 28 c1	 movaps	 xmm0, xmm1
  00b3d	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR inv_a$15[rsp], xmm0

; 6302 :                pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

  00b46	b8 01 00 00 00	 mov	 eax, 1
  00b4b	48 6b c0 00	 imul	 rax, rax, 0
  00b4f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00b57	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b5b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b5f	f3 0f 59 84 24
	b4 00 00 00	 mulss	 xmm0, DWORD PTR ra$14[rsp]
  00b68	f3 0f 58 84 24
	b8 00 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rsp]
  00b71	f3 0f 2c c0	 cvttss2si eax, xmm0
  00b75	b9 01 00 00 00	 mov	 ecx, 1
  00b7a	48 6b c9 00	 imul	 rcx, rcx, 0
  00b7e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pixel$12[rsp]
  00b86	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6303 :                pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

  00b89	b8 01 00 00 00	 mov	 eax, 1
  00b8e	48 6b c0 01	 imul	 rax, rax, 1
  00b92	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00b9a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b9e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ba2	f3 0f 59 84 24
	b4 00 00 00	 mulss	 xmm0, DWORD PTR ra$14[rsp]
  00bab	f3 0f 58 84 24
	b8 00 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rsp]
  00bb4	f3 0f 2c c0	 cvttss2si eax, xmm0
  00bb8	b9 01 00 00 00	 mov	 ecx, 1
  00bbd	48 6b c9 01	 imul	 rcx, rcx, 1
  00bc1	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pixel$12[rsp]
  00bc9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6304 :                pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

  00bcc	b8 01 00 00 00	 mov	 eax, 1
  00bd1	48 6b c0 02	 imul	 rax, rax, 2
  00bd5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pixel$12[rsp]
  00bdd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00be1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00be5	f3 0f 59 84 24
	b4 00 00 00	 mulss	 xmm0, DWORD PTR ra$14[rsp]
  00bee	f3 0f 58 84 24
	b8 00 00 00	 addss	 xmm0, DWORD PTR inv_a$15[rsp]
  00bf7	f3 0f 2c c0	 cvttss2si eax, xmm0
  00bfb	b9 01 00 00 00	 mov	 ecx, 1
  00c00	48 6b c9 02	 imul	 rcx, rcx, 2
  00c04	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pixel$12[rsp]
  00c0c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN62@stbi__psd_:

; 6305 :             }
; 6306 :          }

  00c0f	e9 4f fe ff ff	 jmp	 $LN29@stbi__psd_
$LN30@stbi__psd_:
$LN60@stbi__psd_:
$LN58@stbi__psd_:

; 6307 :       }
; 6308 :    }
; 6309 : 
; 6310 :    // convert to desired output format
; 6311 :    if (req_comp && req_comp != 4) {

  00c14	83 bc 24 60 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00c1c	74 7a		 je	 SHORT $LN63@stbi__psd_
  00c1e	83 bc 24 60 01
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00c26	74 70		 je	 SHORT $LN63@stbi__psd_

; 6312 :       if (ri->bits_per_channel == 16)

  00c28	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00c30	83 38 10	 cmp	 DWORD PTR [rax], 16
  00c33	75 2b		 jne	 SHORT $LN64@stbi__psd_

; 6313 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);

  00c35	8b 44 24 4c	 mov	 eax, DWORD PTR h$[rsp]
  00c39	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c3d	44 8b 4c 24 48	 mov	 r9d, DWORD PTR w$[rsp]
  00c42	44 8b 84 24 60
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00c4a	ba 04 00 00 00	 mov	 edx, 4
  00c4f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00c54	e8 00 00 00 00	 call	 stbi__convert_format16
  00c59	48 89 44 24 50	 mov	 QWORD PTR out$[rsp], rax
  00c5e	eb 29		 jmp	 SHORT $LN65@stbi__psd_
$LN64@stbi__psd_:

; 6314 :       else
; 6315 :          out = stbi__convert_format(out, 4, req_comp, w, h);

  00c60	8b 44 24 4c	 mov	 eax, DWORD PTR h$[rsp]
  00c64	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c68	44 8b 4c 24 48	 mov	 r9d, DWORD PTR w$[rsp]
  00c6d	44 8b 84 24 60
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00c75	ba 04 00 00 00	 mov	 edx, 4
  00c7a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out$[rsp]
  00c7f	e8 00 00 00 00	 call	 stbi__convert_format
  00c84	48 89 44 24 50	 mov	 QWORD PTR out$[rsp], rax
$LN65@stbi__psd_:

; 6316 :       if (out == NULL) return out; // stbi__convert_format frees input on failure

  00c89	48 83 7c 24 50
	00		 cmp	 QWORD PTR out$[rsp], 0
  00c8f	75 07		 jne	 SHORT $LN66@stbi__psd_
  00c91	48 8b 44 24 50	 mov	 rax, QWORD PTR out$[rsp]
  00c96	eb 3a		 jmp	 SHORT $LN1@stbi__psd_
$LN66@stbi__psd_:
$LN63@stbi__psd_:

; 6317 :    }
; 6318 : 
; 6319 :    if (comp) *comp = 4;

  00c98	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00ca1	74 0e		 je	 SHORT $LN67@stbi__psd_
  00ca3	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00cab	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN67@stbi__psd_:

; 6320 :    *y = h;

  00cb1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00cb9	8b 4c 24 4c	 mov	 ecx, DWORD PTR h$[rsp]
  00cbd	89 08		 mov	 DWORD PTR [rax], ecx

; 6321 :    *x = w;

  00cbf	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00cc7	8b 4c 24 48	 mov	 ecx, DWORD PTR w$[rsp]
  00ccb	89 08		 mov	 DWORD PTR [rax], ecx

; 6322 : 
; 6323 :    return out;

  00ccd	48 8b 44 24 50	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__psd_:

; 6324 : }

  00cd2	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00cd9	5f		 pop	 rdi
  00cda	c3		 ret	 0
stbi__psd_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
$T1 = 36
tv83 = 37
tv92 = 38
s$ = 64
str$ = 72
stbi__pic_is4 PROC

; 6336 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	90		 npad	 1

; 6337 :    int i;
; 6338 :    for (i=0; i<4; ++i)

  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00024	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00026	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00030	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  00035	0f 8d c9 00 00
	00		 jge	 $LN3@stbi__pic_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00045	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0004c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00053	73 39		 jae	 SHORT $LN8@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00061	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00064	88 44 24 25	 mov	 BYTE PTR tv83[rsp], al
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00074	48 ff c0	 inc	 rax
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00083	0f b6 44 24 25	 movzx	 eax, BYTE PTR tv83[rsp]
  00088	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  0008c	eb 53		 jmp	 SHORT $LN7@stbi__pic_
$LN8@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00093	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00097	74 43		 je	 SHORT $LN9@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b2	88 44 24 26	 mov	 BYTE PTR tv92[rsp], al
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000bb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000c2	48 ff c0	 inc	 rax
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ca	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d1	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv92[rsp]
  000d6	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000da	eb 05		 jmp	 SHORT $LN7@stbi__pic_
$LN9@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  000dc	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__pic_:

; 6339 :       if (stbi__get8(s) != (stbi_uc)str[i])

  000e1	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ee	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  000f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 04		 je	 SHORT $LN5@stbi__pic_

; 6340 :          return 0;

  000fb	33 c0		 xor	 eax, eax
  000fd	eb 0a		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
  000ff	e9 22 ff ff ff	 jmp	 $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6341 : 
; 6342 :    return 1;

  00104	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6343 : }

  00109	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
stbi__pic_is4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv84 = 36
tv93 = 37
s$ = 64
stbi__pic_test_core PROC

; 6346 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6347 :    int i;
; 6348 : 
; 6349 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00022	e8 00 00 00 00	 call	 stbi__pic_is4
  00027	85 c0		 test	 eax, eax
  00029	75 07		 jne	 SHORT $LN5@stbi__pic_

; 6350 :       return 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 cf 00 00 00	 jmp	 $LN1@stbi__pic_
$LN5@stbi__pic_:

; 6351 : 
; 6352 :    for(i=0;i<84;++i)

  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003a	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00046	83 7c 24 20 54	 cmp	 DWORD PTR i$[rsp], 84	; 00000054H
  0004b	0f 8d 92 00 00
	00		 jge	 $LN3@stbi__pic_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00062	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00069	73 30		 jae	 SHORT $LN9@stbi__pic_

; 1615 :       return *s->img_buffer++;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00070	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00077	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007a	88 44 24 24	 mov	 BYTE PTR tv84[rsp], al
  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	48 ff c0	 inc	 rax
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00092	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00099	eb 43		 jmp	 SHORT $LN8@stbi__pic_
$LN9@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000a4	74 38		 je	 SHORT $LN10@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  000a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ab	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000bf	88 44 24 25	 mov	 BYTE PTR tv93[rsp], al
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000cf	48 ff c0	 inc	 rax
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN10@stbi__pic_:
$LN8@stbi__pic_:

; 6353 :       stbi__get8(s);

  000de	e9 59 ff ff ff	 jmp	 $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6354 : 
; 6355 :    if (!stbi__pic_is4(s,"PICT"))

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	e8 00 00 00 00	 call	 stbi__pic_is4
  000f4	85 c0		 test	 eax, eax
  000f6	75 04		 jne	 SHORT $LN6@stbi__pic_

; 6356 :       return 0;

  000f8	33 c0		 xor	 eax, eax
  000fa	eb 05		 jmp	 SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6357 : 
; 6358 :    return 1;

  000fc	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6359 : }

  00101	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
stbi__pic_test_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
mask$ = 32
i$ = 36
$T1 = 40
$T2 = 44
tv94 = 48
tv75 = 56
tv134 = 64
tv143 = 65
s$ = 96
channel$ = 104
dest$ = 112
stbi__readval PROC

; 6367 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6368 :    int mask=0x80, i;

  0001f	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6369 : 
; 6370 :    for (i=0; i<4; ++i, mask>>=1) {

  00027	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002f	eb 14		 jmp	 SHORT $LN4@stbi__read
$LN2@stbi__read:
  00031	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR mask$[rsp]
  0003f	d1 f8		 sar	 eax, 1
  00041	89 44 24 20	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__read:
  00045	83 7c 24 24 04	 cmp	 DWORD PTR i$[rsp], 4
  0004a	0f 8d 7b 01 00
	00		 jge	 $LN3@stbi__read

; 6371 :       if (channel & mask) {

  00050	8b 44 24 20	 mov	 eax, DWORD PTR mask$[rsp]
  00054	8b 4c 24 68	 mov	 ecx, DWORD PTR channel$[rsp]
  00058	23 c8		 and	 ecx, eax
  0005a	8b c1		 mov	 eax, ecx
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 62 01 00
	00		 je	 $LN5@stbi__read

; 1628 :    if (s->io.read) {

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00069	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006e	74 34		 je	 SHORT $LN11@stbi__read

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00070	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00075	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0007e	ff 50 20	 call	 QWORD PTR [rax+32]
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN12@stbi__read
  00085	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  0008d	eb 49		 jmp	 SHORT $LN10@stbi__read
$LN12@stbi__read:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0008f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00094	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00098	75 0a		 jne	 SHORT $LN13@stbi__read
  0009a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
  000a2	eb 34		 jmp	 SHORT $LN10@stbi__read
$LN13@stbi__read:
$LN11@stbi__read:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ae	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000b5	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000bc	72 0a		 jb	 SHORT $LN15@stbi__read
  000be	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000c6	eb 08		 jmp	 SHORT $LN16@stbi__read
$LN15@stbi__read:
  000c8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@stbi__read:
  000d0	8b 44 24 30	 mov	 eax, DWORD PTR tv94[rsp]
  000d4	89 44 24 28	 mov	 DWORD PTR $T1[rsp], eax
$LN10@stbi__read:

; 6372 :          if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");

  000d8	8b 44 24 28	 mov	 eax, DWORD PTR $T1[rsp]
  000dc	85 c0		 test	 eax, eax
  000de	74 2e		 je	 SHORT $LN6@stbi__read
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  000e7	e8 00 00 00 00	 call	 stbi__err
  000ec	85 c0		 test	 eax, eax
  000ee	74 0b		 je	 SHORT $LN8@stbi__read
  000f0	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
  000f9	eb 09		 jmp	 SHORT $LN9@stbi__read
$LN8@stbi__read:
  000fb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv75[rsp], 0
$LN9@stbi__read:
  00104	48 8b 44 24 38	 mov	 rax, QWORD PTR tv75[rsp]
  00109	e9 c2 00 00 00	 jmp	 $LN1@stbi__read
$LN6@stbi__read:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00118	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0011f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00126	73 39		 jae	 SHORT $LN18@stbi__read

; 1615 :       return *s->img_buffer++;

  00128	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0012d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00134	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00137	88 44 24 40	 mov	 BYTE PTR tv134[rsp], al
  0013b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00140	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00147	48 ff c0	 inc	 rax
  0014a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00156	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv134[rsp]
  0015b	88 44 24 2c	 mov	 BYTE PTR $T2[rsp], al
  0015f	eb 53		 jmp	 SHORT $LN17@stbi__read
$LN18@stbi__read:

; 1616 :    if (s->read_from_callbacks) {

  00161	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00166	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0016a	74 43		 je	 SHORT $LN19@stbi__read

; 1617 :       stbi__refill_buffer(s);

  0016c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00171	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00176	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0017b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00182	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00185	88 44 24 41	 mov	 BYTE PTR tv143[rsp], al
  00189	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0018e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00195	48 ff c0	 inc	 rax
  00198	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0019d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001a4	0f b6 44 24 41	 movzx	 eax, BYTE PTR tv143[rsp]
  001a9	88 44 24 2c	 mov	 BYTE PTR $T2[rsp], al
  001ad	eb 05		 jmp	 SHORT $LN17@stbi__read
$LN19@stbi__read:

; 1619 :    }
; 1620 :    return 0;

  001af	c6 44 24 2c 00	 mov	 BYTE PTR $T2[rsp], 0
$LN17@stbi__read:

; 6373 :          dest[i]=stbi__get8(s);

  001b4	0f b6 44 24 2c	 movzx	 eax, BYTE PTR $T2[rsp]
  001b9	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  001be	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001c3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__read:

; 6374 :       }
; 6375 :    }

  001c6	e9 66 fe ff ff	 jmp	 $LN2@stbi__read
$LN3@stbi__read:

; 6376 : 
; 6377 :    return dest;

  001cb	48 8b 44 24 70	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@stbi__read:

; 6378 : }

  001d0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001d4	5f		 pop	 rdi
  001d5	c3		 ret	 0
stbi__readval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
mask$ = 32
i$ = 36
channel$ = 64
dest$ = 72
src$ = 80
stbi__copyval PROC

; 6381 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6382 :    int mask=0x80,i;

  0001f	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6383 : 
; 6384 :    for (i=0;i<4; ++i, mask>>=1)

  00027	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002f	eb 14		 jmp	 SHORT $LN4@stbi__copy
$LN2@stbi__copy:
  00031	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR mask$[rsp]
  0003f	d1 f8		 sar	 eax, 1
  00041	89 44 24 20	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__copy:
  00045	83 7c 24 24 04	 cmp	 DWORD PTR i$[rsp], 4
  0004a	7d 2e		 jge	 SHORT $LN3@stbi__copy

; 6385 :       if (channel&mask)

  0004c	8b 44 24 20	 mov	 eax, DWORD PTR mask$[rsp]
  00050	8b 4c 24 40	 mov	 ecx, DWORD PTR channel$[rsp]
  00054	23 c8		 and	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	85 c0		 test	 eax, eax
  0005a	74 1c		 je	 SHORT $LN5@stbi__copy

; 6386 :          dest[i]=src[i];

  0005c	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00061	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00066	48 8b 54 24 48	 mov	 rdx, QWORD PTR dest$[rsp]
  0006b	4c 8b 44 24 50	 mov	 r8, QWORD PTR src$[rsp]
  00070	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00075	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__copy:
  00078	eb b7		 jmp	 SHORT $LN2@stbi__copy
$LN3@stbi__copy:

; 6387 : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
stbi__copyval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
act_comp$ = 32
num_packets$ = 36
y$ = 40
chained$ = 44
packets$ = 56
packet$6 = 104
packet_idx$7 = 112
packet$8 = 120
dest$9 = 128
x$10 = 136
left$11 = 140
i$12 = 144
count$13 = 148
value$14 = 164
left$15 = 180
count$16 = 184
i$17 = 188
value$18 = 196
$T19 = 224
$T20 = 225
$T21 = 226
$T22 = 227
$T23 = 228
$T24 = 232
$T25 = 236
$T26 = 240
$T27 = 244
tv69 = 248
tv264 = 256
tv273 = 257
tv281 = 258
tv290 = 259
tv298 = 260
tv307 = 261
tv315 = 262
tv324 = 263
tv336 = 264
tv95 = 272
tv134 = 280
tv138 = 288
tv152 = 292
tv156 = 296
tv344 = 304
tv353 = 305
tv365 = 308
tv176 = 312
tv373 = 320
tv382 = 321
tv426 = 324
tv207 = 328
tv217 = 336
tv238 = 344
__$ArrayPad$ = 352
s$ = 384
width$ = 392
height$ = 400
comp$ = 408
result$ = 416
stbi__pic_load_core PROC

; 6390 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 70 01
	00 00		 sub	 rsp, 368		; 00000170H
  0001b	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00020	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR [rsp+384]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6391 :    int act_comp=0,num_packets=0,y,chained;

  00052	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  0005a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0
$LN4@stbi__pic_:

; 6392 :    stbi__pic_packet packets[10];
; 6393 : 
; 6394 :    // this will (should...) cater for even some bizarre stuff like having data
; 6395 :     // for the same channel in multiple packets.
; 6396 :    do {
; 6397 :       stbi__pic_packet *packet;
; 6398 : 
; 6399 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))

  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00067	48 83 f8 0a	 cmp	 rax, 10
  0006b	75 37		 jne	 SHORT $LN29@stbi__pic_

; 6400 :          return stbi__errpuc("bad format","too many packets");

  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00074	e8 00 00 00 00	 call	 stbi__err
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $LN50@stbi__pic_
  0007d	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv69[rsp], 0
  00089	eb 0c		 jmp	 SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
  0008b	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv69[rsp], 0
$LN51@stbi__pic_:
  00097	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv69[rsp]
  0009f	e9 3b 0d 00 00	 jmp	 $LN1@stbi__pic_
$LN29@stbi__pic_:

; 6401 : 
; 6402 :       packet = &packets[num_packets++];

  000a4	48 63 44 24 24	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  000a9	48 6b c0 03	 imul	 rax, rax, 3
  000ad	48 8d 44 04 38	 lea	 rax, QWORD PTR packets$[rsp+rax]
  000b2	48 89 44 24 68	 mov	 QWORD PTR packet$6[rsp], rax
  000b7	8b 44 24 24	 mov	 eax, DWORD PTR num_packets$[rsp]
  000bb	ff c0		 inc	 eax
  000bd	89 44 24 24	 mov	 DWORD PTR num_packets$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000c1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000d1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000d8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000df	73 4b		 jae	 SHORT $LN69@stbi__pic_

; 1615 :       return *s->img_buffer++;

  000e1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f3	88 84 24 00 01
	00 00		 mov	 BYTE PTR tv264[rsp], al
  000fa	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00102	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00109	48 ff c0	 inc	 rax
  0010c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00114	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0011b	0f b6 84 24 00
	01 00 00	 movzx	 eax, BYTE PTR tv264[rsp]
  00123	88 84 24 e0 00
	00 00		 mov	 BYTE PTR $T19[rsp], al
  0012a	eb 6e		 jmp	 SHORT $LN68@stbi__pic_
$LN69@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  0012c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00134	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00138	74 58		 je	 SHORT $LN70@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  0013a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00142	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00147	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00156	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00159	88 84 24 01 01
	00 00		 mov	 BYTE PTR tv273[rsp], al
  00160	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00168	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0016f	48 ff c0	 inc	 rax
  00172	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0017a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00181	0f b6 84 24 01
	01 00 00	 movzx	 eax, BYTE PTR tv273[rsp]
  00189	88 84 24 e0 00
	00 00		 mov	 BYTE PTR $T19[rsp], al
  00190	eb 08		 jmp	 SHORT $LN68@stbi__pic_
$LN70@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00192	c6 84 24 e0 00
	00 00 00	 mov	 BYTE PTR $T19[rsp], 0
$LN68@stbi__pic_:

; 6403 : 
; 6404 :       chained = stbi__get8(s);

  0019a	0f b6 84 24 e0
	00 00 00	 movzx	 eax, BYTE PTR $T19[rsp]
  001a2	0f b6 c0	 movzx	 eax, al
  001a5	89 44 24 2c	 mov	 DWORD PTR chained$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001a9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b1	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001b9	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001c0	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001c7	73 4b		 jae	 SHORT $LN73@stbi__pic_

; 1615 :       return *s->img_buffer++;

  001c9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001d1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001db	88 84 24 02 01
	00 00		 mov	 BYTE PTR tv281[rsp], al
  001e2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ea	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001f1	48 ff c0	 inc	 rax
  001f4	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001fc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00203	0f b6 84 24 02
	01 00 00	 movzx	 eax, BYTE PTR tv281[rsp]
  0020b	88 84 24 e1 00
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00212	eb 6e		 jmp	 SHORT $LN72@stbi__pic_
$LN73@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  00214	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0021c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00220	74 58		 je	 SHORT $LN74@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  00222	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0022a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0022f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00237	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0023e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00241	88 84 24 03 01
	00 00		 mov	 BYTE PTR tv290[rsp], al
  00248	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00250	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00257	48 ff c0	 inc	 rax
  0025a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00262	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00269	0f b6 84 24 03
	01 00 00	 movzx	 eax, BYTE PTR tv290[rsp]
  00271	88 84 24 e1 00
	00 00		 mov	 BYTE PTR $T20[rsp], al
  00278	eb 08		 jmp	 SHORT $LN72@stbi__pic_
$LN74@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  0027a	c6 84 24 e1 00
	00 00 00	 mov	 BYTE PTR $T20[rsp], 0
$LN72@stbi__pic_:

; 6405 :       packet->size    = stbi__get8(s);

  00282	0f b6 84 24 e1
	00 00 00	 movzx	 eax, BYTE PTR $T20[rsp]
  0028a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR packet$6[rsp]
  0028f	88 01		 mov	 BYTE PTR [rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00291	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00299	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002a8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002af	73 4b		 jae	 SHORT $LN77@stbi__pic_

; 1615 :       return *s->img_buffer++;

  002b1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002c0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c3	88 84 24 04 01
	00 00		 mov	 BYTE PTR tv298[rsp], al
  002ca	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002d2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002d9	48 ff c0	 inc	 rax
  002dc	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002e4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002eb	0f b6 84 24 04
	01 00 00	 movzx	 eax, BYTE PTR tv298[rsp]
  002f3	88 84 24 e2 00
	00 00		 mov	 BYTE PTR $T21[rsp], al
  002fa	eb 6e		 jmp	 SHORT $LN76@stbi__pic_
$LN77@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  002fc	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00304	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00308	74 58		 je	 SHORT $LN78@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  0030a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00312	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00317	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0031f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00326	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00329	88 84 24 05 01
	00 00		 mov	 BYTE PTR tv307[rsp], al
  00330	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00338	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0033f	48 ff c0	 inc	 rax
  00342	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0034a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00351	0f b6 84 24 05
	01 00 00	 movzx	 eax, BYTE PTR tv307[rsp]
  00359	88 84 24 e2 00
	00 00		 mov	 BYTE PTR $T21[rsp], al
  00360	eb 08		 jmp	 SHORT $LN76@stbi__pic_
$LN78@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00362	c6 84 24 e2 00
	00 00 00	 mov	 BYTE PTR $T21[rsp], 0
$LN76@stbi__pic_:

; 6406 :       packet->type    = stbi__get8(s);

  0036a	0f b6 84 24 e2
	00 00 00	 movzx	 eax, BYTE PTR $T21[rsp]
  00372	48 8b 4c 24 68	 mov	 rcx, QWORD PTR packet$6[rsp]
  00377	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0037a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00382	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00391	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00398	73 4b		 jae	 SHORT $LN81@stbi__pic_

; 1615 :       return *s->img_buffer++;

  0039a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003a9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003ac	88 84 24 06 01
	00 00		 mov	 BYTE PTR tv315[rsp], al
  003b3	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003bb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003c2	48 ff c0	 inc	 rax
  003c5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003cd	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003d4	0f b6 84 24 06
	01 00 00	 movzx	 eax, BYTE PTR tv315[rsp]
  003dc	88 84 24 e3 00
	00 00		 mov	 BYTE PTR $T22[rsp], al
  003e3	eb 6e		 jmp	 SHORT $LN80@stbi__pic_
$LN81@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  003e5	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ed	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  003f1	74 58		 je	 SHORT $LN82@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  003f3	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003fb	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00400	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00408	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0040f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00412	88 84 24 07 01
	00 00		 mov	 BYTE PTR tv324[rsp], al
  00419	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00421	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00428	48 ff c0	 inc	 rax
  0042b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00433	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0043a	0f b6 84 24 07
	01 00 00	 movzx	 eax, BYTE PTR tv324[rsp]
  00442	88 84 24 e3 00
	00 00		 mov	 BYTE PTR $T22[rsp], al
  00449	eb 08		 jmp	 SHORT $LN80@stbi__pic_
$LN82@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  0044b	c6 84 24 e3 00
	00 00 00	 mov	 BYTE PTR $T22[rsp], 0
$LN80@stbi__pic_:

; 6407 :       packet->channel = stbi__get8(s);

  00453	0f b6 84 24 e3
	00 00 00	 movzx	 eax, BYTE PTR $T22[rsp]
  0045b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR packet$6[rsp]
  00460	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6408 : 
; 6409 :       act_comp |= packet->channel;

  00463	48 8b 44 24 68	 mov	 rax, QWORD PTR packet$6[rsp]
  00468	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0046c	8b 4c 24 20	 mov	 ecx, DWORD PTR act_comp$[rsp]
  00470	0b c8		 or	 ecx, eax
  00472	8b c1		 mov	 eax, ecx
  00474	89 44 24 20	 mov	 DWORD PTR act_comp$[rsp], eax

; 1628 :    if (s->io.read) {

  00478	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00480	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00485	74 43		 je	 SHORT $LN85@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00487	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0048f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00493	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0049b	ff 50 20	 call	 QWORD PTR [rax+32]
  0049e	85 c0		 test	 eax, eax
  004a0	75 0d		 jne	 SHORT $LN86@stbi__pic_
  004a2	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR $T23[rsp], 0
  004ad	eb 61		 jmp	 SHORT $LN84@stbi__pic_
$LN86@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  004af	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b7	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004bb	75 0d		 jne	 SHORT $LN87@stbi__pic_
  004bd	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR $T23[rsp], 1
  004c8	eb 46		 jmp	 SHORT $LN84@stbi__pic_
$LN87@stbi__pic_:
$LN85@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  004ca	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d2	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004da	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  004e1	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  004e8	72 0d		 jb	 SHORT $LN89@stbi__pic_
  004ea	c7 84 24 08 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv336[rsp], 1
  004f5	eb 0b		 jmp	 SHORT $LN90@stbi__pic_
$LN89@stbi__pic_:
  004f7	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv336[rsp], 0
$LN90@stbi__pic_:
  00502	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv336[rsp]
  00509	89 84 24 e4 00
	00 00		 mov	 DWORD PTR $T23[rsp], eax
$LN84@stbi__pic_:

; 6410 : 
; 6411 :       if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");

  00510	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR $T23[rsp]
  00517	85 c0		 test	 eax, eax
  00519	74 37		 je	 SHORT $LN30@stbi__pic_
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00522	e8 00 00 00 00	 call	 stbi__err
  00527	85 c0		 test	 eax, eax
  00529	74 0e		 je	 SHORT $LN52@stbi__pic_
  0052b	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv95[rsp], 0
  00537	eb 0c		 jmp	 SHORT $LN53@stbi__pic_
$LN52@stbi__pic_:
  00539	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv95[rsp], 0
$LN53@stbi__pic_:
  00545	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv95[rsp]
  0054d	e9 8d 08 00 00	 jmp	 $LN1@stbi__pic_
$LN30@stbi__pic_:

; 6412 :       if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");

  00552	48 8b 44 24 68	 mov	 rax, QWORD PTR packet$6[rsp]
  00557	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0055a	83 f8 08	 cmp	 eax, 8
  0055d	74 37		 je	 SHORT $LN31@stbi__pic_
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00566	e8 00 00 00 00	 call	 stbi__err
  0056b	85 c0		 test	 eax, eax
  0056d	74 0e		 je	 SHORT $LN54@stbi__pic_
  0056f	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv134[rsp], 0
  0057b	eb 0c		 jmp	 SHORT $LN55@stbi__pic_
$LN54@stbi__pic_:
  0057d	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv134[rsp], 0
$LN55@stbi__pic_:
  00589	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv134[rsp]
  00591	e9 49 08 00 00	 jmp	 $LN1@stbi__pic_
$LN31@stbi__pic_:

; 6413 :    } while (chained);

  00596	83 7c 24 2c 00	 cmp	 DWORD PTR chained$[rsp], 0
  0059b	0f 85 c1 fa ff
	ff		 jne	 $LN4@stbi__pic_

; 6414 : 
; 6415 :    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

  005a1	8b 44 24 20	 mov	 eax, DWORD PTR act_comp$[rsp]
  005a5	83 e0 10	 and	 eax, 16
  005a8	85 c0		 test	 eax, eax
  005aa	74 0d		 je	 SHORT $LN56@stbi__pic_
  005ac	c7 84 24 20 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv138[rsp], 4
  005b7	eb 0b		 jmp	 SHORT $LN57@stbi__pic_
$LN56@stbi__pic_:
  005b9	c7 84 24 20 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv138[rsp], 3
$LN57@stbi__pic_:
  005c4	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  005cc	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv138[rsp]
  005d3	89 08		 mov	 DWORD PTR [rax], ecx

; 6416 : 
; 6417 :    for(y=0; y<height; ++y) {

  005d5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0
  005dd	eb 0a		 jmp	 SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
  005df	8b 44 24 28	 mov	 eax, DWORD PTR y$[rsp]
  005e3	ff c0		 inc	 eax
  005e5	89 44 24 28	 mov	 DWORD PTR y$[rsp], eax
$LN7@stbi__pic_:
  005e9	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR height$[rsp]
  005f0	39 44 24 28	 cmp	 DWORD PTR y$[rsp], eax
  005f4	0f 8d dd 07 00
	00		 jge	 $LN6@stbi__pic_

; 6418 :       int packet_idx;
; 6419 : 
; 6420 :       for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

  005fa	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR packet_idx$7[rsp], 0
  00602	eb 0a		 jmp	 SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
  00604	8b 44 24 70	 mov	 eax, DWORD PTR packet_idx$7[rsp]
  00608	ff c0		 inc	 eax
  0060a	89 44 24 70	 mov	 DWORD PTR packet_idx$7[rsp], eax
$LN10@stbi__pic_:
  0060e	8b 44 24 24	 mov	 eax, DWORD PTR num_packets$[rsp]
  00612	39 44 24 70	 cmp	 DWORD PTR packet_idx$7[rsp], eax
  00616	0f 8d b6 07 00
	00		 jge	 $LN9@stbi__pic_

; 6421 :          stbi__pic_packet *packet = &packets[packet_idx];

  0061c	48 63 44 24 70	 movsxd	 rax, DWORD PTR packet_idx$7[rsp]
  00621	48 6b c0 03	 imul	 rax, rax, 3
  00625	48 8d 44 04 38	 lea	 rax, QWORD PTR packets$[rsp+rax]
  0062a	48 89 44 24 78	 mov	 QWORD PTR packet$8[rsp], rax

; 6422 :          stbi_uc *dest = result+y*width*4;

  0062f	8b 44 24 28	 mov	 eax, DWORD PTR y$[rsp]
  00633	0f af 84 24 88
	01 00 00	 imul	 eax, DWORD PTR width$[rsp]
  0063b	c1 e0 02	 shl	 eax, 2
  0063e	48 98		 cdqe
  00640	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00648	48 03 c8	 add	 rcx, rax
  0064b	48 8b c1	 mov	 rax, rcx
  0064e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$9[rsp], rax

; 6423 : 
; 6424 :          switch (packet->type) {

  00656	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  0065b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0065f	88 84 24 24 01
	00 00		 mov	 BYTE PTR tv152[rsp], al
  00666	80 bc 24 24 01
	00 00 00	 cmp	 BYTE PTR tv152[rsp], 0
  0066e	74 53		 je	 SHORT $LN33@stbi__pic_
  00670	80 bc 24 24 01
	00 00 01	 cmp	 BYTE PTR tv152[rsp], 1
  00678	0f 84 b9 00 00
	00		 je	 $LN35@stbi__pic_
  0067e	80 bc 24 24 01
	00 00 02	 cmp	 BYTE PTR tv152[rsp], 2
  00686	0f 84 5e 03 00
	00		 je	 $LN39@stbi__pic_

; 6425 :             default:
; 6426 :                return stbi__errpuc("bad format","packet has bad compression type");

  0068c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMAPJJO@bad?5format@
  00693	e8 00 00 00 00	 call	 stbi__err
  00698	85 c0		 test	 eax, eax
  0069a	74 0e		 je	 SHORT $LN58@stbi__pic_
  0069c	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv156[rsp], 0
  006a8	eb 0c		 jmp	 SHORT $LN59@stbi__pic_
$LN58@stbi__pic_:
  006aa	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv156[rsp], 0
$LN59@stbi__pic_:
  006b6	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  006be	e9 1c 07 00 00	 jmp	 $LN1@stbi__pic_
$LN33@stbi__pic_:

; 6427 : 
; 6428 :             case 0: {//uncompressed
; 6429 :                int x;
; 6430 : 
; 6431 :                for(x=0;x<width;++x, dest+=4)

  006c3	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$10[rsp], 0
  006ce	eb 24		 jmp	 SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
  006d0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$10[rsp]
  006d7	ff c0		 inc	 eax
  006d9	89 84 24 88 00
	00 00		 mov	 DWORD PTR x$10[rsp], eax
  006e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$9[rsp]
  006e8	48 83 c0 04	 add	 rax, 4
  006ec	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$9[rsp], rax
$LN15@stbi__pic_:
  006f4	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  006fb	39 84 24 88 00
	00 00		 cmp	 DWORD PTR x$10[rsp], eax
  00702	7d 2e		 jge	 SHORT $LN14@stbi__pic_

; 6432 :                   if (!stbi__readval(s,packet->channel,dest))

  00704	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  00709	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0070d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dest$9[rsp]
  00715	8b d0		 mov	 edx, eax
  00717	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0071f	e8 00 00 00 00	 call	 stbi__readval
  00724	48 85 c0	 test	 rax, rax
  00727	75 07		 jne	 SHORT $LN34@stbi__pic_

; 6433 :                      return 0;

  00729	33 c0		 xor	 eax, eax
  0072b	e9 af 06 00 00	 jmp	 $LN1@stbi__pic_
$LN34@stbi__pic_:
  00730	eb 9e		 jmp	 SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 6434 :                break;

  00732	e9 96 06 00 00	 jmp	 $LN11@stbi__pic_
$LN35@stbi__pic_:

; 6435 :             }
; 6436 : 
; 6437 :             case 1://Pure RLE
; 6438 :                {
; 6439 :                   int left=width, i;

  00737	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  0073e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR left$11[rsp], eax
$LN16@stbi__pic_:

; 6440 : 
; 6441 :                   while (left>0) {

  00745	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR left$11[rsp], 0
  0074d	0f 8e 92 02 00
	00		 jle	 $LN17@stbi__pic_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00753	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0075b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00763	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0076a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00771	73 4b		 jae	 SHORT $LN92@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00773	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0077b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00782	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00785	88 84 24 30 01
	00 00		 mov	 BYTE PTR tv344[rsp], al
  0078c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00794	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0079b	48 ff c0	 inc	 rax
  0079e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007a6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  007ad	0f b6 84 24 30
	01 00 00	 movzx	 eax, BYTE PTR tv344[rsp]
  007b5	88 84 24 e8 00
	00 00		 mov	 BYTE PTR $T24[rsp], al
  007bc	eb 6e		 jmp	 SHORT $LN91@stbi__pic_
$LN92@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  007be	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c6	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007ca	74 58		 je	 SHORT $LN93@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  007cc	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  007d9	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007eb	88 84 24 31 01
	00 00		 mov	 BYTE PTR tv353[rsp], al
  007f2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00801	48 ff c0	 inc	 rax
  00804	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0080c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00813	0f b6 84 24 31
	01 00 00	 movzx	 eax, BYTE PTR tv353[rsp]
  0081b	88 84 24 e8 00
	00 00		 mov	 BYTE PTR $T24[rsp], al
  00822	eb 08		 jmp	 SHORT $LN91@stbi__pic_
$LN93@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00824	c6 84 24 e8 00
	00 00 00	 mov	 BYTE PTR $T24[rsp], 0
$LN91@stbi__pic_:

; 6442 :                      stbi_uc count,value[4];
; 6443 : 
; 6444 :                      count=stbi__get8(s);

  0082c	0f b6 84 24 e8
	00 00 00	 movzx	 eax, BYTE PTR $T24[rsp]
  00834	88 84 24 94 00
	00 00		 mov	 BYTE PTR count$13[rsp], al

; 1628 :    if (s->io.read) {

  0083b	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00843	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00848	74 43		 je	 SHORT $LN96@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  0084a	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00852	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00856	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085e	ff 50 20	 call	 QWORD PTR [rax+32]
  00861	85 c0		 test	 eax, eax
  00863	75 0d		 jne	 SHORT $LN97@stbi__pic_
  00865	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR $T25[rsp], 0
  00870	eb 61		 jmp	 SHORT $LN95@stbi__pic_
$LN97@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00872	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0087a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0087e	75 0d		 jne	 SHORT $LN98@stbi__pic_
  00880	c7 84 24 ec 00
	00 00 01 00 00
	00		 mov	 DWORD PTR $T25[rsp], 1
  0088b	eb 46		 jmp	 SHORT $LN95@stbi__pic_
$LN98@stbi__pic_:
$LN96@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  0088d	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00895	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0089d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  008a4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  008ab	72 0d		 jb	 SHORT $LN100@stbi__pic_
  008ad	c7 84 24 34 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv365[rsp], 1
  008b8	eb 0b		 jmp	 SHORT $LN101@stbi__pic_
$LN100@stbi__pic_:
  008ba	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv365[rsp], 0
$LN101@stbi__pic_:
  008c5	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv365[rsp]
  008cc	89 84 24 ec 00
	00 00		 mov	 DWORD PTR $T25[rsp], eax
$LN95@stbi__pic_:

; 6445 :                      if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

  008d3	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR $T25[rsp]
  008da	85 c0		 test	 eax, eax
  008dc	74 37		 je	 SHORT $LN36@stbi__pic_
  008de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  008e5	e8 00 00 00 00	 call	 stbi__err
  008ea	85 c0		 test	 eax, eax
  008ec	74 0e		 je	 SHORT $LN60@stbi__pic_
  008ee	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv176[rsp], 0
  008fa	eb 0c		 jmp	 SHORT $LN61@stbi__pic_
$LN60@stbi__pic_:
  008fc	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv176[rsp], 0
$LN61@stbi__pic_:
  00908	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv176[rsp]
  00910	e9 ca 04 00 00	 jmp	 $LN1@stbi__pic_
$LN36@stbi__pic_:

; 6446 : 
; 6447 :                      if (count > left)

  00915	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR count$13[rsp]
  0091d	3b 84 24 8c 00
	00 00		 cmp	 eax, DWORD PTR left$11[rsp]
  00924	7e 0f		 jle	 SHORT $LN37@stbi__pic_

; 6448 :                         count = (stbi_uc) left;

  00926	0f b6 84 24 8c
	00 00 00	 movzx	 eax, BYTE PTR left$11[rsp]
  0092e	88 84 24 94 00
	00 00		 mov	 BYTE PTR count$13[rsp], al
$LN37@stbi__pic_:

; 6449 : 
; 6450 :                      if (!stbi__readval(s,packet->channel,value))  return 0;

  00935	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  0093a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0093e	4c 8d 84 24 a4
	00 00 00	 lea	 r8, QWORD PTR value$14[rsp]
  00946	8b d0		 mov	 edx, eax
  00948	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00950	e8 00 00 00 00	 call	 stbi__readval
  00955	48 85 c0	 test	 rax, rax
  00958	75 07		 jne	 SHORT $LN38@stbi__pic_
  0095a	33 c0		 xor	 eax, eax
  0095c	e9 7e 04 00 00	 jmp	 $LN1@stbi__pic_
$LN38@stbi__pic_:

; 6451 : 
; 6452 :                      for(i=0; i<count; ++i,dest+=4)

  00961	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$12[rsp], 0
  0096c	eb 24		 jmp	 SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
  0096e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$12[rsp]
  00975	ff c0		 inc	 eax
  00977	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$12[rsp], eax
  0097e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$9[rsp]
  00986	48 83 c0 04	 add	 rax, 4
  0098a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$9[rsp], rax
$LN20@stbi__pic_:
  00992	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR count$13[rsp]
  0099a	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$12[rsp], eax
  009a1	7d 23		 jge	 SHORT $LN19@stbi__pic_

; 6453 :                         stbi__copyval(packet->channel,dest,value);

  009a3	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  009a8	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  009ac	4c 8d 84 24 a4
	00 00 00	 lea	 r8, QWORD PTR value$14[rsp]
  009b4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest$9[rsp]
  009bc	8b c8		 mov	 ecx, eax
  009be	e8 00 00 00 00	 call	 stbi__copyval
  009c3	90		 npad	 1
  009c4	eb a8		 jmp	 SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 6454 :                      left -= count;

  009c6	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR count$13[rsp]
  009ce	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR left$11[rsp]
  009d5	2b c8		 sub	 ecx, eax
  009d7	8b c1		 mov	 eax, ecx
  009d9	89 84 24 8c 00
	00 00		 mov	 DWORD PTR left$11[rsp], eax

; 6455 :                   }

  009e0	e9 60 fd ff ff	 jmp	 $LN16@stbi__pic_
$LN17@stbi__pic_:

; 6456 :                }
; 6457 :                break;

  009e5	e9 e3 03 00 00	 jmp	 $LN11@stbi__pic_
$LN39@stbi__pic_:

; 6458 : 
; 6459 :             case 2: {//Mixed RLE
; 6460 :                int left=width;

  009ea	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  009f1	89 84 24 b4 00
	00 00		 mov	 DWORD PTR left$15[rsp], eax
$LN21@stbi__pic_:

; 6461 :                while (left>0) {

  009f8	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR left$15[rsp], 0
  00a00	0f 8e c7 03 00
	00		 jle	 $LN22@stbi__pic_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00a06	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a0e	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a16	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00a1d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00a24	73 4b		 jae	 SHORT $LN103@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00a26	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a2e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a35	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a38	88 84 24 40 01
	00 00		 mov	 BYTE PTR tv373[rsp], al
  00a3f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a47	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a4e	48 ff c0	 inc	 rax
  00a51	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a59	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00a60	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR tv373[rsp]
  00a68	88 84 24 f0 00
	00 00		 mov	 BYTE PTR $T26[rsp], al
  00a6f	eb 6e		 jmp	 SHORT $LN102@stbi__pic_
$LN103@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  00a71	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a79	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00a7d	74 58		 je	 SHORT $LN104@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  00a7f	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a87	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00a8c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a94	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a9b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a9e	88 84 24 41 01
	00 00		 mov	 BYTE PTR tv382[rsp], al
  00aa5	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aad	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ab4	48 ff c0	 inc	 rax
  00ab7	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00abf	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00ac6	0f b6 84 24 41
	01 00 00	 movzx	 eax, BYTE PTR tv382[rsp]
  00ace	88 84 24 f0 00
	00 00		 mov	 BYTE PTR $T26[rsp], al
  00ad5	eb 08		 jmp	 SHORT $LN102@stbi__pic_
$LN104@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00ad7	c6 84 24 f0 00
	00 00 00	 mov	 BYTE PTR $T26[rsp], 0
$LN102@stbi__pic_:

; 6462 :                   int count = stbi__get8(s), i;

  00adf	0f b6 84 24 f0
	00 00 00	 movzx	 eax, BYTE PTR $T26[rsp]
  00ae7	0f b6 c0	 movzx	 eax, al
  00aea	89 84 24 b8 00
	00 00		 mov	 DWORD PTR count$16[rsp], eax

; 1628 :    if (s->io.read) {

  00af1	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00af9	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00afe	74 43		 je	 SHORT $LN107@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00b00	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b08	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00b0c	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b14	ff 50 20	 call	 QWORD PTR [rax+32]
  00b17	85 c0		 test	 eax, eax
  00b19	75 0d		 jne	 SHORT $LN108@stbi__pic_
  00b1b	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR $T27[rsp], 0
  00b26	eb 61		 jmp	 SHORT $LN106@stbi__pic_
$LN108@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00b28	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b30	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00b34	75 0d		 jne	 SHORT $LN109@stbi__pic_
  00b36	c7 84 24 f4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR $T27[rsp], 1
  00b41	eb 46		 jmp	 SHORT $LN106@stbi__pic_
$LN109@stbi__pic_:
$LN107@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00b43	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b4b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b53	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00b5a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00b61	72 0d		 jb	 SHORT $LN111@stbi__pic_
  00b63	c7 84 24 44 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv426[rsp], 1
  00b6e	eb 0b		 jmp	 SHORT $LN112@stbi__pic_
$LN111@stbi__pic_:
  00b70	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv426[rsp], 0
$LN112@stbi__pic_:
  00b7b	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv426[rsp]
  00b82	89 84 24 f4 00
	00 00		 mov	 DWORD PTR $T27[rsp], eax
$LN106@stbi__pic_:

; 6463 :                   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

  00b89	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR $T27[rsp]
  00b90	85 c0		 test	 eax, eax
  00b92	74 37		 je	 SHORT $LN40@stbi__pic_
  00b94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00b9b	e8 00 00 00 00	 call	 stbi__err
  00ba0	85 c0		 test	 eax, eax
  00ba2	74 0e		 je	 SHORT $LN62@stbi__pic_
  00ba4	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv207[rsp], 0
  00bb0	eb 0c		 jmp	 SHORT $LN63@stbi__pic_
$LN62@stbi__pic_:
  00bb2	48 c7 84 24 48
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv207[rsp], 0
$LN63@stbi__pic_:
  00bbe	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tv207[rsp]
  00bc6	e9 14 02 00 00	 jmp	 $LN1@stbi__pic_
$LN40@stbi__pic_:

; 6464 : 
; 6465 :                   if (count >= 128) { // Repeated

  00bcb	81 bc 24 b8 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR count$16[rsp], 128 ; 00000080H
  00bd6	0f 8c 10 01 00
	00		 jl	 $LN41@stbi__pic_

; 6466 :                      stbi_uc value[4];
; 6467 : 
; 6468 :                      if (count==128)

  00bdc	81 bc 24 b8 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR count$16[rsp], 128 ; 00000080H
  00be7	75 16		 jne	 SHORT $LN43@stbi__pic_

; 6469 :                         count = stbi__get16be(s);

  00be9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bf1	e8 00 00 00 00	 call	 stbi__get16be
  00bf6	89 84 24 b8 00
	00 00		 mov	 DWORD PTR count$16[rsp], eax
  00bfd	eb 11		 jmp	 SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6470 :                      else
; 6471 :                         count -= 127;

  00bff	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count$16[rsp]
  00c06	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00c09	89 84 24 b8 00
	00 00		 mov	 DWORD PTR count$16[rsp], eax
$LN44@stbi__pic_:

; 6472 :                      if (count > left)

  00c10	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR left$15[rsp]
  00c17	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR count$16[rsp], eax
  00c1e	7e 37		 jle	 SHORT $LN45@stbi__pic_

; 6473 :                         return stbi__errpuc("bad file","scanline overrun");

  00c20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00c27	e8 00 00 00 00	 call	 stbi__err
  00c2c	85 c0		 test	 eax, eax
  00c2e	74 0e		 je	 SHORT $LN64@stbi__pic_
  00c30	48 c7 84 24 50
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv217[rsp], 0
  00c3c	eb 0c		 jmp	 SHORT $LN65@stbi__pic_
$LN64@stbi__pic_:
  00c3e	48 c7 84 24 50
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv217[rsp], 0
$LN65@stbi__pic_:
  00c4a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR tv217[rsp]
  00c52	e9 88 01 00 00	 jmp	 $LN1@stbi__pic_
$LN45@stbi__pic_:

; 6474 : 
; 6475 :                      if (!stbi__readval(s,packet->channel,value))

  00c57	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  00c5c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00c60	4c 8d 84 24 c4
	00 00 00	 lea	 r8, QWORD PTR value$18[rsp]
  00c68	8b d0		 mov	 edx, eax
  00c6a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c72	e8 00 00 00 00	 call	 stbi__readval
  00c77	48 85 c0	 test	 rax, rax
  00c7a	75 07		 jne	 SHORT $LN46@stbi__pic_

; 6476 :                         return 0;

  00c7c	33 c0		 xor	 eax, eax
  00c7e	e9 5c 01 00 00	 jmp	 $LN1@stbi__pic_
$LN46@stbi__pic_:

; 6477 : 
; 6478 :                      for(i=0;i<count;++i, dest += 4)

  00c83	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$17[rsp], 0
  00c8e	eb 24		 jmp	 SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
  00c90	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR i$17[rsp]
  00c97	ff c0		 inc	 eax
  00c99	89 84 24 bc 00
	00 00		 mov	 DWORD PTR i$17[rsp], eax
  00ca0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$9[rsp]
  00ca8	48 83 c0 04	 add	 rax, 4
  00cac	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$9[rsp], rax
$LN25@stbi__pic_:
  00cb4	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count$16[rsp]
  00cbb	39 84 24 bc 00
	00 00		 cmp	 DWORD PTR i$17[rsp], eax
  00cc2	7d 23		 jge	 SHORT $LN24@stbi__pic_

; 6479 :                         stbi__copyval(packet->channel,dest,value);

  00cc4	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  00cc9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00ccd	4c 8d 84 24 c4
	00 00 00	 lea	 r8, QWORD PTR value$18[rsp]
  00cd5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest$9[rsp]
  00cdd	8b c8		 mov	 ecx, eax
  00cdf	e8 00 00 00 00	 call	 stbi__copyval
  00ce4	90		 npad	 1
  00ce5	eb a9		 jmp	 SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 6480 :                   } else { // Raw

  00ce7	e9 c3 00 00 00	 jmp	 $LN42@stbi__pic_
$LN41@stbi__pic_:

; 6481 :                      ++count;

  00cec	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count$16[rsp]
  00cf3	ff c0		 inc	 eax
  00cf5	89 84 24 b8 00
	00 00		 mov	 DWORD PTR count$16[rsp], eax

; 6482 :                      if (count>left) return stbi__errpuc("bad file","scanline overrun");

  00cfc	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR left$15[rsp]
  00d03	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR count$16[rsp], eax
  00d0a	7e 37		 jle	 SHORT $LN47@stbi__pic_
  00d0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00d13	e8 00 00 00 00	 call	 stbi__err
  00d18	85 c0		 test	 eax, eax
  00d1a	74 0e		 je	 SHORT $LN66@stbi__pic_
  00d1c	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv238[rsp], 0
  00d28	eb 0c		 jmp	 SHORT $LN67@stbi__pic_
$LN66@stbi__pic_:
  00d2a	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv238[rsp], 0
$LN67@stbi__pic_:
  00d36	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR tv238[rsp]
  00d3e	e9 9c 00 00 00	 jmp	 $LN1@stbi__pic_
$LN47@stbi__pic_:

; 6483 : 
; 6484 :                      for(i=0;i<count;++i, dest+=4)

  00d43	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$17[rsp], 0
  00d4e	eb 24		 jmp	 SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
  00d50	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR i$17[rsp]
  00d57	ff c0		 inc	 eax
  00d59	89 84 24 bc 00
	00 00		 mov	 DWORD PTR i$17[rsp], eax
  00d60	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$9[rsp]
  00d68	48 83 c0 04	 add	 rax, 4
  00d6c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$9[rsp], rax
$LN28@stbi__pic_:
  00d74	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count$16[rsp]
  00d7b	39 84 24 bc 00
	00 00		 cmp	 DWORD PTR i$17[rsp], eax
  00d82	7d 2b		 jge	 SHORT $LN27@stbi__pic_

; 6485 :                         if (!stbi__readval(s,packet->channel,dest))

  00d84	48 8b 44 24 78	 mov	 rax, QWORD PTR packet$8[rsp]
  00d89	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00d8d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dest$9[rsp]
  00d95	8b d0		 mov	 edx, eax
  00d97	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d9f	e8 00 00 00 00	 call	 stbi__readval
  00da4	48 85 c0	 test	 rax, rax
  00da7	75 04		 jne	 SHORT $LN48@stbi__pic_

; 6486 :                            return 0;

  00da9	33 c0		 xor	 eax, eax
  00dab	eb 32		 jmp	 SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
  00dad	eb a1		 jmp	 SHORT $LN26@stbi__pic_
$LN27@stbi__pic_:
$LN42@stbi__pic_:

; 6487 :                   }
; 6488 :                   left-=count;

  00daf	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR count$16[rsp]
  00db6	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR left$15[rsp]
  00dbd	2b c8		 sub	 ecx, eax
  00dbf	8b c1		 mov	 eax, ecx
  00dc1	89 84 24 b4 00
	00 00		 mov	 DWORD PTR left$15[rsp], eax

; 6489 :                }

  00dc8	e9 2b fc ff ff	 jmp	 $LN21@stbi__pic_
$LN22@stbi__pic_:
$LN11@stbi__pic_:

; 6490 :                break;
; 6491 :             }
; 6492 :          }
; 6493 :       }

  00dcd	e9 32 f8 ff ff	 jmp	 $LN8@stbi__pic_
$LN9@stbi__pic_:

; 6494 :    }

  00dd2	e9 08 f8 ff ff	 jmp	 $LN5@stbi__pic_
$LN6@stbi__pic_:

; 6495 : 
; 6496 :    return result;

  00dd7	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6497 : }

  00ddf	48 8b f8	 mov	 rdi, rax
  00de2	48 8b cc	 mov	 rcx, rsp
  00de5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_load_core$rtcFrameData
  00dec	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00df1	48 8b c7	 mov	 rax, rdi
  00df4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00dfc	48 33 cc	 xor	 rcx, rsp
  00dff	e8 00 00 00 00	 call	 __security_check_cookie
  00e04	48 81 c4 70 01
	00 00		 add	 rsp, 368		; 00000170H
  00e0b	5f		 pop	 rdi
  00e0c	c3		 ret	 0
stbi__pic_load_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
result$ = 48
i$ = 56
x$ = 60
y$ = 64
internal_comp$ = 84
$T4 = 112
tv175 = 116
tv184 = 117
tv76 = 120
tv81 = 128
tv196 = 136
tv88 = 144
tv130 = 152
tv143 = 160
tv148 = 168
__$ArrayPad$ = 176
s$ = 208
px$ = 216
py$ = 224
comp$ = 232
req_comp$ = 240
ri$ = 248
stbi__pic_load PROC

; 6500 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+208]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6501 :    stbi_uc *result;
; 6502 :    int i, x,y, internal_comp;
; 6503 :    STBI_NOTUSED(ri);
; 6504 : 
; 6505 :    if (!comp) comp = &internal_comp;

  00053	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0005c	75 0d		 jne	 SHORT $LN5@stbi__pic_
  0005e	48 8d 44 24 54	 lea	 rax, QWORD PTR internal_comp$[rsp]
  00063	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN5@stbi__pic_:

; 6506 : 
; 6507 :    for (i=0; i<92; ++i)

  0006b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00073	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00075	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00079	ff c0		 inc	 eax
  0007b	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  0007f	83 7c 24 38 5c	 cmp	 DWORD PTR i$[rsp], 92	; 0000005cH
  00084	0f 8d b0 00 00
	00		 jge	 $LN3@stbi__pic_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0008a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000a1	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000a8	73 39		 jae	 SHORT $LN25@stbi__pic_

; 1615 :       return *s->img_buffer++;

  000aa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000bc	88 44 24 74	 mov	 BYTE PTR tv175[rsp], al
  000c0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000cf	48 ff c0	 inc	 rax
  000d2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000da	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000e1	eb 52		 jmp	 SHORT $LN24@stbi__pic_
$LN25@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  000e3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000eb	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000ef	74 44		 je	 SHORT $LN26@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  000f1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f9	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000fe	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00106	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0010d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00110	88 44 24 75	 mov	 BYTE PTR tv184[rsp], al
  00114	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0011c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00123	48 ff c0	 inc	 rax
  00126	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN26@stbi__pic_:
$LN24@stbi__pic_:

; 6508 :       stbi__get8(s);

  00135	e9 3b ff ff ff	 jmp	 $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6509 : 
; 6510 :    x = stbi__get16be(s);

  0013a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00142	e8 00 00 00 00	 call	 stbi__get16be
  00147	89 44 24 3c	 mov	 DWORD PTR x$[rsp], eax

; 6511 :    y = stbi__get16be(s);

  0014b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00153	e8 00 00 00 00	 call	 stbi__get16be
  00158	89 44 24 40	 mov	 DWORD PTR y$[rsp], eax

; 6512 : 
; 6513 :    if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0015c	81 7c 24 40 00
	00 00 01	 cmp	 DWORD PTR y$[rsp], 16777216 ; 01000000H
  00164	7e 2e		 jle	 SHORT $LN6@stbi__pic_
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0016d	e8 00 00 00 00	 call	 stbi__err
  00172	85 c0		 test	 eax, eax
  00174	74 0b		 je	 SHORT $LN14@stbi__pic_
  00176	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
  0017f	eb 09		 jmp	 SHORT $LN15@stbi__pic_
$LN14@stbi__pic_:
  00181	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv76[rsp], 0
$LN15@stbi__pic_:
  0018a	48 8b 44 24 78	 mov	 rax, QWORD PTR tv76[rsp]
  0018f	e9 b1 02 00 00	 jmp	 $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6514 :    if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00194	81 7c 24 3c 00
	00 00 01	 cmp	 DWORD PTR x$[rsp], 16777216 ; 01000000H
  0019c	7e 37		 jle	 SHORT $LN7@stbi__pic_
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  001a5	e8 00 00 00 00	 call	 stbi__err
  001aa	85 c0		 test	 eax, eax
  001ac	74 0e		 je	 SHORT $LN16@stbi__pic_
  001ae	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv81[rsp], 0
  001ba	eb 0c		 jmp	 SHORT $LN17@stbi__pic_
$LN16@stbi__pic_:
  001bc	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv81[rsp], 0
$LN17@stbi__pic_:
  001c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv81[rsp]
  001d0	e9 70 02 00 00	 jmp	 $LN1@stbi__pic_
$LN7@stbi__pic_:

; 1628 :    if (s->io.read) {

  001d5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001dd	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001e2	74 3d		 je	 SHORT $LN29@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  001e4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ec	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001f0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001f8	ff 50 20	 call	 QWORD PTR [rax+32]
  001fb	85 c0		 test	 eax, eax
  001fd	75 0a		 jne	 SHORT $LN30@stbi__pic_
  001ff	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR $T4[rsp], 0
  00207	eb 5b		 jmp	 SHORT $LN28@stbi__pic_
$LN30@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00209	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00211	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00215	75 0a		 jne	 SHORT $LN31@stbi__pic_
  00217	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR $T4[rsp], 1
  0021f	eb 43		 jmp	 SHORT $LN28@stbi__pic_
$LN31@stbi__pic_:
$LN29@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00221	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00229	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00231	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00238	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0023f	72 0d		 jb	 SHORT $LN33@stbi__pic_
  00241	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv196[rsp], 1
  0024c	eb 0b		 jmp	 SHORT $LN34@stbi__pic_
$LN33@stbi__pic_:
  0024e	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv196[rsp], 0
$LN34@stbi__pic_:
  00259	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv196[rsp]
  00260	89 44 24 70	 mov	 DWORD PTR $T4[rsp], eax
$LN28@stbi__pic_:

; 6515 : 
; 6516 :    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");

  00264	8b 44 24 70	 mov	 eax, DWORD PTR $T4[rsp]
  00268	85 c0		 test	 eax, eax
  0026a	74 37		 je	 SHORT $LN8@stbi__pic_
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GGMBIFE@bad?5file@
  00273	e8 00 00 00 00	 call	 stbi__err
  00278	85 c0		 test	 eax, eax
  0027a	74 0e		 je	 SHORT $LN18@stbi__pic_
  0027c	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv88[rsp], 0
  00288	eb 0c		 jmp	 SHORT $LN19@stbi__pic_
$LN18@stbi__pic_:
  0028a	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv88[rsp], 0
$LN19@stbi__pic_:
  00296	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv88[rsp]
  0029e	e9 a2 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 6517 :    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

  002a3	45 33 c9	 xor	 r9d, r9d
  002a6	41 b8 04 00 00
	00		 mov	 r8d, 4
  002ac	8b 54 24 40	 mov	 edx, DWORD PTR y$[rsp]
  002b0	8b 4c 24 3c	 mov	 ecx, DWORD PTR x$[rsp]
  002b4	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  002b9	85 c0		 test	 eax, eax
  002bb	75 37		 jne	 SHORT $LN9@stbi__pic_
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  002c4	e8 00 00 00 00	 call	 stbi__err
  002c9	85 c0		 test	 eax, eax
  002cb	74 0e		 je	 SHORT $LN20@stbi__pic_
  002cd	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv130[rsp], 0
  002d9	eb 0c		 jmp	 SHORT $LN21@stbi__pic_
$LN20@stbi__pic_:
  002db	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv130[rsp], 0
$LN21@stbi__pic_:
  002e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv130[rsp]
  002ef	e9 51 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 6518 : 
; 6519 :    stbi__get32be(s); //skip `ratio'

  002f4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002fc	e8 00 00 00 00	 call	 stbi__get32be

; 6520 :    stbi__get16be(s); //skip `fields'

  00301	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00309	e8 00 00 00 00	 call	 stbi__get16be

; 6521 :    stbi__get16be(s); //skip `pad'

  0030e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00316	e8 00 00 00 00	 call	 stbi__get16be

; 6522 : 
; 6523 :    // intermediate buffer is RGBA
; 6524 :    result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);

  0031b	45 33 c9	 xor	 r9d, r9d
  0031e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00324	8b 54 24 40	 mov	 edx, DWORD PTR y$[rsp]
  00328	8b 4c 24 3c	 mov	 ecx, DWORD PTR x$[rsp]
  0032c	e8 00 00 00 00	 call	 stbi__malloc_mad3
  00331	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 6525 :    if (!result) return stbi__errpuc("outofmem", "Out of memory");

  00336	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  0033c	75 37		 jne	 SHORT $LN10@stbi__pic_
  0033e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00345	e8 00 00 00 00	 call	 stbi__err
  0034a	85 c0		 test	 eax, eax
  0034c	74 0e		 je	 SHORT $LN22@stbi__pic_
  0034e	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv143[rsp], 0
  0035a	eb 0c		 jmp	 SHORT $LN23@stbi__pic_
$LN22@stbi__pic_:
  0035c	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv143[rsp], 0
$LN23@stbi__pic_:
  00368	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv143[rsp]
  00370	e9 d0 00 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 6526 :    memset(result, 0xff, x*y*4);

  00375	8b 44 24 3c	 mov	 eax, DWORD PTR x$[rsp]
  00379	0f af 44 24 40	 imul	 eax, DWORD PTR y$[rsp]
  0037e	c1 e0 02	 shl	 eax, 2
  00381	48 98		 cdqe
  00383	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  0038b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR result$[rsp]
  00390	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00395	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  0039d	f3 aa		 rep stosb

; 6527 : 
; 6528 :    if (!stbi__pic_load_core(s,x,y,comp, result)) {

  0039f	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  003a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a9	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  003b1	44 8b 44 24 40	 mov	 r8d, DWORD PTR y$[rsp]
  003b6	8b 54 24 3c	 mov	 edx, DWORD PTR x$[rsp]
  003ba	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003c2	e8 00 00 00 00	 call	 stbi__pic_load_core
  003c7	48 85 c0	 test	 rax, rax
  003ca	75 14		 jne	 SHORT $LN11@stbi__pic_

; 6529 :       STBI_FREE(result);

  003cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6530 :       result=0;

  003d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN11@stbi__pic_:

; 6531 :    }
; 6532 :    *px = x;

  003e0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR px$[rsp]
  003e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR x$[rsp]
  003ec	89 08		 mov	 DWORD PTR [rax], ecx

; 6533 :    *py = y;

  003ee	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR py$[rsp]
  003f6	8b 4c 24 40	 mov	 ecx, DWORD PTR y$[rsp]
  003fa	89 08		 mov	 DWORD PTR [rax], ecx

; 6534 :    if (req_comp == 0) req_comp = *comp;

  003fc	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00404	75 11		 jne	 SHORT $LN12@stbi__pic_
  00406	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0040e	8b 00		 mov	 eax, DWORD PTR [rax]
  00410	89 84 24 f0 00
	00 00		 mov	 DWORD PTR req_comp$[rsp], eax
$LN12@stbi__pic_:

; 6535 :    result=stbi__convert_format(result,4,req_comp,x,y);

  00417	8b 44 24 40	 mov	 eax, DWORD PTR y$[rsp]
  0041b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0041f	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR x$[rsp]
  00424	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0042c	ba 04 00 00 00	 mov	 edx, 4
  00431	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00436	e8 00 00 00 00	 call	 stbi__convert_format
  0043b	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 6536 : 
; 6537 :    return result;

  00440	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6538 : }

  00445	48 8b f8	 mov	 rdi, rax
  00448	48 8b cc	 mov	 rcx, rsp
  0044b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_load$rtcFrameData
  00452	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00457	48 8b c7	 mov	 rax, rdi
  0045a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00462	48 33 cc	 xor	 rcx, rsp
  00465	e8 00 00 00 00	 call	 __security_check_cookie
  0046a	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00471	5f		 pop	 rdi
  00472	c3		 ret	 0
stbi__pic_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
stbi__pic_test PROC

; 6541 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6542 :    int r = stbi__pic_test_core(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__pic_test_core
  00020	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6543 :    stbi__rewind(s);

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__rewind

; 6544 :    return r;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6545 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
stbi__pic_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
sz$ = 32
$T1 = 36
$T2 = 37
$T3 = 38
$T4 = 39
$T5 = 40
$T6 = 41
tv130 = 42
tv139 = 43
tv147 = 44
tv156 = 45
tv164 = 46
tv173 = 47
tv181 = 48
tv190 = 49
tv198 = 50
tv207 = 51
tv215 = 52
tv224 = 53
s$ = 80
stbi__gif_test_raw PROC

; 6580 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 39		 jae	 SHORT $LN8@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 2a	 mov	 BYTE PTR tv130[rsp], al
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 2a	 movzx	 eax, BYTE PTR tv130[rsp]
  00063	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00067	eb 53		 jmp	 SHORT $LN7@stbi__gif_
$LN8@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00072	74 43		 je	 SHORT $LN9@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	88 44 24 2b	 mov	 BYTE PTR tv139[rsp], al
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00096	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009d	48 ff c0	 inc	 rax
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ac	0f b6 44 24 2b	 movzx	 eax, BYTE PTR tv139[rsp]
  000b1	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000b5	eb 05		 jmp	 SHORT $LN7@stbi__gif_
$LN9@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  000b7	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  000bc	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000c1	0f b6 c0	 movzx	 eax, al
  000c4	83 f8 47	 cmp	 eax, 71			; 00000047H
  000c7	0f 85 21 02 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000de	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000e5	73 39		 jae	 SHORT $LN12@stbi__gif_

; 1615 :       return *s->img_buffer++;

  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ec	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f6	88 44 24 2c	 mov	 BYTE PTR tv147[rsp], al
  000fa	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ff	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00106	48 ff c0	 inc	 rax
  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0010e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00115	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv147[rsp]
  0011a	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  0011e	eb 53		 jmp	 SHORT $LN11@stbi__gif_
$LN12@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00125	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00129	74 43		 je	 SHORT $LN13@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00130	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0013a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00141	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00144	88 44 24 2d	 mov	 BYTE PTR tv156[rsp], al
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0014d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00154	48 ff c0	 inc	 rax
  00157	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00163	0f b6 44 24 2d	 movzx	 eax, BYTE PTR tv156[rsp]
  00168	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  0016c	eb 05		 jmp	 SHORT $LN11@stbi__gif_
$LN13@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  0016e	c6 44 24 25 00	 mov	 BYTE PTR $T2[rsp], 0
$LN11@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  00173	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T2[rsp]
  00178	0f b6 c0	 movzx	 eax, al
  0017b	83 f8 49	 cmp	 eax, 73			; 00000049H
  0017e	0f 85 6a 01 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00184	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00189	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0018e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00195	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0019c	73 39		 jae	 SHORT $LN16@stbi__gif_

; 1615 :       return *s->img_buffer++;

  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ad	88 44 24 2e	 mov	 BYTE PTR tv164[rsp], al
  001b1	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001b6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001bd	48 ff c0	 inc	 rax
  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001c5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001cc	0f b6 44 24 2e	 movzx	 eax, BYTE PTR tv164[rsp]
  001d1	88 44 24 26	 mov	 BYTE PTR $T3[rsp], al
  001d5	eb 53		 jmp	 SHORT $LN15@stbi__gif_
$LN16@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  001d7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001dc	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001e0	74 43		 je	 SHORT $LN17@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001e7	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001ec	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001f1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fb	88 44 24 2f	 mov	 BYTE PTR tv173[rsp], al
  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00204	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0020b	48 ff c0	 inc	 rax
  0020e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00213	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0021a	0f b6 44 24 2f	 movzx	 eax, BYTE PTR tv173[rsp]
  0021f	88 44 24 26	 mov	 BYTE PTR $T3[rsp], al
  00223	eb 05		 jmp	 SHORT $LN15@stbi__gif_
$LN17@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00225	c6 44 24 26 00	 mov	 BYTE PTR $T3[rsp], 0
$LN15@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  0022a	0f b6 44 24 26	 movzx	 eax, BYTE PTR $T3[rsp]
  0022f	0f b6 c0	 movzx	 eax, al
  00232	83 f8 46	 cmp	 eax, 70			; 00000046H
  00235	0f 85 b3 00 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0023b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00240	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00245	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0024c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00253	73 39		 jae	 SHORT $LN20@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00255	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0025a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00261	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00264	88 44 24 30	 mov	 BYTE PTR tv181[rsp], al
  00268	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0026d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00274	48 ff c0	 inc	 rax
  00277	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0027c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00283	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv181[rsp]
  00288	88 44 24 27	 mov	 BYTE PTR $T4[rsp], al
  0028c	eb 53		 jmp	 SHORT $LN19@stbi__gif_
$LN20@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00293	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00297	74 43		 je	 SHORT $LN21@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00299	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0029e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002a3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002a8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002b2	88 44 24 31	 mov	 BYTE PTR tv190[rsp], al
  002b6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002bb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002c2	48 ff c0	 inc	 rax
  002c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ca	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002d1	0f b6 44 24 31	 movzx	 eax, BYTE PTR tv190[rsp]
  002d6	88 44 24 27	 mov	 BYTE PTR $T4[rsp], al
  002da	eb 05		 jmp	 SHORT $LN19@stbi__gif_
$LN21@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  002dc	c6 44 24 27 00	 mov	 BYTE PTR $T4[rsp], 0
$LN19@stbi__gif_:

; 6581 :    int sz;
; 6582 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  002e1	0f b6 44 24 27	 movzx	 eax, BYTE PTR $T4[rsp]
  002e6	0f b6 c0	 movzx	 eax, al
  002e9	83 f8 38	 cmp	 eax, 56			; 00000038H
  002ec	74 07		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
  002ee	33 c0		 xor	 eax, eax
  002f0	e9 83 01 00 00	 jmp	 $LN1@stbi__gif_
$LN2@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  002f5	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ff	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00306	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0030d	73 39		 jae	 SHORT $LN24@stbi__gif_

; 1615 :       return *s->img_buffer++;

  0030f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00314	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0031b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0031e	88 44 24 32	 mov	 BYTE PTR tv198[rsp], al
  00322	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00327	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0032e	48 ff c0	 inc	 rax
  00331	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00336	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0033d	0f b6 44 24 32	 movzx	 eax, BYTE PTR tv198[rsp]
  00342	88 44 24 28	 mov	 BYTE PTR $T5[rsp], al
  00346	eb 53		 jmp	 SHORT $LN23@stbi__gif_
$LN24@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00348	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0034d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00351	74 43		 je	 SHORT $LN25@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00353	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00358	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0035d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00362	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00369	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0036c	88 44 24 33	 mov	 BYTE PTR tv207[rsp], al
  00370	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00375	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0037c	48 ff c0	 inc	 rax
  0037f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00384	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0038b	0f b6 44 24 33	 movzx	 eax, BYTE PTR tv207[rsp]
  00390	88 44 24 28	 mov	 BYTE PTR $T5[rsp], al
  00394	eb 05		 jmp	 SHORT $LN23@stbi__gif_
$LN25@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00396	c6 44 24 28 00	 mov	 BYTE PTR $T5[rsp], 0
$LN23@stbi__gif_:

; 6583 :    sz = stbi__get8(s);

  0039b	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T5[rsp]
  003a0	0f b6 c0	 movzx	 eax, al
  003a3	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 6584 :    if (sz != '9' && sz != '7') return 0;

  003a7	83 7c 24 20 39	 cmp	 DWORD PTR sz$[rsp], 57	; 00000039H
  003ac	74 0e		 je	 SHORT $LN4@stbi__gif_
  003ae	83 7c 24 20 37	 cmp	 DWORD PTR sz$[rsp], 55	; 00000037H
  003b3	74 07		 je	 SHORT $LN4@stbi__gif_
  003b5	33 c0		 xor	 eax, eax
  003b7	e9 bc 00 00 00	 jmp	 $LN1@stbi__gif_
$LN4@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  003bc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003c6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  003cd	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  003d4	73 39		 jae	 SHORT $LN28@stbi__gif_

; 1615 :       return *s->img_buffer++;

  003d6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003db	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003e2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003e5	88 44 24 34	 mov	 BYTE PTR tv215[rsp], al
  003e9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003ee	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003f5	48 ff c0	 inc	 rax
  003f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003fd	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00404	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv215[rsp]
  00409	88 44 24 29	 mov	 BYTE PTR $T6[rsp], al
  0040d	eb 53		 jmp	 SHORT $LN27@stbi__gif_
$LN28@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0040f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00414	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00418	74 43		 je	 SHORT $LN29@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  0041a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0041f	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00424	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00429	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00430	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00433	88 44 24 35	 mov	 BYTE PTR tv224[rsp], al
  00437	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0043c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00443	48 ff c0	 inc	 rax
  00446	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0044b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00452	0f b6 44 24 35	 movzx	 eax, BYTE PTR tv224[rsp]
  00457	88 44 24 29	 mov	 BYTE PTR $T6[rsp], al
  0045b	eb 05		 jmp	 SHORT $LN27@stbi__gif_
$LN29@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  0045d	c6 44 24 29 00	 mov	 BYTE PTR $T6[rsp], 0
$LN27@stbi__gif_:

; 6585 :    if (stbi__get8(s) != 'a') return 0;

  00462	0f b6 44 24 29	 movzx	 eax, BYTE PTR $T6[rsp]
  00467	0f b6 c0	 movzx	 eax, al
  0046a	83 f8 61	 cmp	 eax, 97			; 00000061H
  0046d	74 04		 je	 SHORT $LN5@stbi__gif_
  0046f	33 c0		 xor	 eax, eax
  00471	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6586 :    return 1;

  00473	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6587 : }

  00478	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0047c	5f		 pop	 rdi
  0047d	c3		 ret	 0
stbi__gif_test_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
stbi__gif_test PROC

; 6590 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6591 :    int r = stbi__gif_test_raw(s);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__gif_test_raw
  00020	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6592 :    stbi__rewind(s);

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 stbi__rewind

; 6593 :    return r;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6594 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
stbi__gif_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
$T1 = 36
$T2 = 37
$T3 = 38
tv136 = 39
tv145 = 40
tv153 = 41
tv162 = 42
tv170 = 43
tv179 = 44
tv93 = 48
s$ = 80
pal$ = 88
num_entries$ = 96
transp$ = 104
stbi__gif_parse_colortable PROC

; 6597 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00025	90		 npad	 1

; 6598 :    int i;
; 6599 :    for (i=0; i < num_entries; ++i) {

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002e	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00030	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00034	ff c0		 inc	 eax
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__gif_:
  0003a	8b 44 24 60	 mov	 eax, DWORD PTR num_entries$[rsp]
  0003e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00042	0f 8d 8f 02 00
	00		 jge	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00052	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00059	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00060	73 39		 jae	 SHORT $LN9@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00067	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00071	88 44 24 27	 mov	 BYTE PTR tv136[rsp], al
  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0007a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00081	48 ff c0	 inc	 rax
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00089	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00090	0f b6 44 24 27	 movzx	 eax, BYTE PTR tv136[rsp]
  00095	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00099	eb 53		 jmp	 SHORT $LN8@stbi__gif_
$LN9@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000a4	74 43		 je	 SHORT $LN10@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  000a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000ab	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000b0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000bc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000bf	88 44 24 28	 mov	 BYTE PTR tv145[rsp], al
  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000cf	48 ff c0	 inc	 rax
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000de	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv145[rsp]
  000e3	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000e7	eb 05		 jmp	 SHORT $LN8@stbi__gif_
$LN10@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  000e9	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN8@stbi__gif_:

; 6600 :       pal[i][2] = stbi__get8(s);

  000ee	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000f3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f8	48 8b 54 24 58	 mov	 rdx, QWORD PTR pal$[rsp]
  000fd	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00101	ba 01 00 00 00	 mov	 edx, 1
  00106	48 6b d2 02	 imul	 rdx, rdx, 2
  0010a	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0010d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00112	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00117	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0011e	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00125	73 39		 jae	 SHORT $LN13@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0012c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00133	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00136	88 44 24 29	 mov	 BYTE PTR tv153[rsp], al
  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0013f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00146	48 ff c0	 inc	 rax
  00149	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0014e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00155	0f b6 44 24 29	 movzx	 eax, BYTE PTR tv153[rsp]
  0015a	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  0015e	eb 53		 jmp	 SHORT $LN12@stbi__gif_
$LN13@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00165	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00169	74 43		 je	 SHORT $LN14@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00170	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0017a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00181	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00184	88 44 24 2a	 mov	 BYTE PTR tv162[rsp], al
  00188	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0018d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00194	48 ff c0	 inc	 rax
  00197	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0019c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001a3	0f b6 44 24 2a	 movzx	 eax, BYTE PTR tv162[rsp]
  001a8	88 44 24 25	 mov	 BYTE PTR $T2[rsp], al
  001ac	eb 05		 jmp	 SHORT $LN12@stbi__gif_
$LN14@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  001ae	c6 44 24 25 00	 mov	 BYTE PTR $T2[rsp], 0
$LN12@stbi__gif_:

; 6601 :       pal[i][1] = stbi__get8(s);

  001b3	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T2[rsp]
  001b8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR pal$[rsp]
  001c2	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  001c6	ba 01 00 00 00	 mov	 edx, 1
  001cb	48 6b d2 01	 imul	 rdx, rdx, 1
  001cf	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001d2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001dc	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001e3	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001ea	73 39		 jae	 SHORT $LN17@stbi__gif_

; 1615 :       return *s->img_buffer++;

  001ec	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001f1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fb	88 44 24 2b	 mov	 BYTE PTR tv170[rsp], al
  001ff	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00204	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0020b	48 ff c0	 inc	 rax
  0020e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00213	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0021a	0f b6 44 24 2b	 movzx	 eax, BYTE PTR tv170[rsp]
  0021f	88 44 24 26	 mov	 BYTE PTR $T3[rsp], al
  00223	eb 53		 jmp	 SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00225	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0022a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0022e	74 43		 je	 SHORT $LN18@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00230	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00235	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0023a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0023f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00246	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00249	88 44 24 2c	 mov	 BYTE PTR tv179[rsp], al
  0024d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00252	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00259	48 ff c0	 inc	 rax
  0025c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00261	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00268	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv179[rsp]
  0026d	88 44 24 26	 mov	 BYTE PTR $T3[rsp], al
  00271	eb 05		 jmp	 SHORT $LN16@stbi__gif_
$LN18@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00273	c6 44 24 26 00	 mov	 BYTE PTR $T3[rsp], 0
$LN16@stbi__gif_:

; 6602 :       pal[i][0] = stbi__get8(s);

  00278	0f b6 44 24 26	 movzx	 eax, BYTE PTR $T3[rsp]
  0027d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00282	48 8b 54 24 58	 mov	 rdx, QWORD PTR pal$[rsp]
  00287	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  0028b	ba 01 00 00 00	 mov	 edx, 1
  00290	48 6b d2 00	 imul	 rdx, rdx, 0
  00294	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6603 :       pal[i][3] = transp == i ? 0 : 255;

  00297	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0029b	39 44 24 68	 cmp	 DWORD PTR transp$[rsp], eax
  0029f	75 0a		 jne	 SHORT $LN6@stbi__gif_
  002a1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  002a9	eb 08		 jmp	 SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
  002ab	c7 44 24 30 ff
	00 00 00	 mov	 DWORD PTR tv93[rsp], 255 ; 000000ffH
$LN7@stbi__gif_:
  002b3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pal$[rsp]
  002bd	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  002c1	b9 01 00 00 00	 mov	 ecx, 1
  002c6	48 6b c9 03	 imul	 rcx, rcx, 3
  002ca	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv93[rsp]
  002cf	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 6604 :    }

  002d2	e9 59 fd ff ff	 jmp	 $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6605 : }

  002d7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002db	5f		 pop	 rdi
  002dc	c3		 ret	 0
stbi__gif_parse_colortable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
version$ = 32
$T1 = 33
$T2 = 34
$T3 = 35
$T4 = 36
$T5 = 37
$T6 = 38
$T7 = 39
$T8 = 40
$T9 = 41
tv181 = 42
tv190 = 43
tv198 = 44
tv207 = 45
tv215 = 46
tv224 = 47
tv232 = 48
tv241 = 49
tv249 = 50
tv258 = 51
tv266 = 52
tv275 = 53
tv283 = 54
tv292 = 55
tv300 = 56
tv309 = 57
tv317 = 58
tv326 = 59
tv520 = 60
s$ = 80
g$ = 88
comp$ = 96
is_info$ = 104
stbi__gif_header PROC

; 6608 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00036	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0003d	73 39		 jae	 SHORT $LN13@stbi__gif_

; 1615 :       return *s->img_buffer++;

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00044	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	88 44 24 2a	 mov	 BYTE PTR tv181[rsp], al
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00057	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0005e	48 ff c0	 inc	 rax
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00066	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0006d	0f b6 44 24 2a	 movzx	 eax, BYTE PTR tv181[rsp]
  00072	88 44 24 21	 mov	 BYTE PTR $T1[rsp], al
  00076	eb 53		 jmp	 SHORT $LN12@stbi__gif_
$LN13@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0007d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00081	74 43		 je	 SHORT $LN14@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00088	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00099	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009c	88 44 24 2b	 mov	 BYTE PTR tv190[rsp], al
  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ac	48 ff c0	 inc	 rax
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000b4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000bb	0f b6 44 24 2b	 movzx	 eax, BYTE PTR tv190[rsp]
  000c0	88 44 24 21	 mov	 BYTE PTR $T1[rsp], al
  000c4	eb 05		 jmp	 SHORT $LN12@stbi__gif_
$LN14@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  000c6	c6 44 24 21 00	 mov	 BYTE PTR $T1[rsp], 0
$LN12@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  000cb	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp]
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	83 f8 47	 cmp	 eax, 71			; 00000047H
  000d6	0f 85 21 02 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000e6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000ed	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000f4	73 39		 jae	 SHORT $LN17@stbi__gif_

; 1615 :       return *s->img_buffer++;

  000f6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000fb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00102	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00105	88 44 24 2c	 mov	 BYTE PTR tv198[rsp], al
  00109	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0010e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00115	48 ff c0	 inc	 rax
  00118	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0011d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00124	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv198[rsp]
  00129	88 44 24 22	 mov	 BYTE PTR $T2[rsp], al
  0012d	eb 53		 jmp	 SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0012f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00134	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00138	74 43		 je	 SHORT $LN18@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  0013a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0013f	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00149	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00150	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00153	88 44 24 2d	 mov	 BYTE PTR tv207[rsp], al
  00157	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0015c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00163	48 ff c0	 inc	 rax
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0016b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00172	0f b6 44 24 2d	 movzx	 eax, BYTE PTR tv207[rsp]
  00177	88 44 24 22	 mov	 BYTE PTR $T2[rsp], al
  0017b	eb 05		 jmp	 SHORT $LN16@stbi__gif_
$LN18@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  0017d	c6 44 24 22 00	 mov	 BYTE PTR $T2[rsp], 0
$LN16@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  00182	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T2[rsp]
  00187	0f b6 c0	 movzx	 eax, al
  0018a	83 f8 49	 cmp	 eax, 73			; 00000049H
  0018d	0f 85 6a 01 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00193	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00198	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0019d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001a4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001ab	73 39		 jae	 SHORT $LN21@stbi__gif_

; 1615 :       return *s->img_buffer++;

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001b2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bc	88 44 24 2e	 mov	 BYTE PTR tv215[rsp], al
  001c0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001c5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001cc	48 ff c0	 inc	 rax
  001cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001d4	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001db	0f b6 44 24 2e	 movzx	 eax, BYTE PTR tv215[rsp]
  001e0	88 44 24 23	 mov	 BYTE PTR $T3[rsp], al
  001e4	eb 53		 jmp	 SHORT $LN20@stbi__gif_
$LN21@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  001e6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001eb	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001ef	74 43		 je	 SHORT $LN22@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  001f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001f6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001fb	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00200	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	88 44 24 2f	 mov	 BYTE PTR tv224[rsp], al
  0020e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00213	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0021a	48 ff c0	 inc	 rax
  0021d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00222	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00229	0f b6 44 24 2f	 movzx	 eax, BYTE PTR tv224[rsp]
  0022e	88 44 24 23	 mov	 BYTE PTR $T3[rsp], al
  00232	eb 05		 jmp	 SHORT $LN20@stbi__gif_
$LN22@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00234	c6 44 24 23 00	 mov	 BYTE PTR $T3[rsp], 0
$LN20@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  00239	0f b6 44 24 23	 movzx	 eax, BYTE PTR $T3[rsp]
  0023e	0f b6 c0	 movzx	 eax, al
  00241	83 f8 46	 cmp	 eax, 70			; 00000046H
  00244	0f 85 b3 00 00
	00		 jne	 $LN3@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0024a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0024f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00254	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0025b	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00262	73 39		 jae	 SHORT $LN25@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00264	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00269	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00270	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00273	88 44 24 30	 mov	 BYTE PTR tv232[rsp], al
  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0027c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00283	48 ff c0	 inc	 rax
  00286	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0028b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00292	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv232[rsp]
  00297	88 44 24 24	 mov	 BYTE PTR $T4[rsp], al
  0029b	eb 53		 jmp	 SHORT $LN24@stbi__gif_
$LN25@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0029d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002a2	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002a6	74 43		 je	 SHORT $LN26@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  002a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ad	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002b2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002b7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002be	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c1	88 44 24 31	 mov	 BYTE PTR tv241[rsp], al
  002c5	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002d1	48 ff c0	 inc	 rax
  002d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002d9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002e0	0f b6 44 24 31	 movzx	 eax, BYTE PTR tv241[rsp]
  002e5	88 44 24 24	 mov	 BYTE PTR $T4[rsp], al
  002e9	eb 05		 jmp	 SHORT $LN24@stbi__gif_
$LN26@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  002eb	c6 44 24 24 00	 mov	 BYTE PTR $T4[rsp], 0
$LN24@stbi__gif_:

; 6609 :    stbi_uc version;
; 6610 :    if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  002f0	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T4[rsp]
  002f5	0f b6 c0	 movzx	 eax, al
  002f8	83 f8 38	 cmp	 eax, 56			; 00000038H
  002fb	74 11		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6611 :       return stbi__err("not GIF", "Corrupt GIF");

  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  00304	e8 00 00 00 00	 call	 stbi__err
  00309	e9 b5 04 00 00	 jmp	 $LN1@stbi__gif_
$LN2@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0030e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00313	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00318	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0031f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00326	73 39		 jae	 SHORT $LN29@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0032d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00334	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00337	88 44 24 32	 mov	 BYTE PTR tv249[rsp], al
  0033b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00340	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00347	48 ff c0	 inc	 rax
  0034a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0034f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00356	0f b6 44 24 32	 movzx	 eax, BYTE PTR tv249[rsp]
  0035b	88 44 24 25	 mov	 BYTE PTR $T5[rsp], al
  0035f	eb 53		 jmp	 SHORT $LN28@stbi__gif_
$LN29@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00361	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00366	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0036a	74 43		 je	 SHORT $LN30@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  0036c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00371	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00376	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0037b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00382	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00385	88 44 24 33	 mov	 BYTE PTR tv258[rsp], al
  00389	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0038e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00395	48 ff c0	 inc	 rax
  00398	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0039d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003a4	0f b6 44 24 33	 movzx	 eax, BYTE PTR tv258[rsp]
  003a9	88 44 24 25	 mov	 BYTE PTR $T5[rsp], al
  003ad	eb 05		 jmp	 SHORT $LN28@stbi__gif_
$LN30@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  003af	c6 44 24 25 00	 mov	 BYTE PTR $T5[rsp], 0
$LN28@stbi__gif_:

; 6612 : 
; 6613 :    version = stbi__get8(s);

  003b4	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T5[rsp]
  003b9	88 44 24 20	 mov	 BYTE PTR version$[rsp], al

; 6614 :    if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

  003bd	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  003c2	83 f8 37	 cmp	 eax, 55			; 00000037H
  003c5	74 1b		 je	 SHORT $LN4@stbi__gif_
  003c7	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  003cc	83 f8 39	 cmp	 eax, 57			; 00000039H
  003cf	74 11		 je	 SHORT $LN4@stbi__gif_
  003d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  003d8	e8 00 00 00 00	 call	 stbi__err
  003dd	e9 e1 03 00 00	 jmp	 $LN1@stbi__gif_
$LN4@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  003e2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003ec	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  003f3	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  003fa	73 39		 jae	 SHORT $LN33@stbi__gif_

; 1615 :       return *s->img_buffer++;

  003fc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00401	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00408	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0040b	88 44 24 34	 mov	 BYTE PTR tv266[rsp], al
  0040f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00414	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0041b	48 ff c0	 inc	 rax
  0041e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00423	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0042a	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv266[rsp]
  0042f	88 44 24 26	 mov	 BYTE PTR $T6[rsp], al
  00433	eb 53		 jmp	 SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00435	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0043a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0043e	74 43		 je	 SHORT $LN34@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00440	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00445	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0044a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0044f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00456	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00459	88 44 24 35	 mov	 BYTE PTR tv275[rsp], al
  0045d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00462	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00469	48 ff c0	 inc	 rax
  0046c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00471	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00478	0f b6 44 24 35	 movzx	 eax, BYTE PTR tv275[rsp]
  0047d	88 44 24 26	 mov	 BYTE PTR $T6[rsp], al
  00481	eb 05		 jmp	 SHORT $LN32@stbi__gif_
$LN34@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00483	c6 44 24 26 00	 mov	 BYTE PTR $T6[rsp], 0
$LN32@stbi__gif_:

; 6615 :    if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

  00488	0f b6 44 24 26	 movzx	 eax, BYTE PTR $T6[rsp]
  0048d	0f b6 c0	 movzx	 eax, al
  00490	83 f8 61	 cmp	 eax, 97			; 00000061H
  00493	74 11		 je	 SHORT $LN5@stbi__gif_
  00495	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  0049c	e8 00 00 00 00	 call	 stbi__err
  004a1	e9 1d 03 00 00	 jmp	 $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6616 : 
; 6617 :    stbi__g_failure_reason = "";

  004a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:stbi__g_failure_reason
  004ab	8b c0		 mov	 eax, eax
  004ad	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  004b6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  004c0	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 6618 :    g->w = stbi__get16le(s);

  004c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  004c9	e8 00 00 00 00	 call	 stbi__get16le
  004ce	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  004d3	89 01		 mov	 DWORD PTR [rcx], eax

; 6619 :    g->h = stbi__get16le(s);

  004d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  004da	e8 00 00 00 00	 call	 stbi__get16le
  004df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  004e4	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  004e7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  004ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  004f1	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  004f8	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  004ff	73 39		 jae	 SHORT $LN37@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00501	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00506	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0050d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00510	88 44 24 36	 mov	 BYTE PTR tv283[rsp], al
  00514	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00519	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00520	48 ff c0	 inc	 rax
  00523	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00528	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0052f	0f b6 44 24 36	 movzx	 eax, BYTE PTR tv283[rsp]
  00534	88 44 24 27	 mov	 BYTE PTR $T7[rsp], al
  00538	eb 53		 jmp	 SHORT $LN36@stbi__gif_
$LN37@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  0053a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0053f	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00543	74 43		 je	 SHORT $LN38@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00545	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0054a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0054f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00554	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0055b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0055e	88 44 24 37	 mov	 BYTE PTR tv292[rsp], al
  00562	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00567	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0056e	48 ff c0	 inc	 rax
  00571	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00576	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0057d	0f b6 44 24 37	 movzx	 eax, BYTE PTR tv292[rsp]
  00582	88 44 24 27	 mov	 BYTE PTR $T7[rsp], al
  00586	eb 05		 jmp	 SHORT $LN36@stbi__gif_
$LN38@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00588	c6 44 24 27 00	 mov	 BYTE PTR $T7[rsp], 0
$LN36@stbi__gif_:

; 6620 :    g->flags = stbi__get8(s);

  0058d	0f b6 44 24 27	 movzx	 eax, BYTE PTR $T7[rsp]
  00592	0f b6 c0	 movzx	 eax, al
  00595	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  0059a	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0059d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  005a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  005a7	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  005ae	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  005b5	73 39		 jae	 SHORT $LN41@stbi__gif_

; 1615 :       return *s->img_buffer++;

  005b7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  005bc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005c3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005c6	88 44 24 38	 mov	 BYTE PTR tv300[rsp], al
  005ca	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  005cf	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005d6	48 ff c0	 inc	 rax
  005d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  005de	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005e5	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv300[rsp]
  005ea	88 44 24 28	 mov	 BYTE PTR $T8[rsp], al
  005ee	eb 53		 jmp	 SHORT $LN40@stbi__gif_
$LN41@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  005f0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  005f5	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  005f9	74 43		 je	 SHORT $LN42@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  005fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00600	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00605	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0060a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00611	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00614	88 44 24 39	 mov	 BYTE PTR tv309[rsp], al
  00618	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0061d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00624	48 ff c0	 inc	 rax
  00627	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0062c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00633	0f b6 44 24 39	 movzx	 eax, BYTE PTR tv309[rsp]
  00638	88 44 24 28	 mov	 BYTE PTR $T8[rsp], al
  0063c	eb 05		 jmp	 SHORT $LN40@stbi__gif_
$LN42@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  0063e	c6 44 24 28 00	 mov	 BYTE PTR $T8[rsp], 0
$LN40@stbi__gif_:

; 6621 :    g->bgindex = stbi__get8(s);

  00643	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T8[rsp]
  00648	0f b6 c0	 movzx	 eax, al
  0064b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  00650	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00653	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00658	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0065d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00664	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0066b	73 39		 jae	 SHORT $LN45@stbi__gif_

; 1615 :       return *s->img_buffer++;

  0066d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00672	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00679	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0067c	88 44 24 3a	 mov	 BYTE PTR tv317[rsp], al
  00680	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00685	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0068c	48 ff c0	 inc	 rax
  0068f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00694	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0069b	0f b6 44 24 3a	 movzx	 eax, BYTE PTR tv317[rsp]
  006a0	88 44 24 29	 mov	 BYTE PTR $T9[rsp], al
  006a4	eb 53		 jmp	 SHORT $LN44@stbi__gif_
$LN45@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  006a6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  006ab	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  006af	74 43		 je	 SHORT $LN46@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  006b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  006b6	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  006bb	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  006c0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006c7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006ca	88 44 24 3b	 mov	 BYTE PTR tv326[rsp], al
  006ce	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  006d3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006da	48 ff c0	 inc	 rax
  006dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  006e2	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006e9	0f b6 44 24 3b	 movzx	 eax, BYTE PTR tv326[rsp]
  006ee	88 44 24 29	 mov	 BYTE PTR $T9[rsp], al
  006f2	eb 05		 jmp	 SHORT $LN44@stbi__gif_
$LN46@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  006f4	c6 44 24 29 00	 mov	 BYTE PTR $T9[rsp], 0
$LN44@stbi__gif_:

; 6622 :    g->ratio = stbi__get8(s);

  006f9	0f b6 44 24 29	 movzx	 eax, BYTE PTR $T9[rsp]
  006fe	0f b6 c0	 movzx	 eax, al
  00701	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  00706	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 6623 :    g->transparent = -1;

  00709	48 8b 44 24 58	 mov	 rax, QWORD PTR g$[rsp]
  0070e	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1

; 6624 : 
; 6625 :    if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00715	48 8b 44 24 58	 mov	 rax, QWORD PTR g$[rsp]
  0071a	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00720	7e 11		 jle	 SHORT $LN6@stbi__gif_
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00729	e8 00 00 00 00	 call	 stbi__err
  0072e	e9 90 00 00 00	 jmp	 $LN1@stbi__gif_
$LN6@stbi__gif_:

; 6626 :    if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00733	48 8b 44 24 58	 mov	 rax, QWORD PTR g$[rsp]
  00738	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  0073f	7e 0e		 jle	 SHORT $LN7@stbi__gif_
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00748	e8 00 00 00 00	 call	 stbi__err
  0074d	eb 74		 jmp	 SHORT $LN1@stbi__gif_
$LN7@stbi__gif_:

; 6627 : 
; 6628 :    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

  0074f	48 83 7c 24 60
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00755	74 0b		 je	 SHORT $LN8@stbi__gif_
  00757	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$[rsp]
  0075c	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN8@stbi__gif_:

; 6629 : 
; 6630 :    if (is_info) return 1;

  00762	83 7c 24 68 00	 cmp	 DWORD PTR is_info$[rsp], 0
  00767	74 07		 je	 SHORT $LN9@stbi__gif_
  00769	b8 01 00 00 00	 mov	 eax, 1
  0076e	eb 53		 jmp	 SHORT $LN1@stbi__gif_
$LN9@stbi__gif_:

; 6631 : 
; 6632 :    if (g->flags & 0x80)

  00770	48 8b 44 24 58	 mov	 rax, QWORD PTR g$[rsp]
  00775	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00778	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0077d	85 c0		 test	 eax, eax
  0077f	74 3d		 je	 SHORT $LN10@stbi__gif_

; 6633 :       stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

  00781	48 8b 44 24 58	 mov	 rax, QWORD PTR g$[rsp]
  00786	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00789	83 e0 07	 and	 eax, 7
  0078c	b9 02 00 00 00	 mov	 ecx, 2
  00791	89 4c 24 3c	 mov	 DWORD PTR tv520[rsp], ecx
  00795	0f b6 c8	 movzx	 ecx, al
  00798	8b 44 24 3c	 mov	 eax, DWORD PTR tv520[rsp]
  0079c	d3 e0		 shl	 eax, cl
  0079e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp]
  007a3	48 83 c1 34	 add	 rcx, 52			; 00000034H
  007a7	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  007ad	44 8b c0	 mov	 r8d, eax
  007b0	48 8b d1	 mov	 rdx, rcx
  007b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  007b8	e8 00 00 00 00	 call	 stbi__gif_parse_colortable
  007bd	90		 npad	 1
$LN10@stbi__gif_:

; 6634 : 
; 6635 :    return 1;

  007be	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6636 : }

  007c3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  007c7	5f		 pop	 rdi
  007c8	c3		 ret	 0
stbi__gif_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
g$ = 32
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi__gif_info_raw PROC

; 6639 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6640 :    stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));

  00025	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  0002a	e8 00 00 00 00	 call	 stbi__malloc
  0002f	48 89 44 24 20	 mov	 QWORD PTR g$[rsp], rax

; 6641 :    if (!g) return stbi__err("outofmem", "Out of memory");

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR g$[rsp], 0
  0003a	75 0e		 jne	 SHORT $LN2@stbi__gif_
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00043	e8 00 00 00 00	 call	 stbi__err
  00048	eb 74		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6642 :    if (!stbi__gif_header(s, g, comp, 1)) {

  0004a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00050	4c 8b 44 24 58	 mov	 r8, QWORD PTR comp$[rsp]
  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR g$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	e8 00 00 00 00	 call	 stbi__gif_header
  00064	85 c0		 test	 eax, eax
  00066	75 19		 jne	 SHORT $LN3@stbi__gif_

; 6643 :       STBI_FREE(g);

  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6644 :       stbi__rewind( s );

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00078	e8 00 00 00 00	 call	 stbi__rewind

; 6645 :       return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 3d		 jmp	 SHORT $LN1@stbi__gif_
$LN3@stbi__gif_:

; 6646 :    }
; 6647 :    if (x) *x = g->w;

  00081	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00087	74 0e		 je	 SHORT $LN4@stbi__gif_
  00089	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  00093	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00095	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__gif_:

; 6648 :    if (y) *y = g->h;

  00097	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  0009d	74 0f		 je	 SHORT $LN5@stbi__gif_
  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  000a9	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000ac	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__gif_:

; 6649 :    STBI_FREE(g);

  000ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6650 :    return 1;

  000b9	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6651 : }

  000be	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
stbi__gif_info_raw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 32
c$ = 40
idx$ = 48
tv257 = 52
g$ = 80
code$ = 88
stbi__out_gif_code PROC

; 6654 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6655 :    stbi_uc *p, *c;
; 6656 :    int idx;
; 6657 : 
; 6658 :    // recurse to decode the prefixes, since the linked-list is backwards,
; 6659 :    // and working backwards through an interleaved image would be nasty
; 6660 :    if (g->codes[code].prefix >= 0)

  0001b	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00020	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00025	0f bf 84 81 34
	08 00 00	 movsx	 eax, WORD PTR [rcx+rax*4+2100]
  0002d	85 c0		 test	 eax, eax
  0002f	7c 1d		 jl	 SHORT $LN4@stbi__out_

; 6661 :       stbi__out_gif_code(g, g->codes[code].prefix);

  00031	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0003b	0f b7 94 81 34
	08 00 00	 movzx	 edx, WORD PTR [rcx+rax*4+2100]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00048	e8 00 00 00 00	 call	 stbi__out_gif_code
  0004d	90		 npad	 1
$LN4@stbi__out_:

; 6662 : 
; 6663 :    if (g->cur_y >= g->max_y) return;

  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00053	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00058	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  0005e	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00064	7c 05		 jl	 SHORT $LN5@stbi__out_
  00066	e9 34 02 00 00	 jmp	 $LN1@stbi__out_
$LN5@stbi__out_:

; 6664 : 
; 6665 :    idx = g->cur_x + g->cur_y;

  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00070	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0007b	03 81 60 88 00
	00		 add	 eax, DWORD PTR [rcx+34912]
  00081	89 44 24 30	 mov	 DWORD PTR idx$[rsp], eax

; 6666 :    p = &g->out[idx];

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR idx$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0008f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 6667 :    g->history[idx / 4] = 1;

  0009e	8b 44 24 30	 mov	 eax, DWORD PTR idx$[rsp]
  000a2	99		 cdq
  000a3	83 e2 03	 and	 edx, 3
  000a6	03 c2		 add	 eax, edx
  000a8	c1 f8 02	 sar	 eax, 2
  000ab	48 98		 cdqe
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000b2	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000b6	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 6668 : 
; 6669 :    c = &g->color_table[g->codes[code].suffix * 4];

  000ba	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000c4	0f b6 84 81 37
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2103]
  000cc	c1 e0 02	 shl	 eax, 2
  000cf	48 98		 cdqe
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000d6	48 8b 89 38 88
	00 00		 mov	 rcx, QWORD PTR [rcx+34872]
  000dd	48 03 c8	 add	 rcx, rax
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 89 44 24 28	 mov	 QWORD PTR c$[rsp], rax

; 6670 :    if (c[3] > 128) { // don't render transparent pixels;

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	48 6b c0 03	 imul	 rax, rax, 3
  000f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR c$[rsp]
  000f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fa	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000ff	0f 8e 90 00 00
	00		 jle	 $LN6@stbi__out_

; 6671 :       p[0] = c[2];

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	48 6b c0 02	 imul	 rax, rax, 2
  0010e	b9 01 00 00 00	 mov	 ecx, 1
  00113	48 6b c9 00	 imul	 rcx, rcx, 0
  00117	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0011c	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00121	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00126	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6672 :       p[1] = c[1];

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 01	 imul	 rax, rax, 1
  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	48 6b c9 01	 imul	 rcx, rcx, 1
  0013b	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  00140	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00145	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0014a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6673 :       p[2] = c[0];

  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	48 6b c0 00	 imul	 rax, rax, 0
  00156	b9 01 00 00 00	 mov	 ecx, 1
  0015b	48 6b c9 02	 imul	 rcx, rcx, 2
  0015f	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  00164	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00169	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0016e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6674 :       p[3] = c[3];

  00171	b8 01 00 00 00	 mov	 eax, 1
  00176	48 6b c0 03	 imul	 rax, rax, 3
  0017a	b9 01 00 00 00	 mov	 ecx, 1
  0017f	48 6b c9 03	 imul	 rcx, rcx, 3
  00183	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  00188	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  0018d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00192	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN6@stbi__out_:

; 6675 :    }
; 6676 :    g->cur_x += 4;

  00195	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  0019a	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  001a0	83 c0 04	 add	 eax, 4
  001a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001a8	89 81 5c 88 00
	00		 mov	 DWORD PTR [rcx+34908], eax

; 6677 : 
; 6678 :    if (g->cur_x >= g->max_x) {

  001ae	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001b8	8b 89 54 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34900]
  001be	39 88 5c 88 00
	00		 cmp	 DWORD PTR [rax+34908], ecx
  001c4	0f 8c d5 00 00
	00		 jl	 $LN7@stbi__out_

; 6679 :       g->cur_x = g->start_x;

  001ca	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001d4	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  001da	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6680 :       g->cur_y += g->step;

  001e0	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001e5	8b 80 60 88 00
	00		 mov	 eax, DWORD PTR [rax+34912]
  001eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001f0	03 81 44 88 00
	00		 add	 eax, DWORD PTR [rcx+34884]
  001f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001fb	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax
$LN2@stbi__out_:

; 6681 : 
; 6682 :       while (g->cur_y >= g->max_y && g->parse > 0) {

  00201	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00206	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0020b	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00211	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00217	0f 8c 82 00 00
	00		 jl	 $LN3@stbi__out_
  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00222	83 b8 40 88 00
	00 00		 cmp	 DWORD PTR [rax+34880], 0
  00229	7e 74		 jle	 SHORT $LN3@stbi__out_

; 6683 :          g->step = (1 << g->parse) * g->line_size;

  0022b	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00230	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  00236	b9 01 00 00 00	 mov	 ecx, 1
  0023b	89 4c 24 34	 mov	 DWORD PTR tv257[rsp], ecx
  0023f	0f b6 c8	 movzx	 ecx, al
  00242	8b 44 24 34	 mov	 eax, DWORD PTR tv257[rsp]
  00246	d3 e0		 shl	 eax, cl
  00248	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0024d	0f af 81 64 88
	00 00		 imul	 eax, DWORD PTR [rcx+34916]
  00254	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00259	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6684 :          g->cur_y = g->start_y + (g->step >> 1);

  0025f	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00264	8b 80 44 88 00
	00		 mov	 eax, DWORD PTR [rax+34884]
  0026a	d1 f8		 sar	 eax, 1
  0026c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00271	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  00277	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0027c	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax

; 6685 :          --g->parse;

  00282	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00287	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  0028d	ff c8		 dec	 eax
  0028f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00294	89 81 40 88 00
	00		 mov	 DWORD PTR [rcx+34880], eax

; 6686 :       }

  0029a	e9 62 ff ff ff	 jmp	 $LN2@stbi__out_
$LN3@stbi__out_:
$LN7@stbi__out_:
$LN1@stbi__out_:

; 6687 :    }
; 6688 : }

  0029f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002a3	5f		 pop	 rdi
  002a4	c3		 ret	 0
stbi__out_gif_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
lzw_cs$ = 32
len$ = 36
init_code$ = 40
first$ = 44
codesize$ = 48
codemask$ = 52
avail$ = 56
oldcode$ = 60
bits$ = 64
valid_bits$ = 68
clear$ = 72
p$ = 80
code$1 = 88
$T2 = 92
$T3 = 93
$T4 = 94
$T5 = 95
tv220 = 96
tv229 = 97
tv326 = 100
tv330 = 104
tv237 = 108
tv246 = 109
tv254 = 110
tv263 = 111
tv389 = 112
tv271 = 116
tv280 = 117
tv163 = 120
tv174 = 128
tv192 = 136
tv198 = 144
tv429 = 152
tv210 = 160
s$ = 192
g$ = 200
stbi__process_gif_raster PROC

; 6691 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0001e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00026	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00035	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0003c	73 42		 jae	 SHORT $LN39@stbi__proc

; 1615 :       return *s->img_buffer++;

  0003e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00046	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00050	88 44 24 60	 mov	 BYTE PTR tv220[rsp], al
  00054	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00063	48 ff c0	 inc	 rax
  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00075	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv220[rsp]
  0007a	88 44 24 5c	 mov	 BYTE PTR $T2[rsp], al
  0007e	eb 62		 jmp	 SHORT $LN38@stbi__proc
$LN39@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00080	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00088	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0008c	74 4f		 je	 SHORT $LN40@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  0008e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00096	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0009b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ad	88 44 24 61	 mov	 BYTE PTR tv229[rsp], al
  000b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b9	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000c0	48 ff c0	 inc	 rax
  000c3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cb	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000d2	0f b6 44 24 61	 movzx	 eax, BYTE PTR tv229[rsp]
  000d7	88 44 24 5c	 mov	 BYTE PTR $T2[rsp], al
  000db	eb 05		 jmp	 SHORT $LN38@stbi__proc
$LN40@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  000dd	c6 44 24 5c 00	 mov	 BYTE PTR $T2[rsp], 0
$LN38@stbi__proc:

; 6692 :    stbi_uc lzw_cs;
; 6693 :    stbi__int32 len, init_code;
; 6694 :    stbi__uint32 first;
; 6695 :    stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6696 :    stbi__gif_lzw *p;
; 6697 : 
; 6698 :    lzw_cs = stbi__get8(s);

  000e2	0f b6 44 24 5c	 movzx	 eax, BYTE PTR $T2[rsp]
  000e7	88 44 24 20	 mov	 BYTE PTR lzw_cs$[rsp], al

; 6699 :    if (lzw_cs > 12) return NULL;

  000eb	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  000f0	83 f8 0c	 cmp	 eax, 12
  000f3	7e 07		 jle	 SHORT $LN10@stbi__proc
  000f5	33 c0		 xor	 eax, eax
  000f7	e9 85 06 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 6700 :    clear = 1 << lzw_cs;

  000fc	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00101	b9 01 00 00 00	 mov	 ecx, 1
  00106	89 4c 24 64	 mov	 DWORD PTR tv326[rsp], ecx
  0010a	0f b6 c8	 movzx	 ecx, al
  0010d	8b 44 24 64	 mov	 eax, DWORD PTR tv326[rsp]
  00111	d3 e0		 shl	 eax, cl
  00113	89 44 24 48	 mov	 DWORD PTR clear$[rsp], eax

; 6701 :    first = 1;

  00117	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1

; 6702 :    codesize = lzw_cs + 1;

  0011f	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00124	ff c0		 inc	 eax
  00126	89 44 24 30	 mov	 DWORD PTR codesize$[rsp], eax

; 6703 :    codemask = (1 << codesize) - 1;

  0012a	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  0012e	b9 01 00 00 00	 mov	 ecx, 1
  00133	89 4c 24 68	 mov	 DWORD PTR tv330[rsp], ecx
  00137	0f b6 c8	 movzx	 ecx, al
  0013a	8b 44 24 68	 mov	 eax, DWORD PTR tv330[rsp]
  0013e	d3 e0		 shl	 eax, cl
  00140	ff c8		 dec	 eax
  00142	89 44 24 34	 mov	 DWORD PTR codemask$[rsp], eax

; 6704 :    bits = 0;

  00146	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 6705 :    valid_bits = 0;

  0014e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR valid_bits$[rsp], 0

; 6706 :    for (init_code = 0; init_code < clear; init_code++) {

  00156	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR init_code$[rsp], 0
  0015e	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  00160	8b 44 24 28	 mov	 eax, DWORD PTR init_code$[rsp]
  00164	ff c0		 inc	 eax
  00166	89 44 24 28	 mov	 DWORD PTR init_code$[rsp], eax
$LN4@stbi__proc:
  0016a	8b 44 24 48	 mov	 eax, DWORD PTR clear$[rsp]
  0016e	39 44 24 28	 cmp	 DWORD PTR init_code$[rsp], eax
  00172	7d 4e		 jge	 SHORT $LN3@stbi__proc

; 6707 :       g->codes[init_code].prefix = -1;

  00174	48 63 44 24 28	 movsxd	 rax, DWORD PTR init_code$[rsp]
  00179	b9 ff ff ff ff	 mov	 ecx, -1
  0017e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00186	66 89 8c 82 34
	08 00 00	 mov	 WORD PTR [rdx+rax*4+2100], cx

; 6708 :       g->codes[init_code].first = (stbi_uc) init_code;

  0018e	48 63 44 24 28	 movsxd	 rax, DWORD PTR init_code$[rsp]
  00193	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0019b	0f b6 54 24 28	 movzx	 edx, BYTE PTR init_code$[rsp]
  001a0	88 94 81 36 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2102], dl

; 6709 :       g->codes[init_code].suffix = (stbi_uc) init_code;

  001a7	48 63 44 24 28	 movsxd	 rax, DWORD PTR init_code$[rsp]
  001ac	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001b4	0f b6 54 24 28	 movzx	 edx, BYTE PTR init_code$[rsp]
  001b9	88 94 81 37 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2103], dl

; 6710 :    }

  001c0	eb 9e		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 6711 : 
; 6712 :    // support no starting clear code
; 6713 :    avail = clear+2;

  001c2	8b 44 24 48	 mov	 eax, DWORD PTR clear$[rsp]
  001c6	83 c0 02	 add	 eax, 2
  001c9	89 44 24 38	 mov	 DWORD PTR avail$[rsp], eax

; 6714 :    oldcode = -1;

  001cd	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6715 : 
; 6716 :    len = 0;

  001d5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN5@stbi__proc:

; 6717 :    for(;;) {
; 6718 :       if (valid_bits < codesize) {

  001dd	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  001e1	39 44 24 44	 cmp	 DWORD PTR valid_bits$[rsp], eax
  001e5	0f 8d eb 01 00
	00		 jge	 $LN11@stbi__proc

; 6719 :          if (len == 0) {

  001eb	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  001f0	0f 85 e8 00 00
	00		 jne	 $LN13@stbi__proc

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  001f6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001fe	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00206	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0020d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00214	73 42		 jae	 SHORT $LN43@stbi__proc

; 1615 :       return *s->img_buffer++;

  00216	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0021e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00225	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00228	88 44 24 6c	 mov	 BYTE PTR tv237[rsp], al
  0022c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00234	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0023b	48 ff c0	 inc	 rax
  0023e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00246	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0024d	0f b6 44 24 6c	 movzx	 eax, BYTE PTR tv237[rsp]
  00252	88 44 24 5d	 mov	 BYTE PTR $T3[rsp], al
  00256	eb 62		 jmp	 SHORT $LN42@stbi__proc
$LN43@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  00258	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00260	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00264	74 4f		 je	 SHORT $LN44@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00266	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0026e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00273	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0027b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00282	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00285	88 44 24 6d	 mov	 BYTE PTR tv246[rsp], al
  00289	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00291	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00298	48 ff c0	 inc	 rax
  0029b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002aa	0f b6 44 24 6d	 movzx	 eax, BYTE PTR tv246[rsp]
  002af	88 44 24 5d	 mov	 BYTE PTR $T3[rsp], al
  002b3	eb 05		 jmp	 SHORT $LN42@stbi__proc
$LN44@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  002b5	c6 44 24 5d 00	 mov	 BYTE PTR $T3[rsp], 0
$LN42@stbi__proc:

; 6720 :             len = stbi__get8(s); // start new block

  002ba	0f b6 44 24 5d	 movzx	 eax, BYTE PTR $T3[rsp]
  002bf	0f b6 c0	 movzx	 eax, al
  002c2	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6721 :             if (len == 0)

  002c6	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  002cb	75 11		 jne	 SHORT $LN14@stbi__proc

; 6722 :                return g->out;

  002cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  002d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002d9	e9 a3 04 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:
$LN13@stbi__proc:

; 6723 :          }
; 6724 :          --len;

  002de	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  002e2	ff c8		 dec	 eax
  002e4	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  002e8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002f8	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002ff	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00306	73 42		 jae	 SHORT $LN47@stbi__proc

; 1615 :       return *s->img_buffer++;

  00308	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00310	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00317	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0031a	88 44 24 6e	 mov	 BYTE PTR tv254[rsp], al
  0031e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00326	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0032d	48 ff c0	 inc	 rax
  00330	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00338	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0033f	0f b6 44 24 6e	 movzx	 eax, BYTE PTR tv254[rsp]
  00344	88 44 24 5e	 mov	 BYTE PTR $T4[rsp], al
  00348	eb 62		 jmp	 SHORT $LN46@stbi__proc
$LN47@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  0034a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00352	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00356	74 4f		 je	 SHORT $LN48@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  00358	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00360	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00365	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0036d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00374	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00377	88 44 24 6f	 mov	 BYTE PTR tv263[rsp], al
  0037b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00383	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0038a	48 ff c0	 inc	 rax
  0038d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00395	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0039c	0f b6 44 24 6f	 movzx	 eax, BYTE PTR tv263[rsp]
  003a1	88 44 24 5e	 mov	 BYTE PTR $T4[rsp], al
  003a5	eb 05		 jmp	 SHORT $LN46@stbi__proc
$LN48@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  003a7	c6 44 24 5e 00	 mov	 BYTE PTR $T4[rsp], 0
$LN46@stbi__proc:

; 6725 :          bits |= (stbi__int32) stbi__get8(s) << valid_bits;

  003ac	0f b6 44 24 5e	 movzx	 eax, BYTE PTR $T4[rsp]
  003b1	0f b6 c0	 movzx	 eax, al
  003b4	8b 4c 24 44	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  003b8	d3 e0		 shl	 eax, cl
  003ba	8b 4c 24 40	 mov	 ecx, DWORD PTR bits$[rsp]
  003be	0b c8		 or	 ecx, eax
  003c0	8b c1		 mov	 eax, ecx
  003c2	89 44 24 40	 mov	 DWORD PTR bits$[rsp], eax

; 6726 :          valid_bits += 8;

  003c6	8b 44 24 44	 mov	 eax, DWORD PTR valid_bits$[rsp]
  003ca	83 c0 08	 add	 eax, 8
  003cd	89 44 24 44	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6727 :       } else {

  003d1	e9 a6 03 00 00	 jmp	 $LN12@stbi__proc
$LN11@stbi__proc:

; 6728 :          stbi__int32 code = bits & codemask;

  003d6	8b 44 24 34	 mov	 eax, DWORD PTR codemask$[rsp]
  003da	8b 4c 24 40	 mov	 ecx, DWORD PTR bits$[rsp]
  003de	23 c8		 and	 ecx, eax
  003e0	8b c1		 mov	 eax, ecx
  003e2	89 44 24 58	 mov	 DWORD PTR code$1[rsp], eax

; 6729 :          bits >>= codesize;

  003e6	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  003ea	0f b6 c8	 movzx	 ecx, al
  003ed	8b 44 24 40	 mov	 eax, DWORD PTR bits$[rsp]
  003f1	d3 f8		 sar	 eax, cl
  003f3	89 44 24 40	 mov	 DWORD PTR bits$[rsp], eax

; 6730 :          valid_bits -= codesize;

  003f7	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  003fb	8b 4c 24 44	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  003ff	2b c8		 sub	 ecx, eax
  00401	8b c1		 mov	 eax, ecx
  00403	89 44 24 44	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6731 :          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6732 :          if (code == clear) {  // clear code

  00407	8b 44 24 48	 mov	 eax, DWORD PTR clear$[rsp]
  0040b	39 44 24 58	 cmp	 DWORD PTR code$1[rsp], eax
  0040f	75 47		 jne	 SHORT $LN15@stbi__proc

; 6733 :             codesize = lzw_cs + 1;

  00411	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00416	ff c0		 inc	 eax
  00418	89 44 24 30	 mov	 DWORD PTR codesize$[rsp], eax

; 6734 :             codemask = (1 << codesize) - 1;

  0041c	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  00420	b9 01 00 00 00	 mov	 ecx, 1
  00425	89 4c 24 70	 mov	 DWORD PTR tv389[rsp], ecx
  00429	0f b6 c8	 movzx	 ecx, al
  0042c	8b 44 24 70	 mov	 eax, DWORD PTR tv389[rsp]
  00430	d3 e0		 shl	 eax, cl
  00432	ff c8		 dec	 eax
  00434	89 44 24 34	 mov	 DWORD PTR codemask$[rsp], eax

; 6735 :             avail = clear + 2;

  00438	8b 44 24 48	 mov	 eax, DWORD PTR clear$[rsp]
  0043c	83 c0 02	 add	 eax, 2
  0043f	89 44 24 38	 mov	 DWORD PTR avail$[rsp], eax

; 6736 :             oldcode = -1;

  00443	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6737 :             first = 0;

  0044b	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0
  00453	e9 24 03 00 00	 jmp	 $LN16@stbi__proc
$LN15@stbi__proc:

; 6738 :          } else if (code == clear + 1) { // end of stream code

  00458	8b 44 24 48	 mov	 eax, DWORD PTR clear$[rsp]
  0045c	ff c0		 inc	 eax
  0045e	39 44 24 58	 cmp	 DWORD PTR code$1[rsp], eax
  00462	0f 85 16 01 00
	00		 jne	 $LN17@stbi__proc

; 6739 :             stbi__skip(s, len);

  00468	8b 54 24 24	 mov	 edx, DWORD PTR len$[rsp]
  0046c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00474	e8 00 00 00 00	 call	 stbi__skip
  00479	90		 npad	 1
$LN8@stbi__proc:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0047a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00482	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0048a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00491	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00498	73 42		 jae	 SHORT $LN51@stbi__proc

; 1615 :       return *s->img_buffer++;

  0049a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004a2	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004a9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004ac	88 44 24 74	 mov	 BYTE PTR tv271[rsp], al
  004b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004bf	48 ff c0	 inc	 rax
  004c2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ca	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004d1	0f b6 44 24 74	 movzx	 eax, BYTE PTR tv271[rsp]
  004d6	88 44 24 5f	 mov	 BYTE PTR $T5[rsp], al
  004da	eb 62		 jmp	 SHORT $LN50@stbi__proc
$LN51@stbi__proc:

; 1616 :    if (s->read_from_callbacks) {

  004dc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004e4	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004e8	74 4f		 je	 SHORT $LN52@stbi__proc

; 1617 :       stbi__refill_buffer(s);

  004ea	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004f2	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  004f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ff	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00506	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00509	88 44 24 75	 mov	 BYTE PTR tv280[rsp], al
  0050d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00515	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0051c	48 ff c0	 inc	 rax
  0051f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00527	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0052e	0f b6 44 24 75	 movzx	 eax, BYTE PTR tv280[rsp]
  00533	88 44 24 5f	 mov	 BYTE PTR $T5[rsp], al
  00537	eb 05		 jmp	 SHORT $LN50@stbi__proc
$LN52@stbi__proc:

; 1619 :    }
; 1620 :    return 0;

  00539	c6 44 24 5f 00	 mov	 BYTE PTR $T5[rsp], 0
$LN50@stbi__proc:

; 6740 :             while ((len = stbi__get8(s)) > 0)

  0053e	0f b6 44 24 5f	 movzx	 eax, BYTE PTR $T5[rsp]
  00543	0f b6 c0	 movzx	 eax, al
  00546	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
  0054a	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  0054f	7e 17		 jle	 SHORT $LN9@stbi__proc

; 6741 :                stbi__skip(s,len);

  00551	8b 54 24 24	 mov	 edx, DWORD PTR len$[rsp]
  00555	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055d	e8 00 00 00 00	 call	 stbi__skip
  00562	90		 npad	 1
  00563	e9 12 ff ff ff	 jmp	 $LN8@stbi__proc
$LN9@stbi__proc:

; 6742 :             return g->out;

  00568	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00570	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00574	e9 08 02 00 00	 jmp	 $LN1@stbi__proc
  00579	e9 fe 01 00 00	 jmp	 $LN18@stbi__proc
$LN17@stbi__proc:

; 6743 :          } else if (code <= avail) {

  0057e	8b 44 24 38	 mov	 eax, DWORD PTR avail$[rsp]
  00582	39 44 24 58	 cmp	 DWORD PTR code$1[rsp], eax
  00586	0f 8f bc 01 00
	00		 jg	 $LN19@stbi__proc

; 6744 :             if (first) {

  0058c	83 7c 24 2c 00	 cmp	 DWORD PTR first$[rsp], 0
  00591	74 2e		 je	 SHORT $LN21@stbi__proc

; 6745 :                return stbi__errpuc("no clear code", "Corrupt GIF");

  00593	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MGDACKOJ@no?5clear?5code@
  0059a	e8 00 00 00 00	 call	 stbi__err
  0059f	85 c0		 test	 eax, eax
  005a1	74 0b		 je	 SHORT $LN28@stbi__proc
  005a3	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv163[rsp], 0
  005ac	eb 09		 jmp	 SHORT $LN29@stbi__proc
$LN28@stbi__proc:
  005ae	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv163[rsp], 0
$LN29@stbi__proc:
  005b7	48 8b 44 24 78	 mov	 rax, QWORD PTR tv163[rsp]
  005bc	e9 c0 01 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 6746 :             }
; 6747 : 
; 6748 :             if (oldcode >= 0) {

  005c1	83 7c 24 3c 00	 cmp	 DWORD PTR oldcode$[rsp], 0
  005c6	0f 8c d9 00 00
	00		 jl	 $LN22@stbi__proc

; 6749 :                p = &g->codes[avail++];

  005cc	48 63 44 24 38	 movsxd	 rax, DWORD PTR avail$[rsp]
  005d1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005d9	48 8d 84 81 34
	08 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+2100]
  005e1	48 89 44 24 50	 mov	 QWORD PTR p$[rsp], rax
  005e6	8b 44 24 38	 mov	 eax, DWORD PTR avail$[rsp]
  005ea	ff c0		 inc	 eax
  005ec	89 44 24 38	 mov	 DWORD PTR avail$[rsp], eax

; 6750 :                if (avail > 8192) {

  005f0	81 7c 24 38 00
	20 00 00	 cmp	 DWORD PTR avail$[rsp], 8192 ; 00002000H
  005f8	7e 37		 jle	 SHORT $LN24@stbi__proc

; 6751 :                   return stbi__errpuc("too many codes", "Corrupt GIF");

  005fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@GJNJCPDJ@too?5many?5codes@
  00601	e8 00 00 00 00	 call	 stbi__err
  00606	85 c0		 test	 eax, eax
  00608	74 0e		 je	 SHORT $LN30@stbi__proc
  0060a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv174[rsp], 0
  00616	eb 0c		 jmp	 SHORT $LN31@stbi__proc
$LN30@stbi__proc:
  00618	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv174[rsp], 0
$LN31@stbi__proc:
  00624	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv174[rsp]
  0062c	e9 50 01 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 6752 :                }
; 6753 : 
; 6754 :                p->prefix = (stbi__int16) oldcode;

  00631	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00636	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR oldcode$[rsp]
  0063b	66 89 08	 mov	 WORD PTR [rax], cx

; 6755 :                p->first = g->codes[oldcode].first;

  0063e	48 63 44 24 3c	 movsxd	 rax, DWORD PTR oldcode$[rsp]
  00643	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00648	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00650	0f b6 84 82 36
	08 00 00	 movzx	 eax, BYTE PTR [rdx+rax*4+2102]
  00658	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6756 :                p->suffix = (code == avail) ? p->first : g->codes[code].first;

  0065b	8b 44 24 38	 mov	 eax, DWORD PTR avail$[rsp]
  0065f	39 44 24 58	 cmp	 DWORD PTR code$1[rsp], eax
  00663	75 12		 jne	 SHORT $LN32@stbi__proc
  00665	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0066a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0066e	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  00675	eb 1c		 jmp	 SHORT $LN33@stbi__proc
$LN32@stbi__proc:
  00677	48 63 44 24 58	 movsxd	 rax, DWORD PTR code$1[rsp]
  0067c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00684	0f b6 84 81 36
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2102]
  0068c	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
$LN33@stbi__proc:
  00693	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00698	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR tv192[rsp]
  006a0	88 48 03	 mov	 BYTE PTR [rax+3], cl
  006a3	eb 41		 jmp	 SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 6757 :             } else if (code == avail)

  006a5	8b 44 24 38	 mov	 eax, DWORD PTR avail$[rsp]
  006a9	39 44 24 58	 cmp	 DWORD PTR code$1[rsp], eax
  006ad	75 37		 jne	 SHORT $LN25@stbi__proc

; 6758 :                return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  006af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
  006b6	e8 00 00 00 00	 call	 stbi__err
  006bb	85 c0		 test	 eax, eax
  006bd	74 0e		 je	 SHORT $LN34@stbi__proc
  006bf	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv198[rsp], 0
  006cb	eb 0c		 jmp	 SHORT $LN35@stbi__proc
$LN34@stbi__proc:
  006cd	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv198[rsp], 0
$LN35@stbi__proc:
  006d9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv198[rsp]
  006e1	e9 9b 00 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:
$LN23@stbi__proc:

; 6759 : 
; 6760 :             stbi__out_gif_code(g, (stbi__uint16) code);

  006e6	0f b7 54 24 58	 movzx	 edx, WORD PTR code$1[rsp]
  006eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  006f3	e8 00 00 00 00	 call	 stbi__out_gif_code

; 6761 : 
; 6762 :             if ((avail & codemask) == 0 && avail <= 0x0FFF) {

  006f8	8b 44 24 34	 mov	 eax, DWORD PTR codemask$[rsp]
  006fc	8b 4c 24 38	 mov	 ecx, DWORD PTR avail$[rsp]
  00700	23 c8		 and	 ecx, eax
  00702	8b c1		 mov	 eax, ecx
  00704	85 c0		 test	 eax, eax
  00706	75 36		 jne	 SHORT $LN26@stbi__proc
  00708	81 7c 24 38 ff
	0f 00 00	 cmp	 DWORD PTR avail$[rsp], 4095 ; 00000fffH
  00710	7f 2c		 jg	 SHORT $LN26@stbi__proc

; 6763 :                codesize++;

  00712	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  00716	ff c0		 inc	 eax
  00718	89 44 24 30	 mov	 DWORD PTR codesize$[rsp], eax

; 6764 :                codemask = (1 << codesize) - 1;

  0071c	8b 44 24 30	 mov	 eax, DWORD PTR codesize$[rsp]
  00720	b9 01 00 00 00	 mov	 ecx, 1
  00725	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv429[rsp], ecx
  0072c	0f b6 c8	 movzx	 ecx, al
  0072f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv429[rsp]
  00736	d3 e0		 shl	 eax, cl
  00738	ff c8		 dec	 eax
  0073a	89 44 24 34	 mov	 DWORD PTR codemask$[rsp], eax
$LN26@stbi__proc:

; 6765 :             }
; 6766 : 
; 6767 :             oldcode = code;

  0073e	8b 44 24 58	 mov	 eax, DWORD PTR code$1[rsp]
  00742	89 44 24 3c	 mov	 DWORD PTR oldcode$[rsp], eax

; 6768 :          } else {

  00746	eb 34		 jmp	 SHORT $LN20@stbi__proc
$LN19@stbi__proc:

; 6769 :             return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  00748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LOKBIIOJ@illegal?5code?5in?5raster@
  0074f	e8 00 00 00 00	 call	 stbi__err
  00754	85 c0		 test	 eax, eax
  00756	74 0e		 je	 SHORT $LN36@stbi__proc
  00758	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv210[rsp], 0
  00764	eb 0c		 jmp	 SHORT $LN37@stbi__proc
$LN36@stbi__proc:
  00766	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv210[rsp], 0
$LN37@stbi__proc:
  00772	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv210[rsp]
  0077a	eb 05		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:
$LN18@stbi__proc:
$LN16@stbi__proc:
$LN12@stbi__proc:

; 6770 :          }
; 6771 :       }
; 6772 :    }

  0077c	e9 5c fa ff ff	 jmp	 $LN5@stbi__proc
$LN1@stbi__proc:

; 6773 : }

  00781	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00788	5f		 pop	 rdi
  00789	c3		 ret	 0
stbi__process_gif_raster ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
dispose$ = 32
first_frame$ = 36
pi$ = 40
pcount$ = 44
tag$1 = 48
x$2 = 52
y$3 = 56
w$4 = 60
h$5 = 64
o$6 = 72
len$7 = 80
ext$8 = 84
$T9 = 88
$T10 = 89
$T11 = 90
$T12 = 91
$T13 = 92
$T14 = 93
$T15 = 94
tv83 = 96
tv142 = 104
tv146 = 112
tv153 = 120
tv159 = 128
tv239 = 136
tv440 = 144
tv449 = 145
tv246 = 148
tv264 = 152
tv457 = 160
tv466 = 161
tv310 = 164
tv761 = 168
tv329 = 176
tv474 = 184
tv483 = 185
tv491 = 186
tv500 = 187
tv508 = 188
tv517 = 189
tv525 = 190
tv534 = 191
tv542 = 192
tv551 = 193
tv427 = 200
s$ = 240
g$ = 248
comp$ = 256
req_comp$ = 264
two_back$ = 272
stbi__gif_load_next PROC

; 6778 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6779 :    int dispose;
; 6780 :    int first_frame;
; 6781 :    int pi;
; 6782 :    int pcount;
; 6783 :    STBI_NOTUSED(req_comp);
; 6784 : 
; 6785 :    // on first frame, any non-written pixels get the background colour (non-transparent)
; 6786 :    first_frame = 0;

  00029	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 0

; 6787 :    if (g->out == 0) {

  00031	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00039	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003e	0f 85 c0 01 00
	00		 jne	 $LN18@stbi__gif_

; 6788 :       if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

  00044	45 33 c9	 xor	 r9d, r9d
  00047	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  0004f	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00057	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	e8 00 00 00 00	 call	 stbi__gif_header
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN20@stbi__gif_
  00068	33 c0		 xor	 eax, eax
  0006a	e9 1b 0f 00 00	 jmp	 $LN1@stbi__gif_
$LN20@stbi__gif_:

; 6789 :       if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

  0006f	45 33 c9	 xor	 r9d, r9d
  00072	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0007a	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0007e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00086	8b 10		 mov	 edx, DWORD PTR [rax]
  00088	b9 04 00 00 00	 mov	 ecx, 4
  0008d	e8 00 00 00 00	 call	 stbi__mad3sizes_valid
  00092	85 c0		 test	 eax, eax
  00094	75 2e		 jne	 SHORT $LN21@stbi__gif_

; 6790 :          return stbi__errpuc("too large", "GIF image is too large");

  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0009d	e8 00 00 00 00	 call	 stbi__err
  000a2	85 c0		 test	 eax, eax
  000a4	74 0b		 je	 SHORT $LN55@stbi__gif_
  000a6	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
  000af	eb 09		 jmp	 SHORT $LN56@stbi__gif_
$LN55@stbi__gif_:
  000b1	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
$LN56@stbi__gif_:
  000ba	48 8b 44 24 60	 mov	 rax, QWORD PTR tv83[rsp]
  000bf	e9 c6 0e 00 00	 jmp	 $LN1@stbi__gif_
$LN21@stbi__gif_:

; 6791 :       pcount = g->w * g->h;

  000c4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  000cc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000d4	8b 00		 mov	 eax, DWORD PTR [rax]
  000d6	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  000da	89 44 24 2c	 mov	 DWORD PTR pcount$[rsp], eax

; 6792 :       g->out = (stbi_uc *) stbi__malloc(4 * pcount);

  000de	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  000e2	c1 e0 02	 shl	 eax, 2
  000e5	48 98		 cdqe
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 stbi__malloc
  000ef	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000f7	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6793 :       g->background = (stbi_uc *) stbi__malloc(4 * pcount);

  000fb	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  000ff	c1 e0 02	 shl	 eax, 2
  00102	48 98		 cdqe
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 stbi__malloc
  0010c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00114	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 6794 :       g->history = (stbi_uc *) stbi__malloc(pcount);

  00118	48 63 44 24 2c	 movsxd	 rax, DWORD PTR pcount$[rsp]
  0011d	48 8b c8	 mov	 rcx, rax
  00120	e8 00 00 00 00	 call	 stbi__malloc
  00125	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0012d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 6795 :       if (!g->out || !g->background || !g->history)

  00131	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00139	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0013e	74 1e		 je	 SHORT $LN23@stbi__gif_
  00140	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00148	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0014d	74 0f		 je	 SHORT $LN23@stbi__gif_
  0014f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00157	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0015c	75 2e		 jne	 SHORT $LN22@stbi__gif_
$LN23@stbi__gif_:

; 6796 :          return stbi__errpuc("outofmem", "Out of memory");

  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00165	e8 00 00 00 00	 call	 stbi__err
  0016a	85 c0		 test	 eax, eax
  0016c	74 0b		 je	 SHORT $LN57@stbi__gif_
  0016e	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv142[rsp], 0
  00177	eb 09		 jmp	 SHORT $LN58@stbi__gif_
$LN57@stbi__gif_:
  00179	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv142[rsp], 0
$LN58@stbi__gif_:
  00182	48 8b 44 24 68	 mov	 rax, QWORD PTR tv142[rsp]
  00187	e9 fe 0d 00 00	 jmp	 $LN1@stbi__gif_
$LN22@stbi__gif_:

; 6797 : 
; 6798 :       // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6799 :       // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6800 :       // color refers to the color that was there the previous frame.
; 6801 :       memset(g->out, 0x00, 4 * pcount);

  0018c	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  00190	c1 e0 02	 shl	 eax, 2
  00193	48 98		 cdqe
  00195	48 89 44 24 70	 mov	 QWORD PTR tv146[rsp], rax
  0019a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001a2	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  001a6	33 c0		 xor	 eax, eax
  001a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv146[rsp]
  001ad	f3 aa		 rep stosb

; 6802 :       memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

  001af	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  001b3	c1 e0 02	 shl	 eax, 2
  001b6	48 98		 cdqe
  001b8	48 89 44 24 78	 mov	 QWORD PTR tv153[rsp], rax
  001bd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001c5	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  001c9	33 c0		 xor	 eax, eax
  001cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv153[rsp]
  001d0	f3 aa		 rep stosb

; 6803 :       memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

  001d2	48 63 44 24 2c	 movsxd	 rax, DWORD PTR pcount$[rsp]
  001d7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  001df	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001e7	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  001eb	33 c0		 xor	 eax, eax
  001ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  001f5	f3 aa		 rep stosb

; 6804 :       first_frame = 1;

  001f7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 1

; 6805 :    } else {

  001ff	e9 61 01 00 00	 jmp	 $LN19@stbi__gif_
$LN18@stbi__gif_:

; 6806 :       // second frame - how do we dispose of the previous one?
; 6807 :       dispose = (g->eflags & 0x1C) >> 2;

  00204	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0020c	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0020f	83 e0 1c	 and	 eax, 28
  00212	c1 f8 02	 sar	 eax, 2
  00215	89 44 24 20	 mov	 DWORD PTR dispose$[rsp], eax

; 6808 :       pcount = g->w * g->h;

  00219	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00221	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00229	8b 00		 mov	 eax, DWORD PTR [rax]
  0022b	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0022f	89 44 24 2c	 mov	 DWORD PTR pcount$[rsp], eax

; 6809 : 
; 6810 :       if ((dispose == 3) && (two_back == 0)) {

  00233	83 7c 24 20 03	 cmp	 DWORD PTR dispose$[rsp], 3
  00238	75 13		 jne	 SHORT $LN24@stbi__gif_
  0023a	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR two_back$[rsp], 0
  00243	75 08		 jne	 SHORT $LN24@stbi__gif_

; 6811 :          dispose = 2; // if I don't have an image to revert back to, default to the old background

  00245	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR dispose$[rsp], 2
$LN24@stbi__gif_:

; 6812 :       }
; 6813 : 
; 6814 :       if (dispose == 3) { // use previous graphic

  0024d	83 7c 24 20 03	 cmp	 DWORD PTR dispose$[rsp], 3
  00252	75 68		 jne	 SHORT $LN25@stbi__gif_

; 6815 :          for (pi = 0; pi < pcount; ++pi) {

  00254	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  0025c	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  0025e	8b 44 24 28	 mov	 eax, DWORD PTR pi$[rsp]
  00262	ff c0		 inc	 eax
  00264	89 44 24 28	 mov	 DWORD PTR pi$[rsp], eax
$LN4@stbi__gif_:
  00268	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  0026c	39 44 24 28	 cmp	 DWORD PTR pi$[rsp], eax
  00270	7d 48		 jge	 SHORT $LN3@stbi__gif_

; 6816 :             if (g->history[pi]) {

  00272	48 63 44 24 28	 movsxd	 rax, DWORD PTR pi$[rsp]
  00277	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0027f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00283	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00287	85 c0		 test	 eax, eax
  00289	74 2d		 je	 SHORT $LN27@stbi__gif_

; 6817 :                memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );

  0028b	8b 44 24 28	 mov	 eax, DWORD PTR pi$[rsp]
  0028f	c1 e0 02	 shl	 eax, 2
  00292	48 98		 cdqe
  00294	8b 4c 24 28	 mov	 ecx, DWORD PTR pi$[rsp]
  00298	c1 e1 02	 shl	 ecx, 2
  0029b	48 63 c9	 movsxd	 rcx, ecx
  0029e	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  002a6	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  002aa	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR two_back$[rsp]
  002b2	8b 04 07	 mov	 eax, DWORD PTR [rdi+rax]
  002b5	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN27@stbi__gif_:

; 6818 :             }
; 6819 :          }

  002b8	eb a4		 jmp	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6820 :       } else if (dispose == 2) {

  002ba	eb 71		 jmp	 SHORT $LN26@stbi__gif_
$LN25@stbi__gif_:
  002bc	83 7c 24 20 02	 cmp	 DWORD PTR dispose$[rsp], 2
  002c1	75 6a		 jne	 SHORT $LN28@stbi__gif_

; 6821 :          // restore what was changed last frame to background before that frame;
; 6822 :          for (pi = 0; pi < pcount; ++pi) {

  002c3	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  002cb	eb 0a		 jmp	 SHORT $LN7@stbi__gif_
$LN5@stbi__gif_:
  002cd	8b 44 24 28	 mov	 eax, DWORD PTR pi$[rsp]
  002d1	ff c0		 inc	 eax
  002d3	89 44 24 28	 mov	 DWORD PTR pi$[rsp], eax
$LN7@stbi__gif_:
  002d7	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  002db	39 44 24 28	 cmp	 DWORD PTR pi$[rsp], eax
  002df	7d 4c		 jge	 SHORT $LN6@stbi__gif_

; 6823 :             if (g->history[pi]) {

  002e1	48 63 44 24 28	 movsxd	 rax, DWORD PTR pi$[rsp]
  002e6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002ee	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f6	85 c0		 test	 eax, eax
  002f8	74 31		 je	 SHORT $LN30@stbi__gif_

; 6824 :                memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );

  002fa	8b 44 24 28	 mov	 eax, DWORD PTR pi$[rsp]
  002fe	c1 e0 02	 shl	 eax, 2
  00301	48 98		 cdqe
  00303	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0030b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0030f	8b 54 24 28	 mov	 edx, DWORD PTR pi$[rsp]
  00313	c1 e2 02	 shl	 edx, 2
  00316	48 63 d2	 movsxd	 rdx, edx
  00319	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR g$[rsp]
  00321	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  00325	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00328	89 04 17	 mov	 DWORD PTR [rdi+rdx], eax
$LN30@stbi__gif_:

; 6825 :             }
; 6826 :          }

  0032b	eb a0		 jmp	 SHORT $LN5@stbi__gif_
$LN6@stbi__gif_:
$LN28@stbi__gif_:
$LN26@stbi__gif_:

; 6827 :       } else {
; 6828 :          // This is a non-disposal case eithe way, so just
; 6829 :          // leave the pixels as is, and they will become the new background
; 6830 :          // 1: do not dispose
; 6831 :          // 0:  not specified.
; 6832 :       }
; 6833 : 
; 6834 :       // background is what out is after the undoing of the previou frame;
; 6835 :       memcpy( g->background, g->out, 4 * g->w * g->h );

  0032d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00335	8b 00		 mov	 eax, DWORD PTR [rax]
  00337	c1 e0 02	 shl	 eax, 2
  0033a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00342	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00346	48 98		 cdqe
  00348	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00350	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00358	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  0035c	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  00360	48 8b c8	 mov	 rcx, rax
  00363	f3 a4		 rep movsb
$LN19@stbi__gif_:

; 6836 :    }
; 6837 : 
; 6838 :    // clear my history;
; 6839 :    memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

  00365	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0036d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00375	8b 00		 mov	 eax, DWORD PTR [rax]
  00377	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0037b	48 98		 cdqe
  0037d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv239[rsp], rax
  00385	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0038d	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00391	33 c0		 xor	 eax, eax
  00393	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv239[rsp]
  0039b	f3 aa		 rep stosb
$LN8@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0039d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ad	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  003b4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  003bb	73 48		 jae	 SHORT $LN68@stbi__gif_

; 1615 :       return *s->img_buffer++;

  003bd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003c5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003cf	88 84 24 90 00
	00 00		 mov	 BYTE PTR tv440[rsp], al
  003d6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003de	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003e5	48 ff c0	 inc	 rax
  003e8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003f7	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR tv440[rsp]
  003ff	88 44 24 58	 mov	 BYTE PTR $T9[rsp], al
  00403	eb 68		 jmp	 SHORT $LN67@stbi__gif_
$LN68@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00405	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0040d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00411	74 55		 je	 SHORT $LN69@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00413	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00420	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00428	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0042f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00432	88 84 24 91 00
	00 00		 mov	 BYTE PTR tv449[rsp], al
  00439	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00441	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00448	48 ff c0	 inc	 rax
  0044b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00453	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0045a	0f b6 84 24 91
	00 00 00	 movzx	 eax, BYTE PTR tv449[rsp]
  00462	88 44 24 58	 mov	 BYTE PTR $T9[rsp], al
  00466	eb 05		 jmp	 SHORT $LN67@stbi__gif_
$LN69@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00468	c6 44 24 58 00	 mov	 BYTE PTR $T9[rsp], 0
$LN67@stbi__gif_:

; 6840 : 
; 6841 :    for (;;) {
; 6842 :       int tag = stbi__get8(s);

  0046d	0f b6 44 24 58	 movzx	 eax, BYTE PTR $T9[rsp]
  00472	0f b6 c0	 movzx	 eax, al
  00475	89 44 24 30	 mov	 DWORD PTR tag$1[rsp], eax

; 6843 :       switch (tag) {

  00479	8b 44 24 30	 mov	 eax, DWORD PTR tag$1[rsp]
  0047d	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv246[rsp], eax
  00484	83 bc 24 94 00
	00 00 21	 cmp	 DWORD PTR tv246[rsp], 33 ; 00000021H
  0048c	0f 84 4a 05 00
	00		 je	 $LN44@stbi__gif_
  00492	83 bc 24 94 00
	00 00 2c	 cmp	 DWORD PTR tv246[rsp], 44 ; 0000002cH
  0049a	74 13		 je	 SHORT $LN31@stbi__gif_
  0049c	83 bc 24 94 00
	00 00 3b	 cmp	 DWORD PTR tv246[rsp], 59 ; 0000003bH
  004a4	0f 84 9d 0a 00
	00		 je	 $LN52@stbi__gif_
  004aa	e9 a2 0a 00 00	 jmp	 $LN53@stbi__gif_
$LN31@stbi__gif_:

; 6844 :          case 0x2C: /* Image Descriptor */
; 6845 :          {
; 6846 :             stbi__int32 x, y, w, h;
; 6847 :             stbi_uc *o;
; 6848 : 
; 6849 :             x = stbi__get16le(s);

  004af	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b7	e8 00 00 00 00	 call	 stbi__get16le
  004bc	89 44 24 34	 mov	 DWORD PTR x$2[rsp], eax

; 6850 :             y = stbi__get16le(s);

  004c0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c8	e8 00 00 00 00	 call	 stbi__get16le
  004cd	89 44 24 38	 mov	 DWORD PTR y$3[rsp], eax

; 6851 :             w = stbi__get16le(s);

  004d1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d9	e8 00 00 00 00	 call	 stbi__get16le
  004de	89 44 24 3c	 mov	 DWORD PTR w$4[rsp], eax

; 6852 :             h = stbi__get16le(s);

  004e2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ea	e8 00 00 00 00	 call	 stbi__get16le
  004ef	89 44 24 40	 mov	 DWORD PTR h$5[rsp], eax

; 6853 :             if (((x + w) > (g->w)) || ((y + h) > (g->h)))

  004f3	8b 44 24 3c	 mov	 eax, DWORD PTR w$4[rsp]
  004f7	8b 4c 24 34	 mov	 ecx, DWORD PTR x$2[rsp]
  004fb	03 c8		 add	 ecx, eax
  004fd	8b c1		 mov	 eax, ecx
  004ff	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00507	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00509	7f 19		 jg	 SHORT $LN33@stbi__gif_
  0050b	8b 44 24 40	 mov	 eax, DWORD PTR h$5[rsp]
  0050f	8b 4c 24 38	 mov	 ecx, DWORD PTR y$3[rsp]
  00513	03 c8		 add	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0051f	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00522	7e 37		 jle	 SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 6854 :                return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GIAALCNJ@bad?5Image?5Descriptor@
  0052b	e8 00 00 00 00	 call	 stbi__err
  00530	85 c0		 test	 eax, eax
  00532	74 0e		 je	 SHORT $LN59@stbi__gif_
  00534	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv264[rsp], 0
  00540	eb 0c		 jmp	 SHORT $LN60@stbi__gif_
$LN59@stbi__gif_:
  00542	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv264[rsp], 0
$LN60@stbi__gif_:
  0054e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv264[rsp]
  00556	e9 2f 0a 00 00	 jmp	 $LN1@stbi__gif_
$LN32@stbi__gif_:

; 6855 : 
; 6856 :             g->line_size = g->w * 4;

  0055b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00563	8b 00		 mov	 eax, DWORD PTR [rax]
  00565	c1 e0 02	 shl	 eax, 2
  00568	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00570	89 81 64 88 00
	00		 mov	 DWORD PTR [rcx+34916], eax

; 6857 :             g->start_x = x * 4;

  00576	8b 44 24 34	 mov	 eax, DWORD PTR x$2[rsp]
  0057a	c1 e0 02	 shl	 eax, 2
  0057d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00585	89 81 4c 88 00
	00		 mov	 DWORD PTR [rcx+34892], eax

; 6858 :             g->start_y = y * g->line_size;

  0058b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00593	8b 4c 24 38	 mov	 ecx, DWORD PTR y$3[rsp]
  00597	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  0059e	8b c1		 mov	 eax, ecx
  005a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005a8	89 81 50 88 00
	00		 mov	 DWORD PTR [rcx+34896], eax

; 6859 :             g->max_x   = g->start_x + w * 4;

  005ae	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005b6	8b 80 4c 88 00
	00		 mov	 eax, DWORD PTR [rax+34892]
  005bc	8b 4c 24 3c	 mov	 ecx, DWORD PTR w$4[rsp]
  005c0	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  005c3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005cb	89 81 54 88 00
	00		 mov	 DWORD PTR [rcx+34900], eax

; 6860 :             g->max_y   = g->start_y + h * g->line_size;

  005d1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005d9	8b 4c 24 40	 mov	 ecx, DWORD PTR h$5[rsp]
  005dd	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  005e4	8b c1		 mov	 eax, ecx
  005e6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005ee	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  005f4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005fc	89 81 58 88 00
	00		 mov	 DWORD PTR [rcx+34904], eax

; 6861 :             g->cur_x   = g->start_x;

  00602	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0060a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00612	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  00618	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6862 :             g->cur_y   = g->start_y;

  0061e	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00626	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0062e	8b 89 50 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34896]
  00634	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx

; 6863 : 
; 6864 :             // if the width of the specified rectangle is 0, that means
; 6865 :             // we may not see *any* pixels or the image is malformed;
; 6866 :             // to make sure this is caught, move the current y down to
; 6867 :             // max_y (which is what out_gif_code checks).
; 6868 :             if (w == 0)

  0063a	83 7c 24 3c 00	 cmp	 DWORD PTR w$4[rsp], 0
  0063f	75 1c		 jne	 SHORT $LN34@stbi__gif_

; 6869 :                g->cur_y = g->max_y;

  00641	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00649	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00651	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00657	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx
$LN34@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0065d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00665	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0066d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00674	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0067b	73 48		 jae	 SHORT $LN72@stbi__gif_

; 1615 :       return *s->img_buffer++;

  0067d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00685	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0068c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0068f	88 84 24 a0 00
	00 00		 mov	 BYTE PTR tv457[rsp], al
  00696	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0069e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006a5	48 ff c0	 inc	 rax
  006a8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006b0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006b7	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv457[rsp]
  006bf	88 44 24 59	 mov	 BYTE PTR $T10[rsp], al
  006c3	eb 68		 jmp	 SHORT $LN71@stbi__gif_
$LN72@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  006c5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006cd	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  006d1	74 55		 je	 SHORT $LN73@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  006d3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006db	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  006e0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006ef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006f2	88 84 24 a1 00
	00 00		 mov	 BYTE PTR tv466[rsp], al
  006f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00701	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00708	48 ff c0	 inc	 rax
  0070b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00713	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0071a	0f b6 84 24 a1
	00 00 00	 movzx	 eax, BYTE PTR tv466[rsp]
  00722	88 44 24 59	 mov	 BYTE PTR $T10[rsp], al
  00726	eb 05		 jmp	 SHORT $LN71@stbi__gif_
$LN73@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00728	c6 44 24 59 00	 mov	 BYTE PTR $T10[rsp], 0
$LN71@stbi__gif_:

; 6870 : 
; 6871 :             g->lflags = stbi__get8(s);

  0072d	0f b6 44 24 59	 movzx	 eax, BYTE PTR $T10[rsp]
  00732	0f b6 c0	 movzx	 eax, al
  00735	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0073d	89 81 48 88 00
	00		 mov	 DWORD PTR [rcx+34888], eax

; 6872 : 
; 6873 :             if (g->lflags & 0x40) {

  00743	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0074b	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00751	83 e0 40	 and	 eax, 64			; 00000040H
  00754	85 c0		 test	 eax, eax
  00756	74 33		 je	 SHORT $LN35@stbi__gif_

; 6874 :                g->step = 8 * g->line_size; // first interlaced spacing

  00758	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00760	8b 80 64 88 00
	00		 mov	 eax, DWORD PTR [rax+34916]
  00766	c1 e0 03	 shl	 eax, 3
  00769	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00771	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6875 :                g->parse = 3;

  00777	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0077f	c7 80 40 88 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+34880], 3

; 6876 :             } else {

  00789	eb 2e		 jmp	 SHORT $LN36@stbi__gif_
$LN35@stbi__gif_:

; 6877 :                g->step = g->line_size;

  0078b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00793	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0079b	8b 89 64 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34916]
  007a1	89 88 44 88 00
	00		 mov	 DWORD PTR [rax+34884], ecx

; 6878 :                g->parse = 0;

  007a7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007af	c7 80 40 88 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+34880], 0
$LN36@stbi__gif_:

; 6879 :             }
; 6880 : 
; 6881 :             if (g->lflags & 0x80) {

  007b9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007c1	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  007c7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007cc	85 c0		 test	 eax, eax
  007ce	0f 84 a3 00 00
	00		 je	 $LN37@stbi__gif_

; 6882 :                stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

  007d4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007dc	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  007df	83 e0 01	 and	 eax, 1
  007e2	85 c0		 test	 eax, eax
  007e4	74 14		 je	 SHORT $LN61@stbi__gif_
  007e6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007ee	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  007f1	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
  007f8	eb 0b		 jmp	 SHORT $LN62@stbi__gif_
$LN61@stbi__gif_:
  007fa	c7 84 24 a4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv310[rsp], -1
$LN62@stbi__gif_:
  00805	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0080d	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00813	83 e0 07	 and	 eax, 7
  00816	b9 02 00 00 00	 mov	 ecx, 2
  0081b	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv761[rsp], ecx
  00822	0f b6 c8	 movzx	 ecx, al
  00825	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv761[rsp]
  0082c	d3 e0		 shl	 eax, cl
  0082e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00836	48 81 c1 34 04
	00 00		 add	 rcx, 1076		; 00000434H
  0083d	44 8b 8c 24 a4
	00 00 00	 mov	 r9d, DWORD PTR tv310[rsp]
  00845	44 8b c0	 mov	 r8d, eax
  00848	48 8b d1	 mov	 rdx, rcx
  0084b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00853	e8 00 00 00 00	 call	 stbi__gif_parse_colortable

; 6883 :                g->color_table = (stbi_uc *) g->lpal;

  00858	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00860	48 05 34 04 00
	00		 add	 rax, 1076		; 00000434H
  00866	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0086e	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax
  00875	eb 68		 jmp	 SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 6884 :             } else if (g->flags & 0x80) {

  00877	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0087f	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00882	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00887	85 c0		 test	 eax, eax
  00889	74 1d		 je	 SHORT $LN39@stbi__gif_

; 6885 :                g->color_table = (stbi_uc *) g->pal;

  0088b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00893	48 83 c0 34	 add	 rax, 52			; 00000034H
  00897	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0089f	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax

; 6886 :             } else

  008a6	eb 37		 jmp	 SHORT $LN40@stbi__gif_
$LN39@stbi__gif_:

; 6887 :                return stbi__errpuc("missing color table", "Corrupt GIF");

  008a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@NAMJKDNF@missing?5color?5table@
  008af	e8 00 00 00 00	 call	 stbi__err
  008b4	85 c0		 test	 eax, eax
  008b6	74 0e		 je	 SHORT $LN63@stbi__gif_
  008b8	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv329[rsp], 0
  008c4	eb 0c		 jmp	 SHORT $LN64@stbi__gif_
$LN63@stbi__gif_:
  008c6	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv329[rsp], 0
$LN64@stbi__gif_:
  008d2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv329[rsp]
  008da	e9 ab 06 00 00	 jmp	 $LN1@stbi__gif_
$LN40@stbi__gif_:
$LN38@stbi__gif_:

; 6888 : 
; 6889 :             o = stbi__process_gif_raster(s, g);

  008df	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  008e7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008ef	e8 00 00 00 00	 call	 stbi__process_gif_raster
  008f4	48 89 44 24 48	 mov	 QWORD PTR o$6[rsp], rax

; 6890 :             if (!o) return NULL;

  008f9	48 83 7c 24 48
	00		 cmp	 QWORD PTR o$6[rsp], 0
  008ff	75 07		 jne	 SHORT $LN41@stbi__gif_
  00901	33 c0		 xor	 eax, eax
  00903	e9 82 06 00 00	 jmp	 $LN1@stbi__gif_
$LN41@stbi__gif_:

; 6891 : 
; 6892 :             // if this was the first frame,
; 6893 :             pcount = g->w * g->h;

  00908	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00910	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00918	8b 00		 mov	 eax, DWORD PTR [rax]
  0091a	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0091e	89 44 24 2c	 mov	 DWORD PTR pcount$[rsp], eax

; 6894 :             if (first_frame && (g->bgindex > 0)) {

  00922	83 7c 24 24 00	 cmp	 DWORD PTR first_frame$[rsp], 0
  00927	0f 84 a5 00 00
	00		 je	 $LN42@stbi__gif_
  0092d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00935	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00939	0f 8e 93 00 00
	00		 jle	 $LN42@stbi__gif_

; 6895 :                // if first frame, any pixel not drawn to gets the background color
; 6896 :                for (pi = 0; pi < pcount; ++pi) {

  0093f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  00947	eb 0a		 jmp	 SHORT $LN15@stbi__gif_
$LN13@stbi__gif_:
  00949	8b 44 24 28	 mov	 eax, DWORD PTR pi$[rsp]
  0094d	ff c0		 inc	 eax
  0094f	89 44 24 28	 mov	 DWORD PTR pi$[rsp], eax
$LN15@stbi__gif_:
  00953	8b 44 24 2c	 mov	 eax, DWORD PTR pcount$[rsp]
  00957	39 44 24 28	 cmp	 DWORD PTR pi$[rsp], eax
  0095b	7d 75		 jge	 SHORT $LN14@stbi__gif_

; 6897 :                   if (g->history[pi] == 0) {

  0095d	48 63 44 24 28	 movsxd	 rax, DWORD PTR pi$[rsp]
  00962	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0096a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0096e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00972	85 c0		 test	 eax, eax
  00974	75 57		 jne	 SHORT $LN43@stbi__gif_

; 6898 :                      g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;

  00976	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0097e	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00982	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0098a	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  0098f	b9 01 00 00 00	 mov	 ecx, 1
  00994	48 6b c9 03	 imul	 rcx, rcx, 3
  00998	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 6899 :                      memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );

  0099c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  009a4	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  009a8	8b 4c 24 28	 mov	 ecx, DWORD PTR pi$[rsp]
  009ac	c1 e1 02	 shl	 ecx, 2
  009af	48 63 c9	 movsxd	 rcx, ecx
  009b2	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  009ba	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  009be	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR g$[rsp]
  009c6	8b 44 87 34	 mov	 eax, DWORD PTR [rdi+rax*4+52]
  009ca	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN43@stbi__gif_:

; 6900 :                   }
; 6901 :                }

  009cd	e9 77 ff ff ff	 jmp	 $LN13@stbi__gif_
$LN14@stbi__gif_:
$LN42@stbi__gif_:

; 6902 :             }
; 6903 : 
; 6904 :             return o;

  009d2	48 8b 44 24 48	 mov	 rax, QWORD PTR o$6[rsp]
  009d7	e9 ae 05 00 00	 jmp	 $LN1@stbi__gif_
$LN44@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  009dc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009e4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009ec	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  009f3	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  009fa	73 48		 jae	 SHORT $LN76@stbi__gif_

; 1615 :       return *s->img_buffer++;

  009fc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a04	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a0b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a0e	88 84 24 b8 00
	00 00		 mov	 BYTE PTR tv474[rsp], al
  00a15	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a1d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a24	48 ff c0	 inc	 rax
  00a27	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a2f	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00a36	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR tv474[rsp]
  00a3e	88 44 24 5a	 mov	 BYTE PTR $T11[rsp], al
  00a42	eb 68		 jmp	 SHORT $LN75@stbi__gif_
$LN76@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00a44	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a4c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00a50	74 55		 je	 SHORT $LN77@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00a52	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a5a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00a5f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a67	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a6e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a71	88 84 24 b9 00
	00 00		 mov	 BYTE PTR tv483[rsp], al
  00a78	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a80	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a87	48 ff c0	 inc	 rax
  00a8a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a92	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00a99	0f b6 84 24 b9
	00 00 00	 movzx	 eax, BYTE PTR tv483[rsp]
  00aa1	88 44 24 5a	 mov	 BYTE PTR $T11[rsp], al
  00aa5	eb 05		 jmp	 SHORT $LN75@stbi__gif_
$LN77@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00aa7	c6 44 24 5a 00	 mov	 BYTE PTR $T11[rsp], 0
$LN75@stbi__gif_:

; 6905 :          }
; 6906 : 
; 6907 :          case 0x21: // Comment Extension.
; 6908 :          {
; 6909 :             int len;
; 6910 :             int ext = stbi__get8(s);

  00aac	0f b6 44 24 5a	 movzx	 eax, BYTE PTR $T11[rsp]
  00ab1	0f b6 c0	 movzx	 eax, al
  00ab4	89 44 24 54	 mov	 DWORD PTR ext$8[rsp], eax

; 6911 :             if (ext == 0xF9) { // Graphic Control Extension.

  00ab8	81 7c 24 54 f9
	00 00 00	 cmp	 DWORD PTR ext$8[rsp], 249 ; 000000f9H
  00ac0	0f 85 85 03 00
	00		 jne	 $LN45@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00ac6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ace	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ad6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00add	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00ae4	73 48		 jae	 SHORT $LN80@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00ae6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aee	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00af5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00af8	88 84 24 ba 00
	00 00		 mov	 BYTE PTR tv491[rsp], al
  00aff	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b07	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b0e	48 ff c0	 inc	 rax
  00b11	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b19	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b20	0f b6 84 24 ba
	00 00 00	 movzx	 eax, BYTE PTR tv491[rsp]
  00b28	88 44 24 5b	 mov	 BYTE PTR $T12[rsp], al
  00b2c	eb 68		 jmp	 SHORT $LN79@stbi__gif_
$LN80@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00b2e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b36	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00b3a	74 55		 je	 SHORT $LN81@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00b3c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b44	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00b49	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b51	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b58	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b5b	88 84 24 bb 00
	00 00		 mov	 BYTE PTR tv500[rsp], al
  00b62	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b6a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b71	48 ff c0	 inc	 rax
  00b74	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b7c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b83	0f b6 84 24 bb
	00 00 00	 movzx	 eax, BYTE PTR tv500[rsp]
  00b8b	88 44 24 5b	 mov	 BYTE PTR $T12[rsp], al
  00b8f	eb 05		 jmp	 SHORT $LN79@stbi__gif_
$LN81@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00b91	c6 44 24 5b 00	 mov	 BYTE PTR $T12[rsp], 0
$LN79@stbi__gif_:

; 6912 :                len = stbi__get8(s);

  00b96	0f b6 44 24 5b	 movzx	 eax, BYTE PTR $T12[rsp]
  00b9b	0f b6 c0	 movzx	 eax, al
  00b9e	89 44 24 50	 mov	 DWORD PTR len$7[rsp], eax

; 6913 :                if (len == 4) {

  00ba2	83 7c 24 50 04	 cmp	 DWORD PTR len$7[rsp], 4
  00ba7	0f 85 87 02 00
	00		 jne	 $LN46@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00bad	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bb5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bbd	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00bc4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00bcb	73 48		 jae	 SHORT $LN84@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00bcd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bd5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00bdc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00bdf	88 84 24 bc 00
	00 00		 mov	 BYTE PTR tv508[rsp], al
  00be6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bee	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00bf5	48 ff c0	 inc	 rax
  00bf8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c00	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00c07	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR tv508[rsp]
  00c0f	88 44 24 5c	 mov	 BYTE PTR $T13[rsp], al
  00c13	eb 68		 jmp	 SHORT $LN83@stbi__gif_
$LN84@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00c15	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c1d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00c21	74 55		 je	 SHORT $LN85@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00c23	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c2b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00c30	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c38	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c3f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c42	88 84 24 bd 00
	00 00		 mov	 BYTE PTR tv517[rsp], al
  00c49	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c51	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00c58	48 ff c0	 inc	 rax
  00c5b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c63	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00c6a	0f b6 84 24 bd
	00 00 00	 movzx	 eax, BYTE PTR tv517[rsp]
  00c72	88 44 24 5c	 mov	 BYTE PTR $T13[rsp], al
  00c76	eb 05		 jmp	 SHORT $LN83@stbi__gif_
$LN85@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00c78	c6 44 24 5c 00	 mov	 BYTE PTR $T13[rsp], 0
$LN83@stbi__gif_:

; 6914 :                   g->eflags = stbi__get8(s);

  00c7d	0f b6 44 24 5c	 movzx	 eax, BYTE PTR $T13[rsp]
  00c82	0f b6 c0	 movzx	 eax, al
  00c85	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00c8d	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 6915 :                   g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

  00c90	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c98	e8 00 00 00 00	 call	 stbi__get16le
  00c9d	6b c0 0a	 imul	 eax, eax, 10
  00ca0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00ca8	89 81 68 88 00
	00		 mov	 DWORD PTR [rcx+34920], eax

; 6916 : 
; 6917 :                   // unset old transparent
; 6918 :                   if (g->transparent >= 0) {

  00cae	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00cb6	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00cba	7c 26		 jl	 SHORT $LN48@stbi__gif_

; 6919 :                      g->pal[g->transparent][3] = 255;

  00cbc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00cc4	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00cc8	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00cd0	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  00cd5	b9 01 00 00 00	 mov	 ecx, 1
  00cda	48 6b c9 03	 imul	 rcx, rcx, 3
  00cde	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH
$LN48@stbi__gif_:

; 6920 :                   }
; 6921 :                   if (g->eflags & 0x01) {

  00ce2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00cea	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00ced	83 e0 01	 and	 eax, 1
  00cf0	85 c0		 test	 eax, eax
  00cf2	0f 84 19 01 00
	00		 je	 $LN49@stbi__gif_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00cf8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d00	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d08	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00d0f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00d16	73 48		 jae	 SHORT $LN88@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00d18	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d20	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d27	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d2a	88 84 24 be 00
	00 00		 mov	 BYTE PTR tv525[rsp], al
  00d31	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d39	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d40	48 ff c0	 inc	 rax
  00d43	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d4b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00d52	0f b6 84 24 be
	00 00 00	 movzx	 eax, BYTE PTR tv525[rsp]
  00d5a	88 44 24 5d	 mov	 BYTE PTR $T14[rsp], al
  00d5e	eb 68		 jmp	 SHORT $LN87@stbi__gif_
$LN88@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00d60	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d68	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00d6c	74 55		 je	 SHORT $LN89@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00d6e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d76	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00d7b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d83	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d8a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d8d	88 84 24 bf 00
	00 00		 mov	 BYTE PTR tv534[rsp], al
  00d94	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d9c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00da3	48 ff c0	 inc	 rax
  00da6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00dae	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00db5	0f b6 84 24 bf
	00 00 00	 movzx	 eax, BYTE PTR tv534[rsp]
  00dbd	88 44 24 5d	 mov	 BYTE PTR $T14[rsp], al
  00dc1	eb 05		 jmp	 SHORT $LN87@stbi__gif_
$LN89@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00dc3	c6 44 24 5d 00	 mov	 BYTE PTR $T14[rsp], 0
$LN87@stbi__gif_:

; 6922 :                      g->transparent = stbi__get8(s);

  00dc8	0f b6 44 24 5d	 movzx	 eax, BYTE PTR $T14[rsp]
  00dcd	0f b6 c0	 movzx	 eax, al
  00dd0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00dd8	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 6923 :                      if (g->transparent >= 0) {

  00ddb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00de3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00de7	7c 26		 jl	 SHORT $LN51@stbi__gif_

; 6924 :                         g->pal[g->transparent][3] = 0;

  00de9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00df1	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00df5	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00dfd	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  00e02	b9 01 00 00 00	 mov	 ecx, 1
  00e07	48 6b c9 03	 imul	 rcx, rcx, 3
  00e0b	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN51@stbi__gif_:

; 6925 :                      }
; 6926 :                   } else {

  00e0f	eb 21		 jmp	 SHORT $LN50@stbi__gif_
$LN49@stbi__gif_:

; 6927 :                      // don't need transparent
; 6928 :                      stbi__skip(s, 1);

  00e11	ba 01 00 00 00	 mov	 edx, 1
  00e16	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e1e	e8 00 00 00 00	 call	 stbi__skip

; 6929 :                      g->transparent = -1;

  00e23	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00e2b	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1
$LN50@stbi__gif_:

; 6930 :                   }
; 6931 :                } else {

  00e32	eb 17		 jmp	 SHORT $LN47@stbi__gif_
$LN46@stbi__gif_:

; 6932 :                   stbi__skip(s, len);

  00e34	8b 54 24 50	 mov	 edx, DWORD PTR len$7[rsp]
  00e38	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e40	e8 00 00 00 00	 call	 stbi__skip
  00e45	90		 npad	 1

; 6933 :                   break;

  00e46	e9 3a 01 00 00	 jmp	 $LN11@stbi__gif_
$LN47@stbi__gif_:
$LN45@stbi__gif_:
$LN16@stbi__gif_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00e4b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e53	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e5b	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00e62	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00e69	73 48		 jae	 SHORT $LN92@stbi__gif_

; 1615 :       return *s->img_buffer++;

  00e6b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e73	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e7a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e7d	88 84 24 c0 00
	00 00		 mov	 BYTE PTR tv542[rsp], al
  00e84	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e8c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e93	48 ff c0	 inc	 rax
  00e96	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e9e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00ea5	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR tv542[rsp]
  00ead	88 44 24 5e	 mov	 BYTE PTR $T15[rsp], al
  00eb1	eb 68		 jmp	 SHORT $LN91@stbi__gif_
$LN92@stbi__gif_:

; 1616 :    if (s->read_from_callbacks) {

  00eb3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ebb	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00ebf	74 55		 je	 SHORT $LN93@stbi__gif_

; 1617 :       stbi__refill_buffer(s);

  00ec1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ec9	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00ece	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ed6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00edd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ee0	88 84 24 c1 00
	00 00		 mov	 BYTE PTR tv551[rsp], al
  00ee7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00eef	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ef6	48 ff c0	 inc	 rax
  00ef9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f01	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00f08	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR tv551[rsp]
  00f10	88 44 24 5e	 mov	 BYTE PTR $T15[rsp], al
  00f14	eb 05		 jmp	 SHORT $LN91@stbi__gif_
$LN93@stbi__gif_:

; 1619 :    }
; 1620 :    return 0;

  00f16	c6 44 24 5e 00	 mov	 BYTE PTR $T15[rsp], 0
$LN91@stbi__gif_:

; 6934 :                }
; 6935 :             }
; 6936 :             while ((len = stbi__get8(s)) != 0) {

  00f1b	0f b6 44 24 5e	 movzx	 eax, BYTE PTR $T15[rsp]
  00f20	0f b6 c0	 movzx	 eax, al
  00f23	89 44 24 50	 mov	 DWORD PTR len$7[rsp], eax
  00f27	83 7c 24 50 00	 cmp	 DWORD PTR len$7[rsp], 0
  00f2c	74 17		 je	 SHORT $LN17@stbi__gif_

; 6937 :                stbi__skip(s, len);

  00f2e	8b 54 24 50	 mov	 edx, DWORD PTR len$7[rsp]
  00f32	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f3a	e8 00 00 00 00	 call	 stbi__skip
  00f3f	90		 npad	 1

; 6938 :             }

  00f40	e9 06 ff ff ff	 jmp	 $LN16@stbi__gif_
$LN17@stbi__gif_:

; 6939 :             break;

  00f45	eb 3e		 jmp	 SHORT $LN11@stbi__gif_
$LN52@stbi__gif_:

; 6940 :          }
; 6941 : 
; 6942 :          case 0x3B: // gif stream termination code
; 6943 :             return (stbi_uc *) s; // using '1' causes warning on some compilers

  00f47	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f4f	eb 39		 jmp	 SHORT $LN1@stbi__gif_
$LN53@stbi__gif_:

; 6944 : 
; 6945 :          default:
; 6946 :             return stbi__errpuc("unknown code", "Corrupt GIF");

  00f51	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DJABBOOH@unknown?5code@
  00f58	e8 00 00 00 00	 call	 stbi__err
  00f5d	85 c0		 test	 eax, eax
  00f5f	74 0e		 je	 SHORT $LN65@stbi__gif_
  00f61	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv427[rsp], 0
  00f6d	eb 0c		 jmp	 SHORT $LN66@stbi__gif_
$LN65@stbi__gif_:
  00f6f	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv427[rsp], 0
$LN66@stbi__gif_:
  00f7b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv427[rsp]
  00f83	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN11@stbi__gif_:

; 6947 :       }
; 6948 :    }

  00f85	e9 13 f4 ff ff	 jmp	 $LN8@stbi__gif_
$LN1@stbi__gif_:

; 6949 : }

  00f8a	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00f91	5f		 pop	 rdi
  00f92	5e		 pop	 rsi
  00f93	c3		 ret	 0
stbi__gif_load_next ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv78 = 32
g$ = 64
out$ = 72
delays$ = 80
stbi__load_gif_main_outofmem PROC

; 6952 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6953 :    STBI_FREE(g->out);

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00025	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6954 :    STBI_FREE(g->history);

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00034	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6955 :    STBI_FREE(g->background);

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00043	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6956 : 
; 6957 :    if (out) STBI_FREE(out);

  0004d	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00053	74 0c		 je	 SHORT $LN2@stbi__load
  00055	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00060	90		 npad	 1
$LN2@stbi__load:

; 6958 :    if (delays && *delays) STBI_FREE(*delays);

  00061	48 83 7c 24 50
	00		 cmp	 QWORD PTR delays$[rsp], 0
  00067	74 1a		 je	 SHORT $LN3@stbi__load
  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  0006e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00072	74 0f		 je	 SHORT $LN3@stbi__load
  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  00079	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00082	90		 npad	 1
$LN3@stbi__load:

; 6959 :    return stbi__errpuc("outofmem", "Out of memory");

  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0008a	e8 00 00 00 00	 call	 stbi__err
  0008f	85 c0		 test	 eax, eax
  00091	74 0b		 je	 SHORT $LN5@stbi__load
  00093	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv78[rsp], 0
  0009c	eb 09		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:
  0009e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv78[rsp], 0
$LN6@stbi__load:
  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR tv78[rsp]

; 6960 : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
stbi__load_gif_main_outofmem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
layers$4 = 48
u$5 = 56
out$6 = 64
two_back$7 = 72
g$8 = 96
stride$9 = 35028
out_size$10 = 35032
delays_size$11 = 35036
tmp$12 = 35040
new_delays$13 = 35048
tv138 = 35064
tv214 = 35072
__$ArrayPad$ = 35080
s$ = 35120
delays$ = 35128
x$ = 35136
y$ = 35144
z$ = 35152
comp$ = 35160
req_comp$ = 35168
stbi__load_gif_main PROC

; 6963 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 18 89 00 00	 mov	 eax, 35096		; 00008918H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00028	b9 3a 22 00 00	 mov	 ecx, 8762		; 0000223aH
  0002d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00032	f3 ab		 rep stosd
  00034	48 8b 8c 24 30
	89 00 00	 mov	 rcx, QWORD PTR [rsp+35120]
  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00043	48 33 c4	 xor	 rax, rsp
  00046	48 89 84 24 08
	89 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00055	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 6964 :    if (stbi__gif_test(s)) {

  0005a	48 8b 8c 24 30
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00062	e8 00 00 00 00	 call	 stbi__gif_test
  00067	85 c0		 test	 eax, eax
  00069	0f 84 ce 03 00
	00		 je	 $LN5@stbi__load

; 6965 :       int layers = 0;

  0006f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR layers$4[rsp], 0

; 6966 :       stbi_uc *u = 0;

  00077	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR u$5[rsp], 0

; 6967 :       stbi_uc *out = 0;

  00080	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR out$6[rsp], 0

; 6968 :       stbi_uc *two_back = 0;

  00089	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR two_back$7[rsp], 0

; 6969 :       stbi__gif g;
; 6970 :       int stride;
; 6971 :       int out_size = 0;

  00092	c7 84 24 d8 88
	00 00 00 00 00
	00		 mov	 DWORD PTR out_size$10[rsp], 0

; 6972 :       int delays_size = 0;

  0009d	c7 84 24 dc 88
	00 00 00 00 00
	00		 mov	 DWORD PTR delays_size$11[rsp], 0

; 6973 : 
; 6974 :       STBI_NOTUSED(out_size);
; 6975 :       STBI_NOTUSED(delays_size);
; 6976 : 
; 6977 :       memset(&g, 0, sizeof(g));

  000a8	48 8d 44 24 60	 lea	 rax, QWORD PTR g$8[rsp]
  000ad	48 8b f8	 mov	 rdi, rax
  000b0	33 c0		 xor	 eax, eax
  000b2	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  000b7	f3 aa		 rep stosb

; 6978 :       if (delays) {

  000b9	48 83 bc 24 38
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  000c2	74 0f		 je	 SHORT $LN7@stbi__load

; 6979 :          *delays = 0;

  000c4	48 8b 84 24 38
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  000cc	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN7@stbi__load:
$LN4@stbi__load:

; 6980 :       }
; 6981 : 
; 6982 :       do {
; 6983 :          u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);

  000d3	48 8b 44 24 48	 mov	 rax, QWORD PTR two_back$7[rsp]
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	44 8b 8c 24 60
	89 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  000e5	4c 8b 84 24 58
	89 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  000ed	48 8d 54 24 60	 lea	 rdx, QWORD PTR g$8[rsp]
  000f2	48 8b 8c 24 30
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000fa	e8 00 00 00 00	 call	 stbi__gif_load_next
  000ff	48 89 44 24 38	 mov	 QWORD PTR u$5[rsp], rax

; 6984 :          if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  00104	48 8b 84 24 30
	89 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0010c	48 39 44 24 38	 cmp	 QWORD PTR u$5[rsp], rax
  00111	75 09		 jne	 SHORT $LN8@stbi__load
  00113	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR u$5[rsp], 0
$LN8@stbi__load:

; 6985 : 
; 6986 :          if (u) {

  0011c	48 83 7c 24 38
	00		 cmp	 QWORD PTR u$5[rsp], 0
  00122	0f 84 8d 02 00
	00		 je	 $LN9@stbi__load

; 6987 :             *x = g.w;

  00128	48 8b 84 24 40
	89 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00130	8b 4c 24 60	 mov	 ecx, DWORD PTR g$8[rsp]
  00134	89 08		 mov	 DWORD PTR [rax], ecx

; 6988 :             *y = g.h;

  00136	48 8b 84 24 48
	89 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0013e	8b 4c 24 64	 mov	 ecx, DWORD PTR g$8[rsp+4]
  00142	89 08		 mov	 DWORD PTR [rax], ecx

; 6989 :             ++layers;

  00144	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  00148	ff c0		 inc	 eax
  0014a	89 44 24 30	 mov	 DWORD PTR layers$4[rsp], eax

; 6990 :             stride = g.w * g.h * 4;

  0014e	8b 44 24 60	 mov	 eax, DWORD PTR g$8[rsp]
  00152	0f af 44 24 64	 imul	 eax, DWORD PTR g$8[rsp+4]
  00157	c1 e0 02	 shl	 eax, 2
  0015a	89 84 24 d4 88
	00 00		 mov	 DWORD PTR stride$9[rsp], eax

; 6991 : 
; 6992 :             if (out) {

  00161	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$6[rsp], 0
  00167	0f 84 1a 01 00
	00		 je	 $LN10@stbi__load

; 6993 :                void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );

  0016d	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  00171	0f af 84 24 d4
	88 00 00	 imul	 eax, DWORD PTR stride$9[rsp]
  00179	48 98		 cdqe
  0017b	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00182	48 0f 40 c1	 cmovo	 rax, rcx
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$6[rsp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00194	48 89 84 24 e0
	88 00 00	 mov	 QWORD PTR tmp$12[rsp], rax

; 6994 :                if (!tmp)

  0019c	48 83 bc 24 e0
	88 00 00 00	 cmp	 QWORD PTR tmp$12[rsp], 0
  001a5	75 1e		 jne	 SHORT $LN12@stbi__load

; 6995 :                   return stbi__load_gif_main_outofmem(&g, out, delays);

  001a7	4c 8b 84 24 38
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  001af	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$6[rsp]
  001b4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR g$8[rsp]
  001b9	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  001be	e9 ac 02 00 00	 jmp	 $LN1@stbi__load
  001c3	eb 20		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:

; 6996 :                else {
; 6997 :                    out = (stbi_uc*) tmp;

  001c5	48 8b 84 24 e0
	88 00 00	 mov	 rax, QWORD PTR tmp$12[rsp]
  001cd	48 89 44 24 40	 mov	 QWORD PTR out$6[rsp], rax

; 6998 :                    out_size = layers * stride;

  001d2	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  001d6	0f af 84 24 d4
	88 00 00	 imul	 eax, DWORD PTR stride$9[rsp]
  001de	89 84 24 d8 88
	00 00		 mov	 DWORD PTR out_size$10[rsp], eax
$LN13@stbi__load:

; 6999 :                }
; 7000 : 
; 7001 :                if (delays) {

  001e5	48 83 bc 24 38
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  001ee	0f 84 8e 00 00
	00		 je	 $LN14@stbi__load

; 7002 :                   int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );

  001f4	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$4[rsp]
  001f9	48 89 84 24 f8
	88 00 00	 mov	 QWORD PTR tv138[rsp], rax
  00201	b8 04 00 00 00	 mov	 eax, 4
  00206	48 8b 8c 24 f8
	88 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  0020e	48 f7 e1	 mul	 rcx
  00211	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00218	48 0f 42 c1	 cmovb	 rax, rcx
  0021c	48 8b d0	 mov	 rdx, rax
  0021f	48 8b 84 24 38
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  00227	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00230	48 89 84 24 e8
	88 00 00	 mov	 QWORD PTR new_delays$13[rsp], rax

; 7003 :                   if (!new_delays)

  00238	48 83 bc 24 e8
	88 00 00 00	 cmp	 QWORD PTR new_delays$13[rsp], 0
  00241	75 1c		 jne	 SHORT $LN15@stbi__load

; 7004 :                      return stbi__load_gif_main_outofmem(&g, out, delays);

  00243	4c 8b 84 24 38
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  0024b	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$6[rsp]
  00250	48 8d 4c 24 60	 lea	 rcx, QWORD PTR g$8[rsp]
  00255	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  0025a	e9 10 02 00 00	 jmp	 $LN1@stbi__load
$LN15@stbi__load:

; 7005 :                   *delays = new_delays;

  0025f	48 8b 84 24 38
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  00267	48 8b 8c 24 e8
	88 00 00	 mov	 rcx, QWORD PTR new_delays$13[rsp]
  0026f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 7006 :                   delays_size = layers * sizeof(int);

  00272	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$4[rsp]
  00277	48 c1 e0 02	 shl	 rax, 2
  0027b	89 84 24 dc 88
	00 00		 mov	 DWORD PTR delays_size$11[rsp], eax
$LN14@stbi__load:

; 7007 :                }
; 7008 :             } else {

  00282	e9 b3 00 00 00	 jmp	 $LN11@stbi__load
$LN10@stbi__load:

; 7009 :                out = (stbi_uc*)stbi__malloc( layers * stride );

  00287	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  0028b	0f af 84 24 d4
	88 00 00	 imul	 eax, DWORD PTR stride$9[rsp]
  00293	48 98		 cdqe
  00295	48 8b c8	 mov	 rcx, rax
  00298	e8 00 00 00 00	 call	 stbi__malloc
  0029d	48 89 44 24 40	 mov	 QWORD PTR out$6[rsp], rax

; 7010 :                if (!out)

  002a2	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$6[rsp], 0
  002a8	75 1c		 jne	 SHORT $LN16@stbi__load

; 7011 :                   return stbi__load_gif_main_outofmem(&g, out, delays);

  002aa	4c 8b 84 24 38
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  002b2	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$6[rsp]
  002b7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR g$8[rsp]
  002bc	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  002c1	e9 a9 01 00 00	 jmp	 $LN1@stbi__load
$LN16@stbi__load:

; 7012 :                out_size = layers * stride;

  002c6	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  002ca	0f af 84 24 d4
	88 00 00	 imul	 eax, DWORD PTR stride$9[rsp]
  002d2	89 84 24 d8 88
	00 00		 mov	 DWORD PTR out_size$10[rsp], eax

; 7013 :                if (delays) {

  002d9	48 83 bc 24 38
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  002e2	74 56		 je	 SHORT $LN17@stbi__load

; 7014 :                   *delays = (int*) stbi__malloc( layers * sizeof(int) );

  002e4	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$4[rsp]
  002e9	48 c1 e0 02	 shl	 rax, 2
  002ed	48 8b c8	 mov	 rcx, rax
  002f0	e8 00 00 00 00	 call	 stbi__malloc
  002f5	48 8b 8c 24 38
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  002fd	48 89 01	 mov	 QWORD PTR [rcx], rax

; 7015 :                   if (!*delays)

  00300	48 8b 84 24 38
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  00308	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0030c	75 1c		 jne	 SHORT $LN18@stbi__load

; 7016 :                      return stbi__load_gif_main_outofmem(&g, out, delays);

  0030e	4c 8b 84 24 38
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  00316	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$6[rsp]
  0031b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR g$8[rsp]
  00320	e8 00 00 00 00	 call	 stbi__load_gif_main_outofmem
  00325	e9 45 01 00 00	 jmp	 $LN1@stbi__load
$LN18@stbi__load:

; 7017 :                   delays_size = layers * sizeof(int);

  0032a	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$4[rsp]
  0032f	48 c1 e0 02	 shl	 rax, 2
  00333	89 84 24 dc 88
	00 00		 mov	 DWORD PTR delays_size$11[rsp], eax
$LN17@stbi__load:
$LN11@stbi__load:

; 7018 :                }
; 7019 :             }
; 7020 :             memcpy( out + ((layers - 1) * stride), u, stride );

  0033a	48 63 84 24 d4
	88 00 00	 movsxd	 rax, DWORD PTR stride$9[rsp]
  00342	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$4[rsp]
  00346	ff c9		 dec	 ecx
  00348	0f af 8c 24 d4
	88 00 00	 imul	 ecx, DWORD PTR stride$9[rsp]
  00350	48 63 c9	 movsxd	 rcx, ecx
  00353	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$6[rsp]
  00358	48 03 d1	 add	 rdx, rcx
  0035b	48 8b ca	 mov	 rcx, rdx
  0035e	48 8b f9	 mov	 rdi, rcx
  00361	48 8b 74 24 38	 mov	 rsi, QWORD PTR u$5[rsp]
  00366	48 8b c8	 mov	 rcx, rax
  00369	f3 a4		 rep movsb

; 7021 :             if (layers >= 2) {

  0036b	83 7c 24 30 02	 cmp	 DWORD PTR layers$4[rsp], 2
  00370	7c 1b		 jl	 SHORT $LN19@stbi__load

; 7022 :                two_back = out - 2 * stride;

  00372	8b 84 24 d4 88
	00 00		 mov	 eax, DWORD PTR stride$9[rsp]
  00379	d1 e0		 shl	 eax, 1
  0037b	48 98		 cdqe
  0037d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$6[rsp]
  00382	48 2b c8	 sub	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 89 44 24 48	 mov	 QWORD PTR two_back$7[rsp], rax
$LN19@stbi__load:

; 7023 :             }
; 7024 : 
; 7025 :             if (delays) {

  0038d	48 83 bc 24 38
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  00396	74 1d		 je	 SHORT $LN20@stbi__load

; 7026 :                (*delays)[layers - 1U] = g.delay;

  00398	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  0039c	ff c8		 dec	 eax
  0039e	8b c0		 mov	 eax, eax
  003a0	48 8b 8c 24 38
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  003a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003ab	8b 94 24 c8 88
	00 00		 mov	 edx, DWORD PTR g$8[rsp+34920]
  003b2	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN20@stbi__load:
$LN9@stbi__load:

; 7027 :             }
; 7028 :          }
; 7029 :       } while (u != 0);

  003b5	48 83 7c 24 38
	00		 cmp	 QWORD PTR u$5[rsp], 0
  003bb	0f 85 12 fd ff
	ff		 jne	 $LN4@stbi__load

; 7030 : 
; 7031 :       // free temp buffer;
; 7032 :       STBI_FREE(g.out);

  003c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR g$8[rsp+8]
  003c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7033 :       STBI_FREE(g.history);

  003cc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR g$8[rsp+24]
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7034 :       STBI_FREE(g.background);

  003d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR g$8[rsp+16]
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7035 : 
; 7036 :       // do the final conversion after loading everything;
; 7037 :       if (req_comp && req_comp != 4)

  003e2	83 bc 24 60 89
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  003ea	74 3a		 je	 SHORT $LN21@stbi__load
  003ec	83 bc 24 60 89
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  003f4	74 30		 je	 SHORT $LN21@stbi__load

; 7038 :          out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

  003f6	8b 44 24 30	 mov	 eax, DWORD PTR layers$4[rsp]
  003fa	0f af 44 24 60	 imul	 eax, DWORD PTR g$8[rsp]
  003ff	8b 4c 24 64	 mov	 ecx, DWORD PTR g$8[rsp+4]
  00403	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00407	44 8b c8	 mov	 r9d, eax
  0040a	44 8b 84 24 60
	89 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00412	ba 04 00 00 00	 mov	 edx, 4
  00417	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$6[rsp]
  0041c	e8 00 00 00 00	 call	 stbi__convert_format
  00421	48 89 44 24 40	 mov	 QWORD PTR out$6[rsp], rax
$LN21@stbi__load:

; 7039 : 
; 7040 :       *z = layers;

  00426	48 8b 84 24 50
	89 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0042e	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$4[rsp]
  00432	89 08		 mov	 DWORD PTR [rax], ecx

; 7041 :       return out;

  00434	48 8b 44 24 40	 mov	 rax, QWORD PTR out$6[rsp]
  00439	eb 34		 jmp	 SHORT $LN1@stbi__load

; 7042 :    } else {

  0043b	eb 32		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:

; 7043 :       return stbi__errpuc("not GIF", "Image was not as a gif type.");

  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KMJLPAII@not?5GIF@
  00444	e8 00 00 00 00	 call	 stbi__err
  00449	85 c0		 test	 eax, eax
  0044b	74 0e		 je	 SHORT $LN23@stbi__load
  0044d	48 c7 84 24 00
	89 00 00 00 00
	00 00		 mov	 QWORD PTR tv214[rsp], 0
  00459	eb 0c		 jmp	 SHORT $LN24@stbi__load
$LN23@stbi__load:
  0045b	48 c7 84 24 00
	89 00 00 00 00
	00 00		 mov	 QWORD PTR tv214[rsp], 0
$LN24@stbi__load:
  00467	48 8b 84 24 00
	89 00 00	 mov	 rax, QWORD PTR tv214[rsp]
$LN6@stbi__load:
$LN1@stbi__load:

; 7044 :    }
; 7045 : }

  0046f	48 8b f8	 mov	 rdi, rax
  00472	48 8b cc	 mov	 rcx, rsp
  00475	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__load_gif_main$rtcFrameData
  0047c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00481	48 8b c7	 mov	 rax, rdi
  00484	48 8b 8c 24 08
	89 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048c	48 33 cc	 xor	 rcx, rsp
  0048f	e8 00 00 00 00	 call	 __security_check_cookie
  00494	48 81 c4 18 89
	00 00		 add	 rsp, 35096		; 00008918H
  0049b	5f		 pop	 rdi
  0049c	5e		 pop	 rsi
  0049d	c3		 ret	 0
stbi__load_gif_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
u$ = 48
g$ = 80
__$ArrayPad$ = 35024
s$ = 35056
x$ = 35064
y$ = 35072
comp$ = 35080
req_comp$ = 35088
ri$ = 35096
stbi__gif_load PROC

; 7048 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 e0 88 00 00	 mov	 eax, 35040		; 000088e0H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00027	b9 2c 22 00 00	 mov	 ecx, 8748		; 0000222cH
  0002c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00031	f3 ab		 rep stosd
  00033	48 8b 8c 24 f0
	88 00 00	 mov	 rcx, QWORD PTR [rsp+35056]
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c4	 xor	 rax, rsp
  00045	48 89 84 24 d0
	88 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00054	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7049 :    stbi_uc *u = 0;

  00059	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0

; 7050 :    stbi__gif g;
; 7051 :    memset(&g, 0, sizeof(g));

  00062	48 8d 44 24 50	 lea	 rax, QWORD PTR g$[rsp]
  00067	48 8b f8	 mov	 rdi, rax
  0006a	33 c0		 xor	 eax, eax
  0006c	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  00071	f3 aa		 rep stosb

; 7052 :    STBI_NOTUSED(ri);
; 7053 : 
; 7054 :    u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

  00073	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0007c	44 8b 8c 24 10
	89 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  00084	4c 8b 84 24 08
	89 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  0008c	48 8d 54 24 50	 lea	 rdx, QWORD PTR g$[rsp]
  00091	48 8b 8c 24 f0
	88 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00099	e8 00 00 00 00	 call	 stbi__gif_load_next
  0009e	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 7055 :    if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  000a3	48 8b 84 24 f0
	88 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000ab	48 39 44 24 30	 cmp	 QWORD PTR u$[rsp], rax
  000b0	75 09		 jne	 SHORT $LN2@stbi__gif_
  000b2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0
$LN2@stbi__gif_:

; 7056 :    if (u) {

  000bb	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  000c1	74 5b		 je	 SHORT $LN3@stbi__gif_

; 7057 :       *x = g.w;

  000c3	48 8b 84 24 f8
	88 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000cb	8b 4c 24 50	 mov	 ecx, DWORD PTR g$[rsp]
  000cf	89 08		 mov	 DWORD PTR [rax], ecx

; 7058 :       *y = g.h;

  000d1	48 8b 84 24 00
	89 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000d9	8b 4c 24 54	 mov	 ecx, DWORD PTR g$[rsp+4]
  000dd	89 08		 mov	 DWORD PTR [rax], ecx

; 7059 : 
; 7060 :       // moved conversion to after successful load so that the same
; 7061 :       // can be done for multiple frames.
; 7062 :       if (req_comp && req_comp != 4)

  000df	83 bc 24 10 89
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000e7	74 33		 je	 SHORT $LN5@stbi__gif_
  000e9	83 bc 24 10 89
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  000f1	74 29		 je	 SHORT $LN5@stbi__gif_

; 7063 :          u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

  000f3	8b 44 24 54	 mov	 eax, DWORD PTR g$[rsp+4]
  000f7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fb	44 8b 4c 24 50	 mov	 r9d, DWORD PTR g$[rsp]
  00100	44 8b 84 24 10
	89 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00108	ba 04 00 00 00	 mov	 edx, 4
  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  00112	e8 00 00 00 00	 call	 stbi__convert_format
  00117	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax
$LN5@stbi__gif_:

; 7064 :    } else if (g.out) {

  0011c	eb 14		 jmp	 SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:
  0011e	48 83 7c 24 58
	00		 cmp	 QWORD PTR g$[rsp+8], 0
  00124	74 0c		 je	 SHORT $LN6@stbi__gif_

; 7065 :       // if there was an error and we allocated an image buffer, free it!
; 7066 :       STBI_FREE(g.out);

  00126	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp+8]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00131	90		 npad	 1
$LN6@stbi__gif_:
$LN4@stbi__gif_:

; 7067 :    }
; 7068 : 
; 7069 :    // free buffers needed for multiple frame loading;
; 7070 :    STBI_FREE(g.history);

  00132	48 8b 4c 24 68	 mov	 rcx, QWORD PTR g$[rsp+24]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7071 :    STBI_FREE(g.background);

  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR g$[rsp+16]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7072 : 
; 7073 :    return u;

  00148	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]

; 7074 : }

  0014d	48 8b f8	 mov	 rdi, rax
  00150	48 8b cc	 mov	 rcx, rsp
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__gif_load$rtcFrameData
  0015a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0015f	48 8b c7	 mov	 rax, rdi
  00162	48 8b 8c 24 d0
	88 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016a	48 33 cc	 xor	 rcx, rsp
  0016d	e8 00 00 00 00	 call	 __security_check_cookie
  00172	48 81 c4 e0 88
	00 00		 add	 rsp, 35040		; 000088e0H
  00179	5f		 pop	 rdi
  0017a	c3		 ret	 0
stbi__gif_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
stbi__gif_info PROC

; 7077 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7078 :    return stbi__gif_info_raw(s,x,y,comp);

  00025	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0002a	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0002f	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 stbi__gif_info_raw

; 7079 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
stbi__gif_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
i$ = 32
$T1 = 36
tv88 = 37
tv129 = 38
s$ = 64
signature$ = 72
stbi__hdr_test_core PROC

; 7087 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	90		 npad	 1

; 7088 :    int i;
; 7089 :    for (i=0; signature[i]; ++i)

  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00024	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  00026	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  00030	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR signature$[rsp]
  0003a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 c9 00 00
	00		 je	 $LN3@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00050	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00057	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0005e	73 39		 jae	 SHORT $LN8@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00065	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006f	88 44 24 25	 mov	 BYTE PTR tv88[rsp], al
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00078	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0007f	48 ff c0	 inc	 rax
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00087	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0008e	0f b6 44 24 25	 movzx	 eax, BYTE PTR tv88[rsp]
  00093	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  00097	eb 53		 jmp	 SHORT $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0009e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  000a2	74 43		 je	 SHORT $LN9@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a9	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ba	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000bd	88 44 24 26	 mov	 BYTE PTR tv129[rsp], al
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000c6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000cd	48 ff c0	 inc	 rax
  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000dc	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv129[rsp]
  000e1	88 44 24 24	 mov	 BYTE PTR $T1[rsp], al
  000e5	eb 05		 jmp	 SHORT $LN7@stbi__hdr_
$LN9@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  000e7	c6 44 24 24 00	 mov	 BYTE PTR $T1[rsp], 0
$LN7@stbi__hdr_:

; 7090 :       if (stbi__get8(s) != signature[i])

  000ec	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T1[rsp]
  000f1	0f b6 c0	 movzx	 eax, al
  000f4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f9	48 8b 54 24 48	 mov	 rdx, QWORD PTR signature$[rsp]
  000fe	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00102	3b c1		 cmp	 eax, ecx
  00104	74 04		 je	 SHORT $LN5@stbi__hdr_

; 7091 :           return 0;

  00106	33 c0		 xor	 eax, eax
  00108	eb 14		 jmp	 SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
  0010a	e9 17 ff ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7092 :    stbi__rewind(s);

  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 stbi__rewind

; 7093 :    return 1;

  00119	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7094 : }

  0011e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
stbi__hdr_test_core ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
stbi__hdr_test PROC

; 7097 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7098 :    int r = stbi__hdr_test_core(s, "#?RADIANCE\n");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00022	e8 00 00 00 00	 call	 stbi__hdr_test_core
  00027	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7099 :    stbi__rewind(s);

  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00030	e8 00 00 00 00	 call	 stbi__rewind

; 7100 :    if(!r) {

  00035	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  0003a	75 20		 jne	 SHORT $LN2@stbi__hdr_

; 7101 :        r = stbi__hdr_test_core(s, "#?RGBE\n");

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KFDJIKCK@?$CD?$DPRGBE?6@
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 stbi__hdr_test_core
  0004d	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7102 :        stbi__rewind(s);

  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00056	e8 00 00 00 00	 call	 stbi__rewind
  0005b	90		 npad	 1
$LN2@stbi__hdr_:

; 7103 :    }
; 7104 :    return r;

  0005c	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 7105 : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
stbi__hdr_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
len$ = 32
c$ = 36
$T1 = 37
$T2 = 40
$T3 = 44
$T4 = 48
$T5 = 49
tv129 = 50
tv138 = 51
tv150 = 52
tv162 = 56
tv170 = 60
tv179 = 61
tv187 = 62
tv196 = 63
z$ = 80
buffer$ = 88
stbi__hdr_gettoken PROC

; 7109 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7110 :    int len=0;

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 7111 :    char c = '\0';

  00023	c6 44 24 24 00	 mov	 BYTE PTR c$[rsp], 0

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00032	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00039	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00040	73 39		 jae	 SHORT $LN9@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00047	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00051	88 44 24 32	 mov	 BYTE PTR tv129[rsp], al
  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0005a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00061	48 ff c0	 inc	 rax
  00064	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00069	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00070	0f b6 44 24 32	 movzx	 eax, BYTE PTR tv129[rsp]
  00075	88 44 24 25	 mov	 BYTE PTR $T1[rsp], al
  00079	eb 53		 jmp	 SHORT $LN8@stbi__hdr_
$LN9@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00080	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00084	74 43		 je	 SHORT $LN10@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0008b	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00095	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009f	88 44 24 33	 mov	 BYTE PTR tv138[rsp], al
  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000a8	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000af	48 ff c0	 inc	 rax
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  000b7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000be	0f b6 44 24 33	 movzx	 eax, BYTE PTR tv138[rsp]
  000c3	88 44 24 25	 mov	 BYTE PTR $T1[rsp], al
  000c7	eb 05		 jmp	 SHORT $LN8@stbi__hdr_
$LN10@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  000c9	c6 44 24 25 00	 mov	 BYTE PTR $T1[rsp], 0
$LN8@stbi__hdr_:

; 7112 : 
; 7113 :    c = (char) stbi__get8(z);

  000ce	0f b6 44 24 25	 movzx	 eax, BYTE PTR $T1[rsp]
  000d3	88 44 24 24	 mov	 BYTE PTR c$[rsp], al
$LN2@stbi__hdr_:

; 1628 :    if (s->io.read) {

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000dc	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000e1	74 34		 je	 SHORT $LN13@stbi__hdr_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000e8	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000ec	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000f1	ff 50 20	 call	 QWORD PTR [rax+32]
  000f4	85 c0		 test	 eax, eax
  000f6	75 0a		 jne	 SHORT $LN14@stbi__hdr_
  000f8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0
  00100	eb 49		 jmp	 SHORT $LN12@stbi__hdr_
$LN14@stbi__hdr_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00107	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0010b	75 0a		 jne	 SHORT $LN15@stbi__hdr_
  0010d	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR $T2[rsp], 1
  00115	eb 34		 jmp	 SHORT $LN12@stbi__hdr_
$LN15@stbi__hdr_:
$LN13@stbi__hdr_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00117	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0011c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00121	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00128	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0012f	72 0a		 jb	 SHORT $LN17@stbi__hdr_
  00131	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  00139	eb 08		 jmp	 SHORT $LN18@stbi__hdr_
$LN17@stbi__hdr_:
  0013b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN18@stbi__hdr_:
  00143	8b 44 24 34	 mov	 eax, DWORD PTR tv150[rsp]
  00147	89 44 24 28	 mov	 DWORD PTR $T2[rsp], eax
$LN12@stbi__hdr_:

; 7114 : 
; 7115 :    while (!stbi__at_eof(z) && c != '\n') {

  0014b	8b 44 24 28	 mov	 eax, DWORD PTR $T2[rsp]
  0014f	85 c0		 test	 eax, eax
  00151	0f 85 29 02 00
	00		 jne	 $LN3@stbi__hdr_
  00157	0f be 44 24 24	 movsx	 eax, BYTE PTR c$[rsp]
  0015c	83 f8 0a	 cmp	 eax, 10
  0015f	0f 84 1b 02 00
	00		 je	 $LN3@stbi__hdr_

; 7116 :       buffer[len++] = c;

  00165	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  0016a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buffer$[rsp]
  0016f	0f b6 54 24 24	 movzx	 edx, BYTE PTR c$[rsp]
  00174	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00177	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0017b	ff c0		 inc	 eax
  0017d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 7117 :       if (len == STBI__HDR_BUFLEN-1) {

  00181	81 7c 24 20 ff
	03 00 00	 cmp	 DWORD PTR len$[rsp], 1023 ; 000003ffH
  00189	0f 85 3d 01 00
	00		 jne	 $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 1628 :    if (s->io.read) {

  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00194	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00199	74 34		 je	 SHORT $LN20@stbi__hdr_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001a0	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  001a4	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001a9	ff 50 20	 call	 QWORD PTR [rax+32]
  001ac	85 c0		 test	 eax, eax
  001ae	75 0a		 jne	 SHORT $LN21@stbi__hdr_
  001b0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T3[rsp], 0
  001b8	eb 49		 jmp	 SHORT $LN19@stbi__hdr_
$LN21@stbi__hdr_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  001ba	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001bf	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001c3	75 0a		 jne	 SHORT $LN22@stbi__hdr_
  001c5	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR $T3[rsp], 1
  001cd	eb 34		 jmp	 SHORT $LN19@stbi__hdr_
$LN22@stbi__hdr_:
$LN20@stbi__hdr_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  001cf	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001d9	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001e0	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001e7	72 0a		 jb	 SHORT $LN24@stbi__hdr_
  001e9	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  001f1	eb 08		 jmp	 SHORT $LN25@stbi__hdr_
$LN24@stbi__hdr_:
  001f3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN25@stbi__hdr_:
  001fb	8b 44 24 38	 mov	 eax, DWORD PTR tv162[rsp]
  001ff	89 44 24 2c	 mov	 DWORD PTR $T3[rsp], eax
$LN19@stbi__hdr_:

; 7118 :          // flush to end of line
; 7119 :          while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

  00203	8b 44 24 2c	 mov	 eax, DWORD PTR $T3[rsp]
  00207	85 c0		 test	 eax, eax
  00209	0f 85 b8 00 00
	00		 jne	 $LN5@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00214	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00219	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00220	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00227	73 39		 jae	 SHORT $LN27@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00229	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0022e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00235	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00238	88 44 24 3c	 mov	 BYTE PTR tv170[rsp], al
  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00241	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00248	48 ff c0	 inc	 rax
  0024b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00250	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00257	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv170[rsp]
  0025c	88 44 24 30	 mov	 BYTE PTR $T4[rsp], al
  00260	eb 53		 jmp	 SHORT $LN26@stbi__hdr_
$LN27@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00262	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00267	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0026b	74 43		 je	 SHORT $LN28@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  0026d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00272	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0027c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00283	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00286	88 44 24 3d	 mov	 BYTE PTR tv179[rsp], al
  0028a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0028f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00296	48 ff c0	 inc	 rax
  00299	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0029e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002a5	0f b6 44 24 3d	 movzx	 eax, BYTE PTR tv179[rsp]
  002aa	88 44 24 30	 mov	 BYTE PTR $T4[rsp], al
  002ae	eb 05		 jmp	 SHORT $LN26@stbi__hdr_
$LN28@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  002b0	c6 44 24 30 00	 mov	 BYTE PTR $T4[rsp], 0
$LN26@stbi__hdr_:

; 7118 :          // flush to end of line
; 7119 :          while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

  002b5	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T4[rsp]
  002ba	0f b6 c0	 movzx	 eax, al
  002bd	83 f8 0a	 cmp	 eax, 10
  002c0	74 05		 je	 SHORT $LN5@stbi__hdr_

; 7120 :             ;

  002c2	e9 c8 fe ff ff	 jmp	 $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 7121 :          break;

  002c7	e9 b4 00 00 00	 jmp	 $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  002cc	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  002d6	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002dd	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002e4	73 39		 jae	 SHORT $LN31@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  002e6	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002eb	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f5	88 44 24 3e	 mov	 BYTE PTR tv187[rsp], al
  002f9	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002fe	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00305	48 ff c0	 inc	 rax
  00308	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0030d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00314	0f b6 44 24 3e	 movzx	 eax, BYTE PTR tv187[rsp]
  00319	88 44 24 31	 mov	 BYTE PTR $T5[rsp], al
  0031d	eb 53		 jmp	 SHORT $LN30@stbi__hdr_
$LN31@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  0031f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00324	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00328	74 43		 je	 SHORT $LN32@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  0032a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0032f	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00334	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00339	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00340	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00343	88 44 24 3f	 mov	 BYTE PTR tv196[rsp], al
  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0034c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00353	48 ff c0	 inc	 rax
  00356	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0035b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00362	0f b6 44 24 3f	 movzx	 eax, BYTE PTR tv196[rsp]
  00367	88 44 24 31	 mov	 BYTE PTR $T5[rsp], al
  0036b	eb 05		 jmp	 SHORT $LN30@stbi__hdr_
$LN32@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  0036d	c6 44 24 31 00	 mov	 BYTE PTR $T5[rsp], 0
$LN30@stbi__hdr_:

; 7122 :       }
; 7123 :       c = (char) stbi__get8(z);

  00372	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T5[rsp]
  00377	88 44 24 24	 mov	 BYTE PTR c$[rsp], al

; 7124 :    }

  0037b	e9 57 fd ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7125 : 
; 7126 :    buffer[len] = 0;

  00380	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  00385	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buffer$[rsp]
  0038a	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 7127 :    return buffer;

  0038e	48 8b 44 24 58	 mov	 rax, QWORD PTR buffer$[rsp]

; 7128 : }

  00393	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00397	5f		 pop	 rdi
  00398	c3		 ret	 0
stbi__hdr_gettoken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f1$1 = 32
tv152 = 36
output$ = 64
input$ = 72
req_comp$ = 80
stbi__hdr_convert PROC

; 7131 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0001b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7132 :    if ( input[3] != 0 ) {

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	48 6b c0 03	 imul	 rax, rax, 3
  00029	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0002e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00032	85 c0		 test	 eax, eax
  00034	0f 84 72 01 00
	00		 je	 $LN4@stbi__hdr_

; 7133 :       float f1;
; 7134 :       // Exponent
; 7135 :       f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	48 6b c0 03	 imul	 rax, rax, 3
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00048	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004c	2d 88 00 00 00	 sub	 eax, 136		; 00000088H
  00051	8b d0		 mov	 edx, eax
  00053	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00061	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00065	f3 0f 11 44 24
	20		 movss	 DWORD PTR f1$1[rsp], xmm0

; 7136 :       if (req_comp <= 2)

  0006b	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  00070	7f 64		 jg	 SHORT $LN6@stbi__hdr_

; 7137 :          output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	48 6b c0 00	 imul	 rax, rax, 0
  0007b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00080	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	48 6b c9 01	 imul	 rcx, rcx, 1
  0008d	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00092	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00096	03 c1		 add	 eax, ecx
  00098	b9 01 00 00 00	 mov	 ecx, 1
  0009d	48 6b c9 02	 imul	 rcx, rcx, 2
  000a1	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  000a6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000aa	03 c1		 add	 eax, ecx
  000ac	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000b0	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000b6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	48 6b c0 00	 imul	 rax, rax, 0
  000c7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000cc	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  000d1	e9 8d 00 00 00	 jmp	 $LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 7138 :       else {
; 7139 :          output[0] = input[0] * f1;

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 00	 imul	 rax, rax, 0
  000df	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ec	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000f2	b8 04 00 00 00	 mov	 eax, 4
  000f7	48 6b c0 00	 imul	 rax, rax, 0
  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00100	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7140 :          output[1] = input[1] * f1;

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00113	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00117	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0011b	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  00121	b8 04 00 00 00	 mov	 eax, 4
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0012f	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7141 :          output[2] = input[2] * f1;

  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	48 6b c0 02	 imul	 rax, rax, 2
  0013d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00142	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00146	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0014a	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  00150	b8 04 00 00 00	 mov	 eax, 4
  00155	48 6b c0 02	 imul	 rax, rax, 2
  00159	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0015e	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN7@stbi__hdr_:

; 7142 :       }
; 7143 :       if (req_comp == 2) output[1] = 1;

  00163	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  00168	75 1b		 jne	 SHORT $LN8@stbi__hdr_
  0016a	b8 04 00 00 00	 mov	 eax, 4
  0016f	48 6b c0 01	 imul	 rax, rax, 1
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00178	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00180	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN8@stbi__hdr_:

; 7144 :       if (req_comp == 4) output[3] = 1;

  00185	83 7c 24 50 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  0018a	75 1b		 jne	 SHORT $LN9@stbi__hdr_
  0018c	b8 04 00 00 00	 mov	 eax, 4
  00191	48 6b c0 03	 imul	 rax, rax, 3
  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0019a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a2	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN9@stbi__hdr_:

; 7145 :    } else {

  001a7	e9 bd 00 00 00	 jmp	 $LN5@stbi__hdr_
$LN4@stbi__hdr_:

; 7146 :       switch (req_comp) {

  001ac	8b 44 24 50	 mov	 eax, DWORD PTR req_comp$[rsp]
  001b0	89 44 24 24	 mov	 DWORD PTR tv152[rsp], eax
  001b4	83 7c 24 24 01	 cmp	 DWORD PTR tv152[rsp], 1
  001b9	0f 84 94 00 00
	00		 je	 $LN13@stbi__hdr_
  001bf	83 7c 24 24 02	 cmp	 DWORD PTR tv152[rsp], 2
  001c4	74 72		 je	 SHORT $LN12@stbi__hdr_
  001c6	83 7c 24 24 03	 cmp	 DWORD PTR tv152[rsp], 3
  001cb	74 27		 je	 SHORT $LN11@stbi__hdr_
  001cd	83 7c 24 24 04	 cmp	 DWORD PTR tv152[rsp], 4
  001d2	74 05		 je	 SHORT $LN10@stbi__hdr_
  001d4	e9 90 00 00 00	 jmp	 $LN2@stbi__hdr_
$LN10@stbi__hdr_:

; 7147 :          case 4: output[3] = 1; /* fallthrough */

  001d9	b8 04 00 00 00	 mov	 eax, 4
  001de	48 6b c0 03	 imul	 rax, rax, 3
  001e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001e7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ef	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN11@stbi__hdr_:

; 7148 :          case 3: output[0] = output[1] = output[2] = 0;

  001f4	b8 04 00 00 00	 mov	 eax, 4
  001f9	48 6b c0 02	 imul	 rax, rax, 2
  001fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00202	0f 57 c0	 xorps	 xmm0, xmm0
  00205	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  0020a	b8 04 00 00 00	 mov	 eax, 4
  0020f	48 6b c0 01	 imul	 rax, rax, 1
  00213	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00218	0f 57 c0	 xorps	 xmm0, xmm0
  0021b	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  00220	b8 04 00 00 00	 mov	 eax, 4
  00225	48 6b c0 00	 imul	 rax, rax, 0
  00229	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0022e	0f 57 c0	 xorps	 xmm0, xmm0
  00231	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7149 :                  break;

  00236	eb 31		 jmp	 SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 7150 :          case 2: output[1] = 1; /* fallthrough */

  00238	b8 04 00 00 00	 mov	 eax, 4
  0023d	48 6b c0 01	 imul	 rax, rax, 1
  00241	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00246	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0024e	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN13@stbi__hdr_:

; 7151 :          case 1: output[0] = 0;

  00253	b8 04 00 00 00	 mov	 eax, 4
  00258	48 6b c0 00	 imul	 rax, rax, 0
  0025c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00261	0f 57 c0	 xorps	 xmm0, xmm0
  00264	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN2@stbi__hdr_:
$LN5@stbi__hdr_:

; 7152 :                  break;
; 7153 :       }
; 7154 :    }
; 7155 : }

  00269	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0026d	5f		 pop	 rdi
  0026e	c3		 ret	 0
stbi__hdr_convert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
buffer$ = 64
token$ = 1112
valid$ = 1124
width$ = 1128
height$ = 1132
scanline$ = 1136
hdr_data$ = 1144
len$ = 1152
count$ = 1156
value$ = 1157
i$ = 1160
j$ = 1164
k$ = 1168
c1$ = 1172
c2$ = 1176
z$ = 1180
headerToken$ = 1184
rgbe$7 = 1204
rgbe$8 = 1236
nleft$9 = 1252
$T10 = 1264
$T11 = 1265
$T12 = 1266
$T13 = 1267
$T14 = 1268
$T15 = 1269
$T16 = 1270
$T17 = 1271
tv78 = 1272
tv94 = 1280
tv138 = 1288
tv155 = 1296
tv165 = 1304
tv170 = 1312
tv183 = 1320
tv194 = 1328
tv346 = 1336
tv355 = 1337
tv363 = 1338
tv372 = 1339
tv380 = 1340
tv421 = 1341
tv429 = 1342
tv438 = 1343
tv446 = 1344
tv455 = 1345
tv256 = 1352
tv267 = 1360
tv463 = 1368
tv472 = 1369
tv480 = 1370
tv489 = 1371
tv290 = 1376
tv309 = 1384
tv497 = 1392
tv506 = 1393
__$ArrayPad$ = 1400
s$ = 1424
x$ = 1432
y$ = 1440
comp$ = 1448
req_comp$ = 1456
ri$ = 1464
stbi__hdr_load PROC

; 7158 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 80 05
	00 00		 sub	 rsp, 1408		; 00000580H
  0001c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00021	b9 54 01 00 00	 mov	 ecx, 340		; 00000154H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1424]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 78
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7159 :    char buffer[STBI__HDR_BUFLEN];
; 7160 :    char *token;
; 7161 :    int valid = 0;

  00053	c7 84 24 64 04
	00 00 00 00 00
	00		 mov	 DWORD PTR valid$[rsp], 0

; 7162 :    int width, height;
; 7163 :    stbi_uc *scanline;
; 7164 :    float *hdr_data;
; 7165 :    int len;
; 7166 :    unsigned char count, value;
; 7167 :    int i, j, k, c1,c2, z;
; 7168 :    const char *headerToken;
; 7169 :    STBI_NOTUSED(ri);
; 7170 : 
; 7171 :    // Check identifier
; 7172 :    headerToken = stbi__hdr_gettoken(s,buffer);

  0005e	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00063	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  00070	48 89 84 24 a0
	04 00 00	 mov	 QWORD PTR headerToken$[rsp], rax

; 7173 :    if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

  00078	48 8b 84 24 a0
	04 00 00	 mov	 rax, QWORD PTR headerToken$[rsp]
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
  00087	48 2b c8	 sub	 rcx, rax
$LL120@stbi__hdr_:
  0008a	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0008d	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  00090	75 0b		 jne	 SHORT $LN122@stbi__hdr_
  00092	48 ff c0	 inc	 rax
  00095	84 d2		 test	 dl, dl
  00097	75 f1		 jne	 SHORT $LL120@stbi__hdr_
  00099	33 c0		 xor	 eax, eax
  0009b	eb 05		 jmp	 SHORT $LN121@stbi__hdr_
$LN122@stbi__hdr_:
  0009d	1b c0		 sbb	 eax, eax
  0009f	83 c8 01	 or	 eax, 1
$LN121@stbi__hdr_:
  000a2	85 c0		 test	 eax, eax
  000a4	74 65		 je	 SHORT $LN30@stbi__hdr_
  000a6	48 8b 84 24 a0
	04 00 00	 mov	 rax, QWORD PTR headerToken$[rsp]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06NDOKKIDJ@?$CD?$DPRGBE@
  000b5	48 2b c8	 sub	 rcx, rax
$LL117@stbi__hdr_:
  000b8	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000bb	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  000be	75 0b		 jne	 SHORT $LN119@stbi__hdr_
  000c0	48 ff c0	 inc	 rax
  000c3	84 d2		 test	 dl, dl
  000c5	75 f1		 jne	 SHORT $LL117@stbi__hdr_
  000c7	33 c0		 xor	 eax, eax
  000c9	eb 05		 jmp	 SHORT $LN118@stbi__hdr_
$LN119@stbi__hdr_:
  000cb	1b c0		 sbb	 eax, eax
  000cd	83 c8 01	 or	 eax, 1
$LN118@stbi__hdr_:
  000d0	85 c0		 test	 eax, eax
  000d2	74 37		 je	 SHORT $LN30@stbi__hdr_

; 7174 :       return stbi__errpf("not HDR", "Corrupt HDR image");

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07NCIOKENI@not?5HDR@
  000db	e8 00 00 00 00	 call	 stbi__err
  000e0	85 c0		 test	 eax, eax
  000e2	74 0e		 je	 SHORT $LN58@stbi__hdr_
  000e4	48 c7 84 24 f8
	04 00 00 00 00
	00 00		 mov	 QWORD PTR tv78[rsp], 0
  000f0	eb 0c		 jmp	 SHORT $LN59@stbi__hdr_
$LN58@stbi__hdr_:
  000f2	48 c7 84 24 f8
	04 00 00 00 00
	00 00		 mov	 QWORD PTR tv78[rsp], 0
$LN59@stbi__hdr_:
  000fe	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR tv78[rsp]
  00106	e9 cf 10 00 00	 jmp	 $LN1@stbi__hdr_
$LN30@stbi__hdr_:
$LN2@stbi__hdr_:

; 7175 : 
; 7176 :    // Parse header
; 7177 :    for(;;) {
; 7178 :       token = stbi__hdr_gettoken(s,buffer);

  0010b	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00110	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00118	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  0011d	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7179 :       if (token[0] == 0) break;

  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	48 6b c0 00	 imul	 rax, rax, 0
  0012e	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00136	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0013a	85 c0		 test	 eax, eax
  0013c	75 02		 jne	 SHORT $LN31@stbi__hdr_
  0013e	eb 3b		 jmp	 SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 7180 :       if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  00140	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
  0014f	48 2b c8	 sub	 rcx, rax
$LL114@stbi__hdr_:
  00152	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00155	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  00158	75 0b		 jne	 SHORT $LN116@stbi__hdr_
  0015a	48 ff c0	 inc	 rax
  0015d	84 d2		 test	 dl, dl
  0015f	75 f1		 jne	 SHORT $LL114@stbi__hdr_
  00161	33 c0		 xor	 eax, eax
  00163	eb 05		 jmp	 SHORT $LN115@stbi__hdr_
$LN116@stbi__hdr_:
  00165	1b c0		 sbb	 eax, eax
  00167	83 c8 01	 or	 eax, 1
$LN115@stbi__hdr_:
  0016a	85 c0		 test	 eax, eax
  0016c	75 0b		 jne	 SHORT $LN32@stbi__hdr_
  0016e	c7 84 24 64 04
	00 00 01 00 00
	00		 mov	 DWORD PTR valid$[rsp], 1
$LN32@stbi__hdr_:

; 7181 :    }

  00179	eb 90		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7182 : 
; 7183 :    if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

  0017b	83 bc 24 64 04
	00 00 00	 cmp	 DWORD PTR valid$[rsp], 0
  00183	75 37		 jne	 SHORT $LN33@stbi__hdr_
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@NKJFFLKL@unsupported?5format@
  0018c	e8 00 00 00 00	 call	 stbi__err
  00191	85 c0		 test	 eax, eax
  00193	74 0e		 je	 SHORT $LN60@stbi__hdr_
  00195	48 c7 84 24 00
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv94[rsp], 0
  001a1	eb 0c		 jmp	 SHORT $LN61@stbi__hdr_
$LN60@stbi__hdr_:
  001a3	48 c7 84 24 00
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv94[rsp], 0
$LN61@stbi__hdr_:
  001af	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR tv94[rsp]
  001b7	e9 1e 10 00 00	 jmp	 $LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 7184 : 
; 7185 :    // Parse width and height
; 7186 :    // can't use sscanf() if we're not using stdio!
; 7187 :    token = stbi__hdr_gettoken(s,buffer);

  001bc	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  001c1	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001c9	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  001ce	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7188 :    if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  001d6	41 b8 03 00 00
	00		 mov	 r8d, 3
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
  001e3	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  001f1	85 c0		 test	 eax, eax
  001f3	74 37		 je	 SHORT $LN34@stbi__hdr_
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
  001fc	e8 00 00 00 00	 call	 stbi__err
  00201	85 c0		 test	 eax, eax
  00203	74 0e		 je	 SHORT $LN62@stbi__hdr_
  00205	48 c7 84 24 08
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv138[rsp], 0
  00211	eb 0c		 jmp	 SHORT $LN63@stbi__hdr_
$LN62@stbi__hdr_:
  00213	48 c7 84 24 08
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv138[rsp], 0
$LN63@stbi__hdr_:
  0021f	48 8b 84 24 08
	05 00 00	 mov	 rax, QWORD PTR tv138[rsp]
  00227	e9 ae 0f 00 00	 jmp	 $LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 7189 :    token += 3;

  0022c	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00234	48 83 c0 03	 add	 rax, 3
  00238	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7190 :    height = (int) strtol(token, &token, 10);

  00240	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00246	48 8d 94 24 58
	04 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  0024e	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  0025c	89 84 24 6c 04
	00 00		 mov	 DWORD PTR height$[rsp], eax
$LN5@stbi__hdr_:

; 7191 :    while (*token == ' ') ++token;

  00263	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0026b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0026e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00271	75 15		 jne	 SHORT $LN6@stbi__hdr_
  00273	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0027b	48 ff c0	 inc	 rax
  0027e	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR token$[rsp], rax
  00286	eb db		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7192 :    if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  00288	41 b8 03 00 00
	00		 mov	 r8d, 3
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
  00295	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  002a3	85 c0		 test	 eax, eax
  002a5	74 37		 je	 SHORT $LN35@stbi__hdr_
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DCNDPIOH@unsupported?5data?5layout@
  002ae	e8 00 00 00 00	 call	 stbi__err
  002b3	85 c0		 test	 eax, eax
  002b5	74 0e		 je	 SHORT $LN64@stbi__hdr_
  002b7	48 c7 84 24 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv155[rsp], 0
  002c3	eb 0c		 jmp	 SHORT $LN65@stbi__hdr_
$LN64@stbi__hdr_:
  002c5	48 c7 84 24 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv155[rsp], 0
$LN65@stbi__hdr_:
  002d1	48 8b 84 24 10
	05 00 00	 mov	 rax, QWORD PTR tv155[rsp]
  002d9	e9 fc 0e 00 00	 jmp	 $LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 7193 :    token += 3;

  002de	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  002e6	48 83 c0 03	 add	 rax, 3
  002ea	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7194 :    width = (int) strtol(token, NULL, 10);

  002f2	41 b8 0a 00 00
	00		 mov	 r8d, 10
  002f8	33 d2		 xor	 edx, edx
  002fa	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00308	89 84 24 68 04
	00 00		 mov	 DWORD PTR width$[rsp], eax

; 7195 : 
; 7196 :    if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  0030f	81 bc 24 6c 04
	00 00 00 00 00
	01		 cmp	 DWORD PTR height$[rsp], 16777216 ; 01000000H
  0031a	7e 37		 jle	 SHORT $LN36@stbi__hdr_
  0031c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00323	e8 00 00 00 00	 call	 stbi__err
  00328	85 c0		 test	 eax, eax
  0032a	74 0e		 je	 SHORT $LN66@stbi__hdr_
  0032c	48 c7 84 24 18
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv165[rsp], 0
  00338	eb 0c		 jmp	 SHORT $LN67@stbi__hdr_
$LN66@stbi__hdr_:
  0033a	48 c7 84 24 18
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv165[rsp], 0
$LN67@stbi__hdr_:
  00346	48 8b 84 24 18
	05 00 00	 mov	 rax, QWORD PTR tv165[rsp]
  0034e	e9 87 0e 00 00	 jmp	 $LN1@stbi__hdr_
$LN36@stbi__hdr_:

; 7197 :    if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  00353	81 bc 24 68 04
	00 00 00 00 00
	01		 cmp	 DWORD PTR width$[rsp], 16777216 ; 01000000H
  0035e	7e 37		 jle	 SHORT $LN37@stbi__hdr_
  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  00367	e8 00 00 00 00	 call	 stbi__err
  0036c	85 c0		 test	 eax, eax
  0036e	74 0e		 je	 SHORT $LN68@stbi__hdr_
  00370	48 c7 84 24 20
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv170[rsp], 0
  0037c	eb 0c		 jmp	 SHORT $LN69@stbi__hdr_
$LN68@stbi__hdr_:
  0037e	48 c7 84 24 20
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv170[rsp], 0
$LN69@stbi__hdr_:
  0038a	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR tv170[rsp]
  00392	e9 43 0e 00 00	 jmp	 $LN1@stbi__hdr_
$LN37@stbi__hdr_:

; 7198 : 
; 7199 :    *x = width;

  00397	48 8b 84 24 98
	05 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0039f	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR width$[rsp]
  003a6	89 08		 mov	 DWORD PTR [rax], ecx

; 7200 :    *y = height;

  003a8	48 8b 84 24 a0
	05 00 00	 mov	 rax, QWORD PTR y$[rsp]
  003b0	8b 8c 24 6c 04
	00 00		 mov	 ecx, DWORD PTR height$[rsp]
  003b7	89 08		 mov	 DWORD PTR [rax], ecx

; 7201 : 
; 7202 :    if (comp) *comp = 3;

  003b9	48 83 bc 24 a8
	05 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  003c2	74 0e		 je	 SHORT $LN38@stbi__hdr_
  003c4	48 8b 84 24 a8
	05 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  003cc	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN38@stbi__hdr_:

; 7203 :    if (req_comp == 0) req_comp = 3;

  003d2	83 bc 24 b0 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  003da	75 0b		 jne	 SHORT $LN39@stbi__hdr_
  003dc	c7 84 24 b0 05
	00 00 03 00 00
	00		 mov	 DWORD PTR req_comp$[rsp], 3
$LN39@stbi__hdr_:

; 7204 : 
; 7205 :    if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))

  003e7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  003ef	41 b9 04 00 00
	00		 mov	 r9d, 4
  003f5	44 8b 84 24 b0
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  003fd	8b 94 24 6c 04
	00 00		 mov	 edx, DWORD PTR height$[rsp]
  00404	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR width$[rsp]
  0040b	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00410	85 c0		 test	 eax, eax
  00412	75 37		 jne	 SHORT $LN40@stbi__hdr_

; 7206 :       return stbi__errpf("too large", "HDR image is too large");

  00414	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0041b	e8 00 00 00 00	 call	 stbi__err
  00420	85 c0		 test	 eax, eax
  00422	74 0e		 je	 SHORT $LN70@stbi__hdr_
  00424	48 c7 84 24 28
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv183[rsp], 0
  00430	eb 0c		 jmp	 SHORT $LN71@stbi__hdr_
$LN70@stbi__hdr_:
  00432	48 c7 84 24 28
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv183[rsp], 0
$LN71@stbi__hdr_:
  0043e	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR tv183[rsp]
  00446	e9 8f 0d 00 00	 jmp	 $LN1@stbi__hdr_
$LN40@stbi__hdr_:

; 7207 : 
; 7208 :    // Read data
; 7209 :    hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);

  0044b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00453	41 b9 04 00 00
	00		 mov	 r9d, 4
  00459	44 8b 84 24 b0
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00461	8b 94 24 6c 04
	00 00		 mov	 edx, DWORD PTR height$[rsp]
  00468	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR width$[rsp]
  0046f	e8 00 00 00 00	 call	 stbi__malloc_mad4
  00474	48 89 84 24 78
	04 00 00	 mov	 QWORD PTR hdr_data$[rsp], rax

; 7210 :    if (!hdr_data)

  0047c	48 83 bc 24 78
	04 00 00 00	 cmp	 QWORD PTR hdr_data$[rsp], 0
  00485	75 37		 jne	 SHORT $LN41@stbi__hdr_

; 7211 :       return stbi__errpf("outofmem", "Out of memory");

  00487	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0048e	e8 00 00 00 00	 call	 stbi__err
  00493	85 c0		 test	 eax, eax
  00495	74 0e		 je	 SHORT $LN72@stbi__hdr_
  00497	48 c7 84 24 30
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv194[rsp], 0
  004a3	eb 0c		 jmp	 SHORT $LN73@stbi__hdr_
$LN72@stbi__hdr_:
  004a5	48 c7 84 24 30
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv194[rsp], 0
$LN73@stbi__hdr_:
  004b1	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR tv194[rsp]
  004b9	e9 1c 0d 00 00	 jmp	 $LN1@stbi__hdr_
$LN41@stbi__hdr_:

; 7212 : 
; 7213 :    // Load image data
; 7214 :    // image data is stored as some number of sca
; 7215 :    if ( width < 8 || width >= 32768) {

  004be	83 bc 24 68 04
	00 00 08	 cmp	 DWORD PTR width$[rsp], 8
  004c6	7c 11		 jl	 SHORT $LN44@stbi__hdr_
  004c8	81 bc 24 68 04
	00 00 00 80 00
	00		 cmp	 DWORD PTR width$[rsp], 32768 ; 00008000H
  004d3	0f 8c dc 00 00
	00		 jl	 $LN42@stbi__hdr_
$LN44@stbi__hdr_:

; 7216 :       // Read flat data
; 7217 :       for (j=0; j < height; ++j) {

  004d9	c7 84 24 8c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  004e4	eb 10		 jmp	 SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
  004e6	8b 84 24 8c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  004ed	ff c0		 inc	 eax
  004ef	89 84 24 8c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN9@stbi__hdr_:
  004f6	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR height$[rsp]
  004fd	39 84 24 8c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00504	0f 8d a6 00 00
	00		 jge	 $LN8@stbi__hdr_

; 7218 :          for (i=0; i < width; ++i) {

  0050a	c7 84 24 88 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00515	eb 10		 jmp	 SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
  00517	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0051e	ff c0		 inc	 eax
  00520	89 84 24 88 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__hdr_:
  00527	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  0052e	39 84 24 88 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00535	7d 74		 jge	 SHORT $LN11@stbi__hdr_
$main_decode_loop$123:

; 7219 :             stbi_uc rgbe[4];
; 7220 :            main_decode_loop:
; 7221 :             stbi__getn(s, rgbe, 4);

  00537	41 b8 04 00 00
	00		 mov	 r8d, 4
  0053d	48 8d 94 24 b4
	04 00 00	 lea	 rdx, QWORD PTR rgbe$7[rsp]
  00545	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0054d	e8 00 00 00 00	 call	 stbi__getn

; 7222 :             stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

  00552	8b 84 24 8c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00559	0f af 84 24 68
	04 00 00	 imul	 eax, DWORD PTR width$[rsp]
  00561	0f af 84 24 b0
	05 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  00569	48 98		 cdqe
  0056b	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00573	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00577	8b 8c 24 88 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0057e	0f af 8c 24 b0
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  00586	48 63 c9	 movsxd	 rcx, ecx
  00589	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0058d	44 8b 84 24 b0
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00595	48 8d 94 24 b4
	04 00 00	 lea	 rdx, QWORD PTR rgbe$7[rsp]
  0059d	48 8b c8	 mov	 rcx, rax
  005a0	e8 00 00 00 00	 call	 stbi__hdr_convert
  005a5	90		 npad	 1

; 7223 :          }

  005a6	e9 6c ff ff ff	 jmp	 $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 7224 :       }

  005ab	e9 36 ff ff ff	 jmp	 $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 7225 :    } else {

  005b0	e9 1d 0c 00 00	 jmp	 $LN43@stbi__hdr_
$LN42@stbi__hdr_:

; 7226 :       // Read RLE-encoded data
; 7227 :       scanline = NULL;

  005b5	48 c7 84 24 70
	04 00 00 00 00
	00 00		 mov	 QWORD PTR scanline$[rsp], 0

; 7228 : 
; 7229 :       for (j = 0; j < height; ++j) {

  005c1	c7 84 24 8c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  005cc	eb 10		 jmp	 SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
  005ce	8b 84 24 8c 04
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  005d5	ff c0		 inc	 eax
  005d7	89 84 24 8c 04
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN15@stbi__hdr_:
  005de	8b 84 24 6c 04
	00 00		 mov	 eax, DWORD PTR height$[rsp]
  005e5	39 84 24 8c 04
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  005ec	0f 8d c6 0b 00
	00		 jge	 $LN14@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  005f2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fa	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00602	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00609	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00610	73 4b		 jae	 SHORT $LN83@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00612	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00621	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00624	88 84 24 38 05
	00 00		 mov	 BYTE PTR tv346[rsp], al
  0062b	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00633	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0063a	48 ff c0	 inc	 rax
  0063d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00645	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0064c	0f b6 84 24 38
	05 00 00	 movzx	 eax, BYTE PTR tv346[rsp]
  00654	88 84 24 f0 04
	00 00		 mov	 BYTE PTR $T10[rsp], al
  0065b	eb 6e		 jmp	 SHORT $LN82@stbi__hdr_
$LN83@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  0065d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00665	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00669	74 58		 je	 SHORT $LN84@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  0066b	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00673	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00678	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00680	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00687	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0068a	88 84 24 39 05
	00 00		 mov	 BYTE PTR tv355[rsp], al
  00691	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00699	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  006a0	48 ff c0	 inc	 rax
  006a3	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006ab	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  006b2	0f b6 84 24 39
	05 00 00	 movzx	 eax, BYTE PTR tv355[rsp]
  006ba	88 84 24 f0 04
	00 00		 mov	 BYTE PTR $T10[rsp], al
  006c1	eb 08		 jmp	 SHORT $LN82@stbi__hdr_
$LN84@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  006c3	c6 84 24 f0 04
	00 00 00	 mov	 BYTE PTR $T10[rsp], 0
$LN82@stbi__hdr_:

; 7230 :          c1 = stbi__get8(s);

  006cb	0f b6 84 24 f0
	04 00 00	 movzx	 eax, BYTE PTR $T10[rsp]
  006d3	0f b6 c0	 movzx	 eax, al
  006d6	89 84 24 94 04
	00 00		 mov	 DWORD PTR c1$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  006dd	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e5	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006ed	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  006f4	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  006fb	73 4b		 jae	 SHORT $LN87@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  006fd	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00705	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0070c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0070f	88 84 24 3a 05
	00 00		 mov	 BYTE PTR tv363[rsp], al
  00716	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0071e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00725	48 ff c0	 inc	 rax
  00728	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00730	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00737	0f b6 84 24 3a
	05 00 00	 movzx	 eax, BYTE PTR tv363[rsp]
  0073f	88 84 24 f1 04
	00 00		 mov	 BYTE PTR $T11[rsp], al
  00746	eb 6e		 jmp	 SHORT $LN86@stbi__hdr_
$LN87@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00748	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00750	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00754	74 58		 je	 SHORT $LN88@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00756	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0075e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00763	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0076b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00772	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00775	88 84 24 3b 05
	00 00		 mov	 BYTE PTR tv372[rsp], al
  0077c	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00784	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0078b	48 ff c0	 inc	 rax
  0078e	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00796	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0079d	0f b6 84 24 3b
	05 00 00	 movzx	 eax, BYTE PTR tv372[rsp]
  007a5	88 84 24 f1 04
	00 00		 mov	 BYTE PTR $T11[rsp], al
  007ac	eb 08		 jmp	 SHORT $LN86@stbi__hdr_
$LN88@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  007ae	c6 84 24 f1 04
	00 00 00	 mov	 BYTE PTR $T11[rsp], 0
$LN86@stbi__hdr_:

; 7231 :          c2 = stbi__get8(s);

  007b6	0f b6 84 24 f1
	04 00 00	 movzx	 eax, BYTE PTR $T11[rsp]
  007be	0f b6 c0	 movzx	 eax, al
  007c1	89 84 24 98 04
	00 00		 mov	 DWORD PTR c2$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  007c8	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007d0	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d8	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  007df	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  007e6	73 4b		 jae	 SHORT $LN91@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  007e8	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007f0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  007f7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007fa	88 84 24 3c 05
	00 00		 mov	 BYTE PTR tv380[rsp], al
  00801	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00809	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00810	48 ff c0	 inc	 rax
  00813	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0081b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00822	0f b6 84 24 3c
	05 00 00	 movzx	 eax, BYTE PTR tv380[rsp]
  0082a	88 84 24 f2 04
	00 00		 mov	 BYTE PTR $T12[rsp], al
  00831	eb 6e		 jmp	 SHORT $LN90@stbi__hdr_
$LN91@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00833	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0083b	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0083f	74 58		 je	 SHORT $LN92@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00841	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00849	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0084e	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00856	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0085d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00860	88 84 24 3d 05
	00 00		 mov	 BYTE PTR tv421[rsp], al
  00867	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0086f	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00876	48 ff c0	 inc	 rax
  00879	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00881	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00888	0f b6 84 24 3d
	05 00 00	 movzx	 eax, BYTE PTR tv421[rsp]
  00890	88 84 24 f2 04
	00 00		 mov	 BYTE PTR $T12[rsp], al
  00897	eb 08		 jmp	 SHORT $LN90@stbi__hdr_
$LN92@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  00899	c6 84 24 f2 04
	00 00 00	 mov	 BYTE PTR $T12[rsp], 0
$LN90@stbi__hdr_:

; 7232 :          len = stbi__get8(s);

  008a1	0f b6 84 24 f2
	04 00 00	 movzx	 eax, BYTE PTR $T12[rsp]
  008a9	0f b6 c0	 movzx	 eax, al
  008ac	89 84 24 80 04
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 7233 :          if (c1 != 2 || c2 != 2 || (len & 0x80)) {

  008b3	83 bc 24 94 04
	00 00 02	 cmp	 DWORD PTR c1$[rsp], 2
  008bb	75 1e		 jne	 SHORT $LN46@stbi__hdr_
  008bd	83 bc 24 98 04
	00 00 02	 cmp	 DWORD PTR c2$[rsp], 2
  008c5	75 14		 jne	 SHORT $LN46@stbi__hdr_
  008c7	8b 84 24 80 04
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  008ce	25 80 00 00 00	 and	 eax, 128		; 00000080H
  008d3	85 c0		 test	 eax, eax
  008d5	0f 84 80 01 00
	00		 je	 $LN45@stbi__hdr_
$LN46@stbi__hdr_:

; 7234 :             // not run-length encoded, so we have to actually use THIS data as a decoded
; 7235 :             // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 7236 :             stbi_uc rgbe[4];
; 7237 :             rgbe[0] = (stbi_uc) c1;

  008db	b8 01 00 00 00	 mov	 eax, 1
  008e0	48 6b c0 00	 imul	 rax, rax, 0
  008e4	0f b6 8c 24 94
	04 00 00	 movzx	 ecx, BYTE PTR c1$[rsp]
  008ec	88 8c 04 d4 04
	00 00		 mov	 BYTE PTR rgbe$8[rsp+rax], cl

; 7238 :             rgbe[1] = (stbi_uc) c2;

  008f3	b8 01 00 00 00	 mov	 eax, 1
  008f8	48 6b c0 01	 imul	 rax, rax, 1
  008fc	0f b6 8c 24 98
	04 00 00	 movzx	 ecx, BYTE PTR c2$[rsp]
  00904	88 8c 04 d4 04
	00 00		 mov	 BYTE PTR rgbe$8[rsp+rax], cl

; 7239 :             rgbe[2] = (stbi_uc) len;

  0090b	b8 01 00 00 00	 mov	 eax, 1
  00910	48 6b c0 02	 imul	 rax, rax, 2
  00914	0f b6 8c 24 80
	04 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0091c	88 8c 04 d4 04
	00 00		 mov	 BYTE PTR rgbe$8[rsp+rax], cl

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00923	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0092b	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00933	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0093a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00941	73 4b		 jae	 SHORT $LN95@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00943	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0094b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00952	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00955	88 84 24 3e 05
	00 00		 mov	 BYTE PTR tv429[rsp], al
  0095c	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00964	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0096b	48 ff c0	 inc	 rax
  0096e	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00976	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0097d	0f b6 84 24 3e
	05 00 00	 movzx	 eax, BYTE PTR tv429[rsp]
  00985	88 84 24 f3 04
	00 00		 mov	 BYTE PTR $T13[rsp], al
  0098c	eb 6e		 jmp	 SHORT $LN94@stbi__hdr_
$LN95@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  0098e	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00996	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0099a	74 58		 je	 SHORT $LN96@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  0099c	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009a4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  009a9	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009b1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  009b8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009bb	88 84 24 3f 05
	00 00		 mov	 BYTE PTR tv438[rsp], al
  009c2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  009d1	48 ff c0	 inc	 rax
  009d4	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009dc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  009e3	0f b6 84 24 3f
	05 00 00	 movzx	 eax, BYTE PTR tv438[rsp]
  009eb	88 84 24 f3 04
	00 00		 mov	 BYTE PTR $T13[rsp], al
  009f2	eb 08		 jmp	 SHORT $LN94@stbi__hdr_
$LN96@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  009f4	c6 84 24 f3 04
	00 00 00	 mov	 BYTE PTR $T13[rsp], 0
$LN94@stbi__hdr_:

; 7240 :             rgbe[3] = (stbi_uc) stbi__get8(s);

  009fc	0f b6 84 24 f3
	04 00 00	 movzx	 eax, BYTE PTR $T13[rsp]
  00a04	b9 01 00 00 00	 mov	 ecx, 1
  00a09	48 6b c9 03	 imul	 rcx, rcx, 3
  00a0d	88 84 0c d4 04
	00 00		 mov	 BYTE PTR rgbe$8[rsp+rcx], al

; 7241 :             stbi__hdr_convert(hdr_data, rgbe, req_comp);

  00a14	44 8b 84 24 b0
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00a1c	48 8d 94 24 d4
	04 00 00	 lea	 rdx, QWORD PTR rgbe$8[rsp]
  00a24	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00a2c	e8 00 00 00 00	 call	 stbi__hdr_convert

; 7242 :             i = 1;

  00a31	c7 84 24 88 04
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1

; 7243 :             j = 0;

  00a3c	c7 84 24 8c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0

; 7244 :             STBI_FREE(scanline);

  00a47	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00a4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00a55	90		 npad	 1

; 7245 :             goto main_decode_loop; // yes, this makes no sense

  00a56	e9 dc fa ff ff	 jmp	 $main_decode_loop$123
$LN45@stbi__hdr_:

; 7246 :          }
; 7247 :          len <<= 8;

  00a5b	8b 84 24 80 04
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00a62	c1 e0 08	 shl	 eax, 8
  00a65	89 84 24 80 04
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00a6c	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a74	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a7c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00a83	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00a8a	73 4b		 jae	 SHORT $LN99@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00a8c	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a94	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00a9b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a9e	88 84 24 40 05
	00 00		 mov	 BYTE PTR tv446[rsp], al
  00aa5	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aad	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ab4	48 ff c0	 inc	 rax
  00ab7	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00abf	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00ac6	0f b6 84 24 40
	05 00 00	 movzx	 eax, BYTE PTR tv446[rsp]
  00ace	88 84 24 f4 04
	00 00		 mov	 BYTE PTR $T14[rsp], al
  00ad5	eb 6e		 jmp	 SHORT $LN98@stbi__hdr_
$LN99@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00ad7	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00adf	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00ae3	74 58		 je	 SHORT $LN100@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00ae5	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aed	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00af2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00afa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b01	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b04	88 84 24 41 05
	00 00		 mov	 BYTE PTR tv455[rsp], al
  00b0b	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b13	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00b1a	48 ff c0	 inc	 rax
  00b1d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b25	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00b2c	0f b6 84 24 41
	05 00 00	 movzx	 eax, BYTE PTR tv455[rsp]
  00b34	88 84 24 f4 04
	00 00		 mov	 BYTE PTR $T14[rsp], al
  00b3b	eb 08		 jmp	 SHORT $LN98@stbi__hdr_
$LN100@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  00b3d	c6 84 24 f4 04
	00 00 00	 mov	 BYTE PTR $T14[rsp], 0
$LN98@stbi__hdr_:

; 7248 :          len |= stbi__get8(s);

  00b45	0f b6 84 24 f4
	04 00 00	 movzx	 eax, BYTE PTR $T14[rsp]
  00b4d	0f b6 c0	 movzx	 eax, al
  00b50	8b 8c 24 80 04
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00b57	0b c8		 or	 ecx, eax
  00b59	8b c1		 mov	 eax, ecx
  00b5b	89 84 24 80 04
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 7249 :          if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

  00b62	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  00b69	39 84 24 80 04
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  00b70	74 53		 je	 SHORT $LN47@stbi__hdr_
  00b72	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00b7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00b80	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00b88	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00b8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JBEOCDFN@invalid?5decoded?5scanline?5length@
  00b95	e8 00 00 00 00	 call	 stbi__err
  00b9a	85 c0		 test	 eax, eax
  00b9c	74 0e		 je	 SHORT $LN74@stbi__hdr_
  00b9e	48 c7 84 24 48
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv256[rsp], 0
  00baa	eb 0c		 jmp	 SHORT $LN75@stbi__hdr_
$LN74@stbi__hdr_:
  00bac	48 c7 84 24 48
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv256[rsp], 0
$LN75@stbi__hdr_:
  00bb8	48 8b 84 24 48
	05 00 00	 mov	 rax, QWORD PTR tv256[rsp]
  00bc0	e9 15 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN47@stbi__hdr_:

; 7250 :          if (scanline == NULL) {

  00bc5	48 83 bc 24 70
	04 00 00 00	 cmp	 QWORD PTR scanline$[rsp], 0
  00bce	75 6c		 jne	 SHORT $LN48@stbi__hdr_

; 7251 :             scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);

  00bd0	45 33 c0	 xor	 r8d, r8d
  00bd3	ba 04 00 00 00	 mov	 edx, 4
  00bd8	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR width$[rsp]
  00bdf	e8 00 00 00 00	 call	 stbi__malloc_mad2
  00be4	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR scanline$[rsp], rax

; 7252 :             if (!scanline) {

  00bec	48 83 bc 24 70
	04 00 00 00	 cmp	 QWORD PTR scanline$[rsp], 0
  00bf5	75 45		 jne	 SHORT $LN49@stbi__hdr_

; 7253 :                STBI_FREE(hdr_data);

  00bf7	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00bff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7254 :                return stbi__errpf("outofmem", "Out of memory");

  00c05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  00c0c	e8 00 00 00 00	 call	 stbi__err
  00c11	85 c0		 test	 eax, eax
  00c13	74 0e		 je	 SHORT $LN76@stbi__hdr_
  00c15	48 c7 84 24 50
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv267[rsp], 0
  00c21	eb 0c		 jmp	 SHORT $LN77@stbi__hdr_
$LN76@stbi__hdr_:
  00c23	48 c7 84 24 50
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv267[rsp], 0
$LN77@stbi__hdr_:
  00c2f	48 8b 84 24 50
	05 00 00	 mov	 rax, QWORD PTR tv267[rsp]
  00c37	e9 9e 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN49@stbi__hdr_:
$LN48@stbi__hdr_:

; 7255 :             }
; 7256 :          }
; 7257 : 
; 7258 :          for (k = 0; k < 4; ++k) {

  00c3c	c7 84 24 90 04
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  00c47	eb 10		 jmp	 SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
  00c49	8b 84 24 90 04
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00c50	ff c0		 inc	 eax
  00c52	89 84 24 90 04
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__hdr_:
  00c59	83 bc 24 90 04
	00 00 04	 cmp	 DWORD PTR k$[rsp], 4
  00c61	0f 8d c5 04 00
	00		 jge	 $LN17@stbi__hdr_

; 7259 :             int nleft;
; 7260 :             i = 0;

  00c67	c7 84 24 88 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
$LN19@stbi__hdr_:

; 7261 :             while ((nleft = width - i) > 0) {

  00c72	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00c79	8b 8c 24 68 04
	00 00		 mov	 ecx, DWORD PTR width$[rsp]
  00c80	2b c8		 sub	 ecx, eax
  00c82	8b c1		 mov	 eax, ecx
  00c84	89 84 24 e4 04
	00 00		 mov	 DWORD PTR nleft$9[rsp], eax
  00c8b	83 bc 24 e4 04
	00 00 00	 cmp	 DWORD PTR nleft$9[rsp], 0
  00c93	0f 8e 8e 04 00
	00		 jle	 $LN20@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00c99	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ca1	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ca9	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00cb0	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00cb7	73 4b		 jae	 SHORT $LN103@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00cb9	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cc1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00cc8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ccb	88 84 24 58 05
	00 00		 mov	 BYTE PTR tv463[rsp], al
  00cd2	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cda	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ce1	48 ff c0	 inc	 rax
  00ce4	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cec	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00cf3	0f b6 84 24 58
	05 00 00	 movzx	 eax, BYTE PTR tv463[rsp]
  00cfb	88 84 24 f5 04
	00 00		 mov	 BYTE PTR $T15[rsp], al
  00d02	eb 6e		 jmp	 SHORT $LN102@stbi__hdr_
$LN103@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00d04	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d0c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00d10	74 58		 je	 SHORT $LN104@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00d12	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d1a	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00d1f	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d27	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d2e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d31	88 84 24 59 05
	00 00		 mov	 BYTE PTR tv472[rsp], al
  00d38	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d40	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00d47	48 ff c0	 inc	 rax
  00d4a	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d52	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00d59	0f b6 84 24 59
	05 00 00	 movzx	 eax, BYTE PTR tv472[rsp]
  00d61	88 84 24 f5 04
	00 00		 mov	 BYTE PTR $T15[rsp], al
  00d68	eb 08		 jmp	 SHORT $LN102@stbi__hdr_
$LN104@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  00d6a	c6 84 24 f5 04
	00 00 00	 mov	 BYTE PTR $T15[rsp], 0
$LN102@stbi__hdr_:

; 7262 :                count = stbi__get8(s);

  00d72	0f b6 84 24 f5
	04 00 00	 movzx	 eax, BYTE PTR $T15[rsp]
  00d7a	88 84 24 84 04
	00 00		 mov	 BYTE PTR count$[rsp], al

; 7263 :                if (count > 128) {

  00d81	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00d89	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00d8e	0f 8e d7 01 00
	00		 jle	 $LN50@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00d94	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d9c	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00da4	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00dab	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00db2	73 4b		 jae	 SHORT $LN107@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  00db4	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dbc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00dc3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00dc6	88 84 24 5a 05
	00 00		 mov	 BYTE PTR tv480[rsp], al
  00dcd	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00dd5	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00ddc	48 ff c0	 inc	 rax
  00ddf	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00de7	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00dee	0f b6 84 24 5a
	05 00 00	 movzx	 eax, BYTE PTR tv480[rsp]
  00df6	88 84 24 f6 04
	00 00		 mov	 BYTE PTR $T16[rsp], al
  00dfd	eb 6e		 jmp	 SHORT $LN106@stbi__hdr_
$LN107@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  00dff	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e07	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00e0b	74 58		 je	 SHORT $LN108@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  00e0d	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e15	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00e1a	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e22	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e29	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e2c	88 84 24 5b 05
	00 00		 mov	 BYTE PTR tv489[rsp], al
  00e33	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e3b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00e42	48 ff c0	 inc	 rax
  00e45	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e4d	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00e54	0f b6 84 24 5b
	05 00 00	 movzx	 eax, BYTE PTR tv489[rsp]
  00e5c	88 84 24 f6 04
	00 00		 mov	 BYTE PTR $T16[rsp], al
  00e63	eb 08		 jmp	 SHORT $LN106@stbi__hdr_
$LN108@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  00e65	c6 84 24 f6 04
	00 00 00	 mov	 BYTE PTR $T16[rsp], 0
$LN106@stbi__hdr_:

; 7264 :                   // Run
; 7265 :                   value = stbi__get8(s);

  00e6d	0f b6 84 24 f6
	04 00 00	 movzx	 eax, BYTE PTR $T16[rsp]
  00e75	88 84 24 85 04
	00 00		 mov	 BYTE PTR value$[rsp], al

; 7266 :                   count -= 128;

  00e7c	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00e84	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00e89	88 84 24 84 04
	00 00		 mov	 BYTE PTR count$[rsp], al

; 7267 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  00e90	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00e98	85 c0		 test	 eax, eax
  00e9a	74 11		 je	 SHORT $LN53@stbi__hdr_
  00e9c	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00ea4	3b 84 24 e4 04
	00 00		 cmp	 eax, DWORD PTR nleft$9[rsp]
  00eab	7e 53		 jle	 SHORT $LN52@stbi__hdr_
$LN53@stbi__hdr_:
  00ead	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00eb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00ebb	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00ec3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00ec9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  00ed0	e8 00 00 00 00	 call	 stbi__err
  00ed5	85 c0		 test	 eax, eax
  00ed7	74 0e		 je	 SHORT $LN78@stbi__hdr_
  00ed9	48 c7 84 24 60
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv290[rsp], 0
  00ee5	eb 0c		 jmp	 SHORT $LN79@stbi__hdr_
$LN78@stbi__hdr_:
  00ee7	48 c7 84 24 60
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv290[rsp], 0
$LN79@stbi__hdr_:
  00ef3	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR tv290[rsp]
  00efb	e9 da 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN52@stbi__hdr_:

; 7268 :                   for (z = 0; z < count; ++z)

  00f00	c7 84 24 9c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR z$[rsp], 0
  00f0b	eb 10		 jmp	 SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
  00f0d	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  00f14	ff c0		 inc	 eax
  00f16	89 84 24 9c 04
	00 00		 mov	 DWORD PTR z$[rsp], eax
$LN23@stbi__hdr_:
  00f1d	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00f25	39 84 24 9c 04
	00 00		 cmp	 DWORD PTR z$[rsp], eax
  00f2c	7d 38		 jge	 SHORT $LN22@stbi__hdr_

; 7269 :                      scanline[i++ * 4 + k] = value;

  00f2e	8b 84 24 90 04
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00f35	8b 8c 24 88 04
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00f3c	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  00f3f	48 98		 cdqe
  00f41	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00f49	0f b6 94 24 85
	04 00 00	 movzx	 edx, BYTE PTR value$[rsp]
  00f51	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00f54	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00f5b	ff c0		 inc	 eax
  00f5d	89 84 24 88 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00f64	eb a7		 jmp	 SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 7270 :                } else {

  00f66	e9 b7 01 00 00	 jmp	 $LN51@stbi__hdr_
$LN50@stbi__hdr_:

; 7271 :                   // Dump
; 7272 :                   if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  00f6b	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00f73	85 c0		 test	 eax, eax
  00f75	74 11		 je	 SHORT $LN55@stbi__hdr_
  00f77	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  00f7f	3b 84 24 e4 04
	00 00		 cmp	 eax, DWORD PTR nleft$9[rsp]
  00f86	7e 53		 jle	 SHORT $LN54@stbi__hdr_
$LN55@stbi__hdr_:
  00f88	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00f90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00f96	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00f9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00fa4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DPPMCAKL@corrupt@
  00fab	e8 00 00 00 00	 call	 stbi__err
  00fb0	85 c0		 test	 eax, eax
  00fb2	74 0e		 je	 SHORT $LN80@stbi__hdr_
  00fb4	48 c7 84 24 68
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv309[rsp], 0
  00fc0	eb 0c		 jmp	 SHORT $LN81@stbi__hdr_
$LN80@stbi__hdr_:
  00fc2	48 c7 84 24 68
	05 00 00 00 00
	00 00		 mov	 QWORD PTR tv309[rsp], 0
$LN81@stbi__hdr_:
  00fce	48 8b 84 24 68
	05 00 00	 mov	 rax, QWORD PTR tv309[rsp]
  00fd6	e9 ff 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN54@stbi__hdr_:

; 7273 :                   for (z = 0; z < count; ++z)

  00fdb	c7 84 24 9c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR z$[rsp], 0
  00fe6	eb 10		 jmp	 SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
  00fe8	8b 84 24 9c 04
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  00fef	ff c0		 inc	 eax
  00ff1	89 84 24 9c 04
	00 00		 mov	 DWORD PTR z$[rsp], eax
$LN26@stbi__hdr_:
  00ff8	0f b6 84 24 84
	04 00 00	 movzx	 eax, BYTE PTR count$[rsp]
  01000	39 84 24 9c 04
	00 00		 cmp	 DWORD PTR z$[rsp], eax
  01007	0f 8d 15 01 00
	00		 jge	 $LN25@stbi__hdr_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0100d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01015	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0101d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  01024	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0102b	73 4b		 jae	 SHORT $LN111@stbi__hdr_

; 1615 :       return *s->img_buffer++;

  0102d	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0103c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0103f	88 84 24 70 05
	00 00		 mov	 BYTE PTR tv497[rsp], al
  01046	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0104e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  01055	48 ff c0	 inc	 rax
  01058	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01060	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  01067	0f b6 84 24 70
	05 00 00	 movzx	 eax, BYTE PTR tv497[rsp]
  0106f	88 84 24 f7 04
	00 00		 mov	 BYTE PTR $T17[rsp], al
  01076	eb 6e		 jmp	 SHORT $LN110@stbi__hdr_
$LN111@stbi__hdr_:

; 1616 :    if (s->read_from_callbacks) {

  01078	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01080	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01084	74 58		 je	 SHORT $LN112@stbi__hdr_

; 1617 :       stbi__refill_buffer(s);

  01086	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0108e	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  01093	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0109b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  010a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  010a5	88 84 24 71 05
	00 00		 mov	 BYTE PTR tv506[rsp], al
  010ac	48 8b 84 24 90
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010b4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  010bb	48 ff c0	 inc	 rax
  010be	48 8b 8c 24 90
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  010c6	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  010cd	0f b6 84 24 71
	05 00 00	 movzx	 eax, BYTE PTR tv506[rsp]
  010d5	88 84 24 f7 04
	00 00		 mov	 BYTE PTR $T17[rsp], al
  010dc	eb 08		 jmp	 SHORT $LN110@stbi__hdr_
$LN112@stbi__hdr_:

; 1619 :    }
; 1620 :    return 0;

  010de	c6 84 24 f7 04
	00 00 00	 mov	 BYTE PTR $T17[rsp], 0
$LN110@stbi__hdr_:

; 7274 :                      scanline[i++ * 4 + k] = stbi__get8(s);

  010e6	0f b6 84 24 f7
	04 00 00	 movzx	 eax, BYTE PTR $T17[rsp]
  010ee	8b 8c 24 90 04
	00 00		 mov	 ecx, DWORD PTR k$[rsp]
  010f5	8b 94 24 88 04
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  010fc	8d 0c 91	 lea	 ecx, DWORD PTR [rcx+rdx*4]
  010ff	48 63 c9	 movsxd	 rcx, ecx
  01102	48 8b 94 24 70
	04 00 00	 mov	 rdx, QWORD PTR scanline$[rsp]
  0110a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0110d	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01114	ff c0		 inc	 eax
  01116	89 84 24 88 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0111d	e9 c6 fe ff ff	 jmp	 $LN24@stbi__hdr_
$LN25@stbi__hdr_:
$LN51@stbi__hdr_:

; 7275 :                }
; 7276 :             }

  01122	e9 4b fb ff ff	 jmp	 $LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 7277 :          }

  01127	e9 1d fb ff ff	 jmp	 $LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 7278 :          for (i=0; i < width; ++i)

  0112c	c7 84 24 88 04
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01137	eb 10		 jmp	 SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
  01139	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01140	ff c0		 inc	 eax
  01142	89 84 24 88 04
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN29@stbi__hdr_:
  01149	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  01150	39 84 24 88 04
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  01157	7d 5a		 jge	 SHORT $LN28@stbi__hdr_

; 7279 :             stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);

  01159	8b 84 24 88 04
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01160	c1 e0 02	 shl	 eax, 2
  01163	48 98		 cdqe
  01165	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  0116d	48 03 c8	 add	 rcx, rax
  01170	48 8b c1	 mov	 rax, rcx
  01173	8b 8c 24 8c 04
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  0117a	0f af 8c 24 68
	04 00 00	 imul	 ecx, DWORD PTR width$[rsp]
  01182	03 8c 24 88 04
	00 00		 add	 ecx, DWORD PTR i$[rsp]
  01189	0f af 8c 24 b0
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  01191	48 63 c9	 movsxd	 rcx, ecx
  01194	48 8b 94 24 78
	04 00 00	 mov	 rdx, QWORD PTR hdr_data$[rsp]
  0119c	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  011a0	44 8b 84 24 b0
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  011a8	48 8b d0	 mov	 rdx, rax
  011ab	e8 00 00 00 00	 call	 stbi__hdr_convert
  011b0	90		 npad	 1
  011b1	eb 86		 jmp	 SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 7280 :       }

  011b3	e9 16 f4 ff ff	 jmp	 $LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 7281 :       if (scanline)

  011b8	48 83 bc 24 70
	04 00 00 00	 cmp	 QWORD PTR scanline$[rsp], 0
  011c1	74 0f		 je	 SHORT $LN56@stbi__hdr_

; 7282 :          STBI_FREE(scanline);

  011c3	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  011cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  011d1	90		 npad	 1
$LN56@stbi__hdr_:
$LN43@stbi__hdr_:

; 7283 :    }
; 7284 : 
; 7285 :    return hdr_data;

  011d2	48 8b 84 24 78
	04 00 00	 mov	 rax, QWORD PTR hdr_data$[rsp]
$LN1@stbi__hdr_:

; 7286 : }

  011da	48 8b f8	 mov	 rdi, rax
  011dd	48 8b cc	 mov	 rcx, rsp
  011e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__hdr_load$rtcFrameData
  011e7	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  011ec	48 8b c7	 mov	 rax, rdi
  011ef	48 8b 8c 24 78
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  011f7	48 33 cc	 xor	 rcx, rsp
  011fa	e8 00 00 00 00	 call	 __security_check_cookie
  011ff	48 81 c4 80 05
	00 00		 add	 rsp, 1408		; 00000580H
  01206	5f		 pop	 rdi
  01207	c3		 ret	 0
stbi__hdr_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
buffer$ = 48
token$ = 1096
valid$ = 1108
dummy$ = 1124
__$ArrayPad$ = 1152
s$ = 1184
x$ = 1192
y$ = 1200
comp$ = 1208
stbi__hdr_info PROC

; 7289 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 04
	00 00		 sub	 rsp, 1168		; 00000490H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 1c 01 00 00	 mov	 ecx, 284		; 0000011cH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR [rsp+1184]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7290 :    char buffer[STBI__HDR_BUFLEN];
; 7291 :    char *token;
; 7292 :    int valid = 0;

  00053	c7 84 24 54 04
	00 00 00 00 00
	00		 mov	 DWORD PTR valid$[rsp], 0

; 7293 :    int dummy;
; 7294 : 
; 7295 :    if (!x) x = &dummy;

  0005e	48 83 bc 24 a8
	04 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  00067	75 10		 jne	 SHORT $LN7@stbi__hdr_
  00069	48 8d 84 24 64
	04 00 00	 lea	 rax, QWORD PTR dummy$[rsp]
  00071	48 89 84 24 a8
	04 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN7@stbi__hdr_:

; 7296 :    if (!y) y = &dummy;

  00079	48 83 bc 24 b0
	04 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00082	75 10		 jne	 SHORT $LN8@stbi__hdr_
  00084	48 8d 84 24 64
	04 00 00	 lea	 rax, QWORD PTR dummy$[rsp]
  0008c	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN8@stbi__hdr_:

; 7297 :    if (!comp) comp = &dummy;

  00094	48 83 bc 24 b8
	04 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0009d	75 10		 jne	 SHORT $LN9@stbi__hdr_
  0009f	48 8d 84 24 64
	04 00 00	 lea	 rax, QWORD PTR dummy$[rsp]
  000a7	48 89 84 24 b8
	04 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN9@stbi__hdr_:

; 7298 : 
; 7299 :    if (stbi__hdr_test(s) == 0) {

  000af	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b7	e8 00 00 00 00	 call	 stbi__hdr_test
  000bc	85 c0		 test	 eax, eax
  000be	75 14		 jne	 SHORT $LN10@stbi__hdr_

; 7300 :        stbi__rewind( s );

  000c0	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c8	e8 00 00 00 00	 call	 stbi__rewind

; 7301 :        return 0;

  000cd	33 c0		 xor	 eax, eax
  000cf	e9 b1 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN10@stbi__hdr_:
$LN2@stbi__hdr_:

; 7302 :    }
; 7303 : 
; 7304 :    for(;;) {
; 7305 :       token = stbi__hdr_gettoken(s,buffer);

  000d4	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000d9	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e1	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  000e6	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7306 :       if (token[0] == 0) break;

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	48 6b c0 00	 imul	 rax, rax, 0
  000f7	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  000ff	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00103	85 c0		 test	 eax, eax
  00105	75 02		 jne	 SHORT $LN11@stbi__hdr_
  00107	eb 3b		 jmp	 SHORT $LN3@stbi__hdr_
$LN11@stbi__hdr_:

; 7307 :       if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  00109	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
  00118	48 2b c8	 sub	 rcx, rax
$LL17@stbi__hdr_:
  0011b	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0011e	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  00121	75 0b		 jne	 SHORT $LN19@stbi__hdr_
  00123	48 ff c0	 inc	 rax
  00126	84 d2		 test	 dl, dl
  00128	75 f1		 jne	 SHORT $LL17@stbi__hdr_
  0012a	33 c0		 xor	 eax, eax
  0012c	eb 05		 jmp	 SHORT $LN18@stbi__hdr_
$LN19@stbi__hdr_:
  0012e	1b c0		 sbb	 eax, eax
  00130	83 c8 01	 or	 eax, 1
$LN18@stbi__hdr_:
  00133	85 c0		 test	 eax, eax
  00135	75 0b		 jne	 SHORT $LN12@stbi__hdr_
  00137	c7 84 24 54 04
	00 00 01 00 00
	00		 mov	 DWORD PTR valid$[rsp], 1
$LN12@stbi__hdr_:

; 7308 :    }

  00142	eb 90		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7309 : 
; 7310 :    if (!valid) {

  00144	83 bc 24 54 04
	00 00 00	 cmp	 DWORD PTR valid$[rsp], 0
  0014c	75 14		 jne	 SHORT $LN13@stbi__hdr_

; 7311 :        stbi__rewind( s );

  0014e	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00156	e8 00 00 00 00	 call	 stbi__rewind

; 7312 :        return 0;

  0015b	33 c0		 xor	 eax, eax
  0015d	e9 23 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN13@stbi__hdr_:

; 7313 :    }
; 7314 :    token = stbi__hdr_gettoken(s,buffer);

  00162	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00167	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016f	e8 00 00 00 00	 call	 stbi__hdr_gettoken
  00174	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7315 :    if (strncmp(token, "-Y ", 3)) {

  0017c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
  00189	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00197	85 c0		 test	 eax, eax
  00199	74 14		 je	 SHORT $LN14@stbi__hdr_

; 7316 :        stbi__rewind( s );

  0019b	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a3	e8 00 00 00 00	 call	 stbi__rewind

; 7317 :        return 0;

  001a8	33 c0		 xor	 eax, eax
  001aa	e9 d6 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN14@stbi__hdr_:

; 7318 :    }
; 7319 :    token += 3;

  001af	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001b7	48 83 c0 03	 add	 rax, 3
  001bb	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7320 :    *y = (int) strtol(token, &token, 10);

  001c3	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001c9	48 8d 94 24 48
	04 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  001d1	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  001df	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  001e7	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__hdr_:

; 7321 :    while (*token == ' ') ++token;

  001e9	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001f1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f4	83 f8 20	 cmp	 eax, 32			; 00000020H
  001f7	75 15		 jne	 SHORT $LN6@stbi__hdr_
  001f9	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00201	48 ff c0	 inc	 rax
  00204	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR token$[rsp], rax
  0020c	eb db		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7322 :    if (strncmp(token, "+X ", 3)) {

  0020e	41 b8 03 00 00
	00		 mov	 r8d, 3
  00214	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
  0021b	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00229	85 c0		 test	 eax, eax
  0022b	74 11		 je	 SHORT $LN15@stbi__hdr_

; 7323 :        stbi__rewind( s );

  0022d	48 8b 8c 24 a0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00235	e8 00 00 00 00	 call	 stbi__rewind

; 7324 :        return 0;

  0023a	33 c0		 xor	 eax, eax
  0023c	eb 47		 jmp	 SHORT $LN1@stbi__hdr_
$LN15@stbi__hdr_:

; 7325 :    }
; 7326 :    token += 3;

  0023e	48 8b 84 24 48
	04 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00246	48 83 c0 03	 add	 rax, 3
  0024a	48 89 84 24 48
	04 00 00	 mov	 QWORD PTR token$[rsp], rax

; 7327 :    *x = (int) strtol(token, NULL, 10);

  00252	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00258	33 d2		 xor	 edx, edx
  0025a	48 8b 8c 24 48
	04 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  00268	48 8b 8c 24 a8
	04 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00270	89 01		 mov	 DWORD PTR [rcx], eax

; 7328 :    *comp = 3;

  00272	48 8b 84 24 b8
	04 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0027a	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 7329 :    return 1;

  00280	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7330 : }

  00285	48 8b f8	 mov	 rdi, rax
  00288	48 8b cc	 mov	 rcx, rsp
  0028b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__hdr_info$rtcFrameData
  00292	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00297	48 8b c7	 mov	 rax, rdi
  0029a	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a2	48 33 cc	 xor	 rcx, rsp
  002a5	e8 00 00 00 00	 call	 __security_check_cookie
  002aa	48 81 c4 90 04
	00 00		 add	 rsp, 1168		; 00000490H
  002b1	5f		 pop	 rdi
  002b2	c3		 ret	 0
stbi__hdr_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 32
info$ = 56
tv77 = 112
__$ArrayPad$ = 120
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
stbi__bmp_info PROC

; 7335 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 18 00 00 00	 mov	 ecx, 24
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004b	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7336 :    void *p;
; 7337 :    stbi__bmp_data info;
; 7338 : 
; 7339 :    info.all_a = 255;

  00050	c7 44 24 54 ff
	00 00 00	 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 7340 :    p = stbi__bmp_parse_header(s, &info);

  00058	48 8d 54 24 38	 lea	 rdx, QWORD PTR info$[rsp]
  0005d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00065	e8 00 00 00 00	 call	 stbi__bmp_parse_header
  0006a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 7341 :    if (p == NULL) {

  0006f	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00075	75 14		 jne	 SHORT $LN2@stbi__bmp_

; 7342 :       stbi__rewind( s );

  00077	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0007f	e8 00 00 00 00	 call	 stbi__rewind

; 7343 :       return 0;

  00084	33 c0		 xor	 eax, eax
  00086	e9 97 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 7344 :    }
; 7345 :    if (x) *x = s->img_x;

  0008b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  00094	74 14		 je	 SHORT $LN3@stbi__bmp_
  00096	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a6	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000a8	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@stbi__bmp_:

; 7346 :    if (y) *y = s->img_y;

  000aa	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  000b3	74 15		 je	 SHORT $LN4@stbi__bmp_
  000b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__bmp_:

; 7347 :    if (comp) {

  000ca	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  000d3	74 48		 je	 SHORT $LN5@stbi__bmp_

; 7348 :       if (info.bpp == 24 && info.ma == 0xff000000)

  000d5	83 7c 24 38 18	 cmp	 DWORD PTR info$[rsp], 24
  000da	75 1a		 jne	 SHORT $LN6@stbi__bmp_
  000dc	81 7c 24 50 00
	00 00 ff	 cmp	 DWORD PTR info$[rsp+24], -16777216 ; ff000000H
  000e4	75 10		 jne	 SHORT $LN6@stbi__bmp_

; 7349 :          *comp = 3;

  000e6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000ee	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
  000f4	eb 27		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 7350 :       else
; 7351 :          *comp = info.ma ? 4 : 3;

  000f6	83 7c 24 50 00	 cmp	 DWORD PTR info$[rsp+24], 0
  000fb	74 0a		 je	 SHORT $LN9@stbi__bmp_
  000fd	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv77[rsp], 4
  00105	eb 08		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:
  00107	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR tv77[rsp], 3
$LN10@stbi__bmp_:
  0010f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00117	8b 4c 24 70	 mov	 ecx, DWORD PTR tv77[rsp]
  0011b	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 7352 :    }
; 7353 :    return 1;

  0011d	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 7354 : }

  00122	48 8b f8	 mov	 rdi, rax
  00125	48 8b cc	 mov	 rcx, rsp
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__bmp_info$rtcFrameData
  0012f	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00134	48 8b c7	 mov	 rax, rdi
  00137	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0013c	48 33 cc	 xor	 rcx, rsp
  0013f	e8 00 00 00 00	 call	 __security_check_cookie
  00144	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
stbi__bmp_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
channelCount$ = 32
dummy$ = 52
depth$ = 68
__$ArrayPad$ = 80
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
stbi__psd_info PROC

; 7359 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 10 00 00 00	 mov	 ecx, 16
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00036	48 33 c4	 xor	 rax, rsp
  00039	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00045	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7360 :    int channelCount, dummy, depth;
; 7361 :    if (!x) x = &dummy;

  0004a	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00050	75 0a		 jne	 SHORT $LN2@stbi__psd_
  00052	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  00057	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__psd_:

; 7362 :    if (!y) y = &dummy;

  0005c	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00065	75 0d		 jne	 SHORT $LN3@stbi__psd_
  00067	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  0006c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__psd_:

; 7363 :    if (!comp) comp = &dummy;

  00074	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0007d	75 0d		 jne	 SHORT $LN4@stbi__psd_
  0007f	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  00084	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__psd_:

; 7364 :    if (stbi__get32be(s) != 0x38425053) {

  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00091	e8 00 00 00 00	 call	 stbi__get32be
  00096	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0009b	74 11		 je	 SHORT $LN5@stbi__psd_

; 7365 :        stbi__rewind( s );

  0009d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	e8 00 00 00 00	 call	 stbi__rewind

; 7366 :        return 0;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 d8 00 00 00	 jmp	 $LN1@stbi__psd_
$LN5@stbi__psd_:

; 7367 :    }
; 7368 :    if (stbi__get16be(s) != 1) {

  000ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000b3	e8 00 00 00 00	 call	 stbi__get16be
  000b8	83 f8 01	 cmp	 eax, 1
  000bb	74 11		 je	 SHORT $LN6@stbi__psd_

; 7369 :        stbi__rewind( s );

  000bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000c2	e8 00 00 00 00	 call	 stbi__rewind

; 7370 :        return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 b8 00 00 00	 jmp	 $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7371 :    }
; 7372 :    stbi__skip(s, 6);

  000ce	ba 06 00 00 00	 mov	 edx, 6
  000d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000d8	e8 00 00 00 00	 call	 stbi__skip

; 7373 :    channelCount = stbi__get16be(s);

  000dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000e2	e8 00 00 00 00	 call	 stbi__get16be
  000e7	89 44 24 20	 mov	 DWORD PTR channelCount$[rsp], eax

; 7374 :    if (channelCount < 0 || channelCount > 16) {

  000eb	83 7c 24 20 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000f0	7c 07		 jl	 SHORT $LN8@stbi__psd_
  000f2	83 7c 24 20 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000f7	7e 0e		 jle	 SHORT $LN7@stbi__psd_
$LN8@stbi__psd_:

; 7375 :        stbi__rewind( s );

  000f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000fe	e8 00 00 00 00	 call	 stbi__rewind

; 7376 :        return 0;

  00103	33 c0		 xor	 eax, eax
  00105	eb 7f		 jmp	 SHORT $LN1@stbi__psd_
$LN7@stbi__psd_:

; 7377 :    }
; 7378 :    *y = stbi__get32be(s);

  00107	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	e8 00 00 00 00	 call	 stbi__get32be
  00111	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  00119	89 01		 mov	 DWORD PTR [rcx], eax

; 7379 :    *x = stbi__get32be(s);

  0011b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00120	e8 00 00 00 00	 call	 stbi__get32be
  00125	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  0012a	89 01		 mov	 DWORD PTR [rcx], eax

; 7380 :    depth = stbi__get16be(s);

  0012c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00131	e8 00 00 00 00	 call	 stbi__get16be
  00136	89 44 24 44	 mov	 DWORD PTR depth$[rsp], eax

; 7381 :    if (depth != 8 && depth != 16) {

  0013a	83 7c 24 44 08	 cmp	 DWORD PTR depth$[rsp], 8
  0013f	74 15		 je	 SHORT $LN9@stbi__psd_
  00141	83 7c 24 44 10	 cmp	 DWORD PTR depth$[rsp], 16
  00146	74 0e		 je	 SHORT $LN9@stbi__psd_

; 7382 :        stbi__rewind( s );

  00148	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0014d	e8 00 00 00 00	 call	 stbi__rewind

; 7383 :        return 0;

  00152	33 c0		 xor	 eax, eax
  00154	eb 30		 jmp	 SHORT $LN1@stbi__psd_
$LN9@stbi__psd_:

; 7384 :    }
; 7385 :    if (stbi__get16be(s) != 3) {

  00156	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0015b	e8 00 00 00 00	 call	 stbi__get16be
  00160	83 f8 03	 cmp	 eax, 3
  00163	74 0e		 je	 SHORT $LN10@stbi__psd_

; 7386 :        stbi__rewind( s );

  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0016a	e8 00 00 00 00	 call	 stbi__rewind

; 7387 :        return 0;

  0016f	33 c0		 xor	 eax, eax
  00171	eb 13		 jmp	 SHORT $LN1@stbi__psd_
$LN10@stbi__psd_:

; 7388 :    }
; 7389 :    *comp = 4;

  00173	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0017b	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 7390 :    return 1;

  00181	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7391 : }

  00186	48 8b f8	 mov	 rdi, rax
  00189	48 8b cc	 mov	 rcx, rsp
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__psd_info$rtcFrameData
  00193	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00198	48 8b c7	 mov	 rax, rdi
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a0	48 33 cc	 xor	 rcx, rsp
  001a3	e8 00 00 00 00	 call	 __security_check_cookie
  001a8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001ac	5f		 pop	 rdi
  001ad	c3		 ret	 0
stbi__psd_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
channelCount$ = 32
depth$ = 36
s$ = 64
stbi__psd_is16 PROC

; 7394 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7395 :    int channelCount, depth;
; 7396 :    if (stbi__get32be(s) != 0x38425053) {

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__get32be
  00020	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00025	74 11		 je	 SHORT $LN2@stbi__psd_

; 7397 :        stbi__rewind( s );

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 stbi__rewind

; 7398 :        return 0;

  00031	33 c0		 xor	 eax, eax
  00033	e9 92 00 00 00	 jmp	 $LN1@stbi__psd_
$LN2@stbi__psd_:

; 7399 :    }
; 7400 :    if (stbi__get16be(s) != 1) {

  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	e8 00 00 00 00	 call	 stbi__get16be
  00042	83 f8 01	 cmp	 eax, 1
  00045	74 0e		 je	 SHORT $LN3@stbi__psd_

; 7401 :        stbi__rewind( s );

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004c	e8 00 00 00 00	 call	 stbi__rewind

; 7402 :        return 0;

  00051	33 c0		 xor	 eax, eax
  00053	eb 75		 jmp	 SHORT $LN1@stbi__psd_
$LN3@stbi__psd_:

; 7403 :    }
; 7404 :    stbi__skip(s, 6);

  00055	ba 06 00 00 00	 mov	 edx, 6
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	e8 00 00 00 00	 call	 stbi__skip

; 7405 :    channelCount = stbi__get16be(s);

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00069	e8 00 00 00 00	 call	 stbi__get16be
  0006e	89 44 24 20	 mov	 DWORD PTR channelCount$[rsp], eax

; 7406 :    if (channelCount < 0 || channelCount > 16) {

  00072	83 7c 24 20 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  00077	7c 07		 jl	 SHORT $LN5@stbi__psd_
  00079	83 7c 24 20 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  0007e	7e 0e		 jle	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 7407 :        stbi__rewind( s );

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00085	e8 00 00 00 00	 call	 stbi__rewind

; 7408 :        return 0;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 3c		 jmp	 SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 7409 :    }
; 7410 :    STBI_NOTUSED(stbi__get32be(s));

  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 stbi__get32be

; 7411 :    STBI_NOTUSED(stbi__get32be(s));

  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009d	e8 00 00 00 00	 call	 stbi__get32be

; 7412 :    depth = stbi__get16be(s);

  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a7	e8 00 00 00 00	 call	 stbi__get16be
  000ac	89 44 24 24	 mov	 DWORD PTR depth$[rsp], eax

; 7413 :    if (depth != 16) {

  000b0	83 7c 24 24 10	 cmp	 DWORD PTR depth$[rsp], 16
  000b5	74 0e		 je	 SHORT $LN6@stbi__psd_

; 7414 :        stbi__rewind( s );

  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000bc	e8 00 00 00 00	 call	 stbi__rewind

; 7415 :        return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 05		 jmp	 SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7416 :    }
; 7417 :    return 1;

  000c5	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7418 : }

  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
stbi__psd_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
act_comp$ = 32
num_packets$ = 36
chained$ = 40
dummy$ = 52
packets$ = 88
packet$5 = 136
$T6 = 152
$T7 = 156
$T8 = 157
$T9 = 158
$T10 = 159
$T11 = 160
tv166 = 164
tv174 = 168
tv183 = 169
tv191 = 170
tv200 = 171
tv208 = 172
tv217 = 173
tv225 = 174
tv234 = 175
tv246 = 176
tv152 = 180
__$ArrayPad$ = 184
s$ = 208
x$ = 216
y$ = 224
comp$ = 232
stbi__pic_info PROC

; 7423 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+208]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7424 :    int act_comp=0,num_packets=0,chained,dummy;

  00053	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  0005b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0

; 7425 :    stbi__pic_packet packets[10];
; 7426 : 
; 7427 :    if (!x) x = &dummy;

  00063	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  0006c	75 0d		 jne	 SHORT $LN5@stbi__pic_
  0006e	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  00073	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN5@stbi__pic_:

; 7428 :    if (!y) y = &dummy;

  0007b	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00084	75 0d		 jne	 SHORT $LN6@stbi__pic_
  00086	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  0008b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN6@stbi__pic_:

; 7429 :    if (!comp) comp = &dummy;

  00093	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0009c	75 0d		 jne	 SHORT $LN7@stbi__pic_
  0009e	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  000a3	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN7@stbi__pic_:

; 7430 : 
; 7431 :    if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
  000b2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ba	e8 00 00 00 00	 call	 stbi__pic_is4
  000bf	85 c0		 test	 eax, eax
  000c1	75 14		 jne	 SHORT $LN8@stbi__pic_

; 7432 :       stbi__rewind(s);

  000c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cb	e8 00 00 00 00	 call	 stbi__rewind

; 7433 :       return 0;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 55 06 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 7434 :    }
; 7435 : 
; 7436 :    stbi__skip(s, 88);

  000d7	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  000dc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 stbi__skip

; 7437 : 
; 7438 :    *x = stbi__get16be(s);

  000e9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 stbi__get16be
  000f6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  000fe	89 01		 mov	 DWORD PTR [rcx], eax

; 7439 :    *y = stbi__get16be(s);

  00100	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00108	e8 00 00 00 00	 call	 stbi__get16be
  0010d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  00115	89 01		 mov	 DWORD PTR [rcx], eax

; 1628 :    if (s->io.read) {

  00117	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0011f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00124	74 43		 je	 SHORT $LN18@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00126	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0012e	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00132	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013a	ff 50 20	 call	 QWORD PTR [rax+32]
  0013d	85 c0		 test	 eax, eax
  0013f	75 0d		 jne	 SHORT $LN19@stbi__pic_
  00141	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR $T6[rsp], 0
  0014c	eb 61		 jmp	 SHORT $LN17@stbi__pic_
$LN19@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0014e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00156	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0015a	75 0d		 jne	 SHORT $LN20@stbi__pic_
  0015c	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR $T6[rsp], 1
  00167	eb 46		 jmp	 SHORT $LN17@stbi__pic_
$LN20@stbi__pic_:
$LN18@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00169	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00171	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00179	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00180	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00187	72 0d		 jb	 SHORT $LN22@stbi__pic_
  00189	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv166[rsp], 1
  00194	eb 0b		 jmp	 SHORT $LN23@stbi__pic_
$LN22@stbi__pic_:
  00196	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv166[rsp], 0
$LN23@stbi__pic_:
  001a1	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv166[rsp]
  001a8	89 84 24 98 00
	00 00		 mov	 DWORD PTR $T6[rsp], eax
$LN17@stbi__pic_:

; 7440 :    if (stbi__at_eof(s)) {

  001af	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR $T6[rsp]
  001b6	85 c0		 test	 eax, eax
  001b8	74 14		 je	 SHORT $LN9@stbi__pic_

; 7441 :       stbi__rewind( s);

  001ba	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001c2	e8 00 00 00 00	 call	 stbi__rewind

; 7442 :       return 0;

  001c7	33 c0		 xor	 eax, eax
  001c9	e9 5e 05 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 7443 :    }
; 7444 :    if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {

  001ce	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001d6	83 38 00	 cmp	 DWORD PTR [rax], 0
  001d9	74 30		 je	 SHORT $LN10@stbi__pic_
  001db	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  001e0	99		 cdq
  001e1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  001e9	f7 39		 idiv	 DWORD PTR [rcx]
  001eb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  001f3	3b 01		 cmp	 eax, DWORD PTR [rcx]
  001f5	7d 14		 jge	 SHORT $LN10@stbi__pic_

; 7445 :       stbi__rewind( s );

  001f7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001ff	e8 00 00 00 00	 call	 stbi__rewind

; 7446 :       return 0;

  00204	33 c0		 xor	 eax, eax
  00206	e9 21 05 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 7447 :    }
; 7448 : 
; 7449 :    stbi__skip(s, 8);

  0020b	ba 08 00 00 00	 mov	 edx, 8
  00210	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00218	e8 00 00 00 00	 call	 stbi__skip
  0021d	90		 npad	 1
$LN4@stbi__pic_:

; 7450 : 
; 7451 :    do {
; 7452 :       stbi__pic_packet *packet;
; 7453 : 
; 7454 :       if (num_packets==sizeof(packets)/sizeof(packets[0]))

  0021e	48 63 44 24 24	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00223	48 83 f8 0a	 cmp	 rax, 10
  00227	75 07		 jne	 SHORT $LN11@stbi__pic_

; 7455 :          return 0;

  00229	33 c0		 xor	 eax, eax
  0022b	e9 fc 04 00 00	 jmp	 $LN1@stbi__pic_
$LN11@stbi__pic_:

; 7456 : 
; 7457 :       packet = &packets[num_packets++];

  00230	48 63 44 24 24	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00235	48 6b c0 03	 imul	 rax, rax, 3
  00239	48 8d 44 04 58	 lea	 rax, QWORD PTR packets$[rsp+rax]
  0023e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR packet$5[rsp], rax
  00246	8b 44 24 24	 mov	 eax, DWORD PTR num_packets$[rsp]
  0024a	ff c0		 inc	 eax
  0024c	89 44 24 24	 mov	 DWORD PTR num_packets$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00250	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00258	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00260	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00267	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0026e	73 4b		 jae	 SHORT $LN25@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00270	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00278	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0027f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00282	88 84 24 a8 00
	00 00		 mov	 BYTE PTR tv174[rsp], al
  00289	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00291	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00298	48 ff c0	 inc	 rax
  0029b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a3	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002aa	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv174[rsp]
  002b2	88 84 24 9c 00
	00 00		 mov	 BYTE PTR $T7[rsp], al
  002b9	eb 6e		 jmp	 SHORT $LN24@stbi__pic_
$LN25@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  002bb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c3	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002c7	74 58		 je	 SHORT $LN26@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  002c9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002d1	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  002d6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002de	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e8	88 84 24 a9 00
	00 00		 mov	 BYTE PTR tv183[rsp], al
  002ef	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002fe	48 ff c0	 inc	 rax
  00301	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00309	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00310	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR tv183[rsp]
  00318	88 84 24 9c 00
	00 00		 mov	 BYTE PTR $T7[rsp], al
  0031f	eb 08		 jmp	 SHORT $LN24@stbi__pic_
$LN26@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00321	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR $T7[rsp], 0
$LN24@stbi__pic_:

; 7458 :       chained = stbi__get8(s);

  00329	0f b6 84 24 9c
	00 00 00	 movzx	 eax, BYTE PTR $T7[rsp]
  00331	0f b6 c0	 movzx	 eax, al
  00334	89 44 24 28	 mov	 DWORD PTR chained$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00338	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00340	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00348	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0034f	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00356	73 4b		 jae	 SHORT $LN29@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00358	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00360	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00367	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0036a	88 84 24 aa 00
	00 00		 mov	 BYTE PTR tv191[rsp], al
  00371	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00379	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00380	48 ff c0	 inc	 rax
  00383	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00392	0f b6 84 24 aa
	00 00 00	 movzx	 eax, BYTE PTR tv191[rsp]
  0039a	88 84 24 9d 00
	00 00		 mov	 BYTE PTR $T8[rsp], al
  003a1	eb 6e		 jmp	 SHORT $LN28@stbi__pic_
$LN29@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  003a3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ab	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  003af	74 58		 je	 SHORT $LN30@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  003b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b9	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  003be	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003c6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003cd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003d0	88 84 24 ab 00
	00 00		 mov	 BYTE PTR tv200[rsp], al
  003d7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003df	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  003e6	48 ff c0	 inc	 rax
  003e9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f1	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  003f8	0f b6 84 24 ab
	00 00 00	 movzx	 eax, BYTE PTR tv200[rsp]
  00400	88 84 24 9d 00
	00 00		 mov	 BYTE PTR $T8[rsp], al
  00407	eb 08		 jmp	 SHORT $LN28@stbi__pic_
$LN30@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  00409	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR $T8[rsp], 0
$LN28@stbi__pic_:

; 7459 :       packet->size    = stbi__get8(s);

  00411	0f b6 84 24 9d
	00 00 00	 movzx	 eax, BYTE PTR $T8[rsp]
  00419	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR packet$5[rsp]
  00421	88 01		 mov	 BYTE PTR [rcx], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00423	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0042b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00433	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0043a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00441	73 4b		 jae	 SHORT $LN33@stbi__pic_

; 1615 :       return *s->img_buffer++;

  00443	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0044b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00452	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00455	88 84 24 ac 00
	00 00		 mov	 BYTE PTR tv208[rsp], al
  0045c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00464	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0046b	48 ff c0	 inc	 rax
  0046e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00476	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0047d	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR tv208[rsp]
  00485	88 84 24 9e 00
	00 00		 mov	 BYTE PTR $T9[rsp], al
  0048c	eb 6e		 jmp	 SHORT $LN32@stbi__pic_
$LN33@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  0048e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00496	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0049a	74 58		 je	 SHORT $LN34@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  0049c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a4	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  004a9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b1	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004b8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004bb	88 84 24 ad 00
	00 00		 mov	 BYTE PTR tv217[rsp], al
  004c2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  004d1	48 ff c0	 inc	 rax
  004d4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004dc	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  004e3	0f b6 84 24 ad
	00 00 00	 movzx	 eax, BYTE PTR tv217[rsp]
  004eb	88 84 24 9e 00
	00 00		 mov	 BYTE PTR $T9[rsp], al
  004f2	eb 08		 jmp	 SHORT $LN32@stbi__pic_
$LN34@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  004f4	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR $T9[rsp], 0
$LN32@stbi__pic_:

; 7460 :       packet->type    = stbi__get8(s);

  004fc	0f b6 84 24 9e
	00 00 00	 movzx	 eax, BYTE PTR $T9[rsp]
  00504	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR packet$5[rsp]
  0050c	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0050f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00517	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0051f	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00526	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0052d	73 4b		 jae	 SHORT $LN37@stbi__pic_

; 1615 :       return *s->img_buffer++;

  0052f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00537	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0053e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00541	88 84 24 ae 00
	00 00		 mov	 BYTE PTR tv225[rsp], al
  00548	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00550	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00557	48 ff c0	 inc	 rax
  0055a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00562	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00569	0f b6 84 24 ae
	00 00 00	 movzx	 eax, BYTE PTR tv225[rsp]
  00571	88 84 24 9f 00
	00 00		 mov	 BYTE PTR $T10[rsp], al
  00578	eb 6e		 jmp	 SHORT $LN36@stbi__pic_
$LN37@stbi__pic_:

; 1616 :    if (s->read_from_callbacks) {

  0057a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00582	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00586	74 58		 je	 SHORT $LN38@stbi__pic_

; 1617 :       stbi__refill_buffer(s);

  00588	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00590	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00595	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0059d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005a7	88 84 24 af 00
	00 00		 mov	 BYTE PTR tv234[rsp], al
  005ae	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005b6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  005bd	48 ff c0	 inc	 rax
  005c0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005c8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  005cf	0f b6 84 24 af
	00 00 00	 movzx	 eax, BYTE PTR tv234[rsp]
  005d7	88 84 24 9f 00
	00 00		 mov	 BYTE PTR $T10[rsp], al
  005de	eb 08		 jmp	 SHORT $LN36@stbi__pic_
$LN38@stbi__pic_:

; 1619 :    }
; 1620 :    return 0;

  005e0	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR $T10[rsp], 0
$LN36@stbi__pic_:

; 7461 :       packet->channel = stbi__get8(s);

  005e8	0f b6 84 24 9f
	00 00 00	 movzx	 eax, BYTE PTR $T10[rsp]
  005f0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR packet$5[rsp]
  005f8	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 7462 :       act_comp |= packet->channel;

  005fb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR packet$5[rsp]
  00603	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00607	8b 4c 24 20	 mov	 ecx, DWORD PTR act_comp$[rsp]
  0060b	0b c8		 or	 ecx, eax
  0060d	8b c1		 mov	 eax, ecx
  0060f	89 44 24 20	 mov	 DWORD PTR act_comp$[rsp], eax

; 1628 :    if (s->io.read) {

  00613	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00620	74 43		 je	 SHORT $LN41@stbi__pic_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00622	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0062a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0062e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00636	ff 50 20	 call	 QWORD PTR [rax+32]
  00639	85 c0		 test	 eax, eax
  0063b	75 0d		 jne	 SHORT $LN42@stbi__pic_
  0063d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR $T11[rsp], 0
  00648	eb 61		 jmp	 SHORT $LN40@stbi__pic_
$LN42@stbi__pic_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0064a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00652	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00656	75 0d		 jne	 SHORT $LN43@stbi__pic_
  00658	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR $T11[rsp], 1
  00663	eb 46		 jmp	 SHORT $LN40@stbi__pic_
$LN43@stbi__pic_:
$LN41@stbi__pic_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00665	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0066d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00675	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0067c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00683	72 0d		 jb	 SHORT $LN45@stbi__pic_
  00685	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv246[rsp], 1
  00690	eb 0b		 jmp	 SHORT $LN46@stbi__pic_
$LN45@stbi__pic_:
  00692	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv246[rsp], 0
$LN46@stbi__pic_:
  0069d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv246[rsp]
  006a4	89 84 24 a0 00
	00 00		 mov	 DWORD PTR $T11[rsp], eax
$LN40@stbi__pic_:

; 7463 : 
; 7464 :       if (stbi__at_eof(s)) {

  006ab	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR $T11[rsp]
  006b2	85 c0		 test	 eax, eax
  006b4	74 11		 je	 SHORT $LN12@stbi__pic_

; 7465 :           stbi__rewind( s );

  006b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006be	e8 00 00 00 00	 call	 stbi__rewind

; 7466 :           return 0;

  006c3	33 c0		 xor	 eax, eax
  006c5	eb 65		 jmp	 SHORT $LN1@stbi__pic_
$LN12@stbi__pic_:

; 7467 :       }
; 7468 :       if (packet->size != 8) {

  006c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR packet$5[rsp]
  006cf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006d2	83 f8 08	 cmp	 eax, 8
  006d5	74 11		 je	 SHORT $LN13@stbi__pic_

; 7469 :           stbi__rewind( s );

  006d7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006df	e8 00 00 00 00	 call	 stbi__rewind

; 7470 :           return 0;

  006e4	33 c0		 xor	 eax, eax
  006e6	eb 44		 jmp	 SHORT $LN1@stbi__pic_
$LN13@stbi__pic_:

; 7471 :       }
; 7472 :    } while (chained);

  006e8	83 7c 24 28 00	 cmp	 DWORD PTR chained$[rsp], 0
  006ed	0f 85 2b fb ff
	ff		 jne	 $LN4@stbi__pic_

; 7473 : 
; 7474 :    *comp = (act_comp & 0x10 ? 4 : 3);

  006f3	8b 44 24 20	 mov	 eax, DWORD PTR act_comp$[rsp]
  006f7	83 e0 10	 and	 eax, 16
  006fa	85 c0		 test	 eax, eax
  006fc	74 0d		 je	 SHORT $LN15@stbi__pic_
  006fe	c7 84 24 b4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv152[rsp], 4
  00709	eb 0b		 jmp	 SHORT $LN16@stbi__pic_
$LN15@stbi__pic_:
  0070b	c7 84 24 b4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv152[rsp], 3
$LN16@stbi__pic_:
  00716	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0071e	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv152[rsp]
  00725	89 08		 mov	 DWORD PTR [rax], ecx

; 7475 : 
; 7476 :    return 1;

  00727	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 7477 : }

  0072c	48 8b f8	 mov	 rdi, rax
  0072f	48 8b cc	 mov	 rcx, rsp
  00732	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pic_info$rtcFrameData
  00739	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0073e	48 8b c7	 mov	 rax, rdi
  00741	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00749	48 33 cc	 xor	 rcx, rsp
  0074c	e8 00 00 00 00	 call	 __security_check_cookie
  00751	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00758	5f		 pop	 rdi
  00759	c3		 ret	 0
stbi__pic_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
p$ = 32
t$ = 33
$T1 = 34
$T2 = 35
tv84 = 36
tv93 = 37
tv133 = 38
tv142 = 39
s$ = 64
stbi__pnm_test PROC

; 7494 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00027	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0002e	73 39		 jae	 SHORT $LN6@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003f	88 44 24 24	 mov	 BYTE PTR tv84[rsp], al
  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00048	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004f	48 ff c0	 inc	 rax
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00057	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0005e	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv84[rsp]
  00063	88 44 24 22	 mov	 BYTE PTR $T1[rsp], al
  00067	eb 53		 jmp	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00072	74 43		 je	 SHORT $LN7@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00079	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	88 44 24 25	 mov	 BYTE PTR tv93[rsp], al
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00096	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0009d	48 ff c0	 inc	 rax
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ac	0f b6 44 24 25	 movzx	 eax, BYTE PTR tv93[rsp]
  000b1	88 44 24 22	 mov	 BYTE PTR $T1[rsp], al
  000b5	eb 05		 jmp	 SHORT $LN5@stbi__pnm_
$LN7@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  000b7	c6 44 24 22 00	 mov	 BYTE PTR $T1[rsp], 0
$LN5@stbi__pnm_:

; 7495 :    char p, t;
; 7496 :    p = (char) stbi__get8(s);

  000bc	0f b6 44 24 22	 movzx	 eax, BYTE PTR $T1[rsp]
  000c1	88 44 24 20	 mov	 BYTE PTR p$[rsp], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000d6	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000dd	73 39		 jae	 SHORT $LN10@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  000df	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000e4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000eb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ee	88 44 24 26	 mov	 BYTE PTR tv133[rsp], al
  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000f7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000fe	48 ff c0	 inc	 rax
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00106	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0010d	0f b6 44 24 26	 movzx	 eax, BYTE PTR tv133[rsp]
  00112	88 44 24 23	 mov	 BYTE PTR $T2[rsp], al
  00116	eb 53		 jmp	 SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  00118	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0011d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00121	74 43		 je	 SHORT $LN11@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  00123	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00128	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00132	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00139	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013c	88 44 24 27	 mov	 BYTE PTR tv142[rsp], al
  00140	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00145	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0014c	48 ff c0	 inc	 rax
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00154	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0015b	0f b6 44 24 27	 movzx	 eax, BYTE PTR tv142[rsp]
  00160	88 44 24 23	 mov	 BYTE PTR $T2[rsp], al
  00164	eb 05		 jmp	 SHORT $LN9@stbi__pnm_
$LN11@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  00166	c6 44 24 23 00	 mov	 BYTE PTR $T2[rsp], 0
$LN9@stbi__pnm_:

; 7497 :    t = (char) stbi__get8(s);

  0016b	0f b6 44 24 23	 movzx	 eax, BYTE PTR $T2[rsp]
  00170	88 44 24 21	 mov	 BYTE PTR t$[rsp], al

; 7498 :    if (p != 'P' || (t != '5' && t != '6')) {

  00174	0f be 44 24 20	 movsx	 eax, BYTE PTR p$[rsp]
  00179	83 f8 50	 cmp	 eax, 80			; 00000050H
  0017c	75 14		 jne	 SHORT $LN3@stbi__pnm_
  0017e	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  00183	83 f8 35	 cmp	 eax, 53			; 00000035H
  00186	74 18		 je	 SHORT $LN2@stbi__pnm_
  00188	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  0018d	83 f8 36	 cmp	 eax, 54			; 00000036H
  00190	74 0e		 je	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7499 :        stbi__rewind( s );

  00192	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00197	e8 00 00 00 00	 call	 stbi__rewind

; 7500 :        return 0;

  0019c	33 c0		 xor	 eax, eax
  0019e	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7501 :    }
; 7502 :    return 1;

  001a0	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pnm_:

; 7503 : }

  001a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a9	5f		 pop	 rdi
  001aa	c3		 ret	 0
stbi__pnm_test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
out$ = 48
tv80 = 56
tv86 = 64
tv138 = 72
tv154 = 80
tv160 = 88
tv172 = 96
s$ = 128
x$ = 136
y$ = 144
comp$ = 152
req_comp$ = 160
ri$ = 168
stbi__pnm_load PROC

; 7506 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7507 :    stbi_uc *out;
; 7508 :    STBI_NOTUSED(ri);
; 7509 : 
; 7510 :    ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);

  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0002d	48 83 c0 08	 add	 rax, 8
  00031	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00039	48 83 c1 04	 add	 rcx, 4
  0003d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00045	4c 8b c8	 mov	 r9, rax
  00048	4c 8b c1	 mov	 r8, rcx
  0004b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 stbi__pnm_info
  00058	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00060	89 01		 mov	 DWORD PTR [rcx], eax

; 7511 :    if (ri->bits_per_channel == 0)

  00062	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0006a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006d	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7512 :       return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 10 03 00 00	 jmp	 $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7513 : 
; 7514 :    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00076	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007e	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00085	76 2e		 jbe	 SHORT $LN3@stbi__pnm_
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0008e	e8 00 00 00 00	 call	 stbi__err
  00093	85 c0		 test	 eax, eax
  00095	74 0b		 je	 SHORT $LN14@stbi__pnm_
  00097	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
  000a0	eb 09		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  000a2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
$LN15@stbi__pnm_:
  000ab	48 8b 44 24 38	 mov	 rax, QWORD PTR tv80[rsp]
  000b0	e9 d1 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 7515 :    if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bd	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000c3	76 2e		 jbe	 SHORT $LN4@stbi__pnm_
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  000cc	e8 00 00 00 00	 call	 stbi__err
  000d1	85 c0		 test	 eax, eax
  000d3	74 0b		 je	 SHORT $LN16@stbi__pnm_
  000d5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
  000de	eb 09		 jmp	 SHORT $LN17@stbi__pnm_
$LN16@stbi__pnm_:
  000e0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN17@stbi__pnm_:
  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR tv86[rsp]
  000ee	e9 93 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7516 : 
; 7517 :    *x = s->img_x;

  000f3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00103	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00105	89 08		 mov	 DWORD PTR [rax], ecx

; 7518 :    *y = s->img_y;

  00107	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0010f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00117	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0011a	89 08		 mov	 DWORD PTR [rax], ecx

; 7519 :    if (comp) *comp = s->img_n;

  0011c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00125	74 15		 je	 SHORT $LN5@stbi__pnm_
  00127	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0012f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00137	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0013a	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__pnm_:

; 7520 : 
; 7521 :    if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))

  0013c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00144	8b 00		 mov	 eax, DWORD PTR [rax]
  00146	99		 cdq
  00147	83 e2 07	 and	 edx, 7
  0014a	03 c2		 add	 eax, edx
  0014c	c1 f8 03	 sar	 eax, 3
  0014f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00157	44 8b c8	 mov	 r9d, eax
  0015a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00162	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00166	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0016e	8b 10		 mov	 edx, DWORD PTR [rax]
  00170	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00178	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0017b	e8 00 00 00 00	 call	 stbi__mad4sizes_valid
  00180	85 c0		 test	 eax, eax
  00182	75 2e		 jne	 SHORT $LN6@stbi__pnm_

; 7522 :       return stbi__errpuc("too large", "PNM too large");

  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09OJDLMMBJ@too?5large@
  0018b	e8 00 00 00 00	 call	 stbi__err
  00190	85 c0		 test	 eax, eax
  00192	74 0b		 je	 SHORT $LN18@stbi__pnm_
  00194	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv138[rsp], 0
  0019d	eb 09		 jmp	 SHORT $LN19@stbi__pnm_
$LN18@stbi__pnm_:
  0019f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv138[rsp], 0
$LN19@stbi__pnm_:
  001a8	48 8b 44 24 48	 mov	 rax, QWORD PTR tv138[rsp]
  001ad	e9 d4 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN6@stbi__pnm_:

; 7523 : 
; 7524 :    out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);

  001b2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  001ba	8b 00		 mov	 eax, DWORD PTR [rax]
  001bc	99		 cdq
  001bd	83 e2 07	 and	 edx, 7
  001c0	03 c2		 add	 eax, edx
  001c2	c1 f8 03	 sar	 eax, 3
  001c5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  001cd	44 8b c8	 mov	 r9d, eax
  001d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001d8	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  001dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e4	8b 10		 mov	 edx, DWORD PTR [rax]
  001e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ee	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001f1	e8 00 00 00 00	 call	 stbi__malloc_mad4
  001f6	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 7525 :    if (!out) return stbi__errpuc("outofmem", "Out of memory");

  001fb	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  00201	75 2e		 jne	 SHORT $LN7@stbi__pnm_
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NOGIMCHF@outofmem@
  0020a	e8 00 00 00 00	 call	 stbi__err
  0020f	85 c0		 test	 eax, eax
  00211	74 0b		 je	 SHORT $LN20@stbi__pnm_
  00213	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv154[rsp], 0
  0021c	eb 09		 jmp	 SHORT $LN21@stbi__pnm_
$LN20@stbi__pnm_:
  0021e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv154[rsp], 0
$LN21@stbi__pnm_:
  00227	48 8b 44 24 50	 mov	 rax, QWORD PTR tv154[rsp]
  0022c	e9 55 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7526 :    if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {

  00231	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00239	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00241	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00244	0f af 01	 imul	 eax, DWORD PTR [rcx]
  00247	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0024f	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00253	89 44 24 58	 mov	 DWORD PTR tv160[rsp], eax
  00257	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  0025f	8b 01		 mov	 eax, DWORD PTR [rcx]
  00261	99		 cdq
  00262	83 e2 07	 and	 edx, 7
  00265	03 c2		 add	 eax, edx
  00267	c1 f8 03	 sar	 eax, 3
  0026a	8b 4c 24 58	 mov	 ecx, DWORD PTR tv160[rsp]
  0026e	0f af c8	 imul	 ecx, eax
  00271	8b c1		 mov	 eax, ecx
  00273	44 8b c0	 mov	 r8d, eax
  00276	48 8b 54 24 30	 mov	 rdx, QWORD PTR out$[rsp]
  0027b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00283	e8 00 00 00 00	 call	 stbi__getn
  00288	85 c0		 test	 eax, eax
  0028a	75 39		 jne	 SHORT $LN8@stbi__pnm_

; 7527 :       STBI_FREE(out);

  0028c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7528 :       return stbi__errpuc("bad PNM", "PNM file truncated");

  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IDKIDMGJ@bad?5PNM@
  0029e	e8 00 00 00 00	 call	 stbi__err
  002a3	85 c0		 test	 eax, eax
  002a5	74 0b		 je	 SHORT $LN22@stbi__pnm_
  002a7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv172[rsp], 0
  002b0	eb 09		 jmp	 SHORT $LN23@stbi__pnm_
$LN22@stbi__pnm_:
  002b2	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv172[rsp], 0
$LN23@stbi__pnm_:
  002bb	48 8b 44 24 60	 mov	 rax, QWORD PTR tv172[rsp]
  002c0	e9 c1 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7529 :    }
; 7530 : 
; 7531 :    if (req_comp && req_comp != s->img_n) {

  002c5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  002cd	0f 84 ae 00 00
	00		 je	 $LN9@stbi__pnm_
  002d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002db	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002de	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  002e5	0f 84 96 00 00
	00		 je	 $LN9@stbi__pnm_

; 7532 :       if (ri->bits_per_channel == 16) {

  002eb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  002f3	83 38 10	 cmp	 DWORD PTR [rax], 16
  002f6	75 3e		 jne	 SHORT $LN10@stbi__pnm_

; 7533 :          out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);

  002f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00300	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00303	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00307	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0030f	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00312	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0031a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00322	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00325	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0032a	e8 00 00 00 00	 call	 stbi__convert_format16
  0032f	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 7534 :       } else {

  00334	eb 3c		 jmp	 SHORT $LN11@stbi__pnm_
$LN10@stbi__pnm_:

; 7535 :          out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

  00336	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0033e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00341	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00345	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0034d	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00350	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00358	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00360	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00363	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00368	e8 00 00 00 00	 call	 stbi__convert_format
  0036d	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax
$LN11@stbi__pnm_:

; 7536 :       }
; 7537 :       if (out == NULL) return out; // stbi__convert_format frees input on failure

  00372	48 83 7c 24 30
	00		 cmp	 QWORD PTR out$[rsp], 0
  00378	75 07		 jne	 SHORT $LN12@stbi__pnm_
  0037a	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  0037f	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN12@stbi__pnm_:
$LN9@stbi__pnm_:

; 7538 :    }
; 7539 :    return out;

  00381	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__pnm_:

; 7540 : }

  00386	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0038a	5f		 pop	 rdi
  0038b	c3		 ret	 0
stbi__pnm_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv76 = 32
c$ = 64
stbi__pnm_isspace PROC

; 7543 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7544 :    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

  00015	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0001a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001d	74 3c		 je	 SHORT $LN3@stbi__pnm_
  0001f	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 f8 09	 cmp	 eax, 9
  00027	74 32		 je	 SHORT $LN3@stbi__pnm_
  00029	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0002e	83 f8 0a	 cmp	 eax, 10
  00031	74 28		 je	 SHORT $LN3@stbi__pnm_
  00033	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  00038	83 f8 0b	 cmp	 eax, 11
  0003b	74 1e		 je	 SHORT $LN3@stbi__pnm_
  0003d	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  00042	83 f8 0c	 cmp	 eax, 12
  00045	74 14		 je	 SHORT $LN3@stbi__pnm_
  00047	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0004c	83 f8 0d	 cmp	 eax, 13
  0004f	74 0a		 je	 SHORT $LN3@stbi__pnm_
  00051	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00059	eb 08		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
$LN4@stbi__pnm_:
  00063	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]

; 7545 : }

  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
stbi__pnm_isspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 48
tv131 = 52
tv139 = 56
tv148 = 57
tv160 = 60
tv172 = 64
tv180 = 68
tv189 = 69
s$ = 96
c$ = 104
stbi__pnm_skip_whitespace PROC

; 7548 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001b	90		 npad	 1
$LN2@stbi__pnm_:
$LN5@stbi__pnm_:

; 1628 :    if (s->io.read) {

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00021	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00026	74 34		 je	 SHORT $LN13@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00036	ff 50 20	 call	 QWORD PTR [rax+32]
  00039	85 c0		 test	 eax, eax
  0003b	75 0a		 jne	 SHORT $LN14@stbi__pnm_
  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00045	eb 49		 jmp	 SHORT $LN12@stbi__pnm_
$LN14@stbi__pnm_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004c	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00050	75 0a		 jne	 SHORT $LN15@stbi__pnm_
  00052	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
  0005a	eb 34		 jmp	 SHORT $LN12@stbi__pnm_
$LN15@stbi__pnm_:
$LN13@stbi__pnm_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00061	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00066	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0006d	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00074	72 0a		 jb	 SHORT $LN17@stbi__pnm_
  00076	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  0007e	eb 08		 jmp	 SHORT $LN18@stbi__pnm_
$LN17@stbi__pnm_:
  00080	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN18@stbi__pnm_:
  00088	8b 44 24 34	 mov	 eax, DWORD PTR tv131[rsp]
  0008c	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
$LN12@stbi__pnm_:

; 7549 :    for (;;) {
; 7550 :       while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

  00090	8b 44 24 20	 mov	 eax, DWORD PTR $T1[rsp]
  00094	85 c0		 test	 eax, eax
  00096	0f 85 cc 00 00
	00		 jne	 $LN6@stbi__pnm_
  0009c	48 8b 44 24 68	 mov	 rax, QWORD PTR c$[rsp]
  000a1	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a4	e8 00 00 00 00	 call	 stbi__pnm_isspace
  000a9	85 c0		 test	 eax, eax
  000ab	0f 84 b7 00 00
	00		 je	 $LN6@stbi__pnm_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000b1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000bb	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000c2	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000c9	73 39		 jae	 SHORT $LN20@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  000cb	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	88 44 24 38	 mov	 BYTE PTR tv139[rsp], al
  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000e3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ea	48 ff c0	 inc	 rax
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000f2	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000f9	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv139[rsp]
  000fe	88 44 24 24	 mov	 BYTE PTR $T2[rsp], al
  00102	eb 53		 jmp	 SHORT $LN19@stbi__pnm_
$LN20@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  00104	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00109	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0010d	74 43		 je	 SHORT $LN21@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0011e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00125	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00128	88 44 24 39	 mov	 BYTE PTR tv148[rsp], al
  0012c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00131	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00138	48 ff c0	 inc	 rax
  0013b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00140	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00147	0f b6 44 24 39	 movzx	 eax, BYTE PTR tv148[rsp]
  0014c	88 44 24 24	 mov	 BYTE PTR $T2[rsp], al
  00150	eb 05		 jmp	 SHORT $LN19@stbi__pnm_
$LN21@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  00152	c6 44 24 24 00	 mov	 BYTE PTR $T2[rsp], 0
$LN19@stbi__pnm_:

; 7551 :          *c = (char) stbi__get8(s);

  00157	0f b6 44 24 24	 movzx	 eax, BYTE PTR $T2[rsp]
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR c$[rsp]
  00161	88 01		 mov	 BYTE PTR [rcx], al
  00163	e9 b4 fe ff ff	 jmp	 $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 1628 :    if (s->io.read) {

  00168	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0016d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00172	74 34		 je	 SHORT $LN24@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00174	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00179	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0017d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00182	ff 50 20	 call	 QWORD PTR [rax+32]
  00185	85 c0		 test	 eax, eax
  00187	75 0a		 jne	 SHORT $LN25@stbi__pnm_
  00189	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T3[rsp], 0
  00191	eb 49		 jmp	 SHORT $LN23@stbi__pnm_
$LN25@stbi__pnm_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00198	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0019c	75 0a		 jne	 SHORT $LN26@stbi__pnm_
  0019e	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR $T3[rsp], 1
  001a6	eb 34		 jmp	 SHORT $LN23@stbi__pnm_
$LN26@stbi__pnm_:
$LN24@stbi__pnm_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  001a8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001b2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  001b9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  001c0	72 0a		 jb	 SHORT $LN28@stbi__pnm_
  001c2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  001ca	eb 08		 jmp	 SHORT $LN29@stbi__pnm_
$LN28@stbi__pnm_:
  001cc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN29@stbi__pnm_:
  001d4	8b 44 24 3c	 mov	 eax, DWORD PTR tv160[rsp]
  001d8	89 44 24 28	 mov	 DWORD PTR $T3[rsp], eax
$LN23@stbi__pnm_:

; 7552 : 
; 7553 :       if (stbi__at_eof(s) || *c != '#')

  001dc	8b 44 24 28	 mov	 eax, DWORD PTR $T3[rsp]
  001e0	85 c0		 test	 eax, eax
  001e2	75 0d		 jne	 SHORT $LN10@stbi__pnm_
  001e4	48 8b 44 24 68	 mov	 rax, QWORD PTR c$[rsp]
  001e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ec	83 f8 23	 cmp	 eax, 35			; 00000023H
  001ef	74 05		 je	 SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 7554 :          break;

  001f1	e9 5e 01 00 00	 jmp	 $LN3@stbi__pnm_
$LN9@stbi__pnm_:
$LN7@stbi__pnm_:

; 1628 :    if (s->io.read) {

  001f6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001fb	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00200	74 34		 je	 SHORT $LN31@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  00202	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00207	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0020b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00210	ff 50 20	 call	 QWORD PTR [rax+32]
  00213	85 c0		 test	 eax, eax
  00215	75 0a		 jne	 SHORT $LN32@stbi__pnm_
  00217	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T4[rsp], 0
  0021f	eb 49		 jmp	 SHORT $LN30@stbi__pnm_
$LN32@stbi__pnm_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00226	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0022a	75 0a		 jne	 SHORT $LN33@stbi__pnm_
  0022c	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR $T4[rsp], 1
  00234	eb 34		 jmp	 SHORT $LN30@stbi__pnm_
$LN33@stbi__pnm_:
$LN31@stbi__pnm_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00236	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00240	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00247	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0024e	72 0a		 jb	 SHORT $LN35@stbi__pnm_
  00250	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00258	eb 08		 jmp	 SHORT $LN36@stbi__pnm_
$LN35@stbi__pnm_:
  0025a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN36@stbi__pnm_:
  00262	8b 44 24 40	 mov	 eax, DWORD PTR tv172[rsp]
  00266	89 44 24 2c	 mov	 DWORD PTR $T4[rsp], eax
$LN30@stbi__pnm_:

; 7555 : 
; 7556 :       while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )

  0026a	8b 44 24 2c	 mov	 eax, DWORD PTR $T4[rsp]
  0026e	85 c0		 test	 eax, eax
  00270	0f 85 d9 00 00
	00		 jne	 $LN8@stbi__pnm_
  00276	48 8b 44 24 68	 mov	 rax, QWORD PTR c$[rsp]
  0027b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0027e	83 f8 0a	 cmp	 eax, 10
  00281	0f 84 c8 00 00
	00		 je	 $LN8@stbi__pnm_
  00287	48 8b 44 24 68	 mov	 rax, QWORD PTR c$[rsp]
  0028c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0028f	83 f8 0d	 cmp	 eax, 13
  00292	0f 84 b7 00 00
	00		 je	 $LN8@stbi__pnm_

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00298	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002a2	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002a9	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002b0	73 39		 jae	 SHORT $LN38@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  002b2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002b7	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002be	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c1	88 44 24 44	 mov	 BYTE PTR tv180[rsp], al
  002c5	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ca	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002d1	48 ff c0	 inc	 rax
  002d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002d9	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002e0	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv180[rsp]
  002e5	88 44 24 30	 mov	 BYTE PTR $T5[rsp], al
  002e9	eb 53		 jmp	 SHORT $LN37@stbi__pnm_
$LN38@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  002eb	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002f0	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002f4	74 43		 je	 SHORT $LN39@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  002f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002fb	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00300	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00305	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0030c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030f	88 44 24 45	 mov	 BYTE PTR tv189[rsp], al
  00313	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00318	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0031f	48 ff c0	 inc	 rax
  00322	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00327	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0032e	0f b6 44 24 45	 movzx	 eax, BYTE PTR tv189[rsp]
  00333	88 44 24 30	 mov	 BYTE PTR $T5[rsp], al
  00337	eb 05		 jmp	 SHORT $LN37@stbi__pnm_
$LN39@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  00339	c6 44 24 30 00	 mov	 BYTE PTR $T5[rsp], 0
$LN37@stbi__pnm_:

; 7557 :          *c = (char) stbi__get8(s);

  0033e	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T5[rsp]
  00343	48 8b 4c 24 68	 mov	 rcx, QWORD PTR c$[rsp]
  00348	88 01		 mov	 BYTE PTR [rcx], al
  0034a	e9 a7 fe ff ff	 jmp	 $LN7@stbi__pnm_
$LN8@stbi__pnm_:

; 7558 :    }

  0034f	e9 c8 fc ff ff	 jmp	 $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7559 : }

  00354	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00358	5f		 pop	 rdi
  00359	c3		 ret	 0
stbi__pnm_skip_whitespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
tv68 = 32
c$ = 64
stbi__pnm_isdigit PROC

; 7562 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00010	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7563 :    return c >= '0' && c <= '9';

  00015	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  0001a	83 f8 30	 cmp	 eax, 48			; 00000030H
  0001d	7c 14		 jl	 SHORT $LN3@stbi__pnm_
  0001f	0f be 44 24 40	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 f8 39	 cmp	 eax, 57			; 00000039H
  00027	7f 0a		 jg	 SHORT $LN3@stbi__pnm_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__pnm_:
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 7564 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
stbi__pnm_isdigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
value$ = 32
$T1 = 36
$T2 = 40
tv95 = 44
tv135 = 48
tv144 = 49
s$ = 80
c$ = 88
stbi__pnm_getinteger PROC

; 7567 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7568 :    int value = 0;

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR value$[rsp], 0
$LN2@stbi__pnm_:

; 1628 :    if (s->io.read) {

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002d	74 34		 je	 SHORT $LN8@stbi__pnm_

; 1629 :       if (!(s->io.eof)(s->io_user_data)) return 0;

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00034	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003d	ff 50 20	 call	 QWORD PTR [rax+32]
  00040	85 c0		 test	 eax, eax
  00042	75 0a		 jne	 SHORT $LN9@stbi__pnm_
  00044	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  0004c	eb 49		 jmp	 SHORT $LN7@stbi__pnm_
$LN9@stbi__pnm_:

; 1630 :       // if feof() is true, check if buffer = end
; 1631 :       // special case: we've only got the special 0 character at the end
; 1632 :       if (s->read_from_callbacks == 0) return 1;

  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00053	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00057	75 0a		 jne	 SHORT $LN10@stbi__pnm_
  00059	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
  00061	eb 34		 jmp	 SHORT $LN7@stbi__pnm_
$LN10@stbi__pnm_:
$LN8@stbi__pnm_:

; 1633 :    }
; 1634 : 
; 1635 :    return s->img_buffer >= s->img_buffer_end;

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00074	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  0007b	72 0a		 jb	 SHORT $LN12@stbi__pnm_
  0007d	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  00085	eb 08		 jmp	 SHORT $LN13@stbi__pnm_
$LN12@stbi__pnm_:
  00087	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN13@stbi__pnm_:
  0008f	8b 44 24 2c	 mov	 eax, DWORD PTR tv95[rsp]
  00093	89 44 24 24	 mov	 DWORD PTR $T1[rsp], eax
$LN7@stbi__pnm_:

; 7569 : 
; 7570 :    while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

  00097	8b 44 24 24	 mov	 eax, DWORD PTR $T1[rsp]
  0009b	85 c0		 test	 eax, eax
  0009d	0f 85 10 01 00
	00		 jne	 $LN3@stbi__pnm_
  000a3	48 8b 44 24 58	 mov	 rax, QWORD PTR c$[rsp]
  000a8	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000ab	e8 00 00 00 00	 call	 stbi__pnm_isdigit
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 fb 00 00
	00		 je	 $LN3@stbi__pnm_

; 7571 :       value = value*10 + (*c - '0');

  000b8	6b 44 24 20 0a	 imul	 eax, DWORD PTR value$[rsp], 10
  000bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR c$[rsp]
  000c2	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000c5	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  000c9	89 44 24 20	 mov	 DWORD PTR value$[rsp], eax

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000de	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000e5	73 39		 jae	 SHORT $LN15@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ec	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f6	88 44 24 30	 mov	 BYTE PTR tv135[rsp], al
  000fa	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ff	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00106	48 ff c0	 inc	 rax
  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0010e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00115	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv135[rsp]
  0011a	88 44 24 28	 mov	 BYTE PTR $T2[rsp], al
  0011e	eb 53		 jmp	 SHORT $LN14@stbi__pnm_
$LN15@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00125	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00129	74 43		 je	 SHORT $LN16@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00130	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0013a	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00141	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00144	88 44 24 31	 mov	 BYTE PTR tv144[rsp], al
  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0014d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00154	48 ff c0	 inc	 rax
  00157	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00163	0f b6 44 24 31	 movzx	 eax, BYTE PTR tv144[rsp]
  00168	88 44 24 28	 mov	 BYTE PTR $T2[rsp], al
  0016c	eb 05		 jmp	 SHORT $LN14@stbi__pnm_
$LN16@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  0016e	c6 44 24 28 00	 mov	 BYTE PTR $T2[rsp], 0
$LN14@stbi__pnm_:

; 7572 :       *c = (char) stbi__get8(s);

  00173	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T2[rsp]
  00178	48 8b 4c 24 58	 mov	 rcx, QWORD PTR c$[rsp]
  0017d	88 01		 mov	 BYTE PTR [rcx], al

; 7573 :       if((value > 214748364) || (value == 214748364 && *c > '7'))

  0017f	81 7c 24 20 cc
	cc cc 0c	 cmp	 DWORD PTR value$[rsp], 214748364 ; 0cccccccH
  00187	7f 17		 jg	 SHORT $LN5@stbi__pnm_
  00189	81 7c 24 20 cc
	cc cc 0c	 cmp	 DWORD PTR value$[rsp], 214748364 ; 0cccccccH
  00191	75 1b		 jne	 SHORT $LN4@stbi__pnm_
  00193	48 8b 44 24 58	 mov	 rax, QWORD PTR c$[rsp]
  00198	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019b	83 f8 37	 cmp	 eax, 55			; 00000037H
  0019e	7e 0e		 jle	 SHORT $LN4@stbi__pnm_
$LN5@stbi__pnm_:

; 7574 :           return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");

  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@OBINMOBC@integer?5parse?5overflow@
  001a7	e8 00 00 00 00	 call	 stbi__err
  001ac	eb 09		 jmp	 SHORT $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7575 :    }

  001ae	e9 70 fe ff ff	 jmp	 $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7576 : 
; 7577 :    return value;

  001b3	8b 44 24 20	 mov	 eax, DWORD PTR value$[rsp]
$LN1@stbi__pnm_:

; 7578 : }

  001b7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001bb	5f		 pop	 rdi
  001bc	c3		 ret	 0
stbi__pnm_getinteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
maxv$ = 32
dummy$ = 52
c$ = 84
p$ = 100
t$ = 101
$T5 = 112
$T6 = 113
$T7 = 114
tv150 = 115
tv159 = 116
tv167 = 117
tv176 = 118
tv81 = 120
tv184 = 124
tv193 = 125
__$ArrayPad$ = 128
s$ = 160
x$ = 168
y$ = 176
comp$ = 184
stbi__pnm_info PROC

; 7581 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 1c 00 00 00	 mov	 ecx, 28
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7582 :    int maxv, dummy;
; 7583 :    char c, p, t;
; 7584 : 
; 7585 :    if (!x) x = &dummy;

  00053	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  0005c	75 0d		 jne	 SHORT $LN2@stbi__pnm_
  0005e	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  00063	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__pnm_:

; 7586 :    if (!y) y = &dummy;

  0006b	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00074	75 0d		 jne	 SHORT $LN3@stbi__pnm_
  00076	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  0007b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__pnm_:

; 7587 :    if (!comp) comp = &dummy;

  00083	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0008c	75 0d		 jne	 SHORT $LN4@stbi__pnm_
  0008e	48 8d 44 24 34	 lea	 rax, QWORD PTR dummy$[rsp]
  00093	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__pnm_:

; 7588 : 
; 7589 :    stbi__rewind(s);

  0009b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a3	e8 00 00 00 00	 call	 stbi__rewind

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  000a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b8	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000bf	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  000c6	73 42		 jae	 SHORT $LN17@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  000c8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d0	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	88 44 24 73	 mov	 BYTE PTR tv150[rsp], al
  000de	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ed	48 ff c0	 inc	 rax
  000f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  000ff	0f b6 44 24 73	 movzx	 eax, BYTE PTR tv150[rsp]
  00104	88 44 24 70	 mov	 BYTE PTR $T5[rsp], al
  00108	eb 62		 jmp	 SHORT $LN16@stbi__pnm_
$LN17@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  0010a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00112	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00116	74 4f		 je	 SHORT $LN18@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  00118	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00120	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  00125	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0012d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00134	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00137	88 44 24 74	 mov	 BYTE PTR tv159[rsp], al
  0013b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00143	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0014a	48 ff c0	 inc	 rax
  0014d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00155	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0015c	0f b6 44 24 74	 movzx	 eax, BYTE PTR tv159[rsp]
  00161	88 44 24 70	 mov	 BYTE PTR $T5[rsp], al
  00165	eb 05		 jmp	 SHORT $LN16@stbi__pnm_
$LN18@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  00167	c6 44 24 70 00	 mov	 BYTE PTR $T5[rsp], 0
$LN16@stbi__pnm_:

; 7590 : 
; 7591 :    // Get identifier
; 7592 :    p = (char) stbi__get8(s);

  0016c	0f b6 44 24 70	 movzx	 eax, BYTE PTR $T5[rsp]
  00171	88 44 24 64	 mov	 BYTE PTR p$[rsp], al

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  00175	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0017d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00185	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0018c	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00193	73 42		 jae	 SHORT $LN21@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  00195	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0019d	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	88 44 24 75	 mov	 BYTE PTR tv167[rsp], al
  001ab	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b3	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  001ba	48 ff c0	 inc	 rax
  001bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001c5	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  001cc	0f b6 44 24 75	 movzx	 eax, BYTE PTR tv167[rsp]
  001d1	88 44 24 71	 mov	 BYTE PTR $T6[rsp], al
  001d5	eb 62		 jmp	 SHORT $LN20@stbi__pnm_
$LN21@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  001d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001df	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  001e3	74 4f		 je	 SHORT $LN22@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  001e5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001ed	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  001f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001fa	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00201	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00204	88 44 24 76	 mov	 BYTE PTR tv176[rsp], al
  00208	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00210	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00217	48 ff c0	 inc	 rax
  0021a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00222	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00229	0f b6 44 24 76	 movzx	 eax, BYTE PTR tv176[rsp]
  0022e	88 44 24 71	 mov	 BYTE PTR $T6[rsp], al
  00232	eb 05		 jmp	 SHORT $LN20@stbi__pnm_
$LN22@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  00234	c6 44 24 71 00	 mov	 BYTE PTR $T6[rsp], 0
$LN20@stbi__pnm_:

; 7593 :    t = (char) stbi__get8(s);

  00239	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T6[rsp]
  0023e	88 44 24 65	 mov	 BYTE PTR t$[rsp], al

; 7594 :    if (p != 'P' || (t != '5' && t != '6')) {

  00242	0f be 44 24 64	 movsx	 eax, BYTE PTR p$[rsp]
  00247	83 f8 50	 cmp	 eax, 80			; 00000050H
  0024a	75 14		 jne	 SHORT $LN6@stbi__pnm_
  0024c	0f be 44 24 65	 movsx	 eax, BYTE PTR t$[rsp]
  00251	83 f8 35	 cmp	 eax, 53			; 00000035H
  00254	74 1e		 je	 SHORT $LN5@stbi__pnm_
  00256	0f be 44 24 65	 movsx	 eax, BYTE PTR t$[rsp]
  0025b	83 f8 36	 cmp	 eax, 54			; 00000036H
  0025e	74 14		 je	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7595 :        stbi__rewind(s);

  00260	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00268	e8 00 00 00 00	 call	 stbi__rewind

; 7596 :        return 0;

  0026d	33 c0		 xor	 eax, eax
  0026f	e9 e6 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7597 :    }
; 7598 : 
; 7599 :    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

  00274	0f be 44 24 65	 movsx	 eax, BYTE PTR t$[rsp]
  00279	83 f8 36	 cmp	 eax, 54			; 00000036H
  0027c	75 0a		 jne	 SHORT $LN14@stbi__pnm_
  0027e	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR tv81[rsp], 3
  00286	eb 08		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  00288	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
$LN15@stbi__pnm_:
  00290	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00298	8b 4c 24 78	 mov	 ecx, DWORD PTR tv81[rsp]
  0029c	89 08		 mov	 DWORD PTR [rax], ecx

; 1614 :    if (s->img_buffer < s->img_buffer_end)

  0029e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002ae	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  002b5	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  002bc	73 42		 jae	 SHORT $LN25@stbi__pnm_

; 1615 :       return *s->img_buffer++;

  002be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002cd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002d0	88 44 24 7c	 mov	 BYTE PTR tv184[rsp], al
  002d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002dc	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  002e3	48 ff c0	 inc	 rax
  002e6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002ee	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  002f5	0f b6 44 24 7c	 movzx	 eax, BYTE PTR tv184[rsp]
  002fa	88 44 24 72	 mov	 BYTE PTR $T7[rsp], al
  002fe	eb 62		 jmp	 SHORT $LN24@stbi__pnm_
$LN25@stbi__pnm_:

; 1616 :    if (s->read_from_callbacks) {

  00300	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00308	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0030c	74 4f		 je	 SHORT $LN26@stbi__pnm_

; 1617 :       stbi__refill_buffer(s);

  0030e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00316	e8 00 00 00 00	 call	 stbi__refill_buffer

; 1618 :       return *s->img_buffer++;

  0031b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00323	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0032a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0032d	88 44 24 7d	 mov	 BYTE PTR tv193[rsp], al
  00331	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00339	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00340	48 ff c0	 inc	 rax
  00343	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0034b	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00352	0f b6 44 24 7d	 movzx	 eax, BYTE PTR tv193[rsp]
  00357	88 44 24 72	 mov	 BYTE PTR $T7[rsp], al
  0035b	eb 05		 jmp	 SHORT $LN24@stbi__pnm_
$LN26@stbi__pnm_:

; 1619 :    }
; 1620 :    return 0;

  0035d	c6 44 24 72 00	 mov	 BYTE PTR $T7[rsp], 0
$LN24@stbi__pnm_:

; 7600 : 
; 7601 :    c = (char) stbi__get8(s);

  00362	0f b6 44 24 72	 movzx	 eax, BYTE PTR $T7[rsp]
  00367	88 44 24 54	 mov	 BYTE PTR c$[rsp], al

; 7602 :    stbi__pnm_skip_whitespace(s, &c);

  0036b	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  00370	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00378	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7603 : 
; 7604 :    *x = stbi__pnm_getinteger(s, &c); // read width

  0037d	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  00382	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038a	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  0038f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00397	89 01		 mov	 DWORD PTR [rcx], eax

; 7605 :    if(*x == 0)

  00399	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  003a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  003a4	75 11		 jne	 SHORT $LN7@stbi__pnm_

; 7606 :        return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  003ad	e8 00 00 00 00	 call	 stbi__err
  003b2	e9 a3 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7607 :    stbi__pnm_skip_whitespace(s, &c);

  003b7	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  003bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003c4	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7608 : 
; 7609 :    *y = stbi__pnm_getinteger(s, &c); // read height

  003c9	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  003ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d6	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  003db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  003e3	89 01		 mov	 DWORD PTR [rcx], eax

; 7610 :    if (*y == 0)

  003e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  003ed	83 38 00	 cmp	 DWORD PTR [rax], 0
  003f0	75 0e		 jne	 SHORT $LN8@stbi__pnm_

; 7611 :        return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MKGNGALN@invalid?5width@
  003f9	e8 00 00 00 00	 call	 stbi__err
  003fe	eb 5a		 jmp	 SHORT $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7612 :    stbi__pnm_skip_whitespace(s, &c);

  00400	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  00405	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0040d	e8 00 00 00 00	 call	 stbi__pnm_skip_whitespace

; 7613 : 
; 7614 :    maxv = stbi__pnm_getinteger(s, &c);  // read max value

  00412	48 8d 54 24 54	 lea	 rdx, QWORD PTR c$[rsp]
  00417	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041f	e8 00 00 00 00	 call	 stbi__pnm_getinteger
  00424	89 44 24 20	 mov	 DWORD PTR maxv$[rsp], eax

; 7615 :    if (maxv > 65535)

  00428	81 7c 24 20 ff
	ff 00 00	 cmp	 DWORD PTR maxv$[rsp], 65535 ; 0000ffffH
  00430	7e 10		 jle	 SHORT $LN9@stbi__pnm_

; 7616 :       return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");

  00432	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@CNFMOKHC@max?5value?5?$DO?565535@
  00439	e8 00 00 00 00	 call	 stbi__err
  0043e	eb 1a		 jmp	 SHORT $LN1@stbi__pnm_
  00440	eb 18		 jmp	 SHORT $LN10@stbi__pnm_
$LN9@stbi__pnm_:

; 7617 :    else if (maxv > 255)

  00442	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR maxv$[rsp], 255 ; 000000ffH
  0044a	7e 09		 jle	 SHORT $LN11@stbi__pnm_

; 7618 :       return 16;

  0044c	b8 10 00 00 00	 mov	 eax, 16
  00451	eb 07		 jmp	 SHORT $LN1@stbi__pnm_
  00453	eb 05		 jmp	 SHORT $LN12@stbi__pnm_
$LN11@stbi__pnm_:

; 7619 :    else
; 7620 :       return 8;

  00455	b8 08 00 00 00	 mov	 eax, 8
$LN12@stbi__pnm_:
$LN10@stbi__pnm_:
$LN1@stbi__pnm_:

; 7621 : }

  0045a	48 8b f8	 mov	 rdi, rax
  0045d	48 8b cc	 mov	 rcx, rsp
  00460	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi__pnm_info$rtcFrameData
  00467	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0046c	48 8b c7	 mov	 rax, rdi
  0046f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00477	48 33 cc	 xor	 rcx, rsp
  0047a	e8 00 00 00 00	 call	 __security_check_cookie
  0047f	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00486	5f		 pop	 rdi
  00487	c3		 ret	 0
stbi__pnm_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
stbi__pnm_is16 PROC

; 7624 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7625 :    if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)

  00016	45 33 c9	 xor	 r9d, r9d
  00019	45 33 c0	 xor	 r8d, r8d
  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 stbi__pnm_info
  00028	83 f8 10	 cmp	 eax, 16
  0002b	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7626 : 	   return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	eb 02		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7627 :    return 0;

  00034	33 c0		 xor	 eax, eax
$LN1@stbi__pnm_:

; 7628 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
stbi__pnm_is16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
stbi__info_main PROC

; 7632 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7633 :    #ifndef STBI_NO_JPEG
; 7634 :    if (stbi__jpeg_info(s, x, y, comp)) return 1;

  00025	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0002a	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0002f	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 stbi__jpeg_info
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN2@stbi__info
  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	e9 38 01 00 00	 jmp	 $LN1@stbi__info
$LN2@stbi__info:

; 7635 :    #endif
; 7636 : 
; 7637 :    #ifndef STBI_NO_PNG
; 7638 :    if (stbi__png_info(s, x, y, comp))  return 1;

  0004c	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00051	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00056	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0005b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00060	e8 00 00 00 00	 call	 stbi__png_info
  00065	85 c0		 test	 eax, eax
  00067	74 0a		 je	 SHORT $LN3@stbi__info
  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	e9 11 01 00 00	 jmp	 $LN1@stbi__info
$LN3@stbi__info:

; 7639 :    #endif
; 7640 : 
; 7641 :    #ifndef STBI_NO_GIF
; 7642 :    if (stbi__gif_info(s, x, y, comp))  return 1;

  00073	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00078	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0007d	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00087	e8 00 00 00 00	 call	 stbi__gif_info
  0008c	85 c0		 test	 eax, eax
  0008e	74 0a		 je	 SHORT $LN4@stbi__info
  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	e9 ea 00 00 00	 jmp	 $LN1@stbi__info
$LN4@stbi__info:

; 7643 :    #endif
; 7644 : 
; 7645 :    #ifndef STBI_NO_BMP
; 7646 :    if (stbi__bmp_info(s, x, y, comp))  return 1;

  0009a	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0009f	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000ae	e8 00 00 00 00	 call	 stbi__bmp_info
  000b3	85 c0		 test	 eax, eax
  000b5	74 0a		 je	 SHORT $LN5@stbi__info
  000b7	b8 01 00 00 00	 mov	 eax, 1
  000bc	e9 c3 00 00 00	 jmp	 $LN1@stbi__info
$LN5@stbi__info:

; 7647 :    #endif
; 7648 : 
; 7649 :    #ifndef STBI_NO_PSD
; 7650 :    if (stbi__psd_info(s, x, y, comp))  return 1;

  000c1	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000c6	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000cb	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000d5	e8 00 00 00 00	 call	 stbi__psd_info
  000da	85 c0		 test	 eax, eax
  000dc	74 0a		 je	 SHORT $LN6@stbi__info
  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	e9 9c 00 00 00	 jmp	 $LN1@stbi__info
$LN6@stbi__info:

; 7651 :    #endif
; 7652 : 
; 7653 :    #ifndef STBI_NO_PIC
; 7654 :    if (stbi__pic_info(s, x, y, comp))  return 1;

  000e8	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000ed	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000f2	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000fc	e8 00 00 00 00	 call	 stbi__pic_info
  00101	85 c0		 test	 eax, eax
  00103	74 07		 je	 SHORT $LN7@stbi__info
  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	eb 78		 jmp	 SHORT $LN1@stbi__info
$LN7@stbi__info:

; 7655 :    #endif
; 7656 : 
; 7657 :    #ifndef STBI_NO_PNM
; 7658 :    if (stbi__pnm_info(s, x, y, comp))  return 1;

  0010c	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00111	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00116	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0011b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00120	e8 00 00 00 00	 call	 stbi__pnm_info
  00125	85 c0		 test	 eax, eax
  00127	74 07		 je	 SHORT $LN8@stbi__info
  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	eb 54		 jmp	 SHORT $LN1@stbi__info
$LN8@stbi__info:

; 7659 :    #endif
; 7660 : 
; 7661 :    #ifndef STBI_NO_HDR
; 7662 :    if (stbi__hdr_info(s, x, y, comp))  return 1;

  00130	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00135	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0013a	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0013f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00144	e8 00 00 00 00	 call	 stbi__hdr_info
  00149	85 c0		 test	 eax, eax
  0014b	74 07		 je	 SHORT $LN9@stbi__info
  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	eb 30		 jmp	 SHORT $LN1@stbi__info
$LN9@stbi__info:

; 7663 :    #endif
; 7664 : 
; 7665 :    // test tga last because it's a crappy test!
; 7666 :    #ifndef STBI_NO_TGA
; 7667 :    if (stbi__tga_info(s, x, y, comp))

  00154	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00159	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0015e	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00163	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00168	e8 00 00 00 00	 call	 stbi__tga_info
  0016d	85 c0		 test	 eax, eax
  0016f	74 07		 je	 SHORT $LN10@stbi__info

; 7668 :        return 1;

  00171	b8 01 00 00 00	 mov	 eax, 1
  00176	eb 0c		 jmp	 SHORT $LN1@stbi__info
$LN10@stbi__info:

; 7669 :    #endif
; 7670 :    return stbi__err("unknown image type", "Image not of any known type, or corrupt");

  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CBEDEJPH@unknown?5image?5type@
  0017f	e8 00 00 00 00	 call	 stbi__err
$LN1@stbi__info:

; 7671 : }

  00184	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
stbi__info_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
stbi__is_16_main PROC

; 7674 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7675 :    #ifndef STBI_NO_PNG
; 7676 :    if (stbi__png_is16(s))  return 1;

  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 stbi__png_is16
  00020	85 c0		 test	 eax, eax
  00022	74 07		 je	 SHORT $LN2@stbi__is_1
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	eb 2c		 jmp	 SHORT $LN1@stbi__is_1
$LN2@stbi__is_1:

; 7677 :    #endif
; 7678 : 
; 7679 :    #ifndef STBI_NO_PSD
; 7680 :    if (stbi__psd_is16(s))  return 1;

  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00030	e8 00 00 00 00	 call	 stbi__psd_is16
  00035	85 c0		 test	 eax, eax
  00037	74 07		 je	 SHORT $LN3@stbi__is_1
  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	eb 17		 jmp	 SHORT $LN1@stbi__is_1
$LN3@stbi__is_1:

; 7681 :    #endif
; 7682 : 
; 7683 :    #ifndef STBI_NO_PNM
; 7684 :    if (stbi__pnm_is16(s))  return 1;

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00045	e8 00 00 00 00	 call	 stbi__pnm_is16
  0004a	85 c0		 test	 eax, eax
  0004c	74 07		 je	 SHORT $LN4@stbi__is_1
  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	eb 02		 jmp	 SHORT $LN1@stbi__is_1
$LN4@stbi__is_1:

; 7685 :    #endif
; 7686 :    return 0;

  00055	33 c0		 xor	 eax, eax
$LN1@stbi__is_1:

; 7687 : }

  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
stbi__is_16_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 32
result$ = 40
filename$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi_info PROC

; 7691 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7692 :     FILE *f = stbi__fopen(filename, "rb");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00031	e8 00 00 00 00	 call	 stbi__fopen
  00036	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax

; 7693 :     int result;
; 7694 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0003b	48 83 7c 24 20
	00		 cmp	 QWORD PTR f$[rsp], 0
  00041	75 0e		 jne	 SHORT $LN2@stbi_info
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  0004a	e8 00 00 00 00	 call	 stbi__err
  0004f	eb 2c		 jmp	 SHORT $LN1@stbi_info
$LN2@stbi_info:

; 7695 :     result = stbi_info_from_file(f, x, y, comp);

  00051	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  00056	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  0005b	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00065	e8 00 00 00 00	 call	 stbi_info_from_file
  0006a	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 7696 :     fclose(f);

  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 7697 :     return result;

  00079	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_info:

; 7698 : }

  0007d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
pos$ = 292
__$ArrayPad$ = 304
f$ = 336
x$ = 344
y$ = 352
comp$ = 360
stbi_info_from_file PROC

; 7701 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7702 :    int r;
; 7703 :    stbi__context s;
; 7704 :    long pos = ftell(f);

  00053	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00061	89 84 24 24 01
	00 00		 mov	 DWORD PTR pos$[rsp], eax

; 7705 :    stbi__start_file(&s, f);

  00068	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00070	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 stbi__start_file

; 7706 :    r = stbi__info_main(&s,x,y,comp);

  0007a	4c 8b 8c 24 68
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00082	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0008a	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00092	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 stbi__info_main
  0009c	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7707 :    fseek(f,pos,SEEK_SET);

  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	8b 94 24 24 01
	00 00		 mov	 edx, DWORD PTR pos$[rsp]
  000aa	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 7708 :    return r;

  000b8	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 7709 : }

  000bc	8b f8		 mov	 edi, eax
  000be	48 8b cc	 mov	 rcx, rsp
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_file$rtcFrameData
  000c8	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000cd	8b c7		 mov	 eax, edi
  000cf	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d7	48 33 cc	 xor	 rcx, rsp
  000da	e8 00 00 00 00	 call	 __security_check_cookie
  000df	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
f$ = 32
result$ = 40
filename$ = 64
stbi_is_16_bit PROC

; 7712 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7713 :     FILE *f = stbi__fopen(filename, "rb");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb@
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00022	e8 00 00 00 00	 call	 stbi__fopen
  00027	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax

; 7714 :     int result;
; 7715 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR f$[rsp], 0
  00032	75 0e		 jne	 SHORT $LN2@stbi_is_16
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JPDHFAGK@can?8t?5fopen@
  0003b	e8 00 00 00 00	 call	 stbi__err
  00040	eb 1d		 jmp	 SHORT $LN1@stbi_is_16
$LN2@stbi_is_16:

; 7716 :     result = stbi_is_16_bit_from_file(f);

  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00047	e8 00 00 00 00	 call	 stbi_is_16_bit_from_file
  0004c	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 7717 :     fclose(f);

  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR f$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 7718 :     return result;

  0005b	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_is_16:

; 7719 : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
stbi_is_16_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
pos$ = 292
__$ArrayPad$ = 304
f$ = 336
stbi_is_16_bit_from_file PROC

; 7722 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0000d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0003f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7723 :    int r;
; 7724 :    stbi__context s;
; 7725 :    long pos = ftell(f);

  00044	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00052	89 84 24 24 01
	00 00		 mov	 DWORD PTR pos$[rsp], eax

; 7726 :    stbi__start_file(&s, f);

  00059	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00061	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00066	e8 00 00 00 00	 call	 stbi__start_file

; 7727 :    r = stbi__is_16_main(&s);

  0006b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00070	e8 00 00 00 00	 call	 stbi__is_16_main
  00075	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7728 :    fseek(f,pos,SEEK_SET);

  00079	45 33 c0	 xor	 r8d, r8d
  0007c	8b 94 24 24 01
	00 00		 mov	 edx, DWORD PTR pos$[rsp]
  00083	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 7729 :    return r;

  00091	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 7730 : }

  00095	8b f8		 mov	 edi, eax
  00097	48 8b cc	 mov	 rcx, rsp
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_file$rtcFrameData
  000a1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a6	8b c7		 mov	 eax, edi
  000a8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b0	48 33 cc	 xor	 rcx, rsp
  000b3	e8 00 00 00 00	 call	 __security_check_cookie
  000b8	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
stbi_is_16_bit_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
buffer$ = 320
len$ = 328
x$ = 336
y$ = 344
comp$ = 352
stbi_info_from_memory PROC

; 7734 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0001b	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00020	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7735 :    stbi__context s;
; 7736 :    stbi__start_mem(&s,buffer,len);

  00052	44 8b 84 24 48
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0005a	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__start_mem

; 7737 :    return stbi__info_main(&s,x,y,comp);

  0006c	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00074	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0007c	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00084	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00089	e8 00 00 00 00	 call	 stbi__info_main

; 7738 : }

  0008e	48 8b f8	 mov	 rdi, rax
  00091	48 8b cc	 mov	 rcx, rsp
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_memory$rtcFrameData
  0009b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a0	48 8b c7	 mov	 rax, rdi
  000a3	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ab	48 33 cc	 xor	 rcx, rsp
  000ae	e8 00 00 00 00	 call	 __security_check_cookie
  000b3	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
c$ = 320
user$ = 328
x$ = 336
y$ = 344
comp$ = 352
stbi_info_from_callbacks PROC

; 7741 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c4	 xor	 rax, rsp
  0003f	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7742 :    stbi__context s;
; 7743 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  00053	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0005b	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__start_callbacks

; 7744 :    return stbi__info_main(&s,x,y,comp);

  0006d	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00075	4c 8b 84 24 58
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0007d	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00085	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0008a	e8 00 00 00 00	 call	 stbi__info_main

; 7745 : }

  0008f	48 8b f8	 mov	 rdi, rax
  00092	48 8b cc	 mov	 rcx, rsp
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_info_from_callbacks$rtcFrameData
  0009c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a1	48 8b c7	 mov	 rax, rdi
  000a4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ac	48 33 cc	 xor	 rcx, rsp
  000af	e8 00 00 00 00	 call	 __security_check_cookie
  000b4	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
buffer$ = 320
len$ = 328
stbi_is_16_bit_from_memory PROC

; 7748 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00011	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00016	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00031	48 33 c4	 xor	 rax, rsp
  00034	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00043	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7749 :    stbi__context s;
; 7750 :    stbi__start_mem(&s,buffer,len);

  00048	44 8b 84 24 48
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00050	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00058	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0005d	e8 00 00 00 00	 call	 stbi__start_mem

; 7751 :    return stbi__is_16_main(&s);

  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 stbi__is_16_main

; 7752 : }

  0006c	48 8b f8	 mov	 rdi, rax
  0006f	48 8b cc	 mov	 rcx, rsp
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_memory$rtcFrameData
  00079	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007e	48 8b c7	 mov	 rax, rdi
  00081	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00089	48 33 cc	 xor	 rcx, rsp
  0008c	e8 00 00 00 00	 call	 __security_check_cookie
  00091	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
stbi_is_16_bit_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\includes\stb-master\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 288
c$ = 320
user$ = 328
stbi_is_16_bit_from_callbacks PROC

; 7755 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00012	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00017	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR [rsp+320]
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__D1DC2946_EntityManager@h
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 7756 :    stbi__context s;
; 7757 :    stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  00049	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00051	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00059	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 stbi__start_callbacks

; 7758 :    return stbi__is_16_main(&s);

  00063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 stbi__is_16_main

; 7759 : }

  0006d	48 8b f8	 mov	 rdi, rax
  00070	48 8b cc	 mov	 rcx, rsp
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stbi_is_16_bit_from_callbacks$rtcFrameData
  0007a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007f	48 8b c7	 mov	 rax, rdi
  00082	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008a	48 33 cc	 xor	 rcx, rsp
  0008d	e8 00 00 00 00	 call	 __security_check_cookie
  00092	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
stbi_is_16_bit_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h
;	COMDAT NugRand
_TEXT	SEGMENT
seed$ = 48
NugRand	PROC						; COMDAT

; 45   : inline unsigned long long NugRand(unsigned long long seed) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__EBE4262C_Dictionary@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 46   : 	return (aConst * seed + cConst) % maxNugRand;

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR aConst
  0001d	48 0f af 44 24
	30		 imul	 rax, QWORD PTR seed$[rsp]
  00023	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR cConst
  0002a	33 d2		 xor	 edx, edx
  0002c	48 f7 35 00 00
	00 00		 div	 QWORD PTR maxNugRand
  00033	48 8b c2	 mov	 rax, rdx

; 47   : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
NugRand	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\math.h
;	COMDAT UAbs
_TEXT	SEGMENT
tv65 = 32
orig$ = 64
UAbs	PROC						; COMDAT

; 35   : inline ULONGLONG UAbs(ULONGLONG orig) {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__46B7CB64_math@h
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   : 	return orig * ((ULONGLONG)(orig >= 0) * 2U - 1);

  00016	48 83 7c 24 40
	00		 cmp	 QWORD PTR orig$[rsp], 0
  0001c	72 0b		 jb	 SHORT $LN3@UAbs
  0001e	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR tv65[rsp], 1
  00027	eb 09		 jmp	 SHORT $LN4@UAbs
$LN3@UAbs:
  00029	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv65[rsp], 0
$LN4@UAbs:
  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR tv65[rsp]
  00037	48 8d 44 00 ff	 lea	 rax, QWORD PTR [rax+rax-1]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR orig$[rsp]
  00041	48 0f af c8	 imul	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx

; 37   : }

  00048	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
UAbs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
; File C:\Users\drago\source\repos\cGame - less comments\cGame\math.h
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
hash$ = 32
head$ = 40
$T1 = 48
$T2 = 56
orig$ = 64
tv67 = 72
tv83 = 80
key$ = 112
GetUintVal2 PROC

; 85   : uint GetUintVal2(ULONGLONG key) {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h

; 46   : 	return (aConst * seed + cConst) % maxNugRand;

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR aConst
  0001d	48 0f af 44 24
	70		 imul	 rax, QWORD PTR key$[rsp]
  00023	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR cConst
  0002a	33 d2		 xor	 edx, edx
  0002c	48 f7 35 00 00
	00 00		 div	 QWORD PTR maxNugRand
  00033	48 8b c2	 mov	 rax, rdx
  00036	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c

; 86   : 	ULONGLONG hash = NugRand(key);

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR hash$[rsp], rax

; 87   : 	uintList* head = uintMap[UAbs(hash % noOfEnemies)];

  00045	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR noOfEnemies
  0004b	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
  00050	33 d2		 xor	 edx, edx
  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR hash$[rsp]
  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv67[rsp]
  0005c	48 f7 f1	 div	 rcx
  0005f	48 8b c2	 mov	 rax, rdx
  00062	48 89 44 24 40	 mov	 QWORD PTR orig$[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\math.h

; 36   : 	return orig * ((ULONGLONG)(orig >= 0) * 2U - 1);

  00067	48 83 7c 24 40
	00		 cmp	 QWORD PTR orig$[rsp], 0
  0006d	72 0b		 jb	 SHORT $LN10@GetUintVal
  0006f	48 c7 44 24 50
	01 00 00 00	 mov	 QWORD PTR tv83[rsp], 1
  00078	eb 09		 jmp	 SHORT $LN11@GetUintVal
$LN10@GetUintVal:
  0007a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv83[rsp], 0
$LN11@GetUintVal:
  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR tv83[rsp]
  00088	48 8d 44 00 ff	 lea	 rax, QWORD PTR [rax+rax-1]
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR orig$[rsp]
  00092	48 0f af c8	 imul	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c

; 87   : 	uintList* head = uintMap[UAbs(hash % noOfEnemies)];

  0009e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR uintMap
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T2[rsp]
  000aa	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000ae	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax
$LN2@GetUintVal:

; 88   : 	while (head) {

  000b3	48 83 7c 24 28
	00		 cmp	 QWORD PTR head$[rsp], 0
  000b9	74 2f		 je	 SHORT $LN3@GetUintVal

; 89   : 		if (head->value->hash == hash) {

  000bb	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hash$[rsp]
  000c8	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  000cc	75 0c		 jne	 SHORT $LN4@GetUintVal

; 90   : 			return head->value->value;

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  000d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d6	8b 00		 mov	 eax, DWORD PTR [rax]
  000d8	eb 18		 jmp	 SHORT $LN1@GetUintVal
$LN4@GetUintVal:

; 91   : 		}
; 92   : 		head = head->next;

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  000df	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e3	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax

; 93   : 	}

  000e8	eb c9		 jmp	 SHORT $LN2@GetUintVal
$LN3@GetUintVal:

; 94   : 	DebugBreak();

  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DebugBreak

; 95   : 	return ((void*)0);

  000f0	33 c0		 xor	 eax, eax
$LN1@GetUintVal:

; 96   : };

  000f2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
GetUintVal2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
; File C:\Users\drago\source\repos\cGame - less comments\cGame\math.h
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
list$ = 32
hash$ = 40
head$ = 48
$T1 = 56
$T2 = 64
orig$ = 72
tv82 = 80
tv129 = 88
key$ = 112
value$ = 120
AddUintVal2 PROC

; 97   : uint AddUintVal2(ULONGLONG key, uint value) {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00015	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 98   : 	uintList* list = malloc(sizeof(uintList));

  0001a	b9 18 00 00 00	 mov	 ecx, 24
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00025	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax

; 99   : 	list->value = malloc(sizeof(*list->value));

  0002a	b9 10 00 00 00	 mov	 ecx, 16
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  0003a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 100  : 	list->value->value = value;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	8b 4c 24 78	 mov	 ecx, DWORD PTR value$[rsp]
  00049	89 08		 mov	 DWORD PTR [rax], ecx
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h

; 46   : 	return (aConst * seed + cConst) % maxNugRand;

  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR aConst
  00052	48 0f af 44 24
	70		 imul	 rax, QWORD PTR key$[rsp]
  00058	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR cConst
  0005f	33 d2		 xor	 edx, edx
  00061	48 f7 35 00 00
	00 00		 div	 QWORD PTR maxNugRand
  00068	48 8b c2	 mov	 rax, rdx
  0006b	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c

; 101  : 	ULONGLONG hash = NugRand(key);

  00070	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  00075	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax

; 102  : 	list->value->hash = hash;

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  0007f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  00087	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 103  : 	uintList** head = &uintMap[UAbs(hash % noOfEnemies)];

  0008b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR noOfEnemies
  00091	48 89 44 24 50	 mov	 QWORD PTR tv82[rsp], rax
  00096	33 d2		 xor	 edx, edx
  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR hash$[rsp]
  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv82[rsp]
  000a2	48 f7 f1	 div	 rcx
  000a5	48 8b c2	 mov	 rax, rdx
  000a8	48 89 44 24 48	 mov	 QWORD PTR orig$[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\math.h

; 36   : 	return orig * ((ULONGLONG)(orig >= 0) * 2U - 1);

  000ad	48 83 7c 24 48
	00		 cmp	 QWORD PTR orig$[rsp], 0
  000b3	72 0b		 jb	 SHORT $LN8@AddUintVal
  000b5	48 c7 44 24 58
	01 00 00 00	 mov	 QWORD PTR tv129[rsp], 1
  000be	eb 09		 jmp	 SHORT $LN9@AddUintVal
$LN8@AddUintVal:
  000c0	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
$LN9@AddUintVal:
  000c9	48 8b 44 24 58	 mov	 rax, QWORD PTR tv129[rsp]
  000ce	48 8d 44 00 ff	 lea	 rax, QWORD PTR [rax+rax-1]
  000d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR orig$[rsp]
  000d8	48 0f af c8	 imul	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	48 89 44 24 40	 mov	 QWORD PTR $T2[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c

; 103  : 	uintList** head = &uintMap[UAbs(hash % noOfEnemies)];

  000e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR uintMap
  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR $T2[rsp]
  000f0	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000f4	48 89 44 24 30	 mov	 QWORD PTR head$[rsp], rax

; 104  : 	list->next = *head;

  000f9	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR head$[rsp]
  00103	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00106	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 105  : 	list->prev = ((void*)0);

  0010a	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  0010f	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 106  : 	if (*head) (*head)->prev = list;

  00117	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  0011c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00120	74 11		 je	 SHORT $LN2@AddUintVal
  00122	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  00127	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  0012f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN2@AddUintVal:

; 107  : 	*head = list;

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  00138	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  0013d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 108  : 	return list->value->value;

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  00145	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00148	8b 00		 mov	 eax, DWORD PTR [rax]

; 109  : };

  0014a	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0014e	5f		 pop	 rdi
  0014f	c3		 ret	 0
AddUintVal2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
hash$ = 32
head$ = 40
path$ = 64
GetLocVal2 PROC

; 110  : int GetLocVal2(char* path) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 111  : 	ULONGLONG hash = NugHash(path);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  0001b	e8 00 00 00 00	 call	 NugHash
  00020	48 89 44 24 20	 mov	 QWORD PTR hash$[rsp], rax

; 112  : 	locList* head = locMap[hash % 100];

  00025	33 d2		 xor	 edx, edx
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR hash$[rsp]
  0002c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00031	48 f7 f1	 div	 rcx
  00034	48 8b c2	 mov	 rax, rdx
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:locMap
  0003e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00042	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax
$LN2@GetLocVal2:

; 113  : 	while (head) {

  00047	48 83 7c 24 28
	00		 cmp	 QWORD PTR head$[rsp], 0
  0004d	74 2f		 je	 SHORT $LN3@GetLocVal2

; 114  : 		if (head->value->hash == hash) return head->value->value;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hash$[rsp]
  0005c	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00060	75 0c		 jne	 SHORT $LN4@GetLocVal2
  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00067	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006a	8b 00		 mov	 eax, DWORD PTR [rax]
  0006c	eb 12		 jmp	 SHORT $LN1@GetLocVal2
$LN4@GetLocVal2:
$cont$7:

; 115  : 	cont:
; 116  : 		head = head->next;

  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax

; 117  : 	}

  0007c	eb c9		 jmp	 SHORT $LN2@GetLocVal2
$LN3@GetLocVal2:

; 118  : 	return NULL;

  0007e	33 c0		 xor	 eax, eax
$LN1@GetLocVal2:

; 119  : };

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
GetLocVal2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
list$ = 32
hash$ = 40
head$ = 48
attribName$ = 80
AddLocVal2 PROC

; 120  : int AddLocVal2(char* attribName) {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 121  : 	locList* list = malloc(sizeof(locList));

  00016	b9 18 00 00 00	 mov	 ecx, 24
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00021	48 89 44 24 20	 mov	 QWORD PTR list$[rsp], rax

; 122  : 	list->value = malloc(sizeof(locData));

  00026	b9 10 00 00 00	 mov	 ecx, 16
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  00036	48 89 01	 mov	 QWORD PTR [rcx], rax

; 123  : 	list->value->value = glGetUniformLocation(shader, attribName);

  00039	48 8b 54 24 50	 mov	 rdx, QWORD PTR attribName$[rsp]
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR shader
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetUniformLocation
  0004b	ff 10		 call	 QWORD PTR [rax]
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  00052	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00055	89 01		 mov	 DWORD PTR [rcx], eax

; 124  : 	ULONGLONG hash = NugHash(attribName);

  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR attribName$[rsp]
  0005c	e8 00 00 00 00	 call	 NugHash
  00061	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax

; 125  : 	list->value->hash = hash;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  00073	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 126  : 	locList** head = &locMap[hash % LOC_DIC_SIZE];

  00077	33 d2		 xor	 edx, edx
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR hash$[rsp]
  0007e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00083	48 f7 f1	 div	 rcx
  00086	48 8b c2	 mov	 rax, rdx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:locMap
  00090	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00094	48 89 44 24 30	 mov	 QWORD PTR head$[rsp], rax

; 127  : 	list->next = *head;

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR head$[rsp]
  000a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 128  : 	list->prev = NULL;

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000af	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 129  : 	if (*head) (*head)->prev = list;

  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  000bc	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000c0	74 11		 je	 SHORT $LN2@AddLocVal2
  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  000c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ca	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  000cf	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN2@AddLocVal2:

; 130  : 	*head = list;

  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR head$[rsp]
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR list$[rsp]
  000dd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 131  : 	return list->value->value;

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR list$[rsp]
  000e5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e8	8b 00		 mov	 eax, DWORD PTR [rax]

; 132  : };

  000ea	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
AddLocVal2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
list$ = 48
frame$ = 56
head$ = 64
hash$ = 96
path$ = 104
AddFrameData PROC

; 133  : byte* AddFrameData(ULONGLONG hash, char* path) {//always adds; doesn't get.

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 134  : 	frameList* list = malloc(sizeof(frameList));

  0001b	b9 18 00 00 00	 mov	 ecx, 24
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00026	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 135  : 	list->value = malloc(sizeof(frameData));

  0002b	b9 10 00 00 00	 mov	 ecx, 16
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0003b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 136  : 	list->value->frame = malloc(sizeof(byte));

  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 89 01	 mov	 QWORD PTR [rcx], rax

; 137  : 	byte* frame = stbi_load(path, &width, &height, &channels, REQ_COMP);

  00054	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:channels
  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:height
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:width
  00071	48 8b 4c 24 68	 mov	 rcx, QWORD PTR path$[rsp]
  00076	e8 00 00 00 00	 call	 stbi_load
  0007b	48 89 44 24 38	 mov	 QWORD PTR frame$[rsp], rax

; 138  : 	list->value->frame = frame;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR frame$[rsp]
  0008d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 139  : 	list->value->hash = hash;

  00090	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hash$[rsp]
  0009d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 140  : 	frameList** head = &frameMap[hash % FRAME_DIC_SIZE];

  000a1	33 d2		 xor	 edx, edx
  000a3	48 8b 44 24 60	 mov	 rax, QWORD PTR hash$[rsp]
  000a8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000ad	48 f7 f1	 div	 rcx
  000b0	48 8b c2	 mov	 rax, rdx
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:frameMap
  000ba	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  000be	48 89 44 24 40	 mov	 QWORD PTR head$[rsp], rax

; 141  : 	Insert(list, head);

  000c3	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR head$[rsp]
  000cd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR list$[rsp]
  000d9	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR head$[rsp]
  000e6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000ea	74 11		 je	 SHORT $LN2@AddFrameDa
  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR head$[rsp]
  000f1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  000f9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN2@AddFrameDa:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR head$[rsp]
  00102	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  00107	48 89 08	 mov	 QWORD PTR [rax], rcx

; 142  : 	return frame;

  0010a	48 8b 44 24 38	 mov	 rax, QWORD PTR frame$[rsp]

; 143  : }

  0010f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00113	5f		 pop	 rdi
  00114	c3		 ret	 0
AddFrameData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
hash$ = 40
frame$ = 56
__$ArrayPad$ = 72
path$ = 96
TryGetFrame PROC

; 144  : byte* TryGetFrame(char *path) {//only use if you are unsure if the value is in the map. kinda slow because of the linear probing. will add to the map if the key isn't already in it.

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000f	b9 0c 00 00 00	 mov	 ecx, 12
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00036	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 145  : 	ULONGLONG hash;
; 146  : 	byte* frame = GetFrame(path, &hash);

  0003b	48 8d 54 24 28	 lea	 rdx, QWORD PTR hash$[rsp]
  00040	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  00045	e8 00 00 00 00	 call	 GetFrame
  0004a	48 89 44 24 38	 mov	 QWORD PTR frame$[rsp], rax

; 147  : 	if (!frame) {

  0004f	48 83 7c 24 38
	00		 cmp	 QWORD PTR frame$[rsp], 0
  00055	75 11		 jne	 SHORT $LN2@TryGetFram

; 148  : 		//printf("returned new frame for \"%s\"\n", path);
; 149  : 		return AddFrameData(hash, path);

  00057	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  00061	e8 00 00 00 00	 call	 AddFrameData
  00066	eb 05		 jmp	 SHORT $LN1@TryGetFram
$LN2@TryGetFram:

; 150  : 	}
; 151  : 	return frame;

  00068	48 8b 44 24 38	 mov	 rax, QWORD PTR frame$[rsp]
$LN1@TryGetFram:

; 152  : }

  0006d	48 8b f8	 mov	 rdi, rax
  00070	48 8b cc	 mov	 rcx, rsp
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TryGetFrame$rtcFrameData
  0007a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0007f	48 8b c7	 mov	 rax, rdi
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00087	48 33 cc	 xor	 rcx, rsp
  0008a	e8 00 00 00 00	 call	 __security_check_cookie
  0008f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
TryGetFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
hash$ = 32
head$ = 40
path$ = 64
outHash$ = 72
GetFrame PROC

; 163  : byte* GetFrame(char *path, ULONGLONG *outHash) {//only use if you are sure if the value is in the map. as slow as TryGetFrame, but doesn't add to the map if the key isn't found. instead, will return null if the key is not found.

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 164  : 	ULONGLONG hash = NugHash(path);

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00020	e8 00 00 00 00	 call	 NugHash
  00025	48 89 44 24 20	 mov	 QWORD PTR hash$[rsp], rax

; 165  : 	frameList* head = frameMap[hash % FRAME_DIC_SIZE];

  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR hash$[rsp]
  00031	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00036	48 f7 f1	 div	 rcx
  00039	48 8b c2	 mov	 rax, rdx
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:frameMap
  00043	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00047	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax
$LN2@GetFrame:

; 166  : 	while (head) {

  0004c	48 83 7c 24 28
	00		 cmp	 QWORD PTR head$[rsp], 0
  00052	74 30		 je	 SHORT $LN3@GetFrame

; 167  : 		if (head->value->hash == hash) return head->value->frame;

  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00059	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hash$[rsp]
  00061	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00065	75 0d		 jne	 SHORT $LN4@GetFrame
  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  0006c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00072	eb 1f		 jmp	 SHORT $LN1@GetFrame
$LN4@GetFrame:

; 168  : 		advance(head);

  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00079	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007d	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax

; 169  : 	}

  00082	eb c8		 jmp	 SHORT $LN2@GetFrame
$LN3@GetFrame:

; 170  : 	*outHash = hash;

  00084	48 8b 44 24 48	 mov	 rax, QWORD PTR outHash$[rsp]
  00089	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hash$[rsp]
  0008e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 171  : 	return NULL;

  00091	33 c0		 xor	 eax, eax
$LN1@GetFrame:

; 172  : }

  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
GetFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c
_TEXT	SEGMENT
_this$ = 32
i$ = 40
$T1 = 48
string$ = 80
NugHash	PROC

; 174  : ULONGLONG NugHash(char* string) {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__460EF0CE_EntityManager@c
  00011	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 175  : 	long long _this = 0;

  00016	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR _this$[rsp], 0

; 176  : 	uint i = 0;

  0001f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN2@NugHash:

; 177  : 	while (*++string) {

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0002c	48 ff c0	 inc	 rax
  0002f	48 89 44 24 50	 mov	 QWORD PTR string$[rsp], rax
  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00039	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003c	85 c0		 test	 eax, eax
  0003e	74 5c		 je	 SHORT $LN3@NugHash

; 178  : 		_this += NugRand(*string) * (i + 1);

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00045	48 0f be 00	 movsx	 rax, BYTE PTR [rax]
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.h

; 46   : 	return (aConst * seed + cConst) % maxNugRand;

  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR aConst
  00050	48 0f af c8	 imul	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 03 05 00 00
	00 00		 add	 rax, QWORD PTR cConst
  0005e	33 d2		 xor	 edx, edx
  00060	48 f7 35 00 00
	00 00		 div	 QWORD PTR maxNugRand
  00067	48 8b c2	 mov	 rax, rdx
  0006a	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
; File C:\Users\drago\source\repos\cGame - less comments\cGame\Dictionary.c

; 178  : 		_this += NugRand(*string) * (i + 1);

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  00074	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  00078	ff c1		 inc	 ecx
  0007a	8b c9		 mov	 ecx, ecx
  0007c	48 0f af c1	 imul	 rax, rcx
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _this$[rsp]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 20	 mov	 QWORD PTR _this$[rsp], rax

; 179  : 		i++;

  00090	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00094	ff c0		 inc	 eax
  00096	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 180  : 	}

  0009a	eb 8b		 jmp	 SHORT $LN2@NugHash
$LN3@NugHash:

; 181  : 	return _this;

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR _this$[rsp]

; 182  : }

  000a1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
NugHash	ENDP
_TEXT	ENDS
END
